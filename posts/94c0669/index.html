<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>SAM后缀自动机学习笔记 | wjyppm's Blog</title><meta name="author" content="wjyppm"><meta name="copyright" content="wjyppm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0.前言 后缀自动机，在字符串算法中居于一种万能的地位，其本体代码编写较简单，优美的 O(n)O(n)O(n) 构建复杂度，是一类极其有用但难以真正理解的字符串后缀结构。笔者投入了大约一周的时间来学习，现在进行总结复习，看看能不能悟到一些新的东西。 同时后缀自动机本身的难度（10 级）决定了理解较难，笔者同时也是这样的感受。我在编写第一二三章节的时候会尽量用图来解释，尽量减少繁杂的符号化语言。必"><meta property="og:type" content="article"><meta property="og:title" content="SAM后缀自动机学习笔记"><meta property="og:url" content="https://worldcpu.github.io/posts/94c0669/index.html"><meta property="og:site_name" content="wjyppm's Blog"><meta property="og:description" content="0.前言 后缀自动机，在字符串算法中居于一种万能的地位，其本体代码编写较简单，优美的 O(n)O(n)O(n) 构建复杂度，是一类极其有用但难以真正理解的字符串后缀结构。笔者投入了大约一周的时间来学习，现在进行总结复习，看看能不能悟到一些新的东西。 同时后缀自动机本身的难度（10 级）决定了理解较难，笔者同时也是这样的感受。我在编写第一二三章节的时候会尽量用图来解释，尽量减少繁杂的符号化语言。必"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220812014_686ffa5e9bdaf.webp"><meta property="article:published_time" content="2025-08-07T06:59:30.000Z"><meta property="article:modified_time" content="2025-09-28T13:11:28.612Z"><meta property="article:author" content="wjyppm"><meta property="article:tag" content="字符串"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220812014_686ffa5e9bdaf.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SAM后缀自动机学习笔记",
  "url": "https://worldcpu.github.io/posts/94c0669/",
  "image": "https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220812014_686ffa5e9bdaf.webp",
  "datePublished": "2025-08-07T06:59:30.000Z",
  "dateModified": "2025-09-28T13:11:28.612Z",
  "author": [
    {
      "@type": "Person",
      "name": "wjyppm",
      "url": "https://worldcpu.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://worldcpu.github.io/posts/94c0669/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/7.0.0/css/all.min.css"><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/fancyapps-ui/6.0.22/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>!function(t,e,n,c,r,s,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(c)).async=1,s.src="https://www.clarity.ms/tag/srmn9gtuyc",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(s,a)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://s4.zstatic.net/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"SAM后缀自动机学习笔记",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/touming.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image:url(https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1754709022174_【哲风壁纸】奇幻森林-柯娜：精神之桥.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.luogu.com.cn/upload/usericon/578829.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220812014_686ffa5e9bdaf.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">wjyppm's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">SAM后缀自动机学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i> <span>返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SAM后缀自动机学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-07T06:59:30.000Z" title="发表于 2025-08-07 14:59:30">2025-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T13:11:28.612Z" title="更新于 2025-09-28 21:11:28">2025-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>后缀自动机，在字符串算法中居于一种万能的地位，其本体代码编写较简单，优美的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 构建复杂度，是一类极其有用但难以真正理解的字符串后缀结构。笔者投入了大约一周的时间来学习，现在进行总结复习，看看能不能悟到一些新的东西。</p><p>同时后缀自动机本身的难度（10 级）决定了理解较难，笔者同时也是这样的感受。我在编写第一二三章节的时候会尽量用图来解释，尽量减少繁杂的符号化语言。必要的也不会省略。</p><p>后缀自动机在做习题的时候，需要有非常扎实的 DS 基础以及面向对象程序设计思想，不然在编写的时候就会炸掉（不然大纲为什么要有这个程序设计思想）。</p><p>一些基本约定：</p><ul><li>本文章默认字符串下标从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 开始。</li><li>我们用打字机字体表示字符串的内容，如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mtext mathvariant="monospace">wjyppm1403</mtext></mrow><annotation encoding="application/x-tex">s=\texttt{wjyppm1403}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.22222em"></span><span class="mord text"><span class="mord texttt">wjyppm1403</span></span></span></span></span>。</li><li>拼接：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 表示将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 拼接<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 后。</li><li>字符集：即构成字符串中字符的集合。</li><li>空串：不含任何字符的字符串称为空串。</li><li>子串：在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 开头或末尾删去若干字符得到的字符串称作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的子串，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 本身和空串也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的子串。我们定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">]</span></span></span></span> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>→</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l \to r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span> 上所有字符链接而成子串。</li><li>匹配：称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 匹配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 中出现。</li><li>字符串长度：我们用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|s|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 来表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的长度。</li></ul><p>前后缀：</p><ul><li>前缀：在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 末尾删除若干字符得到的字符串称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的前缀，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">pre</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span></span></span></span>。</li><li>后缀：在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 开头删除若干字符得到的字符串称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的后缀，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">suf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>。</li><li>最长公共前缀：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">LCP</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{LCP}(s,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">C</span><span class="mord mathrm">P</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span></span></span></span> 的最长公共前缀，即最长的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span></span></span></span> 的前缀。最长公共后缀同理，我们称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">LCS</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{LCS}(s,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">C</span><span class="mord mathrm">S</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>。LCP 的长度格式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">LCP</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\operatorname{LCP}(s,t)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">C</span><span class="mord mathrm">P</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>。</li><li>字典序：定义空字符小于任何字符。称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的&nbsp;<strong>字典序</strong>&nbsp;小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 当且仅当去掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">LCP</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{LCP}(s,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">C</span><span class="mord mathrm">P</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的第一个字符小于&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span>&nbsp;的第一个字符。等价于以第&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span>&nbsp;个字符作为第&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span>&nbsp;关键字比较。</li></ul><p>我们先从概念讲起。</p><h1 id="1-自动机"><a class="markdownIt-Anchor" href="#1-自动机"></a> 1. 自动机</h1><p>自动机，在 OI 中一般我们涉及的是有限状态自动机（DFA），它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以通过输入自动机指令（严谨来说就是字符），让自动机切换到其他的状态。任意时刻状态机只能处在一个状态。</p><p>而有限状态机可以表示为一个有向图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752222970398_image.png" alt="image.png"></p><p>从图中看出来一个信竞复读机（人类的本质是？）一共包含 5 个状态：学信竟，学 whk，吃吃饭，睡睡觉，摸摸鱼。每种带有箭头的连线，表示可以从当前状态切换到其他的状态，以及切换的条件。</p><p>我们列个转移表格：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">学信竟</th><th style="text-align:center">学 whk</th><th style="text-align:center">吃吃饭</th><th style="text-align:center">睡睡觉</th><th style="text-align:center">摸摸鱼</th></tr></thead><tbody><tr><td style="text-align:center">学信竟</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">去机房</td><td style="text-align:center"></td><td style="text-align:center">摆烂时间到</td></tr><tr><td style="text-align:center">学 whk</td><td style="text-align:center">信竟时间到</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">回去午睡</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">吃吃饭</td><td style="text-align:center">去食堂</td><td style="text-align:center">去教室</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">睡睡觉</td><td style="text-align:center"></td><td style="text-align:center">回教室</td><td style="text-align:center">被吵醒</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">摸摸鱼</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">回家</td><td style="text-align:center"></td></tr></tbody></table><p>表格中左侧第一列为当前状态。<br>表格中上方第一行为切换的下一个状态。<br>表格中每行从左到右为状态切换的条件(状态 A 能不能切换到状态B)。</p><p>举例：</p><ul><li>学 whk -&gt; 学信竟：条件（信竟时间到）。</li><li>学信竟 -&gt; 摸摸鱼：条件（摸鱼时间到）。</li><li>摸摸鱼 -&gt; 睡睡觉：条件（回家）。</li></ul><p>一个自动机，我们应当还有起始状态，在本图中我们的起始状态是 “睡睡觉”。（不准通宵！）</p><p>那为啥叫自动呢，是因为只要输入符号和转移规则确定，状态变化是自动的，自动机可以自己通过设定好的路线（即有向图的边权）来进行转移。自动机的工作方式和流程图类似，但是不同的是自动机每一个节点都是一个判定节点，只是一个单纯的状态而非任务。</p><p>我们借用 Oi-Wiki 的例子，例如完成「判断一个二进制数是不是偶数」的自动机如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oi-wiki.org/string/images/automaton2.png" alt=""></p><p>从起始结点开始，从高到低接受这个数的二进制序列，然后看最终停在哪里。如果最终停在红圈结点，则是偶数，否则不是。</p><p>而自动机的实质就是：状态集合（点）+ 转移规则（边）。</p><p>在竞赛中的应用我们有 AC 自动机，后缀自动机，DP 套 DP 等。</p><p>严谨的定义可以看 Oi-Wiki 的讲解，这里不再深入研究：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9vaS13aWtpLm9yZy9zdHJpbmcvYXV0b21hdG9uLyMlRTUlQkQlQTIlRTUlQkMlOEYlRTUlOEMlOTYlRTUlQUUlOUElRTQlQjklODk">传送门</a></p><h1 id="2-后缀自动机"><a class="markdownIt-Anchor" href="#2-后缀自动机"></a> 2. 后缀自动机</h1><h2 id="21-概念"><a class="markdownIt-Anchor" href="#21-概念"></a> 2.1 概念</h2><p>后缀自动机（SAM）是能够存储和识别一个字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的所有后缀的自动机。</p><p>正如我们上面所提到的自动机的定义，后缀自动机也是一个自动机，把节点看作状态，节点之间连的有向边是状态的转移。我们有一个初始状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">st</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">st</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 通过有向边到达其他所有节点，其中有一些状态是终止状态（即自动机到达这个状态后不会在转移）。任意一条从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">st</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 出发到达某个终止状态所经过路径上的字符集合是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的一个子串。不同的路径代表不同的子串，这些路径与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的子串一一对应，不多也不少。</p><p>这么说有点复杂，读者应该知道 Trie 吧，字典树其实也是一个自动机，我们看看字典树的形状，我们借用 OI-Wiki 的图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oi-wiki.org/string/images/trie1.png" alt=""></p><p>那我们回看上面的自动机表示图，你会发现两者十分相似，事实上 Trie 本身也是一个自动机。而我们把字符串所有后缀子串通过字典树的方法建立的一颗树，我们叫做后缀 Trie，后缀 Trie 也可以看作一种简单的后缀自动机：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752885903088_image.png" alt="image.png"></p><p>如上是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mtext mathvariant="monospace">abcbc</mtext></mrow><annotation encoding="application/x-tex">S=\texttt{abcbc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.61111em;vertical-align:0"></span><span class="mord text"><span class="mord texttt">abcbc</span></span></span></span></span> 的后缀 Trie，其中绿色节点表示终止节点。算上跟节点需要共 13 个节点，比较浪费空间，原因是因为做了重复存储，如蓝色虚线内圈起来的两个子串是重复的，那么有没有什么更省空间的结构呢？后缀自动机的结构就是我们想要的结构！</p><p>SAM 中除了上面的定义，还有一个额外条件：结点数最少。关键就在于如何把上面的图给压缩，压缩点重复的地方。而 SAM 将压缩做到极致，做到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的节点规模。那么怎么压缩成结点数最少呢？我们把上面的结构用 SAM 的结构表示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752885926210_image.png" alt="image.png"></p><p>我们把上面后缀 Trie 重复的部分给合并起来，就能够得到上面的一张图。上面的图是一张 DAG，它不仅能表示后缀，还能表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的所有子串。任意从初始状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span> 开始的路径，如果我们将路径上的所有转移的标号写下来，都会形成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的一个子串。而每个子串都对应从初始状态开始的某条路径。到达某个状态的路径可能不止一条，在图中也是有表现的，因此我们说一个状态对应一些字符串的集合，这个集合中的字符串分别对应着这些路径。</p><p>那么如何得到这个 DAG，这个节点数量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的吗。</p><p>我尝试建立这个 DAG，每一次我们都尝试添加一个字符，我们从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mtext mathvariant="monospace">a</mtext></mrow><annotation encoding="application/x-tex">S=\texttt{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord text"><span class="mord texttt">a</span></span></span></span></span> 开始，每次在上一次的末尾添加一个新的节点</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752885946214_image.png" alt="image.png"></p><p>这个 DAG 有多少节点？显然每一次加入节点只会增加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 级别的点数，至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个点，但是实际上我们建 SAM 的点数会出现冲突的情况，这个时候会复制节点，但是最多复制一次，所有实际上最多也只会有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> 个节点。</p><p>SAM 的每一个节点都对应的是原字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的某个子串，读者看图应能自行领会，接下来我们给出几个小定义。</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">substr</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{substr}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">u</span><span class="mord mathrm">b</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span><span class="mord mathrm">r</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>：表示状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所有子串的集合。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">shorest</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{shorest}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>：表示状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所有子串长度最短的那一个。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">longest</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{longest}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>：表示状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所有子串长度最长的那一个。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">minlen</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{minlen}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>：表示状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所有子串长度最短的那一个的长度。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{len}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>：表示状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所有子串长度最长的那一个的长度。</li></ul><h2 id="22-endpos-等价类"><a class="markdownIt-Anchor" href="#22-endpos-等价类"></a> 2.2 Endpos 等价类</h2><p>endpos 等价类是 SAM 中关键的地方，通过它我们可以高效地进行建图。</p><p>我们定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 表示字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 中所有出现的结束位置的集合，例如当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mtext mathvariant="monospace">"abcbc"</mtext></mrow><annotation encoding="application/x-tex">s=\texttt{"abcbc"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.61111em;vertical-align:0"></span><span class="mord text"><span class="mord texttt">"abcbc"</span></span></span></span></span> 的时候，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext mathvariant="monospace">"bc"</mtext><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(\texttt{"bc"})=\left\{ 3,5\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"bc"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span>，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">"bc"</mtext></mrow><annotation encoding="application/x-tex">\texttt{"bc"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61111em;vertical-align:0"></span><span class="mord text"><span class="mord texttt">"bc"</span></span></span></span></span> 出现在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">3,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span></span></span></span> 位置。</p><p>我们把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 的所有子串的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span> 都列出来，有：</p><table><thead><tr><th>子串：</th><th>a</th><th>b</th><th>c</th><th>ab</th><th>bc</th><th>cb</th><th>abc</th><th>bcb</th><th>cbc</th><th>abcb</th><th>bcbc</th><th>abcbc</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span></td><td>1</td><td>2,4</td><td>3,5</td><td>2</td><td>3,5</td><td>4</td><td>3</td><td>4</td><td>5</td><td>4</td><td>5</td><td>5</td></tr></tbody></table><p>我们定义空串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66334em;vertical-align:-.08167em"></span><span class="mord amsrm">∅</span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo>=</mo><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\operatorname{endpos}=\left\{ 1,2,3,4,5 \right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span> 我们按照 endpos 排序如下：</p><table><thead><tr><th>子串</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66334em;vertical-align:-.08167em"></span><span class="mord amsrm">∅</span></span></span></span></th><th>a</th><th>ab</th><th>b</th><th>abc</th><th>bc,c</th><th>abcb,bcb,cb</th><th>abcbc,bcbc,cbc</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span></td><td>1,2,3,4,5</td><td>1</td><td>2</td><td>2,4</td><td>3</td><td>3,5</td><td>4</td><td>5</td></tr></tbody></table><p>我们把 endpos 相等的称之为等价类，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">"c"</mtext><mo separator="true">,</mo><mtext mathvariant="monospace">"bc"</mtext></mrow><annotation encoding="application/x-tex">\texttt{"c"},\texttt{"bc"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80555em;vertical-align:-.19444em"></span><span class="mord text"><span class="mord texttt">"c"</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord text"><span class="mord texttt">"bc"</span></span></span></span></span> 的enpos 等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left\{ 3,5 \right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose delimcenter" style="top:0">}</span></span></span></span></span> 是等价类。</p><p>一个很有趣的事实就是，这样每一个等价类都对应 SAM 的一个状态，读者可以通过 SAM 的图来理解：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752888795682_image.png" alt="image.png"></p><p>接下来我们来阐述 Endpos 等价类所具有的一些特殊性质，endpos 等价类的性质体现的是后缀之间的包含关系。</p><p>以下证明来自 Oi-Wiki：</p><blockquote><p>引理 1：同一个等价类中较短子串是较长子串的后缀。</p></blockquote><p>证明是显然成立的，通过定义感性理解：字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 中所有出现的结束位置的集合。若结束位置相同，那么必然从这个结束位置向左拓展，必然是后缀。</p><blockquote><p>引理 2：对于两个非空子串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">u,w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span>，假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|u| \le |w|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal">u</span><span class="mord">∣</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord">∣</span></span></span></span>。那么，要么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos(u)</mi><mo>⁡</mo><mo>∩</mo><mi mathvariant="normal">endpos(w)</mi><mo>⁡</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\operatorname{endpos(u)} \cap \operatorname{endpos(w)}=\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">(</span><span class="mord mathrm">u</span><span class="mord mathrm">)</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">∩</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">(</span><span class="mord mathrm" style="margin-right:.01389em">w</span><span class="mord mathrm">)</span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.66334em;vertical-align:-.08167em"></span><span class="mord amsrm">∅</span></span></span></span>，要么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(u) \subseteq \operatorname{endpos}(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mclose">)</span></span></span></span>，后者成立当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的后缀。</p></blockquote><p>如果集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span> 与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mclose">)</span></span></span></span> 有至少一个公共元素，那么由于字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 在相同位置结束，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的一个后缀。所以在每次<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 出现的位置，子串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 也会出现。所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(w)\subseteq \operatorname{endpos}(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>引理 3：同一个等价类中子串长度不等，且依次递增 1，覆盖了从最短到最长的子串的区间。即同一个状态对应的子串的长度各不相同，而且是连续的若干自然数，其中较短的总是较长的子串的后缀。</p></blockquote><p>如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的等价类。</p><p>由引理 1，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span> 相同的两个不同字符串中，必定一长一短，且较短者总是较长者的真后缀。也就是说，等价类中没有等长的字符串。</p><p>记<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 为等价类中最长的字符串，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 为等价类中最短的字符串。由引理 1，字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 是字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的真后缀。现在考虑长度在区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mrow><mo fence="true">∣</mo><mi>u</mi><mo fence="true">∣</mo></mrow><mo separator="true">,</mo><mrow><mo fence="true">∣</mo><mi>w</mi><mo fence="true">∣</mo></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\left|u\right|,\left|w\right|]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="minner"><span class="mopen delimcenter" style="top:0">∣</span><span class="mord mathnormal">u</span><span class="mclose delimcenter" style="top:0">∣</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0">∣</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mclose delimcenter" style="top:0">∣</span></span><span class="mclose">]</span></span></span></span> 中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的任意后缀。容易看出，这个后缀也在同一等价类中，因为这个后缀只能在字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 中以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的一个后缀的形式存在（这是因为较短的后缀<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">s</span></span></span></span> 中只以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的后缀的形式存在）。因此，由引理 1，这个后缀和字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span> 相同。</p><h2 id="23-parent-tree"><a class="markdownIt-Anchor" href="#23-parent-tree"></a> 2.3 Parent Tree</h2><p>根据上面 3 个引理，我们知道 endpos 等价类中的子串是具有包含关系，而 SAM 中的节点（或称作状态）就是一个等价类，这样我们通过包含关系把普通后缀树的臃肿给压缩了。</p><p>引理 1 和 3 表示了同一个等价类的包含关系，且长度连续，是一个状态就可以表示的。而引理 2 表示状态时如何进行转移的，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}(v)\subseteq \operatorname{endpos}(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span> 我们定义转移方向从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \to v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的父节点，这里不理解为什么要让大集合向小集合连边可以先了解，后面我们会细说。</p><p>下面我们通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mtext mathvariant="monospace">"abcbc"</mtext></mrow><annotation encoding="application/x-tex">S=\texttt{"abcbc"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.61111em;vertical-align:0"></span><span class="mord text"><span class="mord texttt">"abcbc"</span></span></span></span></span> 来建立一颗 SAM。初始状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76508em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 是空集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66334em;vertical-align:-.08167em"></span><span class="mord amsrm">∅</span></span></span></span>，每一个节点是一个状态，表示一个 endpos 等价类。这棵树只有 8 个点，少于后缀树的 13 个点，我们把这个树称作为母树，即 Parent 树。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752890560527_image.png" alt="image.png"></p><p>这里借用的是 Oi-Wiki 的图，其中 Parent 树中每一个节点我们选取最长字符串来代表状态。我们把表格复制一下列到下面供参考：</p><table><thead><tr><th>子串</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66334em;vertical-align:-.08167em"></span><span class="mord amsrm">∅</span></span></span></span></th><th>a</th><th>ab</th><th>b</th><th>abc</th><th>bc,c</th><th>abcb,bcb,cb</th><th>abcbc,bcbc,cbc</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span></td><td>1,2,3,4,5</td><td>1</td><td>2</td><td>2,4</td><td>3</td><td>3,5</td><td>4</td><td>5</td></tr></tbody></table><p>Parent 树能够完整表达所有子串，有 5 个叶子节点，而 5 个叶子节点对应的endpos 正好是 1 到 5 的完整位置，从根到一个叶子节点的路径上，包含了以这个位置为终点的所有后缀。如最右边的路径。</p><p>Parent 树和 AC 自动机的 Fail 树及其相似，如果你知道什么是 Fail 树的话，可以把 Parent 树看作为 Fail 树的压缩版。</p><p>但是这里的 Parent 树并不实用，因为我们 SAM 这要这么建立的话那么对于每一个节点我们要存一堆字符串，空间复杂度会爆炸。如果我们通过路径表示子串，像 Trie 树一样多好，让每一条独立的路径对应一个独立的子串，这样即好添加节点，也可以操作啦。而 SAM 通过<strong>用路径表示子串</strong>来进行的。</p><p>我们根据上面的图不难发现 SAM 和 Parent 树及其相似，但是怎么从 Parent 树转化到 SAM 呢？</p><h2 id="24-后缀链接"><a class="markdownIt-Anchor" href="#24-后缀链接"></a> 2.4 后缀链接</h2><p>后缀链接是我们将 SAM 和 Parent 树之间建立的一个桥梁，事实上，构建 SAM 的过程和母树是息息相关的。</p><p>考虑 SAM 上的一个不是根的节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>，它的后缀链接（link）定义为它上层的一个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的等价类所包含的子串也是&nbsp;&nbsp;所包含的子串的后缀。其实就是上文 Parent 树上每个点的父亲。其作用就是将两个不同节点的连续子串连接起来，如下图的母树补充，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的最短子串长度等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的最长字串长度加 1，它们是相邻的两个后缀。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752891879965_image.png" alt="image.png"></p><p><s>这图糊的已经没救了。</s></p><p>我们再补充几个例子：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">"a"</mtext><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathrm{endpos}(\texttt{"a"}) = \{1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"a"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">"ab"</mtext><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>2</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mrow><mtext mathvariant="monospace">"abcb",</mtext><mtext>&nbsp;</mtext><mtext mathvariant="monospace">"bcb",</mtext><mtext>&nbsp;</mtext><mtext mathvariant="monospace">"cb"</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>4</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><mo>⊊</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">"b"</mtext><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\begin{aligned} \mathrm{endpos}(\texttt{"ab"}) = \{2\} \\ \mathrm{endpos}(\texttt{"abcb", "bcb", "cb"}) = \{4\} \\ \end{aligned} \subsetneq \mathrm{endpos}(\texttt{"b"}) = \{2, 4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em"><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"ab"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mopen">{</span><span class="mord">2</span><span class="mclose">}</span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"abcb",&nbsp;"bcb",&nbsp;"cb"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mopen">{</span><span class="mord">4</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel amsrm">⊊</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"b"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">"abc"</mtext><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>3</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mrow><mtext mathvariant="monospace">"abcbc",</mtext><mtext>&nbsp;</mtext><mtext mathvariant="monospace">"bcbc",</mtext><mtext>&nbsp;</mtext><mtext mathvariant="monospace">"cbc"</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>5</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><mo>⊊</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mrow><mtext mathvariant="monospace">"bc",</mtext><mtext>&nbsp;</mtext><mtext mathvariant="monospace">"c"</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\begin{aligned} \mathrm{endpos}(\texttt{"abc"}) = \{3\} \\ \mathrm{endpos}(\texttt{"abcbc", "bcbc", "cbc"}) = \{5\} \\ \end{aligned} \subsetneq \mathrm{endpos}(\texttt{"bc", "c"}) = \{3, 5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em"><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"abc"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mopen">{</span><span class="mord">3</span><span class="mclose">}</span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"abcbc",&nbsp;"bcbc",&nbsp;"cbc"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mopen">{</span><span class="mord">5</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel amsrm">⊊</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">"bc",&nbsp;"c"</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose">}</span></span></span></span></span></p><p>每个节点有且仅有一个后缀链接，沿着后缀链接往上走对应的后缀长度会连续变短，最后到达根，。即，一条从根出发到某个节点的后缀链，表达了一个完整的后缀组合，这是母树的本质。后缀链接构成的树本质上是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">endpos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{endpos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span></span></span></span> 集合构成的一棵树。我们从小集合往大集合建边我们充分利用了 endpos 集合中长度单调递增 1 的性质，并且使得具有上面后缀链的性质。</p><p>类似于 AC 自动机的甜蜜组合 Trie+Fail，我们 SAM 就是把转移图和 Parent 树给融合到一起的究极形态。</p><h2 id="25-构建-sam"><a class="markdownIt-Anchor" href="#25-构建-sam"></a> 2.5 构建 SAM</h2><p>构建的核心思想就是我们前面提到过的增量发，我们在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[1,i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的基础上的 SAM 进行更新，从而得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[1,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的 SAM。构建 SAM 只需要 3 个步骤：</p><ol><li>打开 SAM。</li><li>插一个字符。</li><li>关上 SAM。</li></ol><p><s>冰箱梗</s>，读者不难看出 SAM 的构建是在线算法，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护 SAM。</p><p>建立 SAM 的关键在于：</p><ul><li>起点和终点之间的边代表在当前的字符串后添加一个字符。</li><li>从根到达图中任意路径形成的子串都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 中的一个子串。</li><li>要保证每个点的所有字串属于一个 endpos 等价类。</li><li>要符合 Parent 树的父子关系。</li></ul><p>我们这里先给出代码实现与算法流程，让后再逐步说明原理。</p><p>一开始我们钦定 SAM 中有一个根节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76508em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，编号就是 0，定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">link</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{len}(t_{0})=0,\operatorname{link}(t_{0})=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p>让后我们考虑添加一个字符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span> 拓展 SAM。</p><ol><li>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 为添加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span> 之前整个字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 所对应的节点（即上一个所更新的节点）。</li><li>创建一个新的状态，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>l</mi><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{len}(cur)=\operatorname{len}(lst)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</li><li>从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 开始遍历遍历后缀链接，如果当前结点&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>&nbsp;没有标记字符&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span> 的出边，创建一条&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>→</mo><mi>c</mi><mi>u</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">v\to cur</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span>&nbsp;的边，标记为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>。</li><li>如果遍历到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76508em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">link</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{link}(cur)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span></span></span></span>，跳到第 8 步。</li><li>如果当前结点&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>&nbsp;已经有了标记字符&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>&nbsp;的出边，停止遍历，并把这个结点标记为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span>，标记&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span>&nbsp;沿着标记字符&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>&nbsp;的出边到达的点为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>。</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{len}(p)+1=\operatorname{len}(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mclose">)</span></span></span></span>，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">link</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\operatorname{link}(cur)=q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>，跳到第 8 步。</li><li>否则，复制状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> 到一个新的状态里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">nq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>（包括 link 与它在 DAG 上的出边），将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{len}(nq)=\operatorname{len}(p)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。赋值之后在令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">link</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mi>q</mi><mo separator="true">,</mo><mi mathvariant="normal">link</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">\operatorname{link}(q)=nq,\operatorname{link}(cur)=nq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">k</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>。从&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span>&nbsp;遍历后缀链接，设当前遍历到的点为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>，若&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>&nbsp;有标记为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>&nbsp;的出边且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>→</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">v\to q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>，则重定向这条边为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>→</mo><mi>n</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">v \to nq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>。若&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>&nbsp;没有标记为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>&nbsp;的出边或者&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>&nbsp;的标记为&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>&nbsp;的出边所到达的点不是&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>&nbsp;，停止遍历，转 8。</li><li>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo>=</mo><mi>c</mi><mi>u</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">lst=cur</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span>，结束。</li></ol><p>代码实现如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> cur=++tot;</span><br><span class="line">    <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">    <span class="type">int</span> cur=++tot;</span><br><span class="line">    fa[cur]=fa[from];</span><br><span class="line">    <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>{</span><br><span class="line">    <span class="type">int</span> cur=<span class="built_in">newnode</span>(); <span class="comment">//步骤1</span></span><br><span class="line">    len[cur]=len[lst]<span class="number">+1</span>;<span class="comment">//步骤2</span></span><br><span class="line">    <span class="type">int</span> p=lst;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];<span class="comment">//步骤3</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>) fa[cur]=<span class="number">0</span>;<span class="comment">//步骤4</span></span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="type">int</span> q=nxt[p][c];<span class="comment">//步骤5</span></span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>) fa[cur]=q;<span class="comment">//步骤6</span></span><br><span class="line">        <span class="keyword">else</span>{<span class="comment">//步骤7</span></span><br><span class="line">            <span class="type">int</span> nq=<span class="built_in">clone</span>(q);</span><br><span class="line">            len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">            fa[q]=fa[cur]=nq;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    lst=cur;<span class="comment">//步骤8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于每一步的解释，大家可以去看<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemF6YS16dC9wLzE1NDE5MTgxLmh0bWw">后缀自动机(SAM)奶妈式教程 - ZTer</a> 的教程，这里就不再详细展开了，以防篇幅过长。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],fa[MN],len[MN],tot,lst;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        lst=<span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        len[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[<span class="number">0</span>]));</span><br><span class="line">        cnt_init[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        fa[cur]=fa[from];</span><br><span class="line">        <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>();</span><br><span class="line">        len[cur]=len[lst]<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> p=lst;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>) fa[cur]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>) fa[cur]=q;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nq=<span class="built_in">clone</span>(q);</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];</span><br><span class="line">                fa[q]=fa[cur]=nq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        lst=cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inittree</span><span class="params">()</span></span>{<span class="comment">// 构建 link 树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[i].<span class="built_in">clear</span>();</span><br><span class="line">            cnt[i]=<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}sam;</span><br></pre></td></tr></tbody></table></figure><h1 id="3-广义后缀自动机"><a class="markdownIt-Anchor" href="#3-广义后缀自动机"></a> 3. 广义后缀自动机</h1><p>这里讲的是在线做法，因为在线做法只需要在原先的板子上更改一下就可以了。</p><p>广义后缀自动机是后缀自动机的升级版，可以同时表示多个字符串所有字串集合的数据结构。</p><p>而假的在线构建方法及其简单，就是插入完一个字符串后把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">last</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 指针指向根节点，接着插就可以了，但是这样构建的 SAM 虽然能用，但是并不满足前面我们所提过的最小结构。具体来说，有以下两种情况：</p><ul><li>一个等价类被拆成若干个节点，子串信息被分散。</li><li>出现空节点。</li></ul><p>注意到上面的节点的问题在于重复的前缀会被拆分或者重复创建新节点。我们可以通过在 <code>expand</code> 函数中添加特判，重复的前缀会被特判处理到，这样我们就可以对了。</p><p>以下是 <code>expand</code> 代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> lst)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]<span class="number">+1</span>) <span class="keyword">return</span> nxt[lst][c]; <span class="comment">// / 如果节点已经存在，且 len 值相对应，即连续转移，则直接转移。</span></span><br><span class="line">    <span class="type">int</span> cur=<span class="built_in">newnode</span>(),p=lst,flag=<span class="number">0</span>,q,nq;</span><br><span class="line">    len[cur]=len[p]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">    <span class="keyword">if</span>(!p){</span><br><span class="line">        fa[cur]=<span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        q=nxt[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>){</span><br><span class="line">            fa[cur]=q;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(p==lst) flag=<span class="number">1</span>,cur=<span class="number">0</span>,tot--;</span><br><span class="line">            nq=<span class="built_in">clone</span>(q);</span><br><span class="line">            len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">            fa[q]=fa[cur]=nq;</span><br><span class="line">            <span class="keyword">while</span>(p&amp;&amp;nxt[p][c]==q){</span><br><span class="line">                nxt[p][c]=nq;</span><br><span class="line">                p=fa[p];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> flag?nq:cur; <span class="comment">//// 如果 len[las][it] 存在，则 cur 是空壳，返回 nq 即可</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的方法本质就是对匹配串建出 trie 后进行 dfs 构建 SAM。</p><h1 id="4-常用技巧与结论"><a class="markdownIt-Anchor" href="#4-常用技巧与结论"></a> 4. 常用技巧与结论</h1><h2 id="求本质不同子串个数"><a class="markdownIt-Anchor" href="#求本质不同子串个数"></a> 求本质不同子串个数</h2><p>根据 SAM 的性质，每一个字串对应的是唯一一个状态，那么答案就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><msub><mi>a</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{len}(p)-\operatorname{len}(fa_{p})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>a</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">fa_{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.980548em;vertical-align:-.286108em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 表示 link 树上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 状态的父亲。</p><h2 id="线段树合并维护-endpos-集合"><a class="markdownIt-Anchor" href="#线段树合并维护-endpos-集合"></a> 线段树合并维护 endpos 集合。</h2><p>有一些题目我们需要知道 endpos 集合内的内容具体是什么，以刻画每个子串在字符串中所有出现位置的信息。</p><p>根据上面所提到的，endpos 集合构建出来的树就是 link 树。为此，我们可以通过在 link 树上进行线段树合并的方式可以得到每个状态的 endpos 集合。</p><p>同时注意，线段树合并会破坏原有线段树的结构，如果我们需要保留每一个节点的 endpos 集合的话，我们线段树合并的形式应当是新建节点的方式而不是在原有结构直接复制的方式。</p><h2 id="快速定位一个子串的对应状态"><a class="markdownIt-Anchor" href="#快速定位一个子串的对应状态"></a> 快速定位一个子串的对应状态</h2><p>给定区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">]</span></span></span></span>，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">s_{[l,r]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7857599999999999em;vertical-align:-.3551999999999999em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.34480000000000005em"><span style="top:-2.5198em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.3551999999999999em"><span></span></span></span></span></span></span></span></span></span> 在 SAM 上对应的状态，在构建 SAM 时候像 AC 自动机一样预处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">s_{[1,i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7857599999999999em;vertical-align:-.3551999999999999em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.34480000000000005em"><span style="top:-2.5198em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.3551999999999999em"><span></span></span></span></span></span></span></span></span></span> 所表示的状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">pos_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，我们从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><msub><mi>s</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">pos_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 上倍增二分找到第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>≥</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">len \ge r-l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83041em;vertical-align:-.13597em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的状态，这个状态就是我们所求的状态。</p><h2 id="桶排确定-dfs-顺序"><a class="markdownIt-Anchor" href="#桶排确定-dfs-顺序"></a> 桶排确定 dfs 顺序</h2><p>link 树上父亲的 len 值一定小于儿子的，但编号小的不一定 len 也小！考虑对于所有结点按照 len 值从大到小进行桶排序，让后按照顺序合并每个状态及其父亲，效果等同于 link 树自底向上合并信息的过程。</p><h1 id="5-实战演练"><a class="markdownIt-Anchor" href="#5-实战演练"></a> 5. 实战演练</h1><h4 id="p3804-模板后缀自动机-sam"><a class="markdownIt-Anchor" href="#p3804-模板后缀自动机-sam"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDQ">P3804 【模板】后缀自动机 (SAM)</a></h4><p>答案就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≥</mo><mn>2</mn></mrow></munder><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">endpos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\sum\limits_{|\operatorname{endpos}(p)|\ge 2} \operatorname{len}(p)\times |\operatorname{endpos}(p)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.9660100000000003em;vertical-align:-1.216005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.7500050000000001em"><span style="top:-2.058995em;margin-left:0"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mspace mtight" style="margin-right:.19516666666666668em"></span><span class="mop mtight"><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">n</span><span class="mord mathrm mtight">d</span><span class="mord mathrm mtight">p</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">s</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mord mtight">∣</span><span class="mrel mtight">≥</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.0000050000000003em"><span class="pstrut" style="height:3em"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.216005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>，求出 endpos 集合大小即可，具体怎么求可以看代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">3e6</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],fa[MN],len[MN],cnt[MN],tot,lst;</span><br><span class="line">    <span class="type">int</span> cnt_init[MN];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        lst=<span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        len[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[<span class="number">0</span>]));</span><br><span class="line">        cnt_init[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        cnt_init[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        fa[cur]=fa[from];</span><br><span class="line">        cnt_init[cur]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>();</span><br><span class="line">        len[cur]=len[lst]<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> p=lst;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>) fa[cur]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>) fa[cur]=q;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nq=<span class="built_in">clone</span>(q);</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];</span><br><span class="line">                fa[q]=fa[cur]=nq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        lst=cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inittree</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[i].<span class="built_in">clear</span>();</span><br><span class="line">            cnt[i]=<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(cnt[u]!=<span class="number">-1</span>) <span class="keyword">return</span> cnt[u];</span><br><span class="line">        <span class="type">int</span> sum=cnt_init[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            sum+=<span class="built_in">dfs</span>(v);</span><br><span class="line">        }</span><br><span class="line">        cnt[u]=sum;</span><br><span class="line">        <span class="keyword">if</span>(cnt[u]!=<span class="number">1</span>){</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*cnt[u]*len[u]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cnt[u];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">" "</span>+s;</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        sam.<span class="built_in">extend</span>(s[i]-<span class="string">'a'</span>);</span><br><span class="line">    }</span><br><span class="line">    sam.<span class="built_in">inittree</span>();</span><br><span class="line">    sam.<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="p6139-模板广义后缀自动机广义-sam"><a class="markdownIt-Anchor" href="#p6139-模板广义后缀自动机广义-sam"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDYxMzk">P6139 【模板】广义后缀自动机（广义 SAM）</a></h2><p>本质不同子串个数我们已经提到过了，这里不再叙述。</p><p>直接放个板子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">gySAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],fa[MN],pos[MN],len[MN],tot;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[i].<span class="built_in">clear</span>();</span><br><span class="line">            fa[i]=pos[i]=len[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(nxt[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[i]));</span><br><span class="line">        }</span><br><span class="line">        tot=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gySAM</span>(){</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        fa[cur]=fa[from];</span><br><span class="line">        <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> lst)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]<span class="number">+1</span>) <span class="keyword">return</span> nxt[lst][c];</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>(),p=lst,flag=<span class="number">0</span>,q,nq;</span><br><span class="line">        len[cur]=len[p]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(!p){</span><br><span class="line">            fa[cur]=<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>){</span><br><span class="line">                fa[cur]=q;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(p==lst) flag=<span class="number">1</span>,cur=<span class="number">0</span>,tot--;</span><br><span class="line">                nq=<span class="built_in">clone</span>(q);</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                fa[q]=fa[cur]=nq;</span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;nxt[p][c]==q){</span><br><span class="line">                    nxt[p][c]=nq;</span><br><span class="line">                    p=fa[p];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag?nq:cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inittree</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>{</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">length</span>(),lst=<span class="number">1</span>;</span><br><span class="line">        s=<span class="string">" "</span>+s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++){</span><br><span class="line">            lst=<span class="built_in">extend</span>(s[i]-<span class="string">'a'</span>,lst);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}sam;</span><br></pre></td></tr></tbody></table></figure><h2 id="p4070-sdoi2016生成魔咒"><a class="markdownIt-Anchor" href="#p4070-sdoi2016生成魔咒"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwNzA">P4070 [SDOI2016]生成魔咒</a></h2><p>答案就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi mathvariant="normal">len</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><msub><mi>a</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{len}(p)-\operatorname{len}(fa_{p})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>a</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">fa_{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.980548em;vertical-align:-.286108em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 表示 link 树上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 状态的父亲。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>{</span><br><span class="line">    <span class="type">int</span> cur=++tot;</span><br><span class="line">    len[cur]=len[lst]<span class="number">+1</span>;</span><br><span class="line">    cnt_init[cur]=<span class="number">1</span>;</span><br><span class="line">    nxt[cur].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> p=lst;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;!nxt[p][c]){</span><br><span class="line">        nxt[p][c]=cur;</span><br><span class="line">        p=fa[p];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>) fa[cur]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="type">int</span> q=nxt[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>){</span><br><span class="line">            fa[cur]=q;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">            nxt[nq]=nxt[q];</span><br><span class="line">            fa[nq]=fa[q];</span><br><span class="line">            cnt_init[nq]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="number">-1</span>&amp;&amp;nxt[p][c]==q){</span><br><span class="line">                nxt[p][c]=nq;</span><br><span class="line">                p=fa[p];</span><br><span class="line">            }</span><br><span class="line">            fa[q]=fa[cur]=nq;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    lst=cur;</span><br><span class="line">    ans+=len[cur]-len[fa[cur]];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>cnt_init</code> 没有任何用，只是复制板子复制上的。</p><h2 id="p4022-ctsc2012熟悉的文章"><a class="markdownIt-Anchor" href="#p4022-ctsc2012熟悉的文章"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwMjI">P4022 [CTSC2012]熟悉的文章</a></h2><p>典。</p><p>战术二分答案<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span>，问题转化为判断这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span> 是否可行，考虑 DP。设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 表示文章<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 前缀最长符合限制的匹配长度，有转移方程：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>f</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>i</mi><mo>−</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>m</mi><mi>x</mi><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}f_{i} &amp; =\max \{ f_{j}+i-(j+1)+1,f_{i-1} \} &amp; j \in [i-mxlen(i),i-mid]\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5000000000000002em;vertical-align:-.5000000000000002em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em"><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.5000000000000002em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em"><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.5000000000000002em"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em"><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.5000000000000002em"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>x</mi><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">mxlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span> 表示以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 为结尾的字符串出现在模板串中的最长长度，用 SAM 类似于 LCS 的方法即可。</p><p>转移是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，可以通过单调队列优化成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN = <span class="number">5e5</span> + <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n, m, len, f[MN], ql, qr, q[MN], L[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> {</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">3</span>], fa[MN], cnt[MN], len[MN], cnt_init[MN], tot, lst;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        tot = lst = <span class="number">0</span>;</span><br><span class="line">        fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(nxt[<span class="number">0</span>]));</span><br><span class="line">        cnt_init[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(string s, <span class="type">int</span> slen)</span> </span>{</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; slen; i++) {</span><br><span class="line">            <span class="type">int</span> x = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nxt[p][x]) {</span><br><span class="line">                now++;</span><br><span class="line">                p = nxt[p][x];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">for</span> (; p != <span class="number">-1</span> &amp;&amp; !nxt[p][x]; p = fa[p]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>) p = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> now = len[p] + <span class="number">1</span>, p = nxt[p][x];</span><br><span class="line">            }</span><br><span class="line">            L[i + <span class="number">1</span>] = now;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cur = ++tot;</span><br><span class="line">        len[cur] = len[lst] + <span class="number">1</span>;</span><br><span class="line">        cnt_init[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur], <span class="number">0</span>, <span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="type">int</span> p = lst;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; !nxt[p][c]) {</span><br><span class="line">            nxt[p][c] = cur;</span><br><span class="line">            p = fa[p];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">-1</span>) {</span><br><span class="line">            fa[cur] = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">int</span> q = nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) {</span><br><span class="line">                fa[cur] = q;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(nxt[nq], nxt[q], <span class="built_in">sizeof</span>(nxt[q]));</span><br><span class="line">                fa[nq] = fa[q];</span><br><span class="line">                cnt_init[nq] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; nxt[p][c] == q) {</span><br><span class="line">                    nxt[p][c] = nq;</span><br><span class="line">                    p = fa[p];</span><br><span class="line">                }</span><br><span class="line">                fa[q] = fa[cur] = nq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        lst = cur;</span><br><span class="line">    }</span><br><span class="line">} sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>{</span><br><span class="line">    <span class="type">int</span> ql = <span class="number">0</span>, qr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= mid - <span class="number">1</span>; i++) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= len; i++) {</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ql &lt;= qr &amp;&amp; (f[i - mid] - (i - mid)) &gt; (f[q[qr]] - q[qr])) qr--;</span><br><span class="line">        q[++qr] = i - mid;</span><br><span class="line">        <span class="keyword">while</span> (ql &lt;= qr &amp;&amp; q[ql] &lt; (i - L[i])) ql++;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= qr) f[i] = <span class="built_in">max</span>(f[i], f[q[ql]] - q[ql] + i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f[len] * <span class="number">10</span> &gt;= len * <span class="number">9</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) {</span><br><span class="line">            sam.<span class="built_in">extend</span>(c - <span class="string">'0'</span>);</span><br><span class="line">        }</span><br><span class="line">        sam.<span class="built_in">extend</span>(<span class="number">2</span>); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        len = s.<span class="built_in">length</span>();</span><br><span class="line">        sam.<span class="built_in">find</span>(s, len);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = len<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) {</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) {</span><br><span class="line">                l = mid;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                r = mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="sp8093-jzpgyz-sevenk-love-oimaster"><a class="markdownIt-Anchor" href="#sp8093-jzpgyz-sevenk-love-oimaster"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vU1A4MDkz">SP8093 JZPGYZ - Sevenk Love Oimaster</a></h2><p>重要结论，SAM 上暴力跳链是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8002800000000001em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:.833em"><span class="mord mathnormal">n</span></span></span><span style="top:-2.76028em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.23972em"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，下面是证明：</p><p>设一个串长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span></span></span></span>，那么覆盖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的路径长度；同时又有SAM一个节点最多被覆盖后缀树上儿子个数次，因此这个上限是&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span></span></span></span>（SAM大小）</p><p>那么跳链的复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><mi>L</mi></mfrac></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min(L^2,|S|)=L\cdot \min(L,\dfrac{|S|}{L})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-.686em"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span> 的，由均值不等式不难得出不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>S</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-.11333499999999996em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9266650000000001em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:.833em"><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span><span style="top:-2.886665em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.11333499999999996em"><span></span></span></span></span></span></span></span></span>。</p><p>把所有串丢进广义SAM，对每一个节点打标记，记录组后一次它暴力跳到的串的编号。如果已经相同就不跳了。对于每一个询问，沿着转移边走，走到终止节点的覆盖次数即为答案。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">5e6</span><span class="number">+15</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>{</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> n,m,pre[MN],ans[MN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; col[MN];</span><br><span class="line">vector&lt;Query&gt; qry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gySAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],fa[MN],pos[MN],len[MN],cnt[MN],tot;</span><br><span class="line">    <span class="type">int</span> cnt_init[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) adj[i].<span class="built_in">clear</span>();</span><br><span class="line">        tot=<span class="number">1</span>; <span class="comment">// 初始状态设为1</span></span><br><span class="line">        fa[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        len[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[<span class="number">1</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[<span class="number">1</span>]));</span><br><span class="line">        cnt_init[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> lst)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nxt[lst][c] &amp;&amp; len[nxt[lst][c]] == len[lst]<span class="number">+1</span>) <span class="keyword">return</span> nxt[lst][c];</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        len[cur]=len[lst]<span class="number">+1</span>;</span><br><span class="line">        cnt_init[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="type">int</span> p=lst;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !nxt[p][c]){</span><br><span class="line">            nxt[p][c]=cur;</span><br><span class="line">            p=fa[p];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) fa[cur]=<span class="number">1</span>; <span class="comment">// 初始状态是1</span></span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q] == len[p]<span class="number">+1</span>) fa[cur]=q;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nq=++tot;</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(nxt[nq],nxt[q],<span class="built_in">sizeof</span>(nxt[q]));</span><br><span class="line">                fa[nq]=fa[q];</span><br><span class="line">                cnt_init[nq]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; nxt[p][c]==q){</span><br><span class="line">                    nxt[p][c]=nq;</span><br><span class="line">                    p=fa[p];</span><br><span class="line">                }</span><br><span class="line">                fa[q]=fa[cur]=nq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inittree</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) adj[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++) adj[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">}sam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>{</span><br><span class="line">    <span class="type">int</span> t[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(x&lt;MN){</span><br><span class="line">            t[x]+=k;</span><br><span class="line">            x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x){</span><br><span class="line">            ret+=t[x];</span><br><span class="line">            x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> siz[MN],dfn[MN],id[MN],dtot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        dfn[u]=++dtot;</span><br><span class="line">        id[dtot]=u;</span><br><span class="line">        siz[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query x,Query y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">1</span>; <span class="comment">// 初始状态设为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s){</span><br><span class="line">            lst=sam.<span class="built_in">extend</span>(c-<span class="string">'a'</span>,lst);</span><br><span class="line">            col[lst].<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sam.<span class="built_in">inittree</span>();</span><br><span class="line">    dtot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">// DFS根节点设为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">1</span>; <span class="comment">// 初始状态设为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s){</span><br><span class="line">            p=sam.nxt[p][c-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p){</span><br><span class="line">            qry.<span class="built_in">push_back</span>({dfn[p],dfn[p]+siz[p]<span class="number">-1</span>,i});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(qry.<span class="built_in">begin</span>(),qry.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> current_p=<span class="number">1</span>; <span class="comment">// 维护全局的current_p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q:qry){</span><br><span class="line">        <span class="keyword">while</span>(current_p &lt;= q.r){</span><br><span class="line">            <span class="type">int</span> u=id[current_p];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c:col[u]){</span><br><span class="line">                <span class="keyword">if</span>(pre[c]) bit.<span class="built_in">modify</span>(pre[c],<span class="number">-1</span>);</span><br><span class="line">                bit.<span class="built_in">modify</span>(current_p,<span class="number">1</span>);</span><br><span class="line">                pre[c]=current_p;</span><br><span class="line">            }</span><br><span class="line">            current_p++;</span><br><span class="line">        }</span><br><span class="line">        ans[q.id]=bit.<span class="built_in">query</span>(q.r)-bit.<span class="built_in">query</span>(q.l<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="p3649-apio2014-回文串"><a class="markdownIt-Anchor" href="#p3649-apio2014-回文串"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM2NDk">P3649 [APIO2014] 回文串</a></h2><p>首先建 SAM，让后跑 manacher，一旦出现回文串我们就放到 SAM 上查询。</p><p>现在问题转化为快速查询一个字串的出现次数，用上面我们提到的技巧倍增二分即可，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>也有纯 SAM 的，但是理解过于复杂，看不懂 www。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">6e5</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n,m,r[MN],poss[MN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> pre[<span class="number">20</span>][MN];</span><br><span class="line"><span class="type">char</span> p[MN];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],len[MN],c[MN],cnt[MN],id[MN],pos[MN],fa[MN],tot,lst;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        tot=lst=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>();</span><br><span class="line">        fa[cur]=fa[from];</span><br><span class="line">        <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(<span class="type">int</span> c)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>();</span><br><span class="line">        len[cur]=len[lst]<span class="number">+1</span>;</span><br><span class="line">        cnt[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p=lst;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(!p){</span><br><span class="line">            fa[cur]=<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>){</span><br><span class="line">                fa[cur]=q;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nq=<span class="built_in">clone</span>(q);</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                fa[cur]=fa[q]=nq;</span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;nxt[p][c]==q){</span><br><span class="line">                    nxt[p][c]=nq,p=fa[p];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        lst=cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getcnt</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) c[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) id[c[len[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">            cnt[fa[id[i]]]+=cnt[id[i]];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initst</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) pre[<span class="number">0</span>][i]=fa[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot;j++){</span><br><span class="line">                pre[i][j]=pre[i<span class="number">-1</span>][pre[i<span class="number">-1</span>][j]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(l&lt;<span class="number">1</span>||r&gt;n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> slen=r-l<span class="number">+1</span>,now=pos[r];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(pre[i][now]&amp;&amp;len[pre[i][now]]&gt;=slen) now=pre[i][now];</span><br><span class="line">        }</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*cnt[now]*(r-l<span class="number">+1</span>));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span>{</span><br><span class="line">    p[++m]=<span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        p[++m]=<span class="string">'#'</span>;</span><br><span class="line">        p[++m]=s[i];</span><br><span class="line">        poss[m]=i;</span><br><span class="line">    }</span><br><span class="line">    p[++m]=<span class="string">'#'</span>,p[++m]=<span class="string">'$'</span>;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">if</span>(i&lt;mx) r[i]=<span class="built_in">min</span>(mx-i,r[pos*<span class="number">2</span>-i]);</span><br><span class="line">        <span class="keyword">else</span> r[i]=<span class="number">1</span>;</span><br><span class="line">        sam.<span class="built_in">find</span>(poss[i-r[i]<span class="number">+2</span>],poss[i+r[i]<span class="number">-2</span>]);</span><br><span class="line">        <span class="keyword">while</span>(p[i-r[i]]==p[i+r[i]]){</span><br><span class="line">            r[i]++;</span><br><span class="line">            sam.<span class="built_in">find</span>(poss[i-r[i]<span class="number">+2</span>],poss[i+r[i]<span class="number">-2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i+r[i]&gt;mx){</span><br><span class="line">            mx=i+r[i],pos=i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    n=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">" "</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        sam.<span class="built_in">expand</span>(s[i]-<span class="string">'a'</span>);</span><br><span class="line">        sam.pos[i]=sam.lst;</span><br><span class="line">    }</span><br><span class="line">    sam.<span class="built_in">initst</span>();</span><br><span class="line">    sam.<span class="built_in">getcnt</span>();</span><br><span class="line">    <span class="built_in">manacher</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="p5546-poi-2000-公共串"><a class="markdownIt-Anchor" href="#p5546-poi-2000-公共串"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU1NDYjc3VibWl0">P5546 [POI 2000] 公共串</a></h2><p>战术建立广义 SAM，所有串的最长公共子串长度肯定不会超过最短的那个串，所以可以拿最短的那个串建机，然后把其他串放到上面匹配，让后记录每一个点经过的最小值，让后答案就是节点最小值的最大值。</p><h2 id="cf1037h-security"><a class="markdownIt-Anchor" href="#cf1037h-security"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMDM3SA">CF1037H Security</a></h2><p>战术建立 SAM，对于每个询问串，我们要在原串中求出一个字典序最小的串，使得其字典序比他大。考虑在 SAM 的 DAG 转移图上贪心从小到大选取点走，同时还需要利用线段树合并来判断当前字符串是否作为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">]</span></span></span></span> 的子串出现过，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEwMzcvc3VibWlzc2lvbi8zMjc4NjIyMDg">Submission #327862208 - Codeforces</a></p><h2 id="cf700e-cool-slogans"><a class="markdownIt-Anchor" href="#cf700e-cool-slogans"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y3MDBF">CF700E Cool Slogans</a></h2><p>神仙结论题。</p><p>link 树有一个结论，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> 的祖先，则状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 所表示的子串集合在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">longest</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{longest}(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mclose">)</span></span></span></span> 中出现次数与出现位置相同。</p><p>既然都这么说了，考虑建立 SAM，在 link 树上从根向下进行 dp，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 表示到节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 时最大值。</p><p>如果一个父节点的子串在子节点的子串中出现了至少两次，则转移时&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>&nbsp;加一，否则不变。</p><p>考虑如何判断至少出现两次，根据我们上面的结论，出现次数与出现位置相同。考虑设此时节点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span>，那么找到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 对应的 endpos 中任意一个位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span> 的子串一定在 link 树父亲节点出现了一次，那么我们只需要在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>−</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><msub><mi>a</mi><mi>x</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[pos-len(x)+len(fa_{x}),pos-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中出现即可，用线段树合并可以轻松解决，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzcwMC9zdWJtaXNzaW9uLzMyNzkwMjY4Ng">Submission #327902686</a></p><h2 id="uva1673-数字子串的和-str2int"><a class="markdownIt-Anchor" href="#uva1673-数字子串的和-str2int"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vVVZBMTY3Mw">UVA1673 数字子串的和 str2int</a></h2><p>建立广义后缀自动机，让后现在问题是计数，考虑 link 树上计数 DP。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 表示 SAM 上点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 代表的转台结尾的数字之和，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 表示不同的数字数目。</p><p>有转移：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>g</mi><mi>y</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>n</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo>=</mo><mi>y</mi></mrow></munder><msub><mi>g</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">g_{y}=\sum\limits_{nxt[x][c]=y} g_{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">]</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">c</span><span class="mclose mtight">]</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>y</mi></msub><munder><mo>∑</mo><mrow><mi>n</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo>=</mo><mi>y</mi></mrow></munder><msub><mi>f</mi><mi>x</mi></msub><mo>×</mo><mn>10</mn><mo>+</mo><msub><mi>g</mi><mi>x</mi></msub><mo>×</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f_{y}\sum\limits_{nxt[x][c]=y} f_{x}\times 10+g_{x}\times c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">]</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">c</span><span class="mclose mtight">]</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.7777700000000001em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span></span></p><p>初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[1]=0,g[1]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，答案即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum\limits f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-.25001em"></span><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.10764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">1e6</span><span class="number">+15</span>,MOD=<span class="number">2012</span>;</span><br><span class="line"><span class="type">int</span> n,f[MN],g[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gySAM</span>{</span><br><span class="line">    <span class="type">int</span> nxt[MN][<span class="number">26</span>],c[MN],id[MN],fa[MN],len[MN],mxl,tot;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++){</span><br><span class="line">            adj[i].<span class="built_in">clear</span>();</span><br><span class="line">            fa[i]=g[i]=f[i]=len[i]=c[i]=id[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(nxt[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[i]));</span><br><span class="line">        }</span><br><span class="line">        tot=<span class="number">1</span>;</span><br><span class="line">        mxl=<span class="number">0</span>;</span><br><span class="line">        g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gySAM</span>(){</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=++tot;</span><br><span class="line">        f[cur]=g[cur]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nxt[cur],<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> from)</span></span>{</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>();</span><br><span class="line">        fa[cur]=fa[from];</span><br><span class="line">        <span class="built_in">memcpy</span>(nxt[cur],nxt[from],<span class="built_in">sizeof</span>(nxt[from]));</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> lst)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]<span class="number">+1</span>) <span class="keyword">return</span> nxt[lst][c];</span><br><span class="line">        <span class="type">int</span> cur=<span class="built_in">newnode</span>(),p=lst,flag=<span class="number">0</span>,q,nq;</span><br><span class="line">        len[cur]=len[p]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(!p){</span><br><span class="line">            fa[cur]=<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            q=nxt[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]<span class="number">+1</span>){</span><br><span class="line">                fa[cur]=q;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(p==lst) flag=<span class="number">1</span>,cur=<span class="number">0</span>,tot--;</span><br><span class="line">                nq=<span class="built_in">clone</span>(q);</span><br><span class="line">                len[nq]=len[p]<span class="number">+1</span>;</span><br><span class="line">                fa[q]=fa[cur]=nq;</span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;nxt[p][c]==q){</span><br><span class="line">                    nxt[p][c]=nq;</span><br><span class="line">                    p=fa[p];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag?nq:cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>{</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">length</span>(),lst=<span class="number">1</span>;</span><br><span class="line">        s=<span class="string">" "</span>+s;</span><br><span class="line">        mxl=<span class="built_in">max</span>(mxl,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++){</span><br><span class="line">            lst=<span class="built_in">extend</span>(s[i]-<span class="string">'0'</span>,lst);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initc</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; ++i) c[len[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=mxl; ++i) c[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; ++i) c[len[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=mxl; ++i) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; ++i) id[c[len[i]]--]=i;    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">            <span class="type">int</span> u=id[i];</span><br><span class="line">            cerr&lt;&lt;u&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++){</span><br><span class="line">                <span class="keyword">if</span>((u==<span class="number">1</span>&amp;&amp;!j)||!nxt[u][j]) <span class="keyword">continue</span>;</span><br><span class="line">                (f[nxt[u][j]]+=g[u]*j+f[u]*<span class="number">10</span>)%=MOD;</span><br><span class="line">                (g[nxt[u][j]]+=g[u])%=MOD;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}sam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    sam.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        sam.<span class="built_in">insert</span>(s);</span><br><span class="line">    }</span><br><span class="line">    sam.<span class="built_in">initc</span>();</span><br><span class="line">    sam.<span class="built_in">solve</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sam.tot;i++) (ans+=f[i])%=MOD;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n){</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="cf666e-forensic-examination"><a class="markdownIt-Anchor" href="#cf666e-forensic-examination"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y2NjZF">CF666E Forensic Examination</a></h2><p>SAM 技巧大集合。首先考虑建出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s,t_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的广义 SAM，目标是查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 的子串在模板串区间的哪个串里出现次数最多。由于查询的是一个区间次数，考虑线段树合并维护，让后子串查询状态可以用倍增二分的技巧跳到对应状态在线段树上查询最大值就可以了。时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzY2Ni9zdWJtaXNzaW9uLzMyNzcyMzMyOQ">Submission #327723329 - Codeforces</a></p><h2 id="p5576-cmdoi2019-口头禅-洛谷"><a class="markdownIt-Anchor" href="#p5576-cmdoi2019-口头禅-洛谷"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU1NzY">P5576 [CmdOI2019] 口头禅 - 洛谷</a></h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2FydGljbGUvcmhjenp2MG4">command_block 题解</a></p><p>做法 3 好写，真的。</p><h2 id="p8368-lnoi2022-串-洛谷"><a class="markdownIt-Anchor" href="#p8368-lnoi2022-串-洛谷"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgzNjg">P8368 [LNOI2022] 串 - 洛谷</a></h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2FydGljbGUvZXN3OHlsc3A">题解：P8368 [LNOI2022] 串 - 洛谷专栏</a> 我的题解不是因为我不想复制，篇幅过长。</p><h1 id="6-后言"><a class="markdownIt-Anchor" href="#6-后言"></a> 6. 后言</h1><p>留一点练习题：</p><ul><li>轻重子树分治：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ0ODI">P4482 [BJWC2018] Border 的四种求法 - 洛谷</a></li><li>后缀树优化建图：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUyODQ">P5284 [十二省联考 2019] 字符串问题 - 洛谷</a></li><li>线段树合并：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ3NzA">P4770 [NOI2018] 你的名字 - 洛谷</a></li><li>LCT 在 link 树的应用（不会的可以用 ODT）：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDYyOTI">P6292 区间本质不同子串个数 - 洛谷</a></li><li>性质套 SAM：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNDY">P3346 [ZJOI2015]诸神眷顾的幻想乡</a></li><li>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 小：<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM5NzU">P3975 [TJOI2015]弦论</a></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li>罗勇军的《算法竞赛》</li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWxleC13ZWkvcC9Db21tb25fU3RyaW5nX1RoZW9yeV9UaGVvcnlfYXV0b21hdG9uX3JlbGF0ZWQuaHRtbA">常见字符串算法 II：自动机相关 - qAlex_Weiq</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cuY25ibG9ncy5jb20venpjdG9tbXk">zzctommy的后缀自动机练习记录</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9vaS5tZW4uY2kvc3VmZml4LWF1dG9tYXRvbi1ub3Rlcy8">后缀自动机学习笔记 | Menci’s OI Blog</a></li><li>Oi-Wiki</li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cuY25ibG9ncy5jb20venpjdG9tbXkvcC8xNDAxOTM4MC5odG1s">后缀自动机练习记录 - zzctommy - 博客园</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2FydGljbGUvcmhjenp2MG4">command_block 题解</a></li><li>神秘的物质</li></ul></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>SAM后缀自动机学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://worldcpu.github.io/posts/94c0669/">https://worldcpu.github.io/posts/94c0669/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>wjyppm</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-08-07</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-09-28</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a></div><div class="post-share"><div class="social-share" data-image="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220812014_686ffa5e9bdaf.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://s4.zstatic.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/17e083a8/" title="P3441——MET_Subway题解"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752211281055_686ffb41054b0_1_.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">P3441——MET_Subway题解</div></div><div class="info-2"><div class="info-item-1">形式化题面如下： 给定一棵有 nnn 个节点的无向树和一个整数 kkk，选出最多 kkk 条不分叉的路径（即简单链），使得这些路径覆盖的不同节点数尽可能多。输出最多能覆盖的节点数。 DP 显然不太好，考虑贪心，那么贪心尽量让链长。考虑直径一定作为答案的一部分出现，而剩下的就是直径上的分支，分支跨直径配对成路径。考虑这个如何配对，其实就是不同链的叶子两两配对，考虑以直径一端点为根，长链剖分加排序（链长大到小）取 2L−12L-12L−1 个叶子即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+1520;int n,L,rt,ftot,ans;pir...</div></div></div></a><a class="pagination-related" href="/posts/ff3126df/" title="SOSDP高维前缀和"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1754053132649_686ffa5b4f22e.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SOSDP高维前缀和</div></div><div class="info-2"><div class="info-item-1">0. 前言 前置知识： 状压 DP。 1. 概念与介绍 SOSDP，翻译过来就叫做子集和 DP，又称作高维前缀和，用来解决一些涉及子集和计算的问题。 我们通过一道例题来进行引入： 给你一个含 2n2^n2n 的集合 SSS，对于所有的 i∈[0,2n−1]i\in [0,2^n-1]i∈[0,2n−1]，求解 ∑j⊂isj\sum_{j\subset i}s_j∑j⊂i​sj​。 有一个显然的想法是模拟即可 O(4n)O(4^n)O(4n)，但是显然我们可以通过枚举子集轻松做到 O(3n)O(3^n)O(3n)，还能不能可以更优？ 上面枚举子集的方法我们看有没有什么问题，我们发现当一个状态的二进制位上有 kkk 个 0，那么它将在其他状态的带的时候被访问 2k−12^k-12k−1 次，存在许多重复且无用的计算，原因是因为我们每一个对应的 sis_isi​ 没有和状态建立起对应的练习，而是直接暴力枚举子集，我们需要添加另一个状态来避免上述的重复计算。 我们考虑状态的设计与添加，设状态 S(sta)={x∣x⊂sta}S(sta)=\{ x|x \subset sta\...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/6074ec1/" title="AC自动机的进阶应用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220808697_686ffa5e0afdb.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-29</div><div class="info-item-2">AC自动机的进阶应用</div></div><div class="info-2"><div class="info-item-1">0. 前言 你需要知道的芝士： AC 自动机基础； Trie 树； 这里是进阶使用，所以会结合一些例题来讲解，读者应有 AC 自动机的基础芝士即可。 1. 自动机与 AC 自动机本质 考虑到大多数都是先学 AC 自动机，而很久以后才学自动机，这里有必要先给出概念，这样才能更好的理解后面的芝士。 1.1 自动机 自动机，在 OI 中一般我们涉及的是有限状态自动机，它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以通过输入自动机，让自动机切换到其他的状态。任意时刻状态机只能处在一个状态。 而有限状态机可以表示为一个有向图： 从图中看出来一个信息学竞赛一共包含 5 个状态：学信竟，学 whk，吃吃饭，睡睡觉，摸摸鱼。每种带有箭头的连线，表示可以从当前状态切换到其他的状态，以及切换的条件。 我们列个表格： 学信竟 学 whk 吃吃饭 睡睡觉 摸摸鱼 学信竟 去机房 摆烂时间到 学 whk 信竟时间到 回去午睡 吃吃饭 去食堂 去教室 睡睡觉 回教室 被吵醒 摸摸鱼 回家 表格中左侧第一列为当前状态。...</div></div></div></a><a class="pagination-related" href="/posts/18adad6c/" title="Fail树"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220825149_686ffa84cd11c.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">Fail树</div></div><div class="info-2"><div class="info-item-1">0.引入 我们在写KMP的时候会求出来长度为nnn的字符串的前缀最长border的长度为Next[n]Next[n]Next[n]，接下来先介绍一个border 定义：对于一字符串SSS，用∣S∣|S|∣S∣表示其长度，后面我们简化用lenSlen_SlenS​来表示，那么SSS串的一个Border一定是SSS串的一个前缀，并且他前缀和后缀都能够相互匹配。举个例子，比如说“BeckyBe”的一个border就是Be,一个字符串的border可能有多个，但在这里我们要求的是最长的border 对于任意一个字符串SSS，一个Border的长度就对应一个Border（比如说上面的长度为2各border只能是“Be”），我们可以求出他所有border的长度分别为ne[ne[ne[lenSlen_SlenS​]，ne[ne[ne[ne[ne[ne[lenSlen_SlenS​]]]]]] 以此类推直到为0。根据上面的结论，我们可以知道，对一个字符串S求解next数组之后，我们就知道了S所有前缀（包括S自身）的所有Border了。 1.Fail树 fail树就是把所有next[i]n...</div></div></div></a><a class="pagination-related" href="/posts/517465e0/" title="manacher算法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picui.cn/free/2025/07/06/686a2182ad5e1.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-12</div><div class="info-item-2">manacher算法</div></div><div class="info-2"><div class="info-item-1">1.Manacher马拉车算法介绍 Manacher算法，又称马拉车算法。用于计算字符串每一个位置为对称中心的回文串长度，即可以用来查询一个长度为nnn的最长回文字串。他的时间复杂度是O(n)O(n)O(n)。是该情景中效率最高的（你不遍历整个字符串咋求出来） 回文串就是从头读到尾部和从尾部读到头都一样的字符串，例如“abbba”。一个回文串是镜像对称的，也就是说他反转之后也是和原串相同的，我们就是依靠这个性质来跑出马拉车算法的。 回文串有两种，一种是奇数的串，就是字符个数有奇数个。一种是偶数的串，例如“abba”就是一个。对于奇数的传，我们可以发现他的对称中心就是中间的‘b’，但是偶数的串呢。他就有2个对称中心，一个是第二个字符‘b’，一个是第三个字符‘b’（门前有两颗树，一颗是B树，另一个也是B树） 总之偶数的回文串对称中心有2个。 2.暴力法求解 不是说讲马拉车吗？怎么先给我讲暴力法啦？ 其实马拉车就是暴力法的改进。所以我们先讲讲暴力法如何求解。 我会枚举！，每次选一个点让后判断是不是回文串！ O(n3)O(n^3)O(n3) 我会优化！我们考虑到上述加粗的，一个回文串...</div></div></div></a><a class="pagination-related" href="/posts/469b7eaa/" title="后缀数组全家桶-从哈希乱搞到入门"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212693716_686ffa37946d9.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-03</div><div class="info-item-2">后缀数组全家桶-从哈希乱搞到入门</div></div><div class="info-2"><div class="info-item-1">可能更洛谷的阅读体验 0. 前言 后缀数组是信息学竞赛中解决字符串匹配的一大利器，其思想和实现非常简单。虽然倍增加排序的思想很简单，但是它的拓展 hththt 数组功能及其强大并且适用性广，在 OI 范围内广泛应用。 以下应用魏老师的一句话： 几乎所有字符串算法都存在一个共性：基于所求信息的特殊性质与已经求出的信息，使用增量法与势能分析求得所有信息。这体现了动态规划思想。—— Alex_Wei 希望读者也能好好利用这句话来理解字符串算法。 本文章包含后缀数组入门，以及应用，以及技巧及其好题选讲大礼包！ 但是作为本蒟蒻第一个写的算法全家桶，为了考虑到读者感受，写了一大堆没用的废话导致文章及其的长 ( •́ὤ•̀)，本文章共 2.1 万字，感谢管理员付出时间来进行审核。 一些基本约定： 本文章默认字符串下表从 111 开始。 我们用打字机字体表示字符串的内容，如：s=wjyppm1403s=\texttt{wjyppm1403}s=wjyppm1403。 拼接：s+ts+ts+t 表示将 ttt 拼接 sss 后。 字符集：即构成字符串中字符的集合。 空串：不含任何字符的字符...</div></div></div></a><a class="pagination-related" href="/posts/c64445da/" title="和哈希与随机赋权哈希"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212688653_686ffa4151534.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-29</div><div class="info-item-2">和哈希与随机赋权哈希</div></div><div class="info-2"><div class="info-item-1">1. 定义 和哈希，又称集合哈希。 为什么叫集合哈希呢，集合与序列的不同点在于，集合是无序的，也就是说，序列要求每个位置一一相等，而集合只需要对应的元素出现次数相等即可。 我们引入一个问题： 给定一个长为 nnn 的序列 AAA，每次给出两个长度相等的区间 [l1,r1],[l2,r2][l_{1},r_{1}],[l_{2},r_{2}][l1​,r1​],[l2​,r2​] 里面的数排序后是否完全相等，我们就可以说 [2,3,1,4,5][2,3,1,4,5][2,3,1,4,5] 和 [5,4,3,2,1][5,4,3,2,1][5,4,3,2,1] 是相同的。 这种情况我们很难找到一个数据结构来支持这样的查询操作，我们发现如果称两个区间相同，那么这个区间里的每一个数的出现次数和另外一个区间中这个数的出现次数相同。 我们考虑，只需要次数相同就可以的话，那么也就是说，这哈希值之和我数值具体是多少，而和位置无关，那么两个区间相等的必要条件就是 h(l1,r1)=h(l2,r2)h(l_{1},r_{1})=h(l_{2},r_{2})h(l1​,r1​)=h(l2​,r2...</div></div></div></a><a class="pagination-related" href="/posts/d9450503/" title="浅谈FFT与NTT在字符串匹配中的应用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212636113_686ffa99ef2da.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-29</div><div class="info-item-2">浅谈FFT与NTT在字符串匹配中的应用</div></div><div class="info-2"><div class="info-item-1">0. 前言 记录做题中遇见的一些好玩的科技。 1. 含通用符的字符串匹配问题 在没有通用符的字符串匹配问题中，我们一般使用 O(n+m)O(n+m)O(n+m) 的 KMP，多模匹配下我们会考虑 AC 自动机。但是，我们还有令玩意中做法： 设 P(x)=∑i=0m−1(Ai−Bx+i)P(x)=\sum\limits_{i=0}^{m-1} (A_{i}-B_{x+i})P(x)=i=0∑m−1​(Ai​−Bx+i​)。 但是 Ai−Bx+iA_{i}-B_{x+i}Ai​−Bx+i​ 是没有正负性这一说的，所以我们要将其平方，有： P(x)=∑i=0m−1(Ai−Bx+i)2=∑i=0m−1(Ai2−2AiBx+i+Bx+i2)\begin{aligned} P(x) &amp; =\sum\limits_{i=0}^{m-1} (A_{i}-B_{x+i})^2 \\ &amp; =\sum\limits_{i=0}^{m-1} (A_{i}^2-2A_{i}B_{x+i}+B_{x+i}^2) \end{aligned} P(x)​=i=0∑m−1​(Ai​−Bx+i​...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.luogu.com.cn/upload/usericon/578829.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">wjyppm</div><div class="author-info-description">高中蒟蒻信竟生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Worldcpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Worldcpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="/wjyccgg1403@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div style="text-align:left;font-size:14px;line-height:1.6">👋🏻我是PPM，一个热爱编程和信息学竞赛的高中生，喜欢分享做题经验。本博客中所有 latex 公式均可以选中后复制哦😊<br><br>❓有问题欢迎提问，确保内容有意义。如需联系我，欢迎通过邮箱联系我！📧<br><br>嗷嗷！热烈欢迎🤪！来自<br><span style="color:#2679cc"><span id="province" style="white-space:nowrap"></span><span id="city"></span></span><br>的朋友，你好呀！<br>你的网络IP为：<span id="ip" style="display:inline-block;filter:blur(5px);transition:filter .5s ease">***.***.***.***</span><br><br><span id="greet"></span></div><script>!function(){const t=(new Date).getHours(),e=t<6?"🌠凌晨好，早点休息！":t<12?"🌤️ 早上好，快趁机多睡点懒觉！":t<18?"☀️下午好，精神满满！":"🌙晚上好，早点休息！";document.getElementById("greet").textContent=e,fetch("https://qifu-api.baidubce.com/ip/local/geo/v1/district").then(t=>t.json()).then(t=>{if("Success"!==t.code)return void console.warn("接口返回错误",t);const e=t.ip||"***.***.***.***",n=t.data.prov||"",o=t.data.city||"";document.getElementById("province").textContent=n,document.getElementById("city").textContent=o;const c=document.getElementById("ip");c.setAttribute("title",e),c.addEventListener("mouseenter",()=>{c.textContent=e,c.style.filter="blur(0)"}),c.addEventListener("mouseleave",()=>{c.textContent="***.***.***.***",c.style.filter="blur(5px)"})}).catch(t=>{console.error("接口调用失败",t)})}()</script></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">1. 自动机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">2. 后缀自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-endpos-%E7%AD%89%E4%BB%B7%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 Endpos 等价类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-parent-tree"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 Parent Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%90%8E%E7%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 后缀链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%9E%84%E5%BB%BA-sam"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 构建 SAM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">4.</span> <span class="toc-text">3. 广义后缀自动机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%BB%93%E8%AE%BA"><span class="toc-number">5.</span> <span class="toc-text">4. 常用技巧与结论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">求本质不同子串个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E7%BB%B4%E6%8A%A4-endpos-%E9%9B%86%E5%90%88"><span class="toc-number">5.2.</span> <span class="toc-text">线段树合并维护 endpos 集合。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2%E7%9A%84%E5%AF%B9%E5%BA%94%E7%8A%B6%E6%80%81"><span class="toc-number">5.3.</span> <span class="toc-text">快速定位一个子串的对应状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E7%A1%AE%E5%AE%9A-dfs-%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">桶排确定 dfs 顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-number">6.</span> <span class="toc-text">5. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#p3804-%E6%A8%A1%E6%9D%BF%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-sam"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">P3804 【模板】后缀自动机 (SAM)</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#p6139-%E6%A8%A1%E6%9D%BF%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%B9%BF%E4%B9%89-sam"><span class="toc-number">6.1.</span> <span class="toc-text">P6139 【模板】广义后缀自动机（广义 SAM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p4070-sdoi2016%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92"><span class="toc-number">6.2.</span> <span class="toc-text">P4070 [SDOI2016]生成魔咒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p4022-ctsc2012%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0"><span class="toc-number">6.3.</span> <span class="toc-text">P4022 [CTSC2012]熟悉的文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sp8093-jzpgyz-sevenk-love-oimaster"><span class="toc-number">6.4.</span> <span class="toc-text">SP8093 JZPGYZ - Sevenk Love Oimaster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p3649-apio2014-%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">6.5.</span> <span class="toc-text">P3649 [APIO2014] 回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p5546-poi-2000-%E5%85%AC%E5%85%B1%E4%B8%B2"><span class="toc-number">6.6.</span> <span class="toc-text">P5546 [POI 2000] 公共串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf1037h-security"><span class="toc-number">6.7.</span> <span class="toc-text">CF1037H Security</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf700e-cool-slogans"><span class="toc-number">6.8.</span> <span class="toc-text">CF700E Cool Slogans</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uva1673-%E6%95%B0%E5%AD%97%E5%AD%90%E4%B8%B2%E7%9A%84%E5%92%8C-str2int"><span class="toc-number">6.9.</span> <span class="toc-text">UVA1673 数字子串的和 str2int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf666e-forensic-examination"><span class="toc-number">6.10.</span> <span class="toc-text">CF666E Forensic Examination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p5576-cmdoi2019-%E5%8F%A3%E5%A4%B4%E7%A6%85-%E6%B4%9B%E8%B0%B7"><span class="toc-number">6.11.</span> <span class="toc-text">P5576 [CmdOI2019] 口头禅 - 洛谷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p8368-lnoi2022-%E4%B8%B2-%E6%B4%9B%E8%B0%B7"><span class="toc-number">6.12.</span> <span class="toc-text">P8368 [LNOI2022] 串 - 洛谷</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%90%8E%E8%A8%80"><span class="toc-number">7.</span> <span class="toc-text">6. 后言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a6ad8815/" title="路线反思"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220823460_686ffb1d0f61f.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="路线反思"></a><div class="content"><a class="title" href="/posts/a6ad8815/" title="路线反思">路线反思</a><time datetime="2025-09-28T13:08:28.000Z" title="发表于 2025-09-28 21:08:28">2025-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e9478aba/" title="猫树分治"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212663165_686ffa507c01b.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="猫树分治"></a><div class="content"><a class="title" href="/posts/e9478aba/" title="猫树分治">猫树分治</a><time datetime="2025-09-21T13:46:02.000Z" title="发表于 2025-09-21 21:46:02">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c8836e51/" title="MatrixTree矩阵树定理"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752211281055_686ffb41054b0_1_.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MatrixTree矩阵树定理"></a><div class="content"><a class="title" href="/posts/c8836e51/" title="MatrixTree矩阵树定理">MatrixTree矩阵树定理</a><time datetime="2025-09-17T09:03:17.000Z" title="发表于 2025-09-17 17:03:17">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9dc41a00/" title="abc423题解"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752221267079_686ffac98b90e.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="abc423题解"></a><div class="content"><a class="title" href="/posts/9dc41a00/" title="abc423题解">abc423题解</a><time datetime="2025-09-15T00:10:36.000Z" title="发表于 2025-09-15 08:10:36">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/904f5191/" title="整体DP—从勤拿少取到量大管饱"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1757634776012_50f5f31f0d226d3652d507f8e96fb81f.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="整体DP—从勤拿少取到量大管饱"></a><div class="content"><a class="title" href="/posts/904f5191/" title="整体DP—从勤拿少取到量大管饱">整体DP—从勤拿少取到量大管饱</a><time datetime="2025-09-11T23:50:40.000Z" title="发表于 2025-09-12 07:50:40">2025-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 By wjyppm</span><span class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://s4.zstatic.net/ajax/libs/fancyapps-ui/6.0.22/fancybox/fancybox.umd.js"></script><script src="https://s4.zstatic.net/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"),await btf.getScript("https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{const t="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=null,s=t=>"dark"===t?"dark":"light",a=(a=document,o)=>{const n=t?{"data-mapping":"specific","data-term":o}:{"data-mapping":"pathname"},c=(t=>{const e=document.createElement("script");return Object.entries(t).forEach(([t,s])=>{e.setAttribute(t,s)}),e})({src:"https://giscus.app/client.js","data-repo":"Worldcpu/Worldcpu.github.io","data-repo-id":"R_kgDOOYWiqQ","data-category-id":"DIC_kwDOOYWiqc4CpBzT","data-theme":s(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...e,...n});a.querySelector("#giscus-wrap").appendChild(c),t&&(window.shuoshuoComment.destroyGiscus=()=>{a.children.length&&(a.innerHTML="",a.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{const e=document.querySelector("#giscus-wrap iframe");if(e){const a={giscus:{setConfig:{theme:s(t)}}};e.contentWindow.postMessage(a,"https://giscus.app")}},"giscus"),t?window.shuoshuoComment={loadComment:a}:a()})()</script></div><script async src="/js/diytitle.js"></script><script async src="/js/nav.js"></script><script src="https://s4.zstatic.net/ajax/libs/activate-power-mode/1.0.0/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://s4.zstatic.net/ajax/libs/pjax/0.2.8/pjax.js"></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:description"]','link[rel="canonical"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!1,scrollRestoration:!1});const e=e=>{e&&Object.values(e).forEach(e=>e())};document.addEventListener("pjax:send",()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");const t=document.body.classList;t.contains("read-mode")&&t.remove("read-mode"),e(window.globalFn.pjaxSend)}),document.addEventListener("pjax:complete",()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),e(window.globalFn.pjaxComplete)}),document.addEventListener("pjax:error",e=>{if(404===e.request.status){!0?pjax.loadUrl("/404.html"):window.location.href="/404.html"}})})()</script><script async data-pjax="" src="https://s4.zstatic.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>