<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>树链剖分 | wjyppm's Blog</title><meta name="author" content="wjyppm"><meta name="copyright" content="wjyppm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0.前言 你需要的必备芝士：  图的存储与遍历。 DFS序。 线段树的基础应用。 LCA的概念与性质。  准备好了？Let’s GO!  1.重链剖分 什么是树链剖分？他是干什么的？ 树链剖分，字面意思就是将树剖成一条一条链，让后我们利用这些链来维护树上路径的信息。 那我们举个例子吧。  nnn 个点的树，有 mmm 次操作，每一次操作将树上 x→yx\rightarrow yx→y 的路径都加"><meta property="og:type" content="article"><meta property="og:title" content="树链剖分"><meta property="og:url" content="https://worldcpu.github.io/posts/7e454910/index.html"><meta property="og:site_name" content="wjyppm's Blog"><meta property="og:description" content="0.前言 你需要的必备芝士：  图的存储与遍历。 DFS序。 线段树的基础应用。 LCA的概念与性质。  准备好了？Let’s GO!  1.重链剖分 什么是树链剖分？他是干什么的？ 树链剖分，字面意思就是将树剖成一条一条链，让后我们利用这些链来维护树上路径的信息。 那我们举个例子吧。  nnn 个点的树，有 mmm 次操作，每一次操作将树上 x→yx\rightarrow yx→y 的路径都加"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220074863_686ffaf65c374.jpg"><meta property="article:published_time" content="2025-04-18T12:19:27.000Z"><meta property="article:modified_time" content="2025-09-28T13:11:28.617Z"><meta property="article:author" content="wjyppm"><meta property="article:tag" content="图论"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220074863_686ffaf65c374.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "树链剖分",
  "url": "https://worldcpu.github.io/posts/7e454910/",
  "image": "https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220074863_686ffaf65c374.jpg",
  "datePublished": "2025-04-18T12:19:27.000Z",
  "dateModified": "2025-09-28T13:11:28.617Z",
  "author": [
    {
      "@type": "Person",
      "name": "wjyppm",
      "url": "https://worldcpu.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://worldcpu.github.io/posts/7e454910/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/7.0.0/css/all.min.css"><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/fancyapps-ui/6.0.22/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>!function(t,e,n,c,r,s,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(c)).async=1,s.src="https://www.clarity.ms/tag/srmn9gtuyc",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(s,a)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://s4.zstatic.net/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"树链剖分",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/touming.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image:url(https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1754709022174_【哲风壁纸】奇幻森林-柯娜：精神之桥.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.luogu.com.cn/upload/usericon/578829.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220074863_686ffaf65c374.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">wjyppm's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">树链剖分</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i> <span>返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">树链剖分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-18T12:19:27.000Z" title="发表于 2025-04-18 20:19:27">2025-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T13:11:28.617Z" title="更新于 2025-09-28 21:11:28">2025-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>你需要的必备芝士：</p><ol><li>图的存储与遍历。</li><li>DFS序。</li><li>线段树的基础应用。</li><li>LCA的概念与性质。</li></ol><p>准备好了？Let’s GO!</p><h1 id="1重链剖分"><a class="markdownIt-Anchor" href="#1重链剖分"></a> 1.重链剖分</h1><p>什么是树链剖分？他是干什么的？</p><p>树链剖分，字面意思就是将树剖成一条一条链，让后我们利用这些链来维护树上路径的信息。</p><p>那我们举个例子吧。</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点的树，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 次操作，每一次操作将树上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的路径都加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的权值 ，求树所有节点的权值之和。</p></blockquote><p>不难发现树上差分。直接差分做一做就可以了，不知道的可以看<a href="/go.html?u=aHR0cHM6Ly93b3JsZGNwdS5naXRodWIuaW8vJUU2JUEwJTkxJUU0JUI4JThBJUU1JUI3JUFFJUU1JTg4JTg2Lmh0bWw" rel="external nofollow noopener noreferrer" target="_blank">我的博客</a>。</p><p>但是如果我想求路径的值呢？</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点的树，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 次操作，每一次操作将树上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的路径都加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的权值 。<br>给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> 次询问，询问最短路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u\rightarrow v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>上的权值之和</p></blockquote><p>这个时候问题就不一样了，仅靠差分的话复杂度会炸成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mclose">)</span></span></span></span>，怎么办？如果这个问题我们不放到树上，我们就是一个数组的操作，很简单对吧，线段树和树状数组都可以轻轻松松的做到，但是放到树上怎么做我们肯定是不会的。接下来我们要介绍树链剖分是如何做到这一点的。</p><blockquote><p>树链剖分，就是把树剖分成若干条链，使其组合成线性结构，让后用数据结构维护链的信息。 ——OI Wiki</p></blockquote><p>说人话就是：<strong>把一颗树拆成若干个不相交的链，让后用数据结构维护链的信息</strong>。</p><p>说到底为什么我们非要拆成链来维护呢？回忆树上差分，差分本质上我们只能在一个线性结构比如说数组上维护，但是放在树上我们不会做。但是我们可以把一条路径在LCA处劈成2半，分别进行拆分，如下图。我们将这颗树的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">3\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>的路径都加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 。我们拆成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>→</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">3 \rightarrow 2,5\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">6</span></span></span></span>，2条线性的链，这样我们进行差分就十分方便了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/Pasted%20image%2020250418172155.png" alt=""></p><p>让后差分的结果如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/Pasted%20image%2020250418172450.png" alt=""></p><p>而对于路径信息的维护也很好说，就像差分拆成链的思想一样，我们也用链来去维护。上文我们提到了如果我们不放到树上就很好做，只需要用线段树来去维护就可以了，问题在于树不是像数组。但是我们可以利用拆链的思想，把它拆成一条一条链，这样不就类似于数组了吗，让后我们维护数组的信息，就可以了。</p><p>现在问题在于我们怎么把树拆成一条一条链？而且这个链应该怎么拆才能保证我的复杂度不会炸掉？</p><p>我们有2种方法，一种叫重链剖分，一种叫长链剖分。我们先讲重链剖分。</p><p>先来几个概念，别怕会有图辅助理解的：</p><ul><li>重儿子（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">hson</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>数组记录）：该节点子树中，节点个数最多的子树的根节点，即为该节点的重儿子。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/Pasted%20image%2020250418173107.png" alt=""></p><p>对于上面的树结构，节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的重儿子就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 因为节点个数有4个，而对于节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span> 的重儿子是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span> ，因为有2个比3号点要大。而对于3，6，5号点没有重儿子，因为他们是叶子节点。</p><ul><li>重边：连接该节点与它重儿子的边</li></ul><p>就像上面，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\rightarrow 2,2\rightarrow 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span>。</p><ul><li>重链（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span>数组记录顶端）：由一系列重边相连得到的链。特别的，落单的节点也是重链。</li><li>轻链：由一系列非重边相连得到的链。</li></ul><p>借用OI-Wiki的图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/Pasted%20image%2020250418184629.png" alt=""></p><p>这样就不难得到拆树的方法。对于每个节点我们只需要找出它的重儿子，让后就可以根据这些信息拆成许多许多链了。</p><p>话是这么说但是到底咋求？</p><p>我们要分成2次来DFS进行求，我们需要维护如下信息。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">变量名</th><th style="text-align:center">含义</th><th style="text-align:center">维护方式</th></tr></thead><tbody><tr><td style="text-align:center">子树大小</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span></td><td style="text-align:center">子树节点的数量，用于判断轻重儿子</td><td style="text-align:center">自底向上统计（第一次DFS）</td></tr><tr><td style="text-align:center">重儿子</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">hson</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></td><td style="text-align:center">一个节点的重儿子，若无默认为0</td><td style="text-align:center">用子树大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span>计算取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">siz[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">]</span></span></span></span>最大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>（第一次DFS）</td></tr><tr><td style="text-align:center">节点深度</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span></span></span></span></td><td style="text-align:center">节点在树的深度</td><td style="text-align:center">自上向下计算（第一次DFS）</td></tr><tr><td style="text-align:center">节点的父亲</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span></td><td style="text-align:center">父亲节点</td><td style="text-align:center">字面意思维护即可（第一次DFS）</td></tr><tr><td style="text-align:center">重链</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span></td><td style="text-align:center">一条重链的顶端节点，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">top[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>号点所在链的顶端</td><td style="text-align:center">遍历重儿子赋值即可（第二次DFS）</td></tr><tr><td style="text-align:center">按照链遍历的DFS序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span></td><td style="text-align:center">重链优先遍历的DFS序</td><td style="text-align:center">字面意思先遍历重边在遍历轻边（第二次DFS）</td></tr></tbody></table><p>根据这个表，我们能够很轻松的设计出第一个DFS函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{<span class="comment">// u号节点，父亲节点是pre</span></span><br><span class="line">    dep[u]=dep[pre]<span class="number">+1</span>;<span class="comment">// 深度</span></span><br><span class="line">    siz[u]=<span class="number">1</span>;<span class="comment">// 子树大小</span></span><br><span class="line">    fa[u]=pre;<span class="comment">// 父亲</span></span><br><span class="line">    <span class="type">int</span> maxp=<span class="number">-1</span>;<span class="comment">//初始化最大sizv为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(maxp&lt;siz[v]){<span class="comment">// 更新hson</span></span><br><span class="line">            maxp=siz[v];</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而对于第二次的DFS函数，也是很好设计。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">    id[u]=++cnt;<span class="comment">// 设置id，因为我们优先遍历重链所以是重链优先的dfn序</span></span><br><span class="line">    top[u]=ltop;<span class="comment">//节点u所在链的顶端</span></span><br><span class="line">    <span class="keyword">if</span>(!hson[u]) <span class="keyword">return</span>;<span class="comment">//如果没有重儿子显然叶子节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],ltop);<span class="comment">// 先剖重链</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>; <span class="comment">// 别忘了排除重儿子！</span></span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);<span class="comment">//处理轻链</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span> 还好说，为什么要设计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> ？别忘了，我们最终是要用线段树等数据结构来进行维护，这样维护的话一条链在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> 上是排成一个连续区间（即DFS序是连续的），这样就方便了。</p><p>我们建一颗支持区间加的线段树，让后我们考虑怎么维护树上的操作。</p><p>回顾上面的图，我们其实对于路径来说就是根据LCA拆成2条链进行操作。</p><p>问题来了，怎么求LCA？</p><p>一个很显然的想法就是倍增求LCA，但是我跟你说这个也可以同时求出LCA呢？</p><p>我们对上面的图进行小小的改编，并进行重链剖分。对于6号点也是可以作为最长重链的终点，不过链不能分叉。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/Pasted%20image%2020250418185208.png" alt=""></p><p>我们不妨借鉴倍增求LCA的思想：2个节点借助<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span>数组跳到同一个节点。对于重链剖分来说，就是在不同重链的节点，我们让他们不断的跳直到处于同一重链（如果一开始就是同一重链，想一想还用跳吗？）。还记得我们求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span> 数组吗？这个就是替代倍增<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span>的关键。我们直接跳到链的顶端，这样就可以有像倍增跳<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span>一样的效果了！当然和倍增算法一样，我们让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dep[top[x]],dep[top[y]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>中深度大的往上跳。</p><p>跳到最后会出现一个情况，虽然<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span>在一条链上但不一定重合，此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span></span></span></span>就是深度小的节点。</p><p>不难有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span></span></span></span>函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){<span class="comment">//如果不在一条链就继续跳</span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]){<span class="comment">// 优先跳深度大的</span></span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        }</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;<span class="comment">// 深度小的即为LCA</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>等会，时间复杂度多少？这个我们待会再说。</p><p>LCA求完那就都好说，直接LCA维护就可以了。</p><p>例如路径加：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll k)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        sg.<span class="built_in">add</span>(<span class="number">1</span>,id[top[x]],id[x],k);<span class="comment">// x跳的过程中我们就要加上权值，顺序不要搞反了。</span></span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    sg.<span class="built_in">add</span>(<span class="number">1</span>,id[x],id[y],k);</span><br><span class="line">    <span class="comment">// 处理路径LCA-&gt;y的权值，因为LCA与y已经在一条链上所以可以直接加</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有的人会说，你这个跳LCA的时候会更换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span>，难道不会重复加吗？这种问题的解法可以自己模拟一遍LCA的跳法，看看是否会重复加区间，显然是不会的。</p><p>到这里前面2个问题就解决完毕了，但是我还有一个问题。如果我要加子树的权值呢。</p><blockquote><p>给定节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>的子树内权值都加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.02691em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。特别的，叶子节点的子树就是节点本身。</p></blockquote><p>我们思考一个问题，重链优先遍历在子树内的DFS序是连续的吗？</p><p>显然是连续的，这里不再证明。</p><p>那么就好说了，直接对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[id[x],id[x]+siz[x]-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>维护即可。减一是因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span>包含自己<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addchild</span><span class="params">(<span class="type">int</span> x,ll k)</span></span>{ <span class="comment">//加</span></span><br><span class="line">    sg.<span class="built_in">add</span>(<span class="number">1</span>,id[x],id[x]+siz[x]<span class="number">-1</span>,k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">querychild</span><span class="params">(<span class="type">int</span> x)</span></span>{ <span class="comment">// 查</span></span><br><span class="line">    <span class="keyword">return</span> sg.<span class="built_in">query</span>(<span class="number">1</span>,id[x],id[x]+siz[x]<span class="number">-1</span>)%MOD;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以时间复杂度到底是多少？</p><p>有一个性质：<strong>向下经过一条&nbsp;轻边&nbsp;时，所在子树的大小至少会除以二。</strong></p><p>这个是根据性质来说的，那么不难发现，我们拆LCA路径的做法只需要最多走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>次，树上每条路径最多可以划分成不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>条重链。</p><p>来做题，P3884:</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span>个节点的树，根节点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span>，树节点有初始权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.02691em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span>次操作:<br><code>1 x y z</code>，表示将树从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 结点最短路径上所有节点的值都加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span>。<br><code>2 x y</code>，表示求树从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 结点最短路径上所有节点的值之和。<br><code>3 x z</code>，表示将以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 为根节点的子树内所有节点值都加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span>。<br><code>4 x</code> 表示求以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 为根节点的子树内所有节点值之和。<br>数据对给定的模数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span>取模。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>R</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>P</mi><mo>≤</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 10^5,1\le R \le n,1\le P \le 2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8304100000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.13597em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.13597em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><p>照着写就可以了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">5e5</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n,m,rt,MOD,cnt,dep[MN],siz[MN],fa[MN],id[MN],hson[MN],top[MN];</span><br><span class="line">ll w[MN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>{</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span>{</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        ll sum,add;</span><br><span class="line">    }t[MN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>{</span><br><span class="line">        t[p].sum=(t[ls].sum+t[rs].sum)%MOD;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>{</span><br><span class="line">        t[p].l=l;</span><br><span class="line">        t[p].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r){</span><br><span class="line">            t[p].sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].add){</span><br><span class="line">            t[ls].sum=(t[ls].sum+(t[ls].r-t[ls].l<span class="number">+1</span>)*t[p].add)%MOD;</span><br><span class="line">            t[rs].sum=(t[rs].sum+(t[rs].r-t[rs].l<span class="number">+1</span>)*t[p].add)%MOD;</span><br><span class="line"></span><br><span class="line">            t[ls].add=(t[ls].add+t[p].add)%MOD;</span><br><span class="line">            t[rs].add=(t[rs].add+t[p].add)%MOD;</span><br><span class="line"></span><br><span class="line">            t[p].add=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> fl,<span class="type">int</span> fr,ll k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr){</span><br><span class="line">            t[p].add=(t[p].add+k)%MOD;</span><br><span class="line">            t[p].sum=(t[p].sum+(t[p].r-t[p].l<span class="number">+1</span>)*k)%MOD;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=fl) <span class="built_in">add</span>(ls,fl,fr,k);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;fr) <span class="built_in">add</span>(rs,fl,fr,k);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> fl,<span class="type">int</span> fr)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr){</span><br><span class="line">            <span class="keyword">return</span> t[p].sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=fl) ret=(ret+<span class="built_in">query</span>(ls,fl,fr))%MOD;</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;fr) ret=(ret+<span class="built_in">query</span>(rs,fl,fr))%MOD;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">}sg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">    dep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=pre;</span><br><span class="line">    <span class="type">int</span> maxp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(maxp&lt;siz[v]){</span><br><span class="line">            maxp=siz[v];</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">    id[u]=++cnt;</span><br><span class="line">    top[u]=ltop;</span><br><span class="line">    <span class="keyword">if</span>(w[u]!=<span class="number">0</span>){</span><br><span class="line">        sg.<span class="built_in">add</span>(<span class="number">1</span>,id[u],id[u],w[u]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!hson[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addchain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll k)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        sg.<span class="built_in">add</span>(<span class="number">1</span>,id[top[x]],id[x],k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    sg.<span class="built_in">add</span>(<span class="number">1</span>,id[x],id[y],k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">querychain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">    ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ret=(ret+sg.<span class="built_in">query</span>(<span class="number">1</span>,id[top[x]],id[x]))%MOD;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ret=(ret+sg.<span class="built_in">query</span>(<span class="number">1</span>,id[x],id[y]))%MOD;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addchild</span><span class="params">(<span class="type">int</span> x,ll k)</span></span>{</span><br><span class="line">    sg.<span class="built_in">add</span>(<span class="number">1</span>,id[x],id[x]+siz[x]<span class="number">-1</span>,k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">querychild</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> sg.<span class="built_in">query</span>(<span class="number">1</span>,id[x],id[x]+siz[x]<span class="number">-1</span>)%MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// freopen("ans.in","r",stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;rt&gt;&gt;MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    sg.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">dfs1</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        ll z;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>){</span><br><span class="line">            cin&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            <span class="built_in">addchain</span>(x,y,z%MOD);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>){</span><br><span class="line">            cin&gt;&gt;y;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">querychain</span>(x,y)%MOD&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>){</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            <span class="built_in">addchild</span>(x,z);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>){</span><br><span class="line">            cout&lt;&lt;<span class="built_in">querychild</span>(x)%MOD&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="11-例题"><a class="markdownIt-Anchor" href="#11-例题"></a> 1.1 例题</h2><p>CF1555F:</p><blockquote><p>有一含&nbsp;n&nbsp;个点的带权无向图。<br>一个<strong>简单环</strong>被定义为图上一没有重复顶点的环。令这样的一个环的权重为它环上所有边的权值的异或和。<br>若一个图中全部<strong>简单环</strong>的权重都是&nbsp;1&nbsp;，那么我们称这个图为<strong>好图</strong>，而一个图若不是<strong>好图</strong>，那么这个图则是<strong>坏图</strong>。<br>最开始，图是空的。接着会有&nbsp;q&nbsp;个询问。每个询问为以下格式：<br>u&nbsp;v&nbsp;x&nbsp;— 若不会使图变成坏图，则在点&nbsp;u&nbsp;与点&nbsp;v&nbsp;间加一条权值为&nbsp;x&nbsp;的边。<br>对于每一个询问输出到底加不加这条边。</p></blockquote><p>这个不是图论吗？和树上路径有什么关系？</p><p>针对环的问题我们有一个套路就是：离线造生成树。</p><p>环用并查集判断联通性。</p><p>我们考虑什么边能加进来，第一类就是生成树本来的边是可以加；第二类就是这条非树边加入所构成的环不与其他的任何环相交，并且路径异或和为1即可。</p><p>非树边的加入我们可以考虑转化成线段树最大值/和来维护，我们把在环上的边赋值为1，不再的赋值为0，可以加入的条件就是路径上所有边权值都是0，考虑树剖。路径异或和为1考虑树上前缀异或和。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MN=<span class="number">5e5</span><span class="number">+15</span>,MQ=<span class="number">5e5</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt,id[MN],sum[MN],hson[MN],pre[MN],top[MN],dep[MN],siz[MN],fa[MN];</span><br><span class="line"><span class="type">bool</span> isok[MN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qedge</span>{</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">}q[MQ];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>{</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">};</span><br><span class="line">vector&lt;edge&gt; adj[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>{</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">    <span class="keyword">struct</span>{</span><br><span class="line">        <span class="type">int</span> l,r,val,cov;</span><br><span class="line">    }t[MN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>{</span><br><span class="line">        t[p].val=<span class="built_in">max</span>(t[ls].val,t[rs].val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>{</span><br><span class="line">        t[p].l=l;</span><br><span class="line">        t[p].r=r;</span><br><span class="line">        t[p].cov=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r){</span><br><span class="line">            t[p].val=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].cov!=<span class="number">-1</span>){</span><br><span class="line">            t[ls].val=t[ls].cov=t[rs].val=t[rs].cov=t[p].cov;</span><br><span class="line">            t[p].cov=<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> fl,<span class="type">int</span> fr,<span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr){</span><br><span class="line">            t[p].val=t[p].cov=k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=fl) <span class="built_in">update</span>(ls,fl,fr,k);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;fr) <span class="built_in">update</span>(rs,fl,fr,k);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queryone</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> fl,<span class="type">int</span> fr)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr){</span><br><span class="line">            <span class="keyword">return</span> t[p].val;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=fl&amp;&amp;<span class="built_in">queryone</span>(ls,fl,fr)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;fr&amp;&amp;<span class="built_in">queryone</span>(rs,fl,fr)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">}sg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initpre</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pree)</span></span>{</span><br><span class="line">    dep[u]=dep[pree]<span class="number">+1</span>;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=pree;</span><br><span class="line">    <span class="type">int</span> maxp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u]){</span><br><span class="line">        <span class="type">int</span> v=e.v,w=e.w;</span><br><span class="line">        <span class="keyword">if</span>(v==pree) <span class="keyword">continue</span>;</span><br><span class="line">        sum[v]=sum[u]^w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(maxp&lt;siz[v]){</span><br><span class="line">            maxp=siz[v];</span><br><span class="line">            hson[u]=v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">    id[u]=++cnt;</span><br><span class="line">    top[u]=ltop;</span><br><span class="line">    <span class="keyword">if</span>(!hson[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u]){</span><br><span class="line">        <span class="type">int</span> v=e.v,w=e.w;</span><br><span class="line">        <span class="keyword">if</span>(v==hson[u]||v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(pre[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> pre[x]=<span class="built_in">root</span>(pre[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(sg.<span class="built_in">queryone</span>(<span class="number">1</span>,id[top[x]],id[x])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(id[x]<span class="number">+1</span>&lt;=id[y]&amp;&amp;sg.<span class="built_in">queryone</span>(<span class="number">1</span>,id[x]<span class="number">+1</span>,id[y])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        sg.<span class="built_in">update</span>(<span class="number">1</span>,id[top[x]],id[x],<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(id[x]<span class="number">+1</span>&lt;=id[y])sg.<span class="built_in">update</span>(<span class="number">1</span>,id[x]<span class="number">+1</span>,id[y],k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//freopen("ans.in","r",stdin);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    sg.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,MQ);</span><br><span class="line">    <span class="built_in">initpre</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        cin&gt;&gt;q[i].u&gt;&gt;q[i].v&gt;&gt;q[i].w;</span><br><span class="line">        <span class="type">int</span> ru=<span class="built_in">root</span>(q[i].u),rv=<span class="built_in">root</span>(q[i].v);</span><br><span class="line">        <span class="keyword">if</span>(ru!=rv){</span><br><span class="line">            isok[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;q[i].u&lt;&lt;" "&lt;&lt;q[i].v&lt;&lt;" "&lt;&lt;q[i].w&lt;&lt;'\n';</span></span><br><span class="line">            adj[q[i].u].<span class="built_in">push_back</span>({q[i].v,q[i].w});</span><br><span class="line">            adj[q[i].v].<span class="built_in">push_back</span>({q[i].u,q[i].w});</span><br><span class="line">            pre[rv]=ru;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(!dep[i]){</span><br><span class="line">            <span class="built_in">dfs1</span>(i,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dfs2</span>(i,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//cout&lt;&lt;cnt&lt;&lt;'\n';</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">if</span>(isok[i]) cout&lt;&lt;<span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span>(!(sum[q[i].u]^sum[q[i].v]^q[i].w)) cout&lt;&lt;<span class="string">"NO\n"</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">ask</span>(q[i].u,q[i].v)){</span><br><span class="line">                    cout&lt;&lt;<span class="string">"NO\n"</span>;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">modify</span>(q[i].u,q[i].v,<span class="number">1</span>);</span><br><span class="line">                    cout&lt;&lt;<span class="string">"YES\n"</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="12-lca"><a class="markdownIt-Anchor" href="#12-lca"></a> 1.2 LCA</h2><p>根据我们上面说的求就可以了，这里给出一个模板。</p><p>时间复杂度预处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，常数小，代码简单。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">5e5</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> hson[MN],dep[MN],top[MN],fa[MN],siz[MN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    fa[u]=pre;</span><br><span class="line">    dep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> maxp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(maxp&lt;siz[v]){</span><br><span class="line">            hson[u]=v;</span><br><span class="line">            maxp=siz[v];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">    top[u]=ltop;</span><br><span class="line">    <span class="keyword">if</span>(!hson[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==hson[u]){</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]){</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        }</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(s,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">lca</span>(u,v)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2长链剖分"><a class="markdownIt-Anchor" href="#2长链剖分"></a> 2.长链剖分</h1><h2 id="21-介绍"><a class="markdownIt-Anchor" href="#21-介绍"></a> 2.1 介绍</h2><p>长链剖分和重链剖分不一样的一点，前者以子树深度最大的儿子为重儿子，而后者以子树大小最大的儿子为重儿子。</p><p>举个例子，例如下面这棵树，绿色的边就是长链：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.luogu.com.cn/upload/pic/73806.png" alt=""></p><p>我们定义一个节点和它的长儿子节点相连的边（就是上图绿色的边）为实边，其他为虚边。</p><p>以下是代码实现，和重链剖分差不太多：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> dep[MN],fa[MN],mxdep[MN],htop[MN],len[MN],hson[MN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        fa[u]=pre;</span><br><span class="line">        dep[u]=mxdep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=hd[u];i;i=nxt[i]){</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(mxdep[u]&lt;mxdep[v]) mxdep[u]=mxdep[v],hson[u]=v;</span><br><span class="line">        }</span><br><span class="line">        len[u]=mxdep[u]-dep[u]<span class="number">+1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">        htop[u]=ltop;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u]){<span class="keyword">return</span>;}</span><br><span class="line">        <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=hd[u];i;i=nxt[i]){</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br></pre></td></tr></tbody></table></figure><h2 id="22-长链剖分的性质"><a class="markdownIt-Anchor" href="#22-长链剖分的性质"></a> 2.2 长链剖分的性质</h2><p>长链剖分有如下的性质：</p><ul><li>从根节点到任意叶子结点经过的轻边条数不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-.23972em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8002800000000001em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:.833em"><span class="mord mathnormal">n</span></span></span><span style="top:-2.76028em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.23972em"><span></span></span></span></span></span></span></span></span>，比重链剖分的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span></span></span></span> 有点劣。</li><li>一个节点的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 级祖先所在长链长度一定不小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span>。</li><li>每个节点所在长链末端为其子树内最深节点。</li><li>选一个节点能覆盖它到根的所有节点。选<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个节点，覆盖的最多节点数就是前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 条长链长度之和，选择的节点即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 条长链末端。</li></ul><h2 id="23-应用"><a class="markdownIt-Anchor" href="#23-应用"></a> 2.3 应用</h2><h3 id="231-树上-k-级祖先"><a class="markdownIt-Anchor" href="#231-树上-k-级祖先"></a> 2.3.1 树上 k 级祖先</h3><p>首先<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的倍增预处理求出每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span> 级祖先，以及对于每一条长链，从长链向上向下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 步分别能走到哪个节点，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 不超过长链深度。此外预处理每个数在二进制下的最高位（即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>i</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \log_2 i \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.20696799999999996em"><span style="top:-2.4558600000000004em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24414em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">i</span><span class="mclose">⌋</span></span></span></span>，不想预处理的可以用 <code>__lg</code> 函数）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">lg_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。预处理为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)+O(n)+O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>一次查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>，首先跳到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>l</mi><msub><mi>g</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">2^{lg_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8491079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3448em"><span style="top:-2.3487714285714287em;margin-left:-.03588em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15122857142857138em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 级祖先<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span>，由于我们与处理了从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span> 所在长链顶端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 向上/下走不超过链长步分别到哪个节点，故不难直接查询，故查询时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ui unsigned int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">1e6</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n,q,rt,hb[MN];</span><br><span class="line">ui s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> dep[MN],mxdep[MN],fa[<span class="number">21</span>][MN],hson[MN],htop[MN];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; up[MN],dw[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pree)</span></span>{</span><br><span class="line">        dep[u]=mxdep[u]=dep[pree]<span class="number">+1</span>;</span><br><span class="line">        fa[<span class="number">0</span>][u]=pree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++){</span><br><span class="line">            fa[i][u]=fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][u]];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            <span class="keyword">if</span>(v==pree) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(mxdep[v]&gt;mxdep[u]){</span><br><span class="line">                mxdep[u]=mxdep[v];</span><br><span class="line">                hson[u]=v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">        htop[u]=ltop;</span><br><span class="line">        <span class="keyword">if</span>(u==ltop){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,it=u;i&lt;=mxdep[u]-dep[u];i++){</span><br><span class="line">                up[u].<span class="built_in">push_back</span>(it),it=fa[<span class="number">0</span>][it];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,it=u;i&lt;=mxdep[u]-dep[u];i++){</span><br><span class="line">                dw[u].<span class="built_in">push_back</span>(it),it=hson[it];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hson[u]) <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            <span class="keyword">if</span>(v==fa[<span class="number">0</span>][u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> x;</span><br><span class="line">        x=fa[__lg(k)][x];</span><br><span class="line">        k-=<span class="number">1</span>&lt;&lt;(__lg(k));</span><br><span class="line">        k-=dep[x]-dep[htop[x]];</span><br><span class="line">        x=htop[x];</span><br><span class="line">        <span class="keyword">return</span> k&gt;=<span class="number">0</span>?up[x][k]:dw[x][-k];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">ui <span class="title">get</span><span class="params">(ui x)</span></span>{</span><br><span class="line">	x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">	x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">	x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> s = x; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">read</span>(n,q,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="type">int</span> faa;</span><br><span class="line">        <span class="built_in">read</span>(faa);</span><br><span class="line">        <span class="keyword">if</span>(!faa){</span><br><span class="line">            rt=i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        adj[faa].<span class="built_in">push_back</span>(i);</span><br><span class="line">        adj[i].<span class="built_in">push_back</span>(faa);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">    <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++){</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        x=(<span class="built_in">get</span>(s)^lst)%n<span class="number">+1</span>;</span><br><span class="line">        k=(<span class="built_in">get</span>(s)^lst)%dep[x];</span><br><span class="line">        lst=<span class="built_in">query</span>(x,k);</span><br><span class="line">        ans^=<span class="number">1ll</span>*i*(lst);</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="232-长链剖分优化-dp"><a class="markdownIt-Anchor" href="#232-长链剖分优化-dp"></a> 2.3.2 长链剖分优化 DP</h3><p>长链剖分的价值主要体现在于能够优化树上有关深度的 DP，如果子树内每个深度仅对应一个信息，我们就可以用长链剖分优化。</p><p>一般形式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 表示以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 为根的子树内，深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 节点的贡献。</p><p>下面以一道例题来看：</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMDA5Rg">CF1009F</a></p><p>先考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span></span></span></span> 怎么求，有一个显然的转移方程：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></munder><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(i,j)=\sum_{x\in son(i)} d(x,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(i,0)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</p><p>然而是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，无法承受，注意到这个信息子树深度有且仅对应顶点个数这一个信息而非具体是哪些顶点，因此子树内深度相同的点等价。考虑长链剖分优化 DP。</p><p>具体的，类似于 DSU on Tree，我们直接继承重儿子的答案，让后将所有轻儿子的答案合并过来，因为每个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 最多合并一次，即合并<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 所在重链顶端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span> 的父亲<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span></span></span></span> 与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">t</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 所包含的信息就和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>f</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{fa}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.980548em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10764em">f</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>u</mi></msub><mo>−</mo><mi>d</mi><mi>e</mi><msub><mi>p</mi><mrow><mi>f</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dep_u -dep_{fa}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.980548em;vertical-align:-.286108em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10764em">f</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span> 处的信息融为了一体，相当于点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 直接消失了，时间复杂时优秀的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>具体实现上，如何继承重儿子的 DP 值，一个解决方案就是用指针申请内存，对于一条重链，共用一个大小为其长度的数组。这同时解决了上述两个问题。实现时需要特别注意开足空间，并弄清转移方向。</p><p>另一个方法就是 vector，不过通用性没那么好，这里就不再赘述了。</p><h2 id="24-例题"><a class="markdownIt-Anchor" href="#24-例题"></a> 2.4 例题</h2><h3 id="cf1009f"><a class="markdownIt-Anchor" href="#cf1009f"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMDA5Rg">CF1009F</a></h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEwMDkvc3VibWlzc2lvbi8zMzI3Njg5NjY">提交记录</a></p><h3 id="p4292-重建计划"><a class="markdownIt-Anchor" href="#p4292-重建计划"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQyOTI">P4292 重建计划</a></h3><p>直接 01 分数规划上来就是一个二分答案，让后将减掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> 后问题转化为求一个长度在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>U</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L,U]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mclose">]</span></span></span></span> 之间且边权非负的路径。考虑 DP，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 子树内深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的最大路径权值和，转移是显然的，也容易看出来我们求的是最大值，每一个长度只会贡献唯一一个信息。</p><p>考虑长链剖分优化 DP，合并子树的时先遍历轻儿子的答案，这个需要我们求重链的一段区间 dp 值的最大值，若轻儿子对应位置比重儿子更大就修改，所以我们还需要区间单点修改，考虑线段树维护。线段树上我们可以通过给每一个节点赋一个 dfs 序，那么线段树上对应的位置就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(dfn[x]+j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 为 dp 里面的），时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8984479999999999em"><span style="top:-3.1473400000000002em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">1e5</span><span class="number">+15</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> n,L,R;</span><br><span class="line"><span class="type">double</span> tmp[MN],V;</span><br><span class="line">vector&lt;Edge&gt; adj[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>{</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="type">double</span> val;</span><br><span class="line">    }t[MN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>{</span><br><span class="line">        t[p].val=<span class="built_in">max</span>(t[ls].val,t[rs].val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>{</span><br><span class="line">        t[p].l=l;</span><br><span class="line">        t[p].r=r;</span><br><span class="line">        t[p].val=<span class="number">-1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> pos,<span class="type">double</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t[p].l==t[p].r){</span><br><span class="line">            t[p].val=<span class="built_in">max</span>(t[p].val,k);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=pos) <span class="built_in">modify</span>(ls,pos,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(rs,pos,k);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> fl,<span class="type">int</span> fr)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(fl&gt;fr) <span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr){</span><br><span class="line">            <span class="keyword">return</span> t[p].val;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> ret=<span class="number">-1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=fl) ret=<span class="built_in">query</span>(ls,fl,fr);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;fr) ret=<span class="built_in">max</span>(ret,<span class="built_in">query</span>(rs,fl,fr));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">}sg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> htop[MN],hson[MN],dep[MN],mxdep[MN],val[MN],len[MN],fa[MN],dfn[MN],dtot;</span><br><span class="line">    <span class="type">double</span> dis[MN],ret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        fa[u]=pre;</span><br><span class="line">        dep[u]=mxdep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u]){</span><br><span class="line">            <span class="type">int</span> v=e.v,w=e.w;</span><br><span class="line">            <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(mxdep[u]&lt;mxdep[v]){</span><br><span class="line">                mxdep[u]=mxdep[v];</span><br><span class="line">                hson[u]=v;</span><br><span class="line">                val[v]=w;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        len[u]=mxdep[u]-dep[u];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">        dfn[u]=++dtot;</span><br><span class="line">        <span class="keyword">if</span>(hson[u]) <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u]){</span><br><span class="line">            <span class="type">int</span> v=e.v,w=e.w;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        sg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[u],dis[u]);</span><br><span class="line">        <span class="keyword">if</span>(hson[u]){</span><br><span class="line">            dis[hson[u]]=dis[u]+val[hson[u]]-V;</span><br><span class="line">            <span class="built_in">dfs3</span>(hson[u],u);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u]){</span><br><span class="line">            <span class="type">int</span> v=e.v,w=e.w;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v]=dis[u]+e.w-V;</span><br><span class="line">            <span class="built_in">dfs3</span>(v,u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len[v]<span class="number">+1</span>;i++){</span><br><span class="line">                tmp[i]=sg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[v]+i<span class="number">-1</span>,dfn[v]+i<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(len[v]<span class="number">+1</span>,R);i++){</span><br><span class="line">                ret=<span class="built_in">max</span>(ret,tmp[i]+sg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[u]+L-i,<span class="built_in">min</span>(dfn[u]+R-i,dfn[u]+len[u]))<span class="number">-2</span>*dis[u]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len[v]<span class="number">+1</span>;i++){</span><br><span class="line">                sg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[u]+i,tmp[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ret=<span class="built_in">max</span>(ret,sg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[u]+L,<span class="built_in">min</span>(dfn[u]+R,dfn[u]+len[u]))-dis[u]);</span><br><span class="line">    }</span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span>{</span><br><span class="line">    sg.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    V=x,ret=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="built_in">dfs3</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret&gt;=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>({v,w});</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>({u,w});</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps){</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="p5904-hot-hotels"><a class="markdownIt-Anchor" href="#p5904-hot-hotels"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU5MDQ">P5904 HOT-Hotels</a></h3><p>手摸样例启示我们在三个点的 LCA 处统计贡献，直接统计的话虽然解决了三个点到 LCA 距离相等的情况，但是没有统计一个点离 LCA 远，另外两个点离 LCA 距离近一点的形态。考虑用 DP 统计答案，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 子树内，距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的节点个数，让后再来一个转台处理离远一点的信息，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> 子树内来一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 的链凑成 3 元组的数量。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span> 的转移时显然的，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span></span></span></span> 不太好从儿子转移过来。</p><p>遇到这种不太好从儿子转移到父亲的节点的 DP 我们可以考虑合并儿子和父亲子树的信息。有如下分类讨论：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>←</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(i,j)\leftarrow \sum_{x,y \in son(u),x\neq y} f(x,j-1)\times f(y,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>←</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(i,j)\leftarrow \sum_{x\in son(u)} f(x,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>统计答案也需要分类讨论：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>←</mo><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ans\leftarrow g(i,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>←</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ans\leftarrow \sum_{x,y \in son(u),x\neq y} f(x,j-1)\times g(y,j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.808995em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>时间复杂度经优化后达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">3e6</span><span class="number">+15</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll buf[MN],ans,*f[MN],*g[MN],*now;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> dep[MN],mxdep[MN],len[MN],fa[MN],hson[MN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        fa[u]=pre;</span><br><span class="line">        dep[u]=mxdep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(mxdep[u]&lt;mxdep[v]){</span><br><span class="line">                mxdep[u]=mxdep[v];</span><br><span class="line">                hson[u]=v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        len[u]=mxdep[u]-dep[u]<span class="number">+1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(hson[u]){</span><br><span class="line">            f[hson[u]]=f[u]<span class="number">+1</span>;</span><br><span class="line">            g[hson[u]]=g[u]<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">dfs3</span>(hson[u],u);</span><br><span class="line">        }</span><br><span class="line">        f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ans+=g[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]){</span><br><span class="line">            <span class="keyword">if</span>(v==pre||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            f[v]=now;</span><br><span class="line">            now+=len[v]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            g[v]=now;</span><br><span class="line">            now+=len[v]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs3</span>(v,u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len[v];i++){</span><br><span class="line">                <span class="keyword">if</span>(i){</span><br><span class="line">                    ans+=f[u][i<span class="number">-1</span>]*g[v][i];</span><br><span class="line">                }</span><br><span class="line">                ans+=g[u][i<span class="number">+1</span>]*f[v][i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len[v];i++){</span><br><span class="line">                g[u][i<span class="number">+1</span>]+=f[u][i<span class="number">+1</span>]*f[v][i];</span><br><span class="line">                <span class="keyword">if</span>(i) g[u][i<span class="number">-1</span>]+=g[v][i];</span><br><span class="line">                f[u][i<span class="number">+1</span>]+=f[v][i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    now=buf;</span><br><span class="line">    f[<span class="number">1</span>]=now;</span><br><span class="line">    now+=len[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=now;</span><br><span class="line">    now+=len[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs3</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="p3441-poi2006met-subway"><a class="markdownIt-Anchor" href="#p3441-poi2006met-subway"></a> <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM0NDE">P3441 [POI2006]MET-Subway</a></h3><p>形式化题面如下：</p><blockquote><p>给定一棵有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的无向树和一个整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span>，选出最多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 条不分叉的路径（即简单链），使得这些路径覆盖的<strong>不同节点数</strong>尽可能多。输出最多能覆盖的节点数。</p></blockquote><p>DP 显然不太好，考虑贪心，那么贪心尽量让链长。考虑直径一定作为答案的一部分出现，而剩下的就是直径上的分支，分支跨直径配对成路径。考虑这个如何配对，其实就是不同链的叶子两两配对，考虑以直径一端点为根，长链剖分加排序（链长大到小）取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>L</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2L-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个叶子即可。</p><p>实现丑了会卡常，请大家注意常数和空间。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pir pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MN=<span class="number">1e6</span><span class="number">+1520</span>;</span><br><span class="line"><span class="type">int</span> n,L,rt,ftot,ans;</span><br><span class="line">pir lvf[MN];</span><br><span class="line"><span class="type">bool</span> vis[MN];</span><br><span class="line"><span class="type">int</span> hd[MN],nxt[MN&lt;&lt;<span class="number">1</span>],to[MN&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>{to[++tot]=v,nxt[tot]=hd[u],hd[u]=tot;}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ZJTree{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>{<span class="type">int</span> u,fa,len;};</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st)</span></span>{</span><br><span class="line">        queue&lt;Node&gt; q;</span><br><span class="line">        <span class="type">int</span> ans1=<span class="number">-1e9</span>,ans2=<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>({st,<span class="number">0</span>,<span class="number">0</span>});</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">            <span class="keyword">auto</span> [u,fa,w]=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(w&gt;ans1) ans1=w,ans2=u;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=hd[u];i;i=nxt[i]){</span><br><span class="line">                <span class="type">int</span> v=to[i];</span><br><span class="line">                <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>({v,u,w<span class="number">+1</span>});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans2;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tree{</span><br><span class="line">    <span class="type">int</span> dep[MN],fa[MN],mxdep[MN],htop[MN],len[MN],hson[MN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>{</span><br><span class="line">        fa[u]=pre;</span><br><span class="line">        dep[u]=mxdep[u]=dep[pre]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=hd[u];i;i=nxt[i]){</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            <span class="keyword">if</span>(mxdep[u]&lt;mxdep[v]) mxdep[u]=mxdep[v],hson[u]=v;</span><br><span class="line">        }</span><br><span class="line">        len[u]=mxdep[u]-dep[u]<span class="number">+1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ltop)</span></span>{</span><br><span class="line">        htop[u]=ltop;</span><br><span class="line">        <span class="keyword">if</span>(!hson[u]){lvf[++ftot]=<span class="built_in">pir</span>(len[htop[u]],u);<span class="keyword">return</span>;}</span><br><span class="line">        <span class="built_in">dfs2</span>(hson[u],ltop);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=hd[u];i;i=nxt[i]){</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(v==fa[u]||v==hson[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}<span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pir x,pir y)</span></span>{<span class="keyword">return</span> x.first&gt;y.first;}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">read</span>(n,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">read</span>(u,v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    rt=ZJTree::<span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">    <span class="built_in">sort</span>(lvf<span class="number">+1</span>,lvf<span class="number">+1</span>+ftot,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(L&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) vis[rt]=<span class="number">1</span>,ans+=len[rt];</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="type">int</span> p=lvf[i].second;</span><br><span class="line">            <span class="keyword">while</span>(!vis[htop[p]]) vis[htop[p]]=<span class="number">1</span>,ans+=len[htop[p]],p=fa[htop[p]];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">put</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>树链剖分</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://worldcpu.github.io/posts/7e454910/">https://worldcpu.github.io/posts/7e454910/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>wjyppm</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-04-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-09-28</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></div><div class="post-share"><div class="social-share" data-image="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220074863_686ffaf65c374.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://s4.zstatic.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/70f2f90a/" title="基环树"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212637871_686ffa516abbf.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基环树</div></div><div class="info-2"><div class="info-item-1">0. 前言 你需要的知识点： 图的遍历与存储（这都会吧。。。） 树的直径与树上最大独立集（没有上司的舞会）等树形DP基础芝士 环的认识 1. 基环树基本芝士 1.1 概念 想必都知道树结构的特点吧。 给定一张 nnn 个点，n−1n-1n−1 条边的无向图，… 这个就是树的特点，有 n−1n-1n−1 条边。而基环树呢？就是在原先树的情况上加了一条边，于是基环树的特点就是： 给定一张 nnn 个点，nnn 条边的无向（或有向）图，… 那长什么样？ 那有人就会说链，这根本就不是树啊，这有环怎么能叫树呢？事实上也是这样的，人家是个图吗。 比一般的树多一条边，这导致这个基环树图上出现了一个唯一的环，这个的前提是图联通。如果不联通，就会出现多个环，例如下图： 当然，基环树也有有向图的版本，这个版本有2个，一个叫内向基环树，一个叫外向基环树。 1.2 找环 我们对于基环树的处理一般是找到他最特殊的地方，也就是他的环。 怎么找环呢？其实也很简单，我们分无向的和有向的来分别说。 1.2.1 并查集（无向图） 复杂度均摊O(1)O(1)O(1)。 无向图我们可以使用并...</div></div></div></a><a class="pagination-related" href="/posts/4286fd48/" title="换根DP"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212679122_686ffa3878b43.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">换根DP</div></div><div class="info-2"><div class="info-item-1">换根DP 树形 DP 中的换根 DP 问题又被称为二次扫描，通常不会指定根结点，并且根结点的变化会对一些值，例如子结点深度和、点权和等产生影响。 他相比于相比与一般的树形dp拥有以下特点 以树上不同点作为根，他的解不同 求解答案，不能单求解某点的信息，需要求解每个节点的信息。 无法用一次搜索完成答案求解。 难度不算太高 1.例题引入 P3478 [POI 2008] STA-Station 给定一个&nbsp;nnn&nbsp;个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。 一个结点的深度之定义为该节点到根的简单路径上边的数量。 我们先假设某个节点为根（例如1为根），将无根树转换为有根树，再通过一次DFS搜索出以该节点的深度和，时间复杂度O(n)O(n)O(n) 但问题是我们无法确定以该点为根时一定能得到最优解，如果可以的话可以拿样例推推，可以显然发现以任意点为根无法确定是最优解（例如从1开始） 没错这个树长得很奇怪。 我们可以在第二次搜索时完成对答案的统计。 我们假设第一次搜索我们从1号节点出发，通过一次搜索我们就可以获得所有节点子树的大小与节点深度，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/a4051058/" title="2-SAT"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752211281055_686ffb41054b0_1_.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-22</div><div class="info-item-2">2-SAT</div></div><div class="info-2"><div class="info-item-1">0. 前言 因为之前一篇写的太烂了，没有搞清楚主次关系导致云里雾里，以至于后人（没错就是我自己）根本看不懂，所以本篇于2025.4.22重写。 你需要知道芝士： Tarjan求有向图强联通分量 基础图论建模芝士 命题的概念及反命题（初中内容） 1. 2-SAT概念及求法 1.1 概念 这个我们需要好好说这个概念，所以我们对于 “2-SAT” 这个名词我们做一下辨析。 SAT 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，即 k-SAT。 什么，看不懂？没关系因为这个k-SAT问题当 k&gt;2k&gt;2k&gt;2 的时候是NP完全问题，只能暴力求解，但是当 k=2k=2k=2 的2-SAT问题我们可以好好玩。 对于2-SAT问题通俗的说，就是给你 nnn 个变量 XiX_iXi​，每个变量只能取 0或1，同时给定若干条件，形如： (¬)Xi⊕(¬)Xj=0/1(\neg) X_{i}\oplus (\neg)X_{j}=0 /1 (¬)Xi​⊕(¬)Xj​=0/1 其中 ¬Xi\neg X_i¬Xi​ 表示 XiX_iXi...</div></div></div></a><a class="pagination-related" href="/posts/6cf9e98c/" title="Hall定理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212299455_686ffa5a48c3a.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">Hall定理</div></div><div class="info-2"><div class="info-item-1">1. Hall 定理 对于一张二分图，设两部分点数为 (x,y)(x,y)(x,y)，则其的一个完备匹配定义为左部分 xxx 个点成为匹配点，特别的，当 x=yx=yx=y 的时候这列匹配也称作完备匹配。 一个如上定义的二分图存在完备匹配的充要条件是对于左部分大小为 kkk 的任意子集 SSS，这些点在右部连到的点集，记作 N(S)N(S)N(S)，的大小不小于 kkk，即 ∣S∣≥∣N(S)∣|S|\ge |N(S)|∣S∣≥∣N(S)∣。 证明见： 「学习笔记」Hall定理。 上面就是 Hall 定理，下面是它的推论。 二分图存在大小为 kkk 的匹配，当且仅当 ∀S,∣S∣≤∣N(S)∣−k\forall S,|S|\le|N(S)|-k∀S,∣S∣≤∣N(S)∣−k。 进一步推论： 若使 GGG 中存在完美匹配，则最少补充 max⁡{0,∣S∣−∣N(S)∣}\max\{ 0,|S|-|N(S)| \}max{0,∣S∣−∣N(S)∣} 条边。 我们还有网络流的形式： 设左部点的流量为 aia_{i}ai​，右部点的流量为 bib_{i}bi​，那么有左部点满...</div></div></div></a><a class="pagination-related" href="/posts/6d897253/" title="Kruskal重构树学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212299455_686ffa5a48c3a.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-07</div><div class="info-item-2">Kruskal重构树学习笔记</div></div><div class="info-2"><div class="info-item-1">1.算法简介 我们回忆一下 Kruskal 求最小生成树的过程，可以表述为以下： 将边按照边权从小到大进行排序。 若当前边 (u,v)(u,v)(u,v) 两端不连通，我们就在生成树的边集中加入这条边并连接 (u,v)(u,v)(u,v)，关于连通性显然我们可以考虑利用冰茶几维护。 有的时候，我们可能想要求得信息就和边权的大小关系有关，例如路径上的最大边权和最小边权，你可能会想到使用最小生成树，但是问题在于最小生成树上的边权是乱序的，但是我们发现在构建的最小生成树的过程就可以解决这个路径上最大边权和最小边权问题。 如果能用某种结构描述每条边被连接的先后顺序就很好了，因为越往后加入的边权就越大，就可以快速刻画边权有限制的图连通性了。 于是我们就有了 Kruskal 重构树！它在 Kruskal 的过程上进行了一些改进： 将边按照边权进行排序。 若当前边 (u,v)(u,v)(u,v) 两端不连通，连接 u,vu,vu,v 的时候找到 u,vu,vu,v 的代表元 U,VU,VU,V。新建节点 ccc，将并查集中&nbsp;U,VU,VU,V&nbsp;的父亲设为&nbsp;ccc，并在图上连边&nbsp;c→Uc...</div></div></div></a><a class="pagination-related" href="/posts/5c86f54/" title="优化建图技巧"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752223589547_686fe3a4db197.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-12</div><div class="info-item-2">优化建图技巧</div></div><div class="info-2"><div class="info-item-1">0. 前言 会添加的吧，会添加的吧？一定会添加的吧！ 1. 线段树优化建图 CF786B Legacy 区间向区间连边，我们可以利用线段树的优秀区间特性来进行连边。具体来说，我们建立两颗线段树，一颗专门管入边，一颗管出边入边的树父节点向子节点连边（如果子节点向父节点连边，会导致本来只连向该区间的边通过子节点向父节点连的边连向了更大的区间），同理出边的子节点向父节点连边。父子节点之间的边，边权为 0。 总边复杂度大约在 O(mlog⁡n)O(m \log n)O(mlogn) 级别。 例如上图，本题代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define int long...</div></div></div></a><a class="pagination-related" href="/posts/c1d10176/" title="同余最短路"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752748973919_662416540fa68.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-17</div><div class="info-item-2">同余最短路</div></div><div class="info-2"><div class="info-item-1">0. 前言 本篇文章不发布于洛谷文章广场，因为我是在自己 yy，不保证正确。 1. 介绍 同余最短路，用于解决完全背包计数问题，例如给你 nnn 个数，每个数可以选无限次，问你用这些数能够拼凑出的信息。 这里我们一般化，给定物品体积 aaa，每个物品可以选无数次，问是否存在一种选择方式，使得物品总体积恰好为 xxx。 考虑 DP，设 f(i)f(i)f(i) 表示能否拼凑出体积 xxx，转移方程是显然的： f(x)=f(x)or⁡f(x−ai)f(x)=f(x) \operatorname{or} f(x-a_{i}) f(x)=f(x)orf(x−ai​) 这是一个有向无环图（DAG）上的动态规划，没有环，这样的时间复杂度是非常高，因为我们要枚举 xxx，当 xxx 非常大的时候是无法承受。 而同余最短路就是优化这一过程的，首先对于一个完全背包计数问题，如果 xxx 可以被凑出来，那么 x+ai,x+2ai,…x+a_{i},x+2a_{i},\dotsx+ai​,x+2ai​,… 是可以都能够凑出来的。即如果能凑出来 xxx，那么 x+k×ai(k≥0)x+k\times...</div></div></div></a><a class="pagination-related" href="/posts/70f2f90a/" title="基环树"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212637871_686ffa516abbf.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">基环树</div></div><div class="info-2"><div class="info-item-1">0. 前言 你需要的知识点： 图的遍历与存储（这都会吧。。。） 树的直径与树上最大独立集（没有上司的舞会）等树形DP基础芝士 环的认识 1. 基环树基本芝士 1.1 概念 想必都知道树结构的特点吧。 给定一张 nnn 个点，n−1n-1n−1 条边的无向图，… 这个就是树的特点，有 n−1n-1n−1 条边。而基环树呢？就是在原先树的情况上加了一条边，于是基环树的特点就是： 给定一张 nnn 个点，nnn 条边的无向（或有向）图，… 那长什么样？ 那有人就会说链，这根本就不是树啊，这有环怎么能叫树呢？事实上也是这样的，人家是个图吗。 比一般的树多一条边，这导致这个基环树图上出现了一个唯一的环，这个的前提是图联通。如果不联通，就会出现多个环，例如下图： 当然，基环树也有有向图的版本，这个版本有2个，一个叫内向基环树，一个叫外向基环树。 1.2 找环 我们对于基环树的处理一般是找到他最特殊的地方，也就是他的环。 怎么找环呢？其实也很简单，我们分无向的和有向的来分别说。 1.2.1 并查集（无向图） 复杂度均摊O(1)O(1)O(1)。 无向图我们可以使用并...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.luogu.com.cn/upload/usericon/578829.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">wjyppm</div><div class="author-info-description">高中蒟蒻信竟生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Worldcpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Worldcpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="/wjyccgg1403@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div style="text-align:left;font-size:14px;line-height:1.6">👋🏻我是PPM，一个热爱编程和信息学竞赛的高中生，喜欢分享做题经验。本博客中所有 latex 公式均可以选中后复制哦😊<br><br>❓有问题欢迎提问，确保内容有意义。如需联系我，欢迎通过邮箱联系我！📧<br><br>嗷嗷！热烈欢迎🤪！来自<br><span style="color:#2679cc"><span id="province" style="white-space:nowrap"></span><span id="city"></span></span><br>的朋友，你好呀！<br>你的网络IP为：<span id="ip" style="display:inline-block;filter:blur(5px);transition:filter .5s ease">***.***.***.***</span><br><br><span id="greet"></span></div><script>!function(){const t=(new Date).getHours(),e=t<6?"🌠凌晨好，早点休息！":t<12?"🌤️ 早上好，快趁机多睡点懒觉！":t<18?"☀️下午好，精神满满！":"🌙晚上好，早点休息！";document.getElementById("greet").textContent=e,fetch("https://qifu-api.baidubce.com/ip/local/geo/v1/district").then(t=>t.json()).then(t=>{if("Success"!==t.code)return void console.warn("接口返回错误",t);const e=t.ip||"***.***.***.***",n=t.data.prov||"",o=t.data.city||"";document.getElementById("province").textContent=n,document.getElementById("city").textContent=o;const c=document.getElementById("ip");c.setAttribute("title",e),c.addEventListener("mouseenter",()=>{c.textContent=e,c.style.filter="blur(0)"}),c.addEventListener("mouseleave",()=>{c.textContent="***.***.***.***",c.style.filter="blur(5px)"})}).catch(t=>{console.error("接口调用失败",t)})}()</script></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">1.重链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BE%8B%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 例题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-lca"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 LCA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">2.长链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 长链剖分的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-%E6%A0%91%E4%B8%8A-k-%E7%BA%A7%E7%A5%96%E5%85%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.3.1 树上 k 级祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E4%BC%98%E5%8C%96-dp"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.3.2 长链剖分优化 DP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%BE%8B%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cf1009f"><span class="toc-number">3.4.1.</span> <span class="toc-text">CF1009F</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p4292-%E9%87%8D%E5%BB%BA%E8%AE%A1%E5%88%92"><span class="toc-number">3.4.2.</span> <span class="toc-text">P4292 重建计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p5904-hot-hotels"><span class="toc-number">3.4.3.</span> <span class="toc-text">P5904 HOT-Hotels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p3441-poi2006met-subway"><span class="toc-number">3.4.4.</span> <span class="toc-text">P3441 [POI2006]MET-Subway</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a6ad8815/" title="路线反思"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752220823460_686ffb1d0f61f.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="路线反思"></a><div class="content"><a class="title" href="/posts/a6ad8815/" title="路线反思">路线反思</a><time datetime="2025-09-28T13:08:28.000Z" title="发表于 2025-09-28 21:08:28">2025-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e9478aba/" title="猫树分治"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752212663165_686ffa507c01b.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="猫树分治"></a><div class="content"><a class="title" href="/posts/e9478aba/" title="猫树分治">猫树分治</a><time datetime="2025-09-21T13:46:02.000Z" title="发表于 2025-09-21 21:46:02">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c8836e51/" title="MatrixTree矩阵树定理"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752211281055_686ffb41054b0_1_.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MatrixTree矩阵树定理"></a><div class="content"><a class="title" href="/posts/c8836e51/" title="MatrixTree矩阵树定理">MatrixTree矩阵树定理</a><time datetime="2025-09-17T09:03:17.000Z" title="发表于 2025-09-17 17:03:17">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9dc41a00/" title="abc423题解"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1752221267079_686ffac98b90e.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="abc423题解"></a><div class="content"><a class="title" href="/posts/9dc41a00/" title="abc423题解">abc423题解</a><time datetime="2025-09-15T00:10:36.000Z" title="发表于 2025-09-15 08:10:36">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/904f5191/" title="整体DP—从勤拿少取到量大管饱"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://7b594a30.cloudflare-imgbed-8n1.pages.dev/file/1757634776012_50f5f31f0d226d3652d507f8e96fb81f.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="整体DP—从勤拿少取到量大管饱"></a><div class="content"><a class="title" href="/posts/904f5191/" title="整体DP—从勤拿少取到量大管饱">整体DP—从勤拿少取到量大管饱</a><time datetime="2025-09-11T23:50:40.000Z" title="发表于 2025-09-12 07:50:40">2025-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 By wjyppm</span><span class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://s4.zstatic.net/ajax/libs/fancyapps-ui/6.0.22/fancybox/fancybox.umd.js"></script><script src="https://s4.zstatic.net/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"),await btf.getScript("https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{const t="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=null,s=t=>"dark"===t?"dark":"light",a=(a=document,o)=>{const n=t?{"data-mapping":"specific","data-term":o}:{"data-mapping":"pathname"},c=(t=>{const e=document.createElement("script");return Object.entries(t).forEach(([t,s])=>{e.setAttribute(t,s)}),e})({src:"https://giscus.app/client.js","data-repo":"Worldcpu/Worldcpu.github.io","data-repo-id":"R_kgDOOYWiqQ","data-category-id":"DIC_kwDOOYWiqc4CpBzT","data-theme":s(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...e,...n});a.querySelector("#giscus-wrap").appendChild(c),t&&(window.shuoshuoComment.destroyGiscus=()=>{a.children.length&&(a.innerHTML="",a.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{const e=document.querySelector("#giscus-wrap iframe");if(e){const a={giscus:{setConfig:{theme:s(t)}}};e.contentWindow.postMessage(a,"https://giscus.app")}},"giscus"),t?window.shuoshuoComment={loadComment:a}:a()})()</script></div><script async src="/js/diytitle.js"></script><script async src="/js/nav.js"></script><script src="https://s4.zstatic.net/ajax/libs/activate-power-mode/1.0.0/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://s4.zstatic.net/ajax/libs/pjax/0.2.8/pjax.js"></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:description"]','link[rel="canonical"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!1,scrollRestoration:!1});const e=e=>{e&&Object.values(e).forEach(e=>e())};document.addEventListener("pjax:send",()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");const t=document.body.classList;t.contains("read-mode")&&t.remove("read-mode"),e(window.globalFn.pjaxSend)}),document.addEventListener("pjax:complete",()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),e(window.globalFn.pjaxComplete)}),document.addEventListener("pjax:error",e=>{if(404===e.request.status){!0?pjax.loadUrl("/404.html"):window.location.href="/404.html"}})})()</script><script async data-pjax="" src="https://s4.zstatic.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>