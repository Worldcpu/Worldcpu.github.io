<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2-SAT</title>
    <url>/posts/a4051058/</url>
    <content><![CDATA[ 0. 前言
因为之前一篇写的太烂了，没有搞清楚主次关系导致云里雾里，以至于后人（没错就是我自己）根本看不懂，所以本篇于2025.4.22重写。
你需要知道芝士：

Tarjan求有向图强联通分量
基础图论建模芝士
命题的概念及反命题（初中内容）

 1. 2-SAT概念及求法
 1.1 概念
这个我们需要好好说这个概念，所以我们对于 “2-SAT” 这个名词我们做一下辨析。

SAT 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，即 k-SAT。

什么，看不懂？没关系因为这个k-SAT问题当 k&gt;2k&gt;2k&gt;2 的时候是NP完全问题，只能暴力求解，但是当 k=2k=2k=2 的2-SAT问题我们可以好好玩。
对于2-SAT问题通俗的说，就是给你 nnn 个变量 XiX_iXi​，每个变量只能取 0或1，同时给定若干条件，形如：
(¬)Xi⊕(¬)Xj=0/1(\neg) X_{i}\oplus (\neg)X_{j}=0 /1
(¬)Xi​⊕(¬)Xj​=0/1
其中 ¬Xi\neg X_i¬Xi​ 表示 XiX_iXi​ 这个命题的反命题。其中 ⊕\oplus⊕ 代表的操作有与，或，异或操作中的一种。
其实不难发现我们在求解2-SAT问题，如果我们发现这个问题的“方程组”有解，那么其实解有许多组，但是我们只需要求出1组解即可。
 1.2 2-SAT求解
所以怎么求解呢？一个显然的想法是暴力枚举，但是这个复杂度太炸裂了（其实也不算太炸裂www），怎么做？
我们发现与，或，异或操作一定有不同真命题与反命题之间约束的关系…图论？
没错其实对于这类问题我们可以建立图论模型来去解决，虽然两两bool变量的关系有很多，但是可以都归属以下三种关系：
¬Xi∨Xj¬Xi∨¬XjXi∨Xj\begin{aligned}
\neg X_{i} &amp; \vee X_{j} \\
\neg X_{i}&amp; \vee \neg X_{j}\\
X_{i}&amp; \vee X_j
\end{aligned}
¬Xi​¬Xi​Xi​​∨Xj​∨¬Xj​∨Xj​​
其中，∨\vee∨ 符号表示或的关系。其实不难得到如果左边不成立那右边必须成立，于是我们可以对于Xi,¬Xi,Xj,¬XjX_{i},\neg X_{i},X_{j},\neg X_jXi​,¬Xi​,Xj​,¬Xj​ 这四个变量我们可以用四个不同的变量：

Xi→TiX_{i}\rightarrow T_iXi​→Ti​
Xj→TjX_{j}\rightarrow T_jXj​→Tj​
¬Xi→Fi\neg X_{i}\rightarrow F_i¬Xi​→Fi​
¬Xj→Fj\neg X_{j}\rightarrow F_j¬Xj​→Fj​

那么我们可以这么连边：
对于第一个式子，如果我们让 XiX_iXi​ 成立（¬Xi\neg X_i¬Xi​ 不成立 ），那么XjX_jXj​ 必须成立，如果¬Xj\neg X_j¬Xj​ 成立那么 ¬Xi\neg X_i¬Xi​ 必须成立，下面同理：



公式
建边(同时建边代表与)




¬Xi∨Xj\neg X_{i} \vee X_j¬Xi​∨Xj​
Ti→Tj,Fj→FiT_{i}\rightarrow T_{j},F_{j}\rightarrow F_{i}Ti​→Tj​,Fj​→Fi​


¬Xi∨¬Xj\neg X_{i} \vee \neg X_{j}¬Xi​∨¬Xj​
Ti→Fj,Tj→FiT_{i}\rightarrow F_{j},T_{j}\rightarrow F_{i}Ti​→Fj​,Tj​→Fi​


Xi∨XjX_{i} \vee X_{j}Xi​∨Xj​
Fi→Tj,Fj→TiF_{i}\rightarrow T_{j},F_{j} \rightarrow T_{i}Fi​→Tj​,Fj​→Ti​



有没有发现什么？其实建边中都是假设一个变量不成立，那么另一个变量必定成立，通过像这样限定两个变量建2条边就可以限定了。
那我们建立好图：

这里变量名有所改变，但是不难发现的一点就是，如果¬a,b\neg a,b¬a,b 在一个强联通分量那么解肯定是一样的。但是，例如a,¬aa,\neg aa,¬a在同一个强联通分量，那么必定无解，因为这两个必须选一个但是如果在一个强联通分量，那么必定无解，反之一定有解。
那怎么构造解呢？在一个强联通分量如果我们确定任意一个变量的初始赋值，那么这里面其他所有变量的赋值都确定，这启发我们缩点。其次互为逆否命题会成对出现（对称性），所以一个零出度点的否命题（否命题的否命题是真命题）一定有出边，选有出点的一定会影响后面的，而选择零初度点的不会影响。
于是我们可以有一个基本思想就是：自底向上走拓扑排序，不断尝试选择零出度点。
但是tarjan中SCC的一个存储特点就是刚好是反拓扑序（自底向上的），所以只需要对比XiX_iXi​ 和 ¬Xi\neg X_i¬Xi​ 两个所属于的强联通分量编号谁更小，更小的拓扑序越大，越优。
P4782 【模板】2-SAT
这里我们用i→Xi,i+n→¬Xii \rightarrow X_{i},i+n \rightarrow \neg X_{i}i→Xi​,i+n→¬Xi​
那么代码如下：
#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int MN=2*1e6+15;int n,m,dfn[MN],low[MN],vdcc[MN],tot,dcc;vector&lt;int&gt; adj[MN];bool vis[MN];int s[MN],top;void tarjan(int u)&#123;    low[u]=dfn[u]=++tot;    s[++top]=u;    vis[u]=1;    for(int i=0;i&lt;adj[u].size();i++)&#123;        int v=adj[u][i];        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;else if(vis[v])&#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(low[u]==dfn[u])&#123;        dcc++;        int t;        while (s[top]!=u)        &#123;            vdcc[s[top]]=dcc;            vis[s[top]]=0;            top--;        &#125;        vdcc[s[top]]=dcc;        vis[s[top]]=0;        top--;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int xi,a,xj,b;        cin&gt;&gt;xi&gt;&gt;a&gt;&gt;xj&gt;&gt;b;        int ni=xi+n,nj=xj+n;        if(a==0&amp;&amp;b==0)&#123;            adj[ni].push_back(xj);//a=1则b=0            adj[nj].push_back(xi);//b=1则a=0        &#125;        if(a==1&amp;&amp;b==0)&#123;            adj[xi].push_back(xj);//a=0则b=0            adj[nj].push_back(ni);//b=1则a=1        &#125;        if(a==0&amp;&amp;b==1)&#123;            adj[ni].push_back(nj);//a=1则b=1            adj[xj].push_back(xi);//b=0则a=0        &#125;        if(a==1&amp;&amp;b==1)&#123;            adj[xi].push_back(nj);//a=0 b=1            adj[xj].push_back(ni);//b=0 a=1        &#125;    &#125;    for(int i=1;i&lt;=n*2;i++)&#123;        if(!dfn[i])&#123;            tarjan(i);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(vdcc[i]==vdcc[i+n])&#123;            cout&lt;&lt;&quot;IMPOSSIBLE&quot;;            return 0;        &#125;    &#125;    cout&lt;&lt;&quot;POSSIBLE&quot;&lt;&lt;endl;    for(int i=1;i&lt;=n;i++)&#123;        //强联通分量编号越小 -&gt; 拓扑序越大 -&gt; 越优        cout&lt;&lt;(vdcc[i]&gt;vdcc[i+n])&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;
 2. 例题
 2.1 P4171 满汉全席
我们可以拆成2个点，一个是汉式，一个是满式。
于是就变成了正反命题，就可以2-SAT了。
关于式子看代码。
代码如下：
#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int MN=2048;int k,n,m,tot,ecc,dfn[MN],low[MN],color[MN],s[MN],top;vector&lt;int&gt; adj[MN];bool vis[MN];void tarjan(int u)&#123;    low[u]=dfn[u]=++tot;    vis[u]=1;    s[++top]=u;    for(int i=0;i&lt;adj[u].size();i++)&#123;        int v=adj[u][i];        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;else if(vis[v])&#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(low[u]==dfn[u])&#123;        ecc++;        int p;        do        &#123;            p=s[top--];            color[p]=ecc;            vis[p]=0;        &#125; while(p!=u);            &#125;&#125;int main()&#123;    cin&gt;&gt;k;    while (k--)    &#123;        top=tot=ecc=0;        cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;MN;i++)&#123;            dfn[i]=low[i]=color[i]=0;            adj[i].clear();        &#125;        char p1,p2;        int a,b,xa,xb;        //m-&gt;0 h-&gt;1        for(int i=1;i&lt;=m;i++)&#123;            cin&gt;&gt;p1&gt;&gt;a&gt;&gt;p2&gt;&gt;b;            int na=a+n,nb=b+n;            if(p1==&#x27;m&#x27;&amp;&amp;p2==&#x27;h&#x27;)&#123;//a=0 b=1                adj[b].push_back(a);//b=0 a=0                adj[na].push_back(nb);//a=1 b=1            &#125;            if(p1==&#x27;h&#x27;&amp;&amp;p2==&#x27;h&#x27;)&#123;//a=1 b=1                adj[a].push_back(nb);                adj[b].push_back(na);            &#125;            if(p1==&#x27;h&#x27;&amp;&amp;p2==&#x27;m&#x27;)&#123;//a=1 b=0                adj[a].push_back(b);                adj[nb].push_back(na);            &#125;            if(p1==&#x27;m&#x27;&amp;&amp;p2==&#x27;m&#x27;)&#123;// a=0 b=0                adj[nb].push_back(a);                adj[na].push_back(b);            &#125;        &#125;        for(int i=1;i&lt;=2*n;i++)&#123;            if(!dfn[i])&#123;                tarjan(i);            &#125;        &#125;        bool flag=0;        for(int i=1;i&lt;=n;i++)&#123;            if(color[i]==color[i+n])&#123;                cout&lt;&lt;&quot;BAD&quot;&lt;&lt;endl;                flag=1;                break;            &#125;        &#125;        if(!flag) cout&lt;&lt;&quot;GOOD&quot;&lt;&lt;endl;    &#125;        return 0;&#125;
 P6378 Riddle

nnn 个点 mmm 条边的无向图被分成 kkk 个部分。每个部分包含一些点。
请选择一些关键点，使得每个部分恰有一个关键点，且每条边至少有一个端点是关键点。
1≤k,w≤n≤1061\le k,w\le n\le 10^61≤k,w≤n≤106，∑w=n\sum w=n∑w=n，1≤a,b≤n1\le a,b\le n1≤a,b≤n，0≤m≤1060\le m\le 10^60≤m≤106。

初始观察这个题我们其实发现不出来这个和2-SAT有什么关系，但是我们发现一个点，我们边至少有一个端点是关键点。而且这些部分中只能选1个，剩下全都不选。很像2-SAT的真否命题。
那么我们的命题就是选或不选，对于第一个条件，其实就是¬u→v,¬v→u\neg u \rightarrow v,\neg v \rightarrow u¬u→v,¬v→u。
而对于第二个条件，就是枚举组内的点暴力连边，选定一个成立后对组内其他节点暴力连否命题的边，那么这个题就做完…了？
这样暴力连边的复杂度是O(n2)O(n^2)O(n2)，不仅时间炸空间也会炸掉，怎么办？
借用以下阴阳八卦大佬的图：
我们暴力连边的边如下：

这样连边的分数我们只能拿到92分。怎么优化？关键在于怎么优化这种建图方式，第一种是优化不了了只能优化第二种。我们观察以下：

1向4，6，8连边。
3向2，6，8连边。
5向2，4，8连边。
7向2，4，6连边。

我们新建一些点作为这个点的分身：

转移以下边：

我们利用上面的方式，我们其实不难发现9-16，10-16，11-16，可以直接转成9-10-11-16这样连边，而且这样连边甚至9-15,9-16都不用连了！这样连就可以得到这张图。

唉不对啊，1-9-14-13-2这是什么，我们修改以下，把9-14改为9-4，把10-13改为3-13。一系列操作有：

这种优化方式叫做 前缀优化建图，通过类似于前缀和的优化操作来建图。
有的人会说线段树优化建图，请自己想想两个建图方式实质上是不是类似。
故代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=8e6+15;int n,m,k,dfn[MN],low[MN],vdcc[MN],tot,dcc; // dfn: DFS序, low: Tarjan算法中的low值, // vdcc: 强连通分量编号, tot: dfn时间戳, dcc: 强连通分量计数器vector&lt;int&gt; adj[MN],gp[MN]; //gp: 存储每个部分(题意中的部分)的点bool vis[MN];int s[MN],top;void tarjan(int u)&#123;    // tarjan求强联通    low[u]=dfn[u]=++tot;    s[++top]=u;    vis[u]=1;    for(auto v:adj[u])&#123;        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;else if(vis[v])&#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(low[u]==dfn[u])&#123;        dcc++;        int p;        do        &#123;            p=s[top--];            vdcc[p]=dcc;            vis[p]=0;        &#125; while (p!=u);    &#125;&#125;// 以下注释中// ¬u表示u的否定，即u+n// u的前缀辅助点，即u+2n// u的后缀辅助点，即u+3nint main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        int fu=u+n,fv=v+n;        adj[fu].push_back(v); // 添加边¬u → v        adj[fv].push_back(u); // 添加边¬v → u    &#125;    for(int i=1;i&lt;=k;i++)&#123;        int num;        cin&gt;&gt;num;        for(int j=1;j&lt;=num;j++)&#123;            int p;            cin&gt;&gt;p;            gp[i].push_back(p);            adj[p].push_back(p+2*n); // 添加边 p → p+2n（前缀变量）            adj[p+3*n].push_back(p+n); // 添加边 p+3n → ¬p（后缀变量）        &#125;        for(int j=1;j&lt;gp[i].size();j++)&#123;            int d1=gp[i][j-1],d2=gp[i][j]; // 前一个点和当前点            adj[d1+2*n].push_back(d2+2*n); // 添加边 d1+2n → d2+2n（前缀传递）            adj[d2+3*n].push_back(d1+3*n); // 添加边 d2+3n → d1+3n（后缀传递，可以看图理解）            adj[d1+2*n].push_back(d2+n); // 添加边 d1+2n → ¬d2（前缀已选，d2不可选）            adj[d2].push_back(d1+3*n); // 添加边 d2 → d1+3n（选d2，后缀必须选到d1）        &#125;    &#125;    for(int i=1;i&lt;=n*4;i++)&#123;        if(!dfn[i]) tarjan(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(vdcc[i]==vdcc[i+n] || vdcc[i+2*n]==vdcc[i+3*n])&#123;             // 如果i和¬i在同一分量，或前缀和后缀变量在同一分量则环无解            cout&lt;&lt;&quot;NIE&quot;;            return 0;        &#125;    &#125;    cout&lt;&lt;&quot;TAK&quot;;    return 0;&#125;
 3. 总结
2-SAT的问题在于怎么看出来，其实一个明显的特征就是类似于取或不取的关系，或者二元对立的关系（议论文？），或者要么取这个，要么取那个，或者转化成蕴含关系，考法很灵活，我目前见到的只有上面的，做题还是有点少www。
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-8-10提高组模拟赛</title>
    <url>/posts/f566038c/</url>
    <content><![CDATA[被诈骗的一集。
话说你是打得好才记吗，下次打的不好更应该记录反思的好吧。
 T1
CF1295D Same GCDs - 洛谷
暴力肯定是不行的，考虑如何对这个 xxx 计数，考虑算术唯一分解定理，对于 gcd⁡\gcdgcd 来说就是所有质数上指数取 min⁡\minmin，那么对 gcd⁡(a+x,m)=gcd⁡(a,m)\gcd(a+x,m)=\gcd(a,m)gcd(a+x,m)=gcd(a,m) 可以把 xxx 以质因数分解的形式看待的话，就是加上 xxx 之后取 min⁡\minmin 的值不变，可以分析出几个性质：

xxx 不会添加新的质数，质数取集只在 a,ma,ma,m 之间。
xxx 不会改变 aaa 取到 min⁡\minmin 指数的质数贡献。

那么有 gcd⁡(x,m)=gcd⁡(a,m)\gcd(x,m)=\gcd(a,m)gcd(x,m)=gcd(a,m)，除掉 gcd⁡(a,m)\gcd(a,m)gcd(a,m)，gcd⁡(xgcd⁡(a,m),mgcd⁡(a,m))=1\gcd(\frac{x}{\gcd(a,m)},\frac{m}{\gcd(a,m)})=1gcd(gcd(a,m)x​,gcd(a,m)m​)=1，求有多少满足这个的 xxx，显然这是欧拉函数的定义，答案就是 φ(mgcd⁡(a,m))\varphi(\frac{m}{\gcd(a,m)})φ(gcd(a,m)m​)，m\sqrt{m}m​ 直接做即可。
显然我们没有看数据，数据中有一个及其 nb 的地方在于多测且 t≤2×106t\le 2 \times 10^6t≤2×106，而 mmm 在 10710^7107 根号显然会炸掉，需要线性筛预处理不然只有 60 分也是无敌了，下次多留心以下数据吧 www。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e7+15;int a,m,phi[MN];vector&lt;int&gt; prime;vector&lt;bool&gt; notp(1e7+15);namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;void euler(int n)&#123;    phi[1]=1;    notp[1]=1;    for(int i=2;i&lt;=n;i++)&#123;        if(!notp[i])&#123;            prime.push_back(i);            phi[i]=i-1;        &#125;        for(auto p:prime)&#123;            if(i*p&gt;n) break;            notp[i*p]=1;            if(i%p==0)&#123;                phi[i*p]=phi[i]*p;                break;            &#125;            phi[i*p]=phi[i]*(p-1);        &#125;    &#125;&#125;int phii(int n)&#123;    if(n&lt;=1e7) return phi[n];    int ans=n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            ans=ans/i*(i-1);            while(n%i==0)&#123;                n/=i;            &#125;        &#125;    &#125;    if(n&gt;=2)&#123;        ans=ans/n*(n-1);    &#125;    return ans;&#125;void solve()&#123;    read(a,m);    put(phii(m/__gcd(a,m)));&#125;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;num.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;num.out&quot;,&quot;w&quot;,stdout);    #endif    euler(1e7);    int T;    read(T);    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 T2
PAM？PAM？Manacher？其实不是。
正着做及其困难，因为我也不知道这玩意到底怎么做，反正我们正难则反，那么答案就是 n×n−12−坏子串个数\dfrac{n\times n-1}{2}-\text{坏子串个数}2n×n−1​−坏子串个数。让后现在问题在于怎么求后面的坏子串个数。
考虑坏子串有没有什么性质，手摸不难发现坏子串只可能有如下四种情况：

…AAAAB\dots AAAAB…AAAAB
…BBBBA\dots BBBBA…BBBBA
ABBBB…ABBBB\dotsABBBB…
BAAAA…BAAAA\dotsBAAAA…

只有一端端头字符不同的子串不合法。可以 O(n)O(n)O(n) 扫一遍乘两边贡献就可以了，但是我是唐诗我 O(n2log⁡n)O(n^2 \log n)O(n2logn) 暴力拿下 80 分，剪枝高手有点无敌。
反思：做完题目之后要正确分析复杂度，而不是靠着虚无的剪枝骗分。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e6+15;int a[MN],n,ans;string s;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;palin.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;palin.out&quot;,&quot;w&quot;,stdout);    #endif    read(n,s);    for(int i=0,r;i&lt;n;i=r)&#123;        r=i;        while(r&lt;n&amp;&amp;s[i]==s[r]) r++;        if(i&gt;0) ans+=r-i;        if(r&lt;n) ans+=r-i-1;    &#125;    put(n*(n-1)/2-ans);    return 0;&#125;
 T3

给定一个仅包含小写英文字母的字符串 SSS，你需要以最小代价编辑出完全等于 SSS 的字符串。
初始时，你手中并没有任何字符。你可以使用以下操作：

购买操作：你可以一次性购买 SSS 的任意前缀。若购买的是长度为 LLL 的前缀，则需花费 a×La \times La×L 万元。
复制操作：你可以将当前已有的字符串整体复制一遍并接在末尾，花费 bbb 万元。
切割操作：你可以在当前字符串的任意位置切开，只保留前缀部分，花费 ccc 万元。

你可以多次使用这些操作，顺序任意。请计算：最少需要花费多少万元才能编辑出字符串 SSS。
1≤x,y,z≤10,1≤∣S∣≤2×1051\le x,y,z \le 10,1\le |S| \le 2\times 10^51≤x,y,z≤10,1≤∣S∣≤2×105。

好题，因为我真不太会拓展 kmp www。
设 f(i)f(i)f(i) 表示编辑出前缀 iii 的最小花费，有三种转移：

直接购买：f(i)=x×if(i)=x\times if(i)=x×i；
倍长 f(2i)=f(i)+yf(2i)=f(i)+yf(2i)=f(i)+y，当且仅当 s[1,i]=s[i+1,2i]s[1,i]=s[i+1,2i]s[1,i]=s[i+1,2i]。
倍长后剪切：f(i+k)=f(i)+y+zf(i+k)=f(i)+y+zf(i+k)=f(i)+y+z，当且仅当 s[1,k]=s[i+1,i+k]s[1,k]=s[i+1,i+k]s[1,k]=s[i+1,i+k]。

显然要用拓展 kmp 求出 s[i:n]s[i:n]s[i:n] 与 sss 的 LCP，那么第三个转移的限制就是 k∈[1,min⁡(zi+1,i)]k\in [1,\min(z_{i+1},i)]k∈[1,min(zi+1​,i)]，这是 O(n2)O(n^2)O(n2)，用一个后缀 min 的树状数组维护转移可以做到 O(nlog⁡n)O(n\log n)O(nlogn)。
反思：我们仅需要保留与状态计算有关的量，尽量做到所谓的状态 “最小化”，在场上自行设计状态的时候设计了二维状态（从哪里倍长过来），导致时间复杂度来到了 O(n3)O(n^3)O(n3)。在 DP 设计状态的时候应当需要保留和状态计算有关的量，这里倍长完全可以正解设一维转移过来。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15,INF=0x3f3f3f3f3f3f3f3f;int n,X,Y,Z,nxt[MN],f[MN];string s;struct BIT&#123;    int t[MN];    BIT()&#123;        memset(t,0x3f,sizeof(t));    &#125;    int lowbit(int x)&#123;return x&amp;-x;&#125;    void modify(int x,int k)&#123;        while(x)&#123;            t[x]=min(t[x],k);            x-=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=INF;        while(x&lt;MN)&#123;            ret=min(ret,t[x]);            x+=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;void qnxt(string s)&#123;    int l=-1,r=-1;    nxt[0]=n;    for(int i=1;i&lt;n;i++)&#123;        if(i&lt;r) nxt[i]=min(nxt[i-l],r-i);        while(i+nxt[i]&lt;n&amp;&amp;s[i+nxt[i]]==s[nxt[i]]) ++nxt[i];        if(i+nxt[i]&gt;r)&#123;            l=i;            r=i+nxt[i];        &#125;    &#125;&#125;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;edit.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;edit.out&quot;,&quot;w&quot;,stdout);    #endif    cin&gt;&gt;s&gt;&gt;X&gt;&gt;Y&gt;&gt;Z;    n=s.length();    qnxt(s);    for(int i=1;i&lt;=n;i++)&#123;        f[i]=min(bit.query(i),X*i);        if(i%2==0&amp;&amp;nxt[i/2]&gt;=i/2) f[i]=min(f[i],f[i/2]+Y);        int r=i+min(nxt[i],i-1);        bit.modify(r, f[i]+Y+Z);    &#125;    cout&lt;&lt;f[n];    return 0;&#125;
 T4
CF1538E
啊哈，我已经在 GF 被骗过了，所以不会再骗啦，只需要计算跨段的贡献就可以了，合并时可能增加的 haha 数量只会在边界字符拼接产生。只需要记录开头和结尾的字符串，拼接的时候暴力模拟就可以了，常熟是 555。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n;string lst;struct Node&#123;    string ls,rs;    int ans;    Node()&#123;        ans=0,ls=&quot;&quot;,rs=&quot;&quot;;    &#125;    Node(const string &amp;st)&#123;        ans=(st.find(&quot;haha&quot;))!=string::npos;        ls=st.substr(0,min(4ll,(int)st.length())),rs=st.substr(max(0ll,(int)st.length()-4));    &#125;    friend Node operator +(const Node &amp;x,const Node &amp;y)&#123;        Node ret=x;        ret.ls+=y.ls;        ret.rs+=y.rs;        ret.ls=ret.ls.substr(0,min(4ll,(int)ret.ls.length()));        ret.rs=ret.rs.substr(max(0ll,(int)ret.rs.length()-4));        ret.ans+=y.ans;        int rss=(x.rs.find(&quot;haha&quot;)!=string::npos),lss=((y.ls.find(&quot;haha&quot;))!=string::npos),res=0;        string st=x.rs+y.ls;        for(int i=0;i&lt;=(int)st.length()-4;i++)&#123;            if(st.substr(i,4)==&quot;haha&quot;) res++;        &#125;        ret.ans+=res-rss-lss;        return ret;    &#125;&#125;;map&lt;string,Node&gt; mp;void solve()&#123;    cin&gt;&gt;n;    string lst;    for(int i=1;i&lt;=n;i++)&#123;        string x,y,z;        string op,tmp;        cin&gt;&gt;x&gt;&gt;op;        if(op==&quot;:=&quot;)&#123;            cin&gt;&gt;y;            mp[x]=Node(y);            lst=x;        &#125;else&#123;            cin&gt;&gt;y&gt;&gt;tmp&gt;&gt;z;            mp[x]=mp[y]+mp[z];            lst=x;        &#125;    &#125;    cout&lt;&lt;mp[lst].ans&lt;&lt;&#x27;\n&#x27;;    mp.clear();&#125;signed main()&#123;    freopen(&quot;haha.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;haha.out&quot;,&quot;w&quot;,stdout);    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>比赛记录</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2025.8.16模拟赛</title>
    <url>/posts/ec022ca1/</url>
    <content><![CDATA[ T1
8 数码问题简化版，O(7!)O(7!)O(7!) 爆搜 BFS，没了。
 T2

∑i=0m+1(n+1i)=∑i=0m(ni)+(n−1i)\sum\limits_{i=0}^{m+1}\binom{n+1}{i}=\sum\limits_{i=0}^{m}\binom{n}{i}+\binom{n-1}{i}
i=0∑m+1​(in+1​)=i=0∑m​(in​)+(in−1​)
∑i=0m+1(ni)=∑i=0m(ni)+(nm+1)\sum\limits_{i=0}^{m+1}\binom{n}{i}=\sum\limits_{i=0}^m \binom{n}{i}+\binom{n}{m+1}
i=0∑m+1​(in​)=i=0∑m​(in​)+(m+1n​)
时间复杂度为 O(n)O(n)O(n)，瓶颈在预处理组合数。
 T3

 Subtask 1
暴力枚举排列，逆序对也可以暴力统计，时间复杂度 O(7!)O(7!)O(7!)。
 Subtask 2
注意到暴力枚举排列不行，但是注意到这个只和排列奇偶性有关。本质上就是求行列式。具体的就是照题目的把矩阵 [li,ri][l_{i},r_{i}][li​,ri​] 设为 1，其他设为 0。求行列式即可，时间复杂度 O(n3)O(n^3)O(n3)。
 Subtask 3
特判了所以没分。
 Subtask 4
首先我们到了 O(nlog⁡n)O(n\log n)O(nlogn)，连暴力 O(n2)O(n^2)O(n2) 初始化矩阵都无法初始化了就很难受。考虑到本题就是让你求行列式，那么目标就是优化求行列式的这一步骤。
我们考虑发掘一个性质，发现最大的性质就是行列式的取值就是 {0,1}\{ 0,1\}{0,1}，且 111 是连续的一段。
考虑行列式展开：
det⁡M=∑psgn⁡(p)∏i=1nAi,pi\det M = \sum_{p} \operatorname{sgn}(p) \prod_{i=1}^n A_{i,p_{i}}
detM=p∑​sgn(p)i=1∏n​Ai,pi​​
这个 sgnsgnsgn 就是题目中的逆序对奇偶性，即 (−1)逆序对对数(-1)^{\text{逆序对对数}}(−1)逆序对对数，而 pip_{i}pi​ 就是我们枚举的排列。
根据过往在提高组线性代数课上，我把这个玩意叫做二分图完美匹配问题。
那么转化一下到二分图，一个合法排列相当于区间匹配问题：对于 Ai,piA_{i,p_{i}}Ai,pi​​，每行选取的列是一个区间，要在区间里挑一个点，要求所有选取的列互不相同。
二分图建模相当于就是左部点是行 iii，右部点是列 jjj，对于 j∈[li,ri],i→jj\in [l_{i},r_{i}],i\to jj∈[li​,ri​],i→j 连边，问题转化为求二分图完美匹配和这个逆序对奇偶性。
这里我们顺序扫描列，枚举右部点来和左部点进行匹配。我们发现一个性质：

若看作二分图结构的话，那么左部点向右部点连边的是一个区间范围。

那么我们有一个贪心的想法，每次我们选择连边区间右端点最小的匹配。证明考虑反证法，如果不选右端点最小的区间，那么它很可能在后面用不了，导致全局无解释。
然后我们就可以做了，具体的，我们需要维护一个可并堆的结构，初始把所有区间插入每个左端点对应的堆里面，每次取出右端点最小的右端点，让后将剩下的元素放到 heapi+1heap_{i+1}heapi+1​ 这个堆里面。
如果你不会可并堆，可以使用 Fhq-Treap 维护最小值和合并进行操作，但是我用可并堆是因为我一开始写 Fhq-Treap 写了一小时炸杠了 QAQ。
而奇偶性可以把高斯消元的代码抄过来，也是可以的，就是如果当前主元不再对角线上，我们可以把它交换回来，同时一次交换代表出现一个逆序对，将 ans 制反即可。
时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：图论模型的转化是一个比较常见的，对于优化如果无从下手是否可以考虑贪心的想法来进行优化？
 T4

好题
首先大量对优先级区间的查询操作，很容易想到使用线段树来维护优先级的查询，但是查什么？如何维护？
考虑发掘性质，发现一个关键性质就是结点数 ≤9\le 9≤9，这是一个关键提示，而且题目中求的是多源最短路，联想 Floyd。
但是题目中还有一个限制就是走的优先级边必须单调不降，如果直接用 Floyd 做的话很难受不好处理性质。但是结点数很少，我们能不能……把每一个优先级对应的边用单独的图存下来？
思考这种方法可行性，注意到 Floyd 的本质其实是邻接矩阵的 (min⁡,+)(\min,+)(min,+) 广义矩阵乘法。也就是说这个又结合律，也可以上线段树维护！从左向右乘，正好满足了不同优先级道路之间的先后顺序。
做法也就这么出来了，注意到 ppp 总共就 2000 个，所以创建最多 2000 个叶子节点，让后并对每个叶子结点跑一遍 Floyd 预处理出只走该优先级道路时的最短路。让后用线段树维护矩阵乘法。
查询的时候通过和线段树无任何差别，答案通过矩阵乘法统计即可。
反思：
当看到某个数据量极小的时候，我们要从它入手，分析性质，例如本题的结点数，上场模拟赛 T4 的 k≤5k\le 5k≤5。
应用线段树要灵活。一般进行区间修改，查询等操作的题目都可以使用线段树解决。其结点类型也不一定是“数”，只要是具有可并性的数据类型都可以当成结点，只要再对其各种操作进行相应修改即可。感觉要再复习一遍线段树理论了。
]]></content>
      <categories>
        <category>比赛记录</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2025.8.19模拟赛</title>
    <url>/posts/1d09772c/</url>
    <content><![CDATA[ T1
字符串基础练习，时间复杂度 O(nL)O(nL)O(nL)。
 T2

BFS 洪水填充，但是如果你直接暴力枚举一个点进行拓展的话显然不对。我们可以通过多源 BFS 来做到 O(nm)O(nm)O(nm)。
注意这里必须 O(nm)O(nm)O(nm)，记得以后一定要计算复杂度，不然会被卡常。
 T3
更唐的做法：
观察一组合法的三元组的格式是怎样的，显然这三元组因为在树上，故必然存在一个点使得到这三个点距离相等(距离不等反而赢了）。如果不认为显然的请列方程计算，你会发现有解情况唯一剩下的都有环。
那么我们可以枚举交点，把它提起来作为根，然后我们枚举距离 ttt，对每一个孩子的子树求其子树内有多少距离根节点为 ttt 的点，记一个孩子子树的合法点个数为 aia_{i}ai​。
那么答案就是三个不同子树的点进行配对 ∑i≠j≠kaiajak\sum\limits_{i\neq j\neq k} a_{i}a_{j}a_{k}i=j=k∑​ai​aj​ak​。不难发现上述过程光枚举就花了 O(n2)O(n^2)O(n2)，这个玩意还是 O(n3)O(n^3)O(n3) 的，我们很成功的只有 252525 分，而且是 O(1)O(1)O(1) 进行计算很难泵。
然后考虑怎么优化这个答案统计过程，发现及其难以优化。但是发现这具有组合意义，考虑容斥计算。
首先记 sum1=∑iaisum1=\sum\limits_{i}a_{i}sum1=i∑​ai​，那么任意选三个点的方案数就是 (sum13)\dbinom{sum1}{3}(3sum1​)。显然这个方案包含了同子树的，我们要把他们减去：

两个点在一个子树：∑i(ai2)⋅(sum−ai)\sum\limits_{i} \dbinom{a_{i}}{2} \cdot (sum-a_{i})i∑​(2ai​​)⋅(sum−ai​)。
三个点在一个子树：∑i(ai3)\sum\limits_{i}\dbinom{a_{i}}{3}i∑​(3ai​​)。

故答案 (sum13)−∑i(ai2)⋅(sum−ai)−∑i(ai3)\dbinom{sum1}{3}-\sum\limits_{i} \dbinom{a_{i}}{2} \cdot (sum-a_{i})-\sum\limits_{i}\dbinom{a_{i}}{3}(3sum1​)−i∑​(2ai​​)⋅(sum−ai​)−i∑​(3ai​​)。
直接开始化简！

第一个式子：(sum13)=sum(sum−1)(sum−2)6\dbinom{sum1}{3}=\dfrac{sum(sum-1)(sum-2)}{6}(3sum1​)=6sum(sum−1)(sum−2)​。
第二个式子：∑i(ai2)⋅(sum−ai)=ai−(ai−1)2(sum−ai)\sum\limits_{i} \dbinom{a_{i}}{2} \cdot (sum-a_{i})=\dfrac{a_{i}-(a_{i}-1)}{2} (sum-a_{i})i∑​(2ai​​)⋅(sum−ai​)=2ai​−(ai​−1)​(sum−ai​)。
第三个式子：ai(ai−1)(ai−2)6\dfrac{a_{i}(a_{i}-1)(a_{i}-2)}{6}6ai​(ai​−1)(ai​−2)​

第二个式子和第三个式子：
=ai(ai−1)2(sum−ai)+ai(ai−1)(ai−2)6=ai(ai−1)6(3(sum−ai)+(ai−2))=ai(ai−1)6(3sum−2ai−2)\begin{aligned}
&amp; =\dfrac{a_{i}(a_{i}-1)}{2}(sum-a_{i})+\dfrac{a_{i}(a_{i}-1)(a_{i}-2)}{6} \\
&amp; = \dfrac{a_{i}(a_{i}-1)}{6}(3(sum-a_{i})+(a_{i}-2)) \\
&amp; = \dfrac{a_{i}(a_{i}-1)}{6}(3sum -2a_{i} -2)
\end{aligned}
​=2ai​(ai​−1)​(sum−ai​)+6ai​(ai​−1)(ai​−2)​=6ai​(ai​−1)​(3(sum−ai​)+(ai​−2))=6ai​(ai​−1)​(3sum−2ai​−2)​
原式即为：
sum(sum−1)(sum−2)6−∑iai(ai−1)6(3sum−2ai−2)\dfrac{sum(sum-1)(sum-2)}{6}-\sum\limits_{i} \dfrac{a_{i}(a_{i}-1)}{6}(3sum -2a_{i} -2)
6sum(sum−1)(sum−2)​−i∑​6ai​(ai​−1)​(3sum−2ai​−2)
进一步化简：
16[sum(sum−1)(sum−2)−∑iai(ai−1)(3sum−2ai−2)]\dfrac{1}{6}[sum(sum-1)(sum-2)-\sum\limits_{i} a_{i}(a_{i}-1)(3sum-2a_{i}-2)]
61​[sum(sum−1)(sum−2)−i∑​ai​(ai​−1)(3sum−2ai​−2)]
考虑后式，记 sum2=∑iai2,sum3=∑iai3sum_{2}=\sum\limits_{i}a_{i}^2,sum_{3}=\sum\limits_{i}a_{i}^3sum2​=i∑​ai2​,sum3​=i∑​ai3​。有：
∑iai(ai−1)(3sum−2ai−2)=∑i(3sum⋅ai2−(3sum−2)ai−2ai3)\sum\limits_{i} a_{i}(a_{i}-1)(3sum-2a_{i}-2)=\sum\limits_{i}(3sum\cdot a_{i}^2-(3sum-2)a_{i}-2a_{i}^3)
i∑​ai​(ai​−1)(3sum−2ai​−2)=i∑​(3sum⋅ai2​−(3sum−2)ai​−2ai3​)
进一步化简代回分子式有：
sum(sum−1)(sum−2)−(3sum⋅sum2−(3sum−2)⋅sum−2sum3)sum(sum-1)(sum-2)-(3sum\cdot sum_{2}-(3sum -2)\cdot sum-2sum_3)
sum(sum−1)(sum−2)−(3sum⋅sum2​−(3sum−2)⋅sum−2sum3​)
最后化简有：
ans=sum3−3sum⋅sum2+2sum36ans=\dfrac{sum^3 -3sum\cdot sum_{2}+2sum_{3}}{6}
ans=6sum3−3sum⋅sum2​+2sum3​​
即可 O(1)O(1)O(1) 计算，用 BFS 按层计算，时间复杂度 O(nm)O(nm)O(nm)，推式子时长占到了总时长的 90%，据观察没有人会想我这么唐推这个式子，直接一开始不等距离也是可以直接做的，反而会更简单直接组合数即可。
总结：不要看到式子就星宇大发，一定要冷静观察有没有更好的做法。
 T4



 赛后总结
T3 太唐了没有分配好时间去做。推完式子发现没时间做了，以后要有时间意识。
卡常，卡常，卡常！
]]></content>
      <categories>
        <category>比赛记录</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2025.8.24模拟赛</title>
    <url>/posts/71159a9d/</url>
    <content><![CDATA[省流：被诈骗的一集
 T1
诈骗题。
本题的性质只能从答案入手，很难观察到答案不超过 333，具体的就是令 i=n−2,j=n−1i=n-2,j=n-1i=n−2,j=n−1。那么由于 LCP 肯定不超过长度，所以答案构造 ≤3\le 3≤3。
一个暴力的想法就是暴力枚举两个指针 i,ji,ji,j 来去判断，但是这是 O(n2)O(n^2)O(n2) 的，不过有了答案 ≤3\le 3≤3 我们思考具体取值。
考虑固定 iii。首先 j∈[i+1,i+3]j\in[i+1,i+3]j∈[i+1,i+3] 的枚举是肯定需要的，复杂度可以接受。但是一但到了 i+4i+4i+4 之后呢？结论是直接取到 j=n−1j=n-1j=n−1 即可，答案还是因为答案不超过 3，可以让 LCP(a,c)+LCP(b,c)=0LCP(a,c)+LCP(b,c)=0LCP(a,c)+LCP(b,c)=0 当且仅当存在 cj≠a1∧cj≠bic_j\neq a_1\land c_j\neq b_icj​=a1​∧cj​=bi​。否则：如果 a1≠bia_1\neq b_ia1​=bi​，我们选 j=n−1j = n - 1j=n−1 就有 LCP(a,c)+LCP(b,c)=1LCP(a,c)+LCP(b,c)=1LCP(a,c)+LCP(b,c)=1，最优；如果 a1=bia_1 = b_ia1​=bi​，那后面的 cjc_jcj​ 也都和它们相等，LCP(a,c)+LCP(b,c)≥2LCP(a,c)+LCP(b,c)\ge 2LCP(a,c)+LCP(b,c)≥2，还是选 j=n−1j=n-1j=n−1 最优。
所以就枚举 iii，然后按照上面暴力统计即可。
总结：当且仅当无法从正向导出任何有效结论且用时过长，考虑从答案入手。一个简要的方法就是通过暴力或题目所给出的特殊性结构（例如树），通常会发现答案与给出的特殊性结构或着取值在一个范围内。
 T2
题意就是问有多少个图的深度优先搜索树是给定的树。
题目代码给定了每个点孩子的访问顺序是编号从小到大，所以可以直接得到每个点的 dfs 序。
考虑 dfs 过程，可以发现树边一定存在，非树边如果是横叉边（两端点在 dfs 树上不是祖孙关系）则一定不存在（否则先 dfs 到其中一端的时候一定会让另一端在这个 dfs 树的子树里），如果是返祖边（祖先到子孙）则在子孙点编号大于它在 dfs 树上所在祖先子树的编号（也就是到祖先点路径的倒数第二个点的编号）时可以存在，否则也不能存在。
综合起来，结论是所有树边一定存在，一部分非树边一定不存在，其余非树边可以存在也可以不存在且每条边状态都互相独立任选。那么答案等于 2c2^c2c，其中 ccc 是可存在可不存在的非树边个数。我们称这些非树边是合法的。
根据上述讨论，一条非树边合法当且仅当它是祖孙边，且子孙点所属的祖先点的子树的根编号小于子孙点的编号。那么合法的边数总数其实就是满足以下条件的 (u,v)(u,v)(u,v) 点对数：

uuu 是 vvv 的祖先。
u&lt;vu\lt vu&lt;v
uuu 不是根。（u≠1u\ne 1u=1）

这样，uuu 父亲和 vvv 之间的边是合法的。
要统计这样的点对数，只要统计每个点到根路径上编号小于自己的点数之和。dfs 一遍，用树状数组或者其它数据结构在 dfs 过程中维护当前点到根路径上的点集即可。用权值线段树可以简单做到 O(nlog⁡n)O(n\log n)O(nlogn)。但是问题在于你不对拍，你 30 分。
总结：对拍过程：先暴力拍小的，然后不带暴力拍大的测极端数据下是否合法。
 T3
先考虑 k=1k=1k=1 的情况，看到这种有多个可以状压的部分，你可能无从下手，但是我们要考虑我们到底要状压什么部分。
考虑贡献，贡献有三部分，固定点内部，固定点与可选点，可选点内部的贡献。
考虑到前两部分的贡献都是可以暴力预处理的，但是后面很难受，这个地方就是我们要特殊处理的部分。
首先考虑这个距离贡献，曼哈顿距离我们将绝对值拆开有：
∣a∣+∣b∣=max⁡(a+b,a−b,−a+b,−a−b).|a|+|b|=\max(a+b,a-b,-a+b,-a-b).
∣a∣+∣b∣=max(a+b,a−b,−a+b,−a−b).
也就是说，绝对值此时无关紧要，我们只需要考虑安排好每个数每一维正负号的贡献就好了。举个例子，假设已经选好了 mmm 个点，那么你可以先排序成  x1≤x2≤⋯≤xmx_1\le x_2\le \cdots\le x_mx1​≤x2​≤⋯≤xm​，然后你按贡献计算 ∑i=1m(2i−m−1)xi=∑i≠j∣xi−xj∣\sum_{i=1}^m(2i-m-1)x_i=\sum_{i\ne j}|x_i-x_j|∑i=1m​(2i−m−1)xi​=∑i=j​∣xi​−xj​∣。我们实际上只需要枚举 m!m!m! 种排列，然后将 ∑i=1m(2i−m−1)xi\sum_{i=1}^m(2i-m-1)x_i∑i=1m​(2i−m−1)xi​ 的最大值算出来。
那么有状压 DP，设 f(i,S)f(i,S)f(i,S) 表示前 iii 个点中，已经钦定了一些点位于 SSS 这些位置的情况下，所能产生的贡献最大值。此处的 SSS 应当是 mmm 位二进制数。也就是相当于用状压DP枚举了点坐标大小的 m!m!m! 种排列。
转移时，把第 iii 个点放到第 ppp 个位置，贡献将会是 (2p−m−1)xi+ci(2p - m - 1)x _i + c _i(2p−m−1)xi​+ci​，其中 cic _ici​ 表示第 iii 个点与其他固定点之间的贡献。如此状压 DP，复杂度是 O(nm2m)O(n m2^m)O(nm2m)，其中 nnn 代表可选点数，也即 m+tm + tm+t。
考虑 k=2k=2k=2，同上拓展，设 f(i,S1,S2)f(i, S_1, S_2)f(i,S1​,S2​) 表示前 iii 个点中，已经钦定了一些点的 xxx 坐标占据了 S1S_1S1​ 的位置，yyy 坐标占据了 S2S_2S2​ 的位置，所能产生的贡献最大值。
转移时，把第 iii 个点的 xxx 坐标放到 p1p _1p1​ 的位置，yyy 坐标放到 p2p _2p2​ 的位置，贡献将会是 (2p1−m−1)xi+(2p2−m−1)yi+ci(2p _1 - m - 1)x _i + (2p _2 - m - 1)y _i + c _i(2p1​−m−1)xi​+(2p2​−m−1)yi​+ci​，复杂度粗略估计一下大概是 O(nm24m)O(nm^2 4^m)O(nm24m)，已经可以过了。
但是注意到，S1S _1S1​ 和 S2S_2S2​ 互相之间是有限制的，因为他们总需要保证出现的点数相同，不可能会是 O(4m)O(4 ^m)O(4m) 级别的状态量。实际上考虑枚举两个状态中出现的点数 kkk，状态量应当为
∑k=0m(mk)2,\sum _{k = 0}^m {m \choose k}^2,
k=0∑m​(km​)2,
这是 O(4mm)O(\frac {4^m} {\sqrt m})O(m​4m​) 的。
总结：
看到一堆可以状压的变量时，首先要分析贡献发觉性质而不是什么考虑状压的变量。有的时候状态变量可能会比实际要更少。
 T4
彩色括号
]]></content>
      <categories>
        <category>比赛记录</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20250814模拟赛</title>
    <url>/posts/68036b89/</url>
    <content><![CDATA[ 前言
省流：300 分。
 T1
考虑 DP，设 f(i,0/1/2)f(i,0/1/2)f(i,0/1/2) 表示处理到第 iii 个数，当前是往左，不动，往右，方案是否合法，转移如下：
f[i][0]=f[i−1][0]⋅[xi−xi−1=1]+f[i−1][1]⋅[xi−(xi−1−1)=1]+f[i−1][2]⋅[xi−(xi−1+1)=1],f[i][1]=f[i−1][0]⋅[xi−1−xi−1=1]+f[i−1][1]⋅[xi−1−(xi−1−1)=1]+f[i−1][2]⋅[xi−1−(xi−1+1)=1],f[i][2]=f[i−1][0]⋅[xi+1−xi−1=1]+f[i−1][1]⋅[xi+1−(xi−1−1)=1]+f[i−1][2]⋅[xi+1−(xi−1+1)=1],\begin{aligned}
f[i][0] &amp;= f[i-1][0] \cdot [x_i - x_{i-1} = 1] 
        + f[i-1][1] \cdot [x_i - (x_{i-1} - 1) = 1] 
        + f[i-1][2] \cdot [x_i - (x_{i-1} + 1) = 1], \\
f[i][1] &amp;= f[i-1][0] \cdot [x_i - 1 - x_{i-1} = 1] 
        + f[i-1][1] \cdot [x_i - 1 - (x_{i-1} - 1) = 1] 
        + f[i-1][2] \cdot [x_i - 1 - (x_{i-1} + 1) = 1], \\
f[i][2] &amp;= f[i-1][0] \cdot [x_i + 1 - x_{i-1} = 1] 
        + f[i-1][1] \cdot [x_i + 1 - (x_{i-1} - 1) = 1] 
        + f[i-1][2] \cdot [x_i + 1 - (x_{i-1} + 1) = 1],
\end{aligned}f[i][0]f[i][1]f[i][2]​=f[i−1][0]⋅[xi​−xi−1​=1]+f[i−1][1]⋅[xi​−(xi−1​−1)=1]+f[i−1][2]⋅[xi​−(xi−1​+1)=1],=f[i−1][0]⋅[xi​−1−xi−1​=1]+f[i−1][1]⋅[xi​−1−(xi−1​−1)=1]+f[i−1][2]⋅[xi​−1−(xi−1​+1)=1],=f[i−1][0]⋅[xi​+1−xi−1​=1]+f[i−1][1]⋅[xi​+1−(xi−1​−1)=1]+f[i−1][2]⋅[xi​+1−(xi−1​+1)=1],​
O(n)O(n)O(n)。
O(1)O(1)O(1) 做法：直接判断 an−a1≤n+1a_n-a_{1}\le n+1an​−a1​≤n+1 即可。
 T2
原题 CF1824B2 LuoTianyi and the Floating Islands (Hard Version) - 洛谷
 T3
四元环计数，考虑和三元环计数一样，先度数小的往度数大的定向。
不难发现只有三种情况：

A -&gt; B -&gt; C -&gt; D
A -&gt; B -&gt; D -&gt; C
A -&gt; D -&gt; B -&gt; C

考虑固定 AAA，让后我们对于后面三个进行暴力枚举，不难发现后面三个相当于在枚举三元环，时间复杂度是 O(mm)O(m\sqrt{m})O(mm​)。
有必要澄清一点的是，loj 的提交是因为我根本不知道样例合法性，有好心人说样例有误我也只能自己猜样例这样改应该是对的，不算分。
 T4
一眼 nnn 极大 m,km,km,k 极小，考虑矩阵快速幂。
先把 DP 设出来，由于 kkk 极小可以直接在状态内部表示我们恐怖的奴隶主的类型，设 f(i,cnt1,cnt2,cnt3)f(i,cnt1,cnt2,cnt3)f(i,cnt1,cnt2,cnt3) 表示目前打到第 iii 轮，恐怖的奴隶主剩一滴血的数量为 cnt1cnt1cnt1，两滴血的为 cnt2cnt2cnt2，三滴血的为 cnt3cnt3cnt3，的扣减 Boss 的生命值点数的期望。先写出打 4 种怪的概率：

打 Boss：p0=1cnt1+cnt2+cnt3+1p_0=\dfrac{1}{cnt1+cnt2+cnt3+1}p0​=cnt1+cnt2+cnt3+11​。
打一滴血的：p1=cnt1cnt1+cnt2+cnt3+1p_{1}=\dfrac{cnt1}{cnt1+cnt2+cnt3+1}p1​=cnt1+cnt2+cnt3+1cnt1​。
打两滴血的：p2=cnt2cnt1+cnt2+cnt3+1p_{2}=\dfrac{cnt2}{cnt1+cnt2+cnt3+1}p2​=cnt1+cnt2+cnt3+1cnt2​。
打三滴血的：p3=cnt3cnt1+cnt2+cnt3+1p_{3}=\dfrac{cnt3}{cnt1+cnt2+cnt3+1}p3​=cnt1+cnt2+cnt3+1cnt3​。

那么转移如下，令 nowf=f(i,cnt1,cnt2,cnt3)nowf=f(i,cnt1,cnt2,cnt3)nowf=f(i,cnt1,cnt2,cnt3)：
f(i+1,cnt1,cnt2,cnt3)←nowf+p0f(i+1,cnt1,cnt2,cnt3)\leftarrow nowf+p_0
f(i+1,cnt1,cnt2,cnt3)←nowf+p0​
f(i+1,cnt1−1,cnt2,cnt3)←nowf⋅p1(cnt1≠0)f(i+1,cnt1+1,cnt2−1,cnt3+1)←nowf⋅p2(cnt1+cnt2+cnt3≤k)f(i+1,cnt1+1,cnt2−1,cnt3)←nowf⋅p2(cnt1+cnt2+cnt3&gt;k)f(i+1,cnt1,cnt2+1,cnt3)←nowf⋅p3(cnt1+cnt2+cnt3≤k)f(i+1,cnt1,cnt2+1,cnt3−1)←nowf⋅p3(cnt1+cnt2+cnt3&gt;k)\begin{aligned}
f(i+1,cnt1-1,cnt2,cnt3) &amp; \leftarrow nowf\cdot p_{1} &amp; (cnt1\neq 0) \\ \\
f(i+1,cnt1+1,cnt2-1,cnt3+1) &amp; \leftarrow nowf\cdot p_{2} &amp; (cnt1+cnt2+cnt3 \le k) \\
f(i+1,cnt1+1,cnt2-1,cnt3) &amp; \leftarrow nowf\cdot p_{2} &amp; (cnt1+cnt2+cnt3 &gt; k) \\ \\
f(i+1,cnt1,cnt2+1,cnt3) &amp; \leftarrow nowf\cdot p_{3} &amp; (cnt1+cnt2+cnt3 \le k) \\
f(i+1,cnt1,cnt2+1,cnt3-1) &amp; \leftarrow nowf\cdot p_{3} &amp; (cnt1+cnt2+cnt3 &gt; k) \\
\end{aligned}f(i+1,cnt1−1,cnt2,cnt3)f(i+1,cnt1+1,cnt2−1,cnt3+1)f(i+1,cnt1+1,cnt2−1,cnt3)f(i+1,cnt1,cnt2+1,cnt3)f(i+1,cnt1,cnt2+1,cnt3−1)​←nowf⋅p1​←nowf⋅p2​←nowf⋅p2​←nowf⋅p3​←nowf⋅p3​​(cnt1=0)(cnt1+cnt2+cnt3≤k)(cnt1+cnt2+cnt3&gt;k)(cnt1+cnt2+cnt3≤k)(cnt1+cnt2+cnt3&gt;k)​
时间复杂度 O(nk)O(nk)O(nk)，爆搜发现有效的状态数上界 kkk 很小，在 170 左右，用矩阵快速幂简单优化可以做到 O(Tk3log⁡n)O(Tk^3 \log n)O(Tk3logn)，发现炸掉了，考虑优化。
首先向量乘法是 k2k^2k2 的，所以简单实现向量乘法而不是矩阵乘法容易有 O(Tk2(k3log⁡n)O(Tk^2(k^3 \log n)O(Tk2(k3logn)，发现瓶颈在于每一次我们都要算一遍转移矩阵。注意到 m,km,km,k 固定而 nnn 才是变化的。所以预处理转移矩阵，通过二进制分组转移即可，时间复杂度 O(k3log⁡n+Tk2log⁡n)O(k^3 \log n+Tk^2 \log n)O(k3logn+Tk2logn)。
反思：矩阵乘法实现的时候应当注意有效状态的数量以及矩阵乘法带来的 n3n^3n3 的大小，这个一定是要注意的。
]]></content>
      <categories>
        <category>比赛记录</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC236G题解</title>
    <url>/posts/f19f1a1/</url>
    <content><![CDATA[推销自己的矩阵优化文章：矩阵快速幂优化DP

注意到点数及其小，边数也算小，而 LLL 极大，有一股浓烈的矩阵快速幂优化的味道。
首先这个问题肯定是一个 DP 的题，我们有一个暴力的想法，我们对于每一个操作，利用 Floyd 的 DP 思想，邻接矩表示图两点之间经过 111 条边的路径数量这个特点，对于每一个操作我们更新邻接矩阵，让后在上面跑矩阵快速幂，幂 LLL 次后的邻接矩阵代表的就是经过 LLL 条边的信息，一次次更新答案判断可达性即可，时间复杂度 O(Tn3log⁡L)O(T n^3 \log L)O(Tn3logL)，不能通过。
我们考虑如何优化，根据题意，每一次操作只会添加一条边，而要求的是求经过边中操作编号更靠后（也就是更大）的边。我们可以将这个操作编号绑到边权上，那么实际上我们就是要对经过的边的边权取 max⁡\maxmax 操作。
那么我们有一个显而易见的状态，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示在从 iii 到 jjj 节点，经过 kkk 条边的最大边权，转移如下：
f(i,j,k)=min⁡{max⁡p=1nf(i,p,k−1)+w(p,j)}f(i,j,k)=\min\left\{ \max_{p=1}^{n} f(i,p,k-1)+w(p,j) \right\}
f(i,j,k)=min{p=1maxn​f(i,p,k−1)+w(p,j)}
其中 w(i,j)w(i,j)w(i,j) 表示从 i→ji\rightarrow ji→j 边的边权。
考虑这个能不能转成广义矩阵乘法的形式，检验如下：

外部加法结合交换律：min⁡\minmin 满足结合律交换律。
内部乘法结合律：max⁡\maxmax 满足结合律与交换律。
分配律：左分配为：max⁡(a,min⁡(b,c))=min⁡(max⁡(a,b),max⁡(a,c))\max(a,\min(b,c))=\min(\max(a,b),\max(a,c))max(a,min(b,c))=min(max(a,b),max(a,c))，由于 max⁡\maxmax 有交换律所有右分配律同样成立，故分配律成立。

注意转矩阵乘法后千万不要思维定势，各个特殊乘法加法的单位元都是不一样的，下面给出一张图给出了各个广义矩阵乘法对应的单位元：

注意到这个矩阵幂的形式其实和上面 Floyd 的形式差不太多，我们在实现的时候还是邻接矩阵，每个操作的边的边权设为 iii，跑矩阵快速幂即可。时间复杂度 O(n3log⁡L)O(n^3 \log L)O(n3logL)，代码如下，跑的很慢大常数选手非我莫属 www。
#include&lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define int long longusing namespace std;constexpr int MN=250,INF=1e18;int n,t,l;struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=INF)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                mat[i][j]=INF;            &#125;        &#125;        if(x==INF) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]=min(ret.mat[i][j],max(mat[i][k],x.mat[k][j]));                &#125;            &#125;        &#125;        return ret;    &#125;&#125;adj;Matrix ksm(Matrix a,int b)&#123;    Matrix ret(0);    while(b)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;t&gt;&gt;l;    for(int i=1;i&lt;=t;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj.mat[u][v]=i;    &#125;    adj=ksm(adj,l);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;(adj.mat[1][i]==INF?-1:adj.mat[1][i])&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC410E题解</title>
    <url>/posts/7d01b1ce/</url>
    <content><![CDATA[可能更洛谷的体验
有一个 O(n3)O(n^3)O(n3) 的 DP 是很显然的，就是设 f(i,j,k,0/1)f(i,j,k,0/1)f(i,j,k,0/1) 表示第 iii 只怪兽，用了 jjj 的体力，用了 kkk 的魔力，当前打怪兽用不用魔力的最大打怪兽数量，这显然不能通过。
我们考虑什么状态中信息是有用的。首先，既然我们是一个一个按顺序打的怪物，遇到每一个怪兽我们肯定都要打。那么实际上我们根本就不用存储打怪兽的数量，只需要存储当前魔力或体力的信息，通过这个我们来判断是否到现在能够打怪兽。
那么，我们只需要把体力或魔力任一维度丢到我们 DP 求解的答案即可，因为这里我们有一个是否使用魔力的状态决策，我们考虑把魔力丢进去。
设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示第 iii 只怪兽，用了 jjj 的体力，当前打怪兽用不用魔力的最小魔力使用。转移方程是显然的：
f(i,j,0)=min⁡{f(i−1,j+ai,0),f(i−1,j+ai,1)}f(i,j,1)=min⁡{f(i−1,j,0),f(i−1,j,1)}+bi\begin{aligned}
f(i,j,0) &amp; = \min \left\{ f(i-1,j+a_{i},0),f(i-1,j+a_{i},1) \right\} \\

f(i,j,1) &amp; = \min \left\{ f(i-1,j,0),f(i-1,j,1) \right\} +b_{i}

\end{aligned}
f(i,j,0)f(i,j,1)​=min{f(i−1,j+ai​,0),f(i−1,j+ai​,1)}=min{f(i−1,j,0),f(i−1,j,1)}+bi​​
答案统计即求最大的 iii 使得 min⁡j=1h{f(i,j,0),f(i,j,1)}≤M\min\limits_{j=1}^{h} \left\{ f(i,j,0),f(i,j,1) \right\}\le Mj=1minh​{f(i,j,0),f(i,j,1)}≤M。
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3520;int f[MN][MN][2],n,h,m,a[MN],b[MN];signed main()&#123;    cin&gt;&gt;n&gt;&gt;h&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i]&gt;&gt;b[i];    &#125;    memset(f,0x3f,sizeof(f));    for(int i=0;i&lt;=h;i++)&#123;        f[0][i][0]=f[0][i][1]=0;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=0;j+a[i]&lt;=h;j++)&#123;            f[i][j][0]=min(f[i-1][j+a[i]][0],f[i-1][j+a[i]][1]);        &#125;        for(int j=0;j&lt;=h;j++)             f[i][j][1]=min(f[i-1][j][0],f[i-1][j][1])+b[i];    &#125;    bool flag=0;    for(int i=n;i&gt;=1;i--)&#123;        int ans=0x3f3f3f3f3f3f3f3f;        for(int j=0;j&lt;=h;j++)&#123;            ans=min(&#123;ans,f[i][j][0],f[i][j][1]&#125;);        &#125;        if(ans&lt;=m)&#123;            flag=1;            cout&lt;&lt;i;            break;        &#125;    &#125;    if(!flag) cout&lt;&lt;0;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC422题解A-F</title>
    <url>/posts/4b51acd/</url>
    <content><![CDATA[省流：20:50~22:00 短时场
 A
暴力模拟即可
 B
每个点暴力判断即可，写挂了 1 次
 C
没脑子写二分，有脑子猜结论，上界显然是 min⁡{na,nb}\min\{n_{a},n_{b}\}min{na​,nb​}，下界不太好，因为下界和这个能够分配的数量有关，设数量为 xxx，那么显然答案必定为 na−x+nb+nc−x≥xn_{a}-x+n_{b}+n_{c}-x\ge xna​−x+nb​+nc​−x≥x，那么显然 na+nb+nc−2x≥xn_{a}+n_{b}+n_{c}-2x\ge xna​+nb​+nc​−2x≥x。显然有 x≥nA+nB+nC3x\ge \dfrac{n_{A}+n_{B}+n_{C}}{3}x≥3nA​+nB​+nC​​。上下界有了知道咋做了吧。
 D
你猜为什么给你 2n2^n2n？
你倒着操作，每次操作肯定是 2n2=2n−1\dfrac{2^n}{2}=2^{n-1}22n​=2n−1 啊，这些部分相当于子问题分治的结构，再翻译一下就是完全二叉树的结构，根节点点权为 kkk，你要在遍历每一层的时候通过合理均分当前点点权到两个孩子，使得分配到两个孩子的权值之间差值最小，什么时候最小？直接除二平均分不就做完了，时间复杂度 O(n)O(n)O(n)。因为我是唐我写了个 O(n2n)O(n 2^n)O(n2n) 判断不平衡度。
 E
要求 &gt;⌊n2⌋&gt; \lfloor \dfrac{n}{2} \rfloor&gt;⌊2n​⌋？而且题目没说无解？
直接随机化，每次取 2 个点求直线即可，时间复杂度 O(能过)O(\text{能过})O(能过)。
 F
Dijkstra 能解决的好吧，但是论文级别。动态权这玩意除非你学过论文级别的东西否则这玩意是没法做的。
注意到时间复杂度是宽裕的 O(nm)O(nm)O(nm)，同时注意到我们可以通过拆分法将路径点权贡献拆分到每个点上，这些点的贡献只和当前路径长度有关。也就是说我们可以考虑 DP 求解，设 f(i,j)f(i,j)f(i,j) 表示目前到 iii 点路径长度为 jjj 的最小花费，枚举每一个点和路径长度求解即可，时间复杂度 O(n2+nm)O(n^2+nm)O(n2+nm)。
其实有更好的性质就是每一个点不会经过两次，所以这个图必定是一个 DAG，DAG上 DP 即可，时间复杂度 O(n+m)O(n+m)O(n+m)。
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机的进阶应用</title>
    <url>/posts/6074ec1/</url>
    <content><![CDATA[ 0. 前言
你需要知道的芝士：

AC 自动机基础；
Trie 树；

这里是进阶使用，所以会结合一些例题来讲解，读者应有 AC 自动机的基础芝士即可。
 1. 自动机与 AC 自动机本质
考虑到大多数都是先学 AC 自动机，而很久以后才学自动机，这里有必要先给出概念，这样才能更好的理解后面的芝士。
 1.1 自动机
自动机，在 OI 中一般我们涉及的是有限状态自动机，它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以通过输入自动机，让自动机切换到其他的状态。任意时刻状态机只能处在一个状态。
而有限状态机可以表示为一个有向图：

从图中看出来一个信息学竞赛一共包含 5 个状态：学信竟，学 whk，吃吃饭，睡睡觉，摸摸鱼。每种带有箭头的连线，表示可以从当前状态切换到其他的状态，以及切换的条件。
我们列个表格：




学信竟
学 whk
吃吃饭
睡睡觉
摸摸鱼




学信竟


去机房

摆烂时间到


学 whk
信竟时间到


回去午睡



吃吃饭
去食堂
去教室





睡睡觉

回教室
被吵醒




摸摸鱼



回家




表格中左侧第一列为当前状态。
表格中上方第一行为切换的下一个状态。
表格中每行从左到右为状态切换的条件(状态 A 能不能切换到状态B)。
举例：

学 whk -&gt; 学信竟：条件（信竟时间到）。
学信竟 -&gt; 摸摸鱼：条件（摸鱼时间到）。
摸摸鱼 -&gt; 睡睡觉：条件（回家）。

几个概念：

状态：当前所处的状态，在当前状态下可以有不同的行为和属性。
转移：状态变更，满足条件是从一个状态转移到另一个状态。
动作：表示在给定时刻进行的活动。
条件：触发一个事件、当一个条件满足触发状态转移切换到另一个状态。

一个自动机，我们应当还有起始状态，在本图中我们的起始状态是 “睡睡觉”。（不准通宵！）
那为啥叫自动呢，是因为只要输入符号和转移规则确定，状态变化是自动的，自动机可以自己通过设定好的路线（即有向图的边权）来进行转移。
而自动机的实质就是：状态集合（点） + 转移规则（边）。
在竞赛中的应用我们有 AC 自动机，后缀自动机，DP 套 DP等。
 1.2 Trie 与 AC 自动机
那我们上面提到了自动机，那么，信竟中有哪些我们值得举例的呢？
例如字典树，我们看看字典树的形状，我们借用 OI-Wiki 的图：

那我们回看上面的自动机表示图，你会发现两者十分相似，我们模拟一下 Trie 的过程。
我们把自动机丢在 1 号点，让自动机读入字符串。起始状态在 1 号点，让后我们输入一个字符 a，就转移到 2 号点，让后输入一个字符 b，转移到 6 号点，让后输入一个字符 a，转移到 11 号点。
那么实际上，字典树其实就是一个自动机，通过接受指定字符串集合中的元素来转移，而转移的时候就是利用 Trie 图上的边来进行转移。
而 AC 自动机，是 Trie+Fail 指针，本质上是 Trie 上的自动机。
Trie 不用说我们上面已经提到过了，那么既然 AC 自动机叫自动机，那么 Trie+Fail 这一甜蜜组合一定也能构成自动机吧？其实是的，Fail 指针实际上就是在 Trie 的有向转移图上进行拓展。在单模式匹配中，失败时需要回溯文本指针；而 AC 自动机通过失配指针自动匹配状态，让 Trie 进化为一条永通路，以便避免文本串匹配时一个模式串到结尾了没有地方可走的尴尬。
严格来说，AC自动机是一个带有失败转移的确定性有限状态自动机（DFA），在经典的 Trie 上我们增加了失败状态的优化处理机制。而我们引入失配指针，是为了最小化状态数（避免为所有可能的失败情况显式建边），同时保持高效匹配。而AC自动机的 “自动” 正体现在其能根据预定义的转移规则（包括正常转移和失败转移），无需人工干预地完成多模式匹配。
 2. AC 自动机上 DP
 2.1 状态设计
我们上面讲自动机当然不是摆烂的，我们需要结合芝士进行讲解。
众所周知，AC 自动机上的 DP，一般来说都是这么设计状态 f(i,j)f(i,j)f(i,j)，表示长度为 iii 的字符串在 AC 自动机上匹配到 jjj 节点。但是我们为什么这个设计？
动态规划通过将问题分解为子问题，并存储子问题的解（状态）来避免重复计算。关键在于：

状态定义；
状态转移；
边界确定；

而 AC 自动机上 DP，本质就是自动机上的 DP，其本质就是：将问题的约束条件建模为一个自动机，在 DP 状态中增加自动机的状态维度，通过在自动机上逐层推进的转移规则指导 DP 的决策。因为自动机的状态是唯一确定的，通过 AC 自动机的有向转移图，我们就可以方便的进行状态转移，并进行答案统计。
通常来说，自动机上的 DP 我们需要自动机的状态，一般来说为 f(i,S)f(i,S)f(i,S)，其中 iii 是一个确定的顺序，而 SSS 代表自动机的状态。对应到 AC 自动机上，AC 自动机的状态是一个节点，所以我们定义 f(i,j)f(i,j)f(i,j)，表示长度为 iii 的字符串在 AC 自动机上匹配到 jjj 节点。
还是来看例题吧：
 2.2 例题
 USACO12JAN] Video Game G
对输入的模板串建 AC 自动机，设 f(i,j)f(i,j)f(i,j) 表示前 iii 个字符，最后一个跑到了 AC 自动机 jjj 号点的最大答案，我们只需要枚举对于每一个 f(i,j)f(i,j)f(i,j) 下一个是字符是什么，题目中是 A，B，C。转移到下一个节点，让后跳 Fail 指针求答案，对于匹配到一个长度为 kkk 的模板串，有 f(i,son[j][k])=max⁡(f(i−1,j)+end[son[j][k]]f(i,son[j][k]) = \max(f(i-1,j)+end[son[j][k]]f(i,son[j][k])=max(f(i−1,j)+end[son[j][k]]。直接做就可以了。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e4+15;int n,K,f[MN][520];struct ACAuto&#123;    int t[MN][3],fail[MN],end[MN],tot;    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;A&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[p]++;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;3;i++)&#123;            if(t[0][i]) q.push(t[0][i]);        &#125;          while(!q.empty())&#123;            int u=q.front();            q.pop();            for(int i=0;i&lt;3;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;            end[u]+=end[fail[u]];        &#125;    &#125;&#125;t;signed main()&#123;    cin&gt;&gt;n&gt;&gt;K;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        t.insert(s);    &#125;    t.build();    memset(f,-0x3f,sizeof(f));    for(int i=0;i&lt;=K;i++) f[i][0]=0;    for(int i=1;i&lt;=K;i++)&#123;        for(int j=0;j&lt;=t.tot;j++)&#123;            for(int k=0;k&lt;3;k++)&#123;                f[i][t.t[j][k]]=max(f[i][t.t[j][k]],f[i-1][j]+t.end[t.t[j][k]]);            &#125;        &#125;    &#125;    int ans=-0x3f3f3f3f;    for(int i=0;i&lt;=t.tot;i++) ans=max(ans,f[K][i]);    cout&lt;&lt;ans;    return 0;&#125;
 JSOI2007 文本生成器
本部分是反向的计算 DP。
状态还是我们上面所说的，f(i,j)f(i,j)f(i,j)，表示长度为 iii 的字符串在 AC 自动机上匹配到 jjj 节点。但是题目中还有一个限制：“包含至少一个”，考虑容斥，答案就是整体减去一个模式串都不包含的文本串数。整体是 26m26^m26m，问题转化为求解第二部分。
文本串中不能出现模式串，所以我们要在一个字符串的末尾打标记 enduend_{u}endu​，同时如果一个字符串的后缀也是模式串，那么它也不能出现在文本串中，所以我们要让 endu=endfail[u]end_{u}=end_{fail[u]}endu​=endfail[u]​。
那么转移方程就是避开模式串进行转移：
void dodp()&#123;    f[0][0]=1;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;=tot;j++)&#123;            for(int k=0;k&lt;26;k++)&#123;                if(!end[ch[j][k]])&#123;                    f[i+1][ch[j][k]]=(f[i+1][ch[j][k]]+f[i][j])%MOD;                &#125;            &#125;        &#125;    &#125;&#125;
那么第二部分答案就是 ∑i=1cntf(m,i)\sum\limits_{i=1}^{cnt} f(m,i)i=1∑cnt​f(m,i)，其中 cntcntcnt 表示 AC 自动机的点数，那么答案就是：
26m−∑i=1cntf(m,i)(mod10007)26^m - \sum\limits_{i=1}^{cnt} f(m,i) \pmod{10007}
26m−i=1∑cnt​f(m,i)(mod10007)
直接写：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MOD=1e4+7,MN=120,MK=1e5;int n,m,f[MN][MK];template&lt;typename type&gt;inline void read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();    flag?x=-x:0;&#125;inline string stread()&#123;    char ch = getchar();    string st1 = &quot;&quot;;    while (!((ch &gt;= &#x27;A&#x27;) &amp;&amp; (ch &lt;= &#x27;Z&#x27;)))        ch = getchar();    while ((ch &gt;= &#x27;A&#x27;) &amp;&amp; (ch &lt;= &#x27;Z&#x27;))        st1 += ch, ch = getchar();    return st1;&#125;struct Acauto&#123;    int ch[MK][26],tot,fail[MK],end[MK];    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            if(!ch[p][c-&#x27;A&#x27;]) ch[p][c-&#x27;A&#x27;]=++tot;            p=ch[p][c-&#x27;A&#x27;];        &#125;        end[p]=1;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            if(ch[0][i]) q.push(ch[0][i]);        &#125;        while(!q.empty())&#123;            int f=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                if(ch[f][i])&#123;                     fail[ch[f][i]]=ch[fail[f]][i];                    q.push(ch[f][i]);                    end[ch[f][i]]|=end[fail[ch[f][i]]];                &#125;                else ch[f][i]=ch[fail[f]][i];            &#125;        &#125;    &#125;    void dodp()&#123;        f[0][0]=1;        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;=tot;j++)&#123;                for(int k=0;k&lt;26;k++)&#123;                    if(!end[ch[j][k]])&#123;                        f[i+1][ch[j][k]]=(f[i+1][ch[j][k]]+f[i][j])%MOD;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;ac;int qpow(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=(ret*a)%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;int main()&#123;    read(n);    read(m);    for(int i=1;i&lt;=n;i++)&#123;        string s;        s=stread();        ac.insert(s);    &#125;    ac.build();    ac.dodp();    int ans=qpow(26,m);    for(int i=0;i&lt;=ac.tot;i++)&#123;        ans=(ans-f[m][i]+MOD)%MOD;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 SDOI2014 数数
自动机上 DP 可以与许多不同类型的 DP 结合，因为实质上自动机上 DP 利用的是自动机的转移顺序，所以很灵活可以与许多类型的 DP 结合，这里是数位 DP。
注意到本题就是不让特定的模式数串出现，考虑到一个集合有许多模式数串，考虑 AC 自动机，因为自动机上的 DP 我们是必须要知道自动机跑到哪里了，有一个维度必须设计 SSS 表示 AC 自动机上的节点（即自动机状态）。本题在数位 DP 只需要关心自动机状态即可，考虑设 f[pos][st]f[pos][st]f[pos][st] 表示现在从最高位填到第 pospospos 位，当前 AC 自动机状态节点在 ststst。通过记忆化搜索是很容易实现的，注意一下前导零也是算模式串里面的，注意实现细节。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1520,MOD=1e9+7;int m,a[MN],tot,f[MN][MN];string n;struct ACAuto&#123;    int t[MN][12],tot,fail[MN],end[MN];    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;0&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[p]=1;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;10;i++)&#123;            if(t[0][i]) q.push(t[0][i]);        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();                        for(int i=0;i&lt;10;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;            end[u]|=end[fail[u]];        &#125;    &#125;&#125;t;int dfs(int pos,bool lim,bool lead,int st)&#123;    if(t.end[st]) return 0;    if(!pos) return !lead;    if(!lim&amp;&amp;!lead&amp;&amp;~f[pos][st]) return f[pos][st];    int up=lim?a[pos]:9;    int ret=0;    for(int i=0;i&lt;=up;i++)&#123;        ret=(ret+dfs(pos-1,lim&amp;&amp;i==up,(lead&amp;&amp;!i),(lead&amp;&amp;!i)?0:t.t[st][i]))%MOD;    &#125;    if(!lim&amp;&amp;!lead) f[pos][st]=ret;    return ret;&#125;int solve()&#123;    memset(f,-1,sizeof(f));    tot=0;    for(auto c:n)&#123;        a[++tot]=(int)(c-&#x27;0&#x27;);    &#125;    reverse(a+1,a+1+tot);    return dfs(tot,1,1,0);&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        string s;        cin&gt;&gt;s;        t.insert(s);    &#125;    t.build();    cout&lt;&lt;solve();    return 0;&#125;
 CF696D Legen
有的时候，转移过程过大，但是通过借助 AC 自动机状态数有的时候较小，我们可以通过矩阵快速幂来优化 DP 这一过程。
顺便推销自己优质文章：矩阵快速幂优化DP。
有显然的转移，和第一道例题差不太多。设 f(i,j)f(i,j)f(i,j) 表示前 iii 个字符，最后一个跑到了 AC 自动机 jjj 号点的最大答案，有显然的转移方程：
f(i+1,j′)=max⁡(f(i,j)+end[j′])f(i+1,j&#x27;)=\max(f(i,j)+end[j&#x27;])
f(i+1,j′)=max(f(i,j)+end[j′])
其中 j′j&#x27;j′ 为当前状态 jjj 转移后的节点，而 end[j′]end[j&#x27;]end[j′] 表示自动机在节点 j′j&#x27;j′ 上有多少模式串以该节点为结尾的数量。
但是问题在于 lll 太大啦！怎么办？观察数据范围，注意到 n≤200,∑∣Si∣≤200n\le 200,\sum\limits |S_{i}|\le 200n≤200,∑∣Si​∣≤200，也就是说一个模式串的长度是很小的，也就是说 AC 自动机转移的状态数是很小的，但是转移过程是巨大不可接受的，浓烈的矩阵优化味道，考虑矩阵快速幂优化。我们可以把转移图当作在有向图上进行转移，我们把 AC 自动机的图当作邻接矩阵存起来，让后利用广义矩阵乘法矩阵快速幂，接着再给初始状态以其他状态作为结束状态的权值和取个最大值即可。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=201,INF=1e9;int n,L,a[MN],ret;struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=-1e9)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                mat[i][j]=-INF;            &#125;        &#125;        for(int i=0;i&lt;MN;i++)&#123;            mat[i][i]=x;        &#125;    &#125;    Matrix operator *(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]=max(ret.mat[i][j],mat[i][k]+x.mat[k][j]);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;G;struct ACAuto&#123;    int t[MN][26],tot,fail[MN],end[MN];    void insert(string s,int val)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[p]+=val;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            if(t[0][i]) q.push(t[0][i]);        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;            end[u]+=end[fail[u]];        &#125;        for(int i=0;i&lt;=tot;i++)&#123;            for(int j=0;j&lt;26;j++)&#123;                G.mat[i][t[i][j]]=end[t[i][j]];            &#125;        &#125;    &#125;&#125;t;Matrix ksm(Matrix a,int b)&#123;    Matrix ret(0);    while(b)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;L;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        t.insert(s,a[i]);      &#125;    t.build();    Matrix QwQ=ksm(G,L);    for(int i=0;i&lt;=t.tot;i++)&#123;        ret=max(ret,QwQ.mat[0][i]);    &#125;    cout&lt;&lt;ret;    return 0;&#125;
 UVA1401 Remeber the Word
来点不一样的，Trie 上 DP，别忘了 Trie 也是一个自动机！
设 f(i)f(i)f(i) 表示 i→leni \to leni→len 有多少种表示方法，转移如下：
f(i)=∑f(j+1)si∈[i+1,j] 可以由多个字典拼成\begin{aligned}f(i) &amp; = \sum\limits f(j+1) &amp;  s _{i}\in [i+1,j]\text{ 可以由多个字典拼成} \end{aligned}
f(i)​=∑f(j+1)​si​∈[i+1,j] 可以由多个字典拼成​
利用字典树就可以快速判断，DP 结果为 f(0)f(0)f(0)。
 HNOI2004 L语言
本题目是状压 DP 的运用用于优化 DP 过程中跳 Fail 的复杂度。
有一个显然的思路就是建 AC 自动机，让后在子殴打凝固剂上对于所有 fail 指针的子串，让后取最大值得到答案，但是这样的复杂度不是线性因为要跳 fail。
根据题目特殊性质，所有单词长度只有 202020？不难考虑到状压，但是我们要状压什么？我们的时间瓶颈在于跳 fail 这一步，我们不妨将其优化到 O(1)O(1)O(1)！
我们可以将前 202020 位字母所有可能的字串长度存下来，并压缩到状态中，并存于每个字节点中。
那么我们插入和建 fail 可以这么写：
void insert(string s,int id)&#123;    int p=0;    for(auto c:s)&#123;        int k=c-&#x27;a&#x27;;        if(!t[p][k]) t[p][k]=++tot;        p=t[p][k];    &#125;    end[p]=id;&#125;void build()&#123;    queue&lt;int&gt; q;    for(int i=0;i&lt;26;i++)&#123;        if(t[0][i])&#123;            q.push(t[0][i]);            dep[t[0][i]]=1;        &#125;    &#125;    while(!q.empty())&#123;        int u=q.front();        q.pop();        st[u]=st[fail[u]];        if(end[u])&#123;            st[u]|=1&lt;&lt;(dep[u]);        &#125;        for(int i=0;i&lt;26;i++)&#123;            int v=t[u][i];            if(v)&#123;                fail[v]=t[fail[u]][i];                dep[v]=dep[u]+1;                q.push(v);            &#125;else t[u][i]=t[fail[u]][i];        &#125;    &#125;&#125;
而查询我们这么写：
int query(string s)&#123;    int p=0,mx=0;    unsigned now=1;    for(int i=0;i&lt;s.length();i++)&#123;        int k=s[i]-&#x27;a&#x27;;        p=t[p][k];        now&lt;&lt;=1;        if(st[p]&amp;now) now|=1,mx=i+1; // 若与不为 0 那么长度集交集非空，那就是有匹配串。    &#125;    return mx;&#125;
代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e6+15;int n,m;struct ACAuto&#123;    int t[MN][26],tot,end[MN],dep[MN],fail[MN],st[MN];    void insert(string s,int id)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[p]=id;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            if(t[0][i])&#123;                q.push(t[0][i]);                dep[t[0][i]]=1;            &#125;        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();            st[u]=st[fail[u]];            if(end[u])&#123;                st[u]|=1&lt;&lt;(dep[u]);            &#125;            for(int i=0;i&lt;26;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    dep[v]=dep[u]+1;                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;        &#125;    &#125;    int query(string s)&#123;        int p=0,mx=0;        unsigned now=1;        for(int i=0;i&lt;s.length();i++)&#123;            int k=s[i]-&#x27;a&#x27;;            p=t[p][k];            now&lt;&lt;=1;            if(st[p]&amp;now) now|=1,mx=i+1;        &#125;        return mx;    &#125;&#125;t;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;int main()&#123;    read(n,m);    for(int i=1;i&lt;=n;i++)&#123;        string s;        read(s);        t.insert(s,i);    &#125;    t.build();    for(int i=1;i&lt;=m;i++)&#123;        string s;        read(s);        put(t.query(s));    &#125;    return 0;&#125;
 3. Fail 树
有的时候，我们的复杂度瓶颈就在于跳 Fail 这一步。
思考一下 AC 自动机的匹配过程：从第一个字符开始，每到达一个节点 xxx，就从 xxx 开始不断跳 fail 到根。期间跳到的节点代表的串都在文本串中出现。
既然我们可以从文本串每一位向上跳 fail 找模式串结尾节点，那么，我们可以倒过来！我们从结尾节点逆着找 fail 找文本串节点！
那么，从结尾节点开始逆着跳 fail，期间跳到的文本串节点个数就是这个模式串在文本串中出现的次数。
而 Fail 树，就是 AC 自动机建立好之后，只留下反向的 Fail 指针作为边，就得到的 Fail 树：

而这颗树是在一个 Trie 的基础上产生的，所以这棵树上的每个点都是一个字符串的前缀，而且每个字符串的每个前缀在这棵树上都对应着一个点。其次，由于 fail 指针，每个点父节点的字符串都是这个点字符串的后缀，并且树上没有更长的它的后缀。也就是说，对于字符串 sss，在 Fail 树上的祖先就是 sss 的所有子串。
这是一个 Trick：一个串对应终止节点在 fail 树上到根的这段路径就是他的所有子串。我们后面会提到的。
而对于任意两个节点，它们在 Fail 树上的 LCA 就是它们所共同拥有的子串。
那么怎么优化跳 Fail 呢？只需要将每个属于文本串的终止节点权值设置为 111，那么节点 xxx 的子树总权值就是 xxx 代表的串在文本串中出现的次数。
那怎么快速求呢？这里有一个 Trick：子树的 DFN 序是连续的一个区间。那么我们就可以通过 DFS 序加树状数组来进行实现，接下来我们来看例题：
 P2414 [NOI2011] 阿狸的打字机
首先一个很 native 的想法就是把所有串拿出来建 AC 自动机，让后暴力跳 fail 找 xxx 串的末尾，但是这样时间复杂度是飞起的。
但是，我们在跳 fail 啊，我们是不是可以用上面的思路来求解呢？每次查询从 yyy 串向上跳到 xxx 终止节点，而反过来就是往子树跳能达到多少个 yyy 串的节点，这不就是我们上面所说的吗！我们每次把 yyy 这个串插入树状数组的时候，只需要对 yyy 所在子树 +1+1+1 即可，对应到 DFN 上就是区间加。这不就是树状数组加差分吗！对于结束的位置打 −1-1−1，其余打 111。让后就做完了，代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=8e5+15;struct Query&#123; int x,y,id; &#125; qry[MN];int n, siz[MN], dfn[MN], ans[MN],stk[MN], dtot;string st;vector&lt;int&gt; ft[MN];struct BIT &#123;    int t[MN];    int lowbit(int x) &#123; return x&amp;-x; &#125;    int query(int x) &#123;        int ret=0;        while(x&gt;0) ret+=t[x], x-=lowbit(x);        return ret;    &#125;    void update(int x, int k) &#123;        while(x&lt;MN) t[x]+=k, x+=lowbit(x);    &#125;&#125; bit;namespace ACAuto &#123;    struct Node &#123; int ch[26], fail; &#125; t[MN];    int tot, g_top, ctot, cut[MN], sta[MN];    void buildAC(string str) &#123;        int p = 0;        g_top = 0;        for (int i=0; i&lt;str.length(); i++) &#123;            if (str[i]&gt;=&#x27;a&#x27; &amp;&amp; str[i]&lt;=&#x27;z&#x27;) &#123;                int ch = str[i]-&#x27;a&#x27;;                if (!t[p].ch[ch]) t[p].ch[ch] = ++tot;                p = t[p].ch[ch];                sta[++g_top] = p;            &#125; else if (str[i]==&#x27;B&#x27;) &#123;                p = sta[--g_top];            &#125; else &#123;                cut[++ctot] = p;            &#125;        &#125;    &#125;    void build() &#123;        queue&lt;int&gt; q;        for (int i=0; i&lt;26; i++) &#123;            if (t[0].ch[i]) &#123;                q.push(t[0].ch[i]);                ft[0].push_back(t[0].ch[i]);            &#125;        &#125;        while (!q.empty()) &#123;            int f = q.front(); q.pop();            for (int i=0; i&lt;26; i++) &#123;                int &amp;v = t[f].ch[i];                if (v) &#123;                    t[v].fail = t[t[f].fail].ch[i];                    ft[t[v].fail].push_back(v);                    q.push(v);                &#125; else &#123;                    v = t[t[f].fail].ch[i];                &#125;            &#125;        &#125;    &#125;&#125;using namespace ACAuto;bool cmp(Query x, Query y) &#123;    return x.y != y.y ? x.y &lt; y.y : x.id &lt; y.id;&#125;void dfs(int u) &#123;    dfn[u] = ++dtot;    siz[u] = 1;    for (int v : ft[u]) &#123;        dfs(v);        siz[u] += siz[v];    &#125;&#125;int main() &#123;    cin &gt;&gt; st;    cin &gt;&gt; n;    for (int i=1; i&lt;=n; i++) &#123;        cin &gt;&gt; qry[i].x &gt;&gt; qry[i].y;        qry[i].id = i;    &#125;    sort(qry+1, qry+n+1, cmp);    buildAC(st);    build();    dfs(0);    for (int i=1, p=0, top=0, pt=0, up=0; i&lt;=n; i++) &#123;        while (up &lt; qry[i].y) &#123;            if (st[pt]&gt;=&#x27;a&#x27; &amp;&amp; st[pt]&lt;=&#x27;z&#x27;) &#123;                int ch = st[pt]-&#x27;a&#x27;;                p = t[p].ch[ch];                stk[++top] = p;                bit.update(dfn[p], 1);            &#125; else if (st[pt]==&#x27;B&#x27;) &#123;                bit.update(dfn[p], -1);                p = stk[--top];            &#125; else &#123;                up++;            &#125;            pt++;        &#125;        int node = cut[qry[i].x];        ans[qry[i].id]=bit.query(dfn[node]+siz[node]-1)- bit.query(dfn[node]-1);    &#125;    for (int i=1; i&lt;=n; i++) cout &lt;&lt; ans[i] &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
 CF1437G
用到上面我们的 Trick：一个串对应终止节点在 fail 树上到根的这段路径就是他的所有子串。
那么现在问题转化为单点修改和在 Fail 树上一条链查询权值的最大值，对 Fail 树上进行树链剖分即可，代码如下：
但是有重复串，要用 Multiset 维护每个节点的最大权值。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e5+1145;int n,m,pval[MN];vector&lt;int&gt; adj[MN];multiset&lt;int&gt; val[MN];struct ACAuto&#123;    int t[MN][26],tot,fail[MN],end[MN];    void insert(string s,int x)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[x]=p;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            if(t[0][i]) q.push(t[0][i]);        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;        &#125;        for(int i=1;i&lt;=tot;i++)&#123;            adj[fail[i]].push_back(i);         &#125;    &#125;&#125;ac;struct Segment&#123;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,val;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].val=max(t[ls].val,t[rs].val);    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r)&#123;            t[p].val=-1;            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void modify(int p,int pos,int k)&#123;        if(t[p].l==t[p].r)&#123;            t[p].val=k;            return;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) modify(ls,pos,k);        else modify(rs,pos,k);        pushup(p);    &#125;    int query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        int ret=-1;        if(mid&gt;=fl) ret=max(ret,query(ls,fl,fr));        if(mid&lt;fr) ret=max(ret,query(rs,fl,fr));        return ret;    &#125;#undef ls #undef rs&#125;sg;namespace Tree&#123;    int id[MN],dtot,siz[MN],dep[MN],fa[MN],hson[MN],htop[MN];    void dfs1(int u,int pre)&#123;        dep[u]=dep[pre]+1;        siz[u]=1;        fa[u]=pre;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs1(v,u);            siz[u]+=siz[v];            if(!hson[u]||siz[hson[u]]&lt;siz[v]) hson[u]=v;        &#125;    &#125;    void dfs2(int u,int top)&#123;        htop[u]=top;        id[u]=++dtot;        if(!hson[u]) return;        dfs2(hson[u],top);        for(auto v:adj[u])&#123;            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;    int querychain(int x,int y)&#123;        int ret=-1;        while(htop[x]!=htop[y])&#123;            if(dep[htop[x]]&lt;dep[htop[y]]) swap(x,y);            ret=max(ret,sg.query(1,id[htop[x]],id[x]));            x=fa[htop[x]];        &#125;        if(dep[x]&gt;dep[y]) swap(x,y);        ret=max(ret,sg.query(1,id[x],id[y]));        return ret;    &#125;&#125;using namespace Tree;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        ac.insert(s,i);    &#125;    ac.build();    sg.build(1,1,MN-1);    dfs1(0,0);    dfs2(0,0);    for(int i=1;i&lt;=n;i++)&#123;        sg.modify(1,id[ac.end[i]],0);        pval[i]=0;         val[ac.end[i]].insert(0);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int op;        cin&gt;&gt;op;        if(op==1)&#123;            int x,y;            cin&gt;&gt;x&gt;&gt;y;            val[ac.end[x]].erase(val[ac.end[x]].find(pval[x]));            pval[x]=y;            val[ac.end[x]].insert(pval[x]);            sg.modify(1,id[ac.end[x]],*prev(val[ac.end[x]].end()));        &#125;else&#123;            string s;            cin&gt;&gt;s;            int p=0,ret=-1;            for(auto c:s)&#123;                int k=c-&#x27;a&#x27;;                p=ac.t[p][k];                ret=max(ret,querychain(0,p));            &#125;            cout&lt;&lt;ret&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 P5840 Divljak
首先先建出来 AC 自动机。搞出来 Fail 树。
我们暴力的思路就跳 Fail，将经过的路径的权值都加上 1，让后查询特定的终止节点被访问了多少次即可。那么怎么搬到 Fail 树上呢？我们利用树上差分的思想，首先把将要插入的字符串 PPP 统计在 Trie 中走过的节点，再按照 DFN 排序，每相邻节点在树上位置加 1，表示多一个串匹配上，但是它们的 LCA 及其祖先显然多加了一次，减去 1 即可。自此，我们可以通过树链剖分加树状数组维护即可：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e6+15;int n,q,a[MN];vector&lt;int&gt; adj[MN];struct BIT&#123;    int t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void modify(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;&#125;bit;struct ACAuto&#123;    int t[MN][26],tot=1,fail[MN],end[MN];    void insert(string s,int id)&#123;        int p=1;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[id]=p;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            t[0][i]=1;        &#125;        q.push(1);        while(!q.empty())&#123;            int u=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;        &#125;    &#125;&#125;t;namespace Tree&#123;    int dfn[MN],dfntot,fa[MN],dep[MN],siz[MN],hson[MN],htop[MN];    void dfs1(int u,int pre)&#123;        siz[u]=1;        fa[u]=pre;        dep[u]=dep[pre]+1;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs1(v,u);            siz[u]+=siz[v];            if(siz[hson[u]]&lt;siz[v]) hson[u]=v;        &#125;    &#125;    void dfs2(int u,int top)&#123;        htop[u]=top;        dfn[u]=++dfntot;        if(!hson[u]) return;        dfs2(hson[u],top);        for(auto v:adj[u])&#123;            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;    int lca(int x,int y)&#123;        while(htop[x]!=htop[y])&#123;            if(dep[htop[x]]&lt;dep[htop[y]])&#123;                swap(x,y);            &#125;            x=fa[htop[x]];        &#125;        return dep[x]&lt;dep[y]?x:y;    &#125;&#125;using namespace Tree;bool cmp(int x,int y)&#123;    return dfn[x]&lt;dfn[y];&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        t.insert(s,i);    &#125;    t.build();    for(int i=2;i&lt;=t.tot;i++)&#123;        adj[t.fail[i]].push_back(i);    &#125;    dfs1(1,0);    dfs2(1,1);    cin&gt;&gt;q;    while(q--)&#123;        int op,x;        string p;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;p;            int len=p.length(),u=1;            p=&quot; &quot;+p;            for(int i=1;i&lt;=len;i++)&#123;                int v=p[i]-&#x27;a&#x27;;                u=t.t[u][v];                a[i]=u;            &#125;            sort(a+1,a+1+len,cmp);            for(int i=1;i&lt;=len;i++)&#123;                bit.modify(dfn[a[i]],1);            &#125;            for(int i=1;i&lt;len;i++)&#123;                bit.modify(dfn[lca(a[i],a[i+1])],-1);            &#125;        &#125;else&#123;            cin&gt;&gt;x;            int p=t.end[x];            cout&lt;&lt;bit.query(dfn[p]+siz[p]-1)-bit.query(dfn[p]-1)&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 P2444 POI 2000病毒
本题即构造一个可行的无限长文本串，使没有任何子串为给出模式串中的一个。
那么，实际上就是我们永远都不会跳到某个病毒代码的终止节点，我们会一直在自动机上跑啊跑，也就是说，若能构造文本串，当且仅当自动机有成环，并且走到环的路径及其环内没有终止节点，DFS 判断即可：
等会这个和 Fail 树有啥关系？其实还是要理解跳 Fail 的本质是在干什么。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e4+15;int n;bool vis[MN],inst[MN];namespace ACAuto&#123;    struct Node&#123;        int ch[2];        int end,fail;    &#125;t[MN];    int tot;    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            int cp=c-48;            if(!t[p].ch[cp]) t[p].ch[cp]=++tot;            p=t[p].ch[cp];        &#125;        t[p].end=1;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;=1;i++)&#123;            if(t[0].ch[i]) q.push(t[0].ch[i]);        &#125;        while(!q.empty())&#123;            int f=q.front();            q.pop();            for(int i=0;i&lt;=1;i++)&#123;                int v=t[f].ch[i];                if(v)&#123;                    t[v].fail=t[t[f].fail].ch[i];                    t[v].end|=t[t[t[f].fail].ch[i]].end;                    q.push(v);                &#125;else t[f].ch[i]=t[t[f].fail].ch[i];            &#125;        &#125;    &#125;&#125;using namespace ACAuto;void dfs(int u)&#123;    if(inst[u])&#123;        cout&lt;&lt;&quot;TAK&quot;;        exit(0);    &#125;    if(vis[u]||t[u].end) return;    inst[u]=vis[u]=1;    dfs(t[u].ch[0]);    dfs(t[u].ch[1]);    inst[u]=0;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        string st;        cin&gt;&gt;st;        insert(st);    &#125;    build();    dfs(0);    cout&lt;&lt;&quot;NIE&quot;;    return 0;&#125;
 4. 数据结构结合
通过数据结构和 AC 自动机的完美，我们就可以通过快速维护某些信息来求解答案。
 P3121 Censoring G
多模式串匹配，考虑 AC 自动机，难点在于拼合过程。我们发现，一个字符匹配上之后就会删除，让后接着进行匹配，我们发现，只需要记录某个点在 Trie 图上匹配的位置就可以了，一旦成功匹配，我们只需要跳到这个单词的前一个字符的位置即可。考虑怎么维护，我们可以用栈来维护，删除逐个删除字符，加入一个一个加，时间复杂度是 O(n)O(n)O(n) 的：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e5+15;int n,top;int s1[MN];char s2[MN];string s;namespace ACAuto&#123;    int tot,trie[MN][26];    int end[MN],fail[MN];    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!trie[p][k]) trie[p][k]=++tot;            p=trie[p][k];        &#125;        end[p]=s.length();    &#125;    void build()&#123;        queue&lt;int&gt; q;        memset(fail,0,sizeof(fail));        for(int i=0;i&lt;26;i++)&#123;            if(trie[0][i]) q.push(trie[0][i]);        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                if(trie[u][i])&#123;                    fail[trie[u][i]]=trie[fail[u]][i];                    q.push(trie[u][i]);                &#125;else trie[u][i]=trie[fail[u]][i];            &#125;        &#125;    &#125;    void query(string s)&#123;        int p=0;        for(auto c:s)&#123;            p=trie[p][c-&#x27;a&#x27;];            s1[++top]=p;            s2[top]=c;            while(end[p])&#123;                top-=end[p];                p=top?s1[top]:0;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;s&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        string awa;        cin&gt;&gt;awa;        ACAuto::insert(awa);    &#125;    ACAuto::build();    ACAuto::query(s);    for(int i=1;i&lt;=top;i++) cout&lt;&lt;s2[i];    return 0;&#125;
是不是很水，能不能上一点难度啊！
 P5599 文本编辑器（毕业题）
？？？安详的睡去 XD。
没关系我们顺着 Subtask 一步一步来：
 Subtask 1-2
AC 自动机板子，14分 get！
 Subtask 3
只有一个模式串，要不要 KMP 呢？
但是正解显然不是让我们要用 KMP 啊，可是这里只有一个模式串耶？
我们考虑，一个匹配，当且仅当 s[i−L+1,i]s[i-L+1,i]s[i−L+1,i] 是完全相同的，其中 LLL 为模式串的长度。我们不妨考虑设 f(i)f(i)f(i) 表示 s[i−L+1,i]s[i-L+1,i]s[i−L+1,i] 是否完全匹配，那么查询就是查 ∑k∈[l+len−1,r]fk\sum\limits_{k \in [l+len-1,r]} f_{k}k∈[l+len−1,r]∑​fk​，这是区间和，可以上线段树耶。
但是修改怎么办，我们注意到，修改实质上是一个循环，一次修改只会影响 [l,r+L)[l,r+L)[l,r+L)（有循环截止部分），而我们的 f(i)f(i)f(i) 只需要判断出没出现过即可，而 f(i)f(i)f(i) 显然会有一个长度为 ∣t∣|t|∣t∣ 的循环节，而且一定在经过 LLL 个字符后出现，考虑对循环节之前的地方暴力，中间部分通过线段树打加法标记即可。
但是区间右端点在截止的时候也会修改，考虑把区间 (r,r+L)(r,r+L)(r,r+L) 的信息暴力修改就可以了，13 分 get！
 Subtask 4
没有修改！那我们就不用关心难受的循环节了哈哈哈。
现在问题转化为如何快速求出贡献之和，我们当然要建立起 AC 自动机，但是怎么维护区间呢？
我们考虑设 f(i)f(i)f(i) 表示 AC 自动机上匹配 s[1→i]s[1\to i]s[1→i]，的时候，到达的点 uuu 在 fail 树上子树中有多少终止节点。
不难发现一个对答案有贡献的字符串长度一定 ≤L\le L≤L，考虑对于一个询问 [l,r][l,r][l,r]，我们暴力求出 s[l→l+L−1]s[l \to l+L-1]s[l→l+L−1] 所有字串对答案贡献，让后查询 fff 在区间 [l+L,r][l+L,r][l+L,r] 的区间和就可以了。
让后就不会了啊啊啊啊啊啊。
 Subtask 5,6,7,114514
这部分参考了s_r_f 的题解。
其实答案就是 ∑f(i)+g(l,l+L−1)\sum\limits f(i)+g(l,l+L-1)∑f(i)+g(l,l+L−1)，其中 g(l,r)g(l,r)g(l,r) 表示 s[l→r]s[l \to r]s[l→r] 所有字串对答案的贡献，第二个很好求之前我们讲过，现在问题如何快速维护第一个。
每次区间修改的话必然会有循环节，但是我们只维护 fff 是求不出来循环节的，我们考虑我们要知道什么信息才能维护循环节，通过 Sub 3 我们发现，暴力修改完 [l,l+L−1][l,l+L-1][l,l+L−1] 之后需要知道匹配到 s[1→l+L−1]s[1\to l+L-1]s[1→l+L−1] 到 AC 自动机上的节点，也就是说，我们需要维护 uuu。
我们考虑在线段树的节点维护两个信息：

uuu 表示匹配 s[1→r]s[1\to r]s[1→r] 时到了 AC 自动机哪个节点。
ccc 表示区间 ∑f(i)\sum\limits f(i)∑f(i)。

让后我们对于叶子节点我们还需要知道这个点是什么字符，这样方便我取维护 u,cu,cu,c。
对于一次查询，我们只需要 [l,l+L)[l,l+L)[l,l+L) 暴力，[l+L,r][l+L,r][l+L,r] 暴力查 ccc。
怎么修改，首先前面 l+Ll+Ll+L 的部分还是暴力修改，让后我们查询 [l+L−1,l+L−1][l+L-1,l+L-1][l+L−1,l+L−1] 这个叶子节点的 uuu 来求循环节，让后对 [l+L,r][l+L,r][l+L,r] 进行区间修改，最后在对 [r+1,r+L][r+1,r+L][r+1,r+L] 所有的 uuu 暴力修改以下即可。
没了？没了！（一脸震惊 Orz）
复杂度 O(62×∑∣si∣+q×(log⁡n+L))O(62 \times \sum\limits |s_{i}|+q\times (\log n +L))O(62×∑∣si​∣+q×(logn+L))
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15,L=55;int n,m,q,id,f[MN],len[MN],sum[MN];string a,qry[MN];vector&lt;int&gt; pre[MN];unordered_map&lt;char,int&gt; mp;struct ACAuto&#123;    int t[MN][62],fail[MN],end[MN],tot;    void insert(string s)&#123;        int p=0;        for(auto c:s)&#123;            int k=mp[c];            if(!t[p][k]) t[p][k]=++tot;            p=t[p][k];        &#125;        end[p]++;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;62;i++)&#123;            if(t[0][i]) q.push(t[0][i]);        &#125;        while(!q.empty())&#123;            int u=q.front();            q.pop();            end[u]+=end[fail[u]];            for(int i=0;i&lt;62;i++)&#123;                int v=t[u][i];                if(v)&#123;                    fail[v]=t[fail[u]][i];                    q.push(v);                &#125;else t[u][i]=t[fail[u]][i];            &#125;        &#125;    &#125;    void getf()&#123;        int p=0;        for(int i=1;i&lt;=n;i++)&#123;            p=t[p][mp[a[i-1]]];            f[i]=end[p];        &#125;    &#125;    &#125;ac;struct Segment&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct Lazytag&#123;        int id,hd;    &#125;;    struct Node&#123;        int l,r,val;        Lazytag tag;    &#125;t[MN&lt;&lt;2];    int lpos;    string tmp;    void pushup(int p)&#123;        t[p].val=t[ls].val+t[rs].val;    &#125;    void dotag(int p,int id,int hd)&#123;        t[p].tag=&#123;id,hd&#125;;        int bef=t[p].l-hd,lid=(t[p].r-bef)%len[id],rid=(t[p].r-bef)/len[id];        if(rid==0)&#123;            t[p].val=pre[id][lid]-(hd?pre[id][hd-1]:0);        &#125;else t[p].val=pre[id][lid]+rid*sum[id]-(hd?pre[id][hd-1]:0);    &#125;    void pushdown(int p)&#123;        if(t[p].tag.id)&#123;            int id=t[p].tag.id,hd=t[p].tag.hd,val=(hd+(t[ls].r-t[ls].l+1))%len[id];            dotag(ls,id,hd);            dotag(rs,id,val);            t[p].tag.id=0;        &#125;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r)&#123;            t[p].val=f[l];            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void modifyt(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            dotag(p,id,(t[p].l-lpos)%len[id]);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modifyt(ls,fl,fr);        if(mid&lt;fr) modifyt(rs,fl,fr);        pushup(p);    &#125;    void modifyc(int p,int fl,int fr,bool tg)&#123;        if(fl&gt;fr) return;        if(t[p].l==t[p].r)&#123;            t[p].val=f[t[p].l];            if(tg)&#123;                t[p].tag=&#123;id,(t[p].l-lpos)%len[id]&#125;;            &#125;            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modifyc(ls,fl,fr,tg);        if(mid&lt;fr) modifyc(rs,fl,fr,tg);        pushup(p);    &#125;    void modify(int p,int fl,int fr)&#123;        if(fl&gt;fr) return;        if(t[p].l==t[p].r)&#123;            if(t[p].tag.id)&#123;                tmp+=qry[t[p].tag.id][t[p].tag.hd];            &#125;else tmp+=a[t[p].l-1];            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modify(ls,fl,fr);        if(mid&lt;fr) modify(rs,fl,fr);        pushup(p);    &#125;    int query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        int ret=0;        if(mid&gt;=fl) ret+=query(ls,fl,fr);        if(mid&lt;fr) ret+=query(rs,fl,fr);        return ret;    &#125;    #undef ls    #undef rs&#125;sg;void initmp()&#123;	for(int i=&#x27;A&#x27;;i&lt;=&#x27;Z&#x27;;i++)mp[i]=i-&#x27;A&#x27;;	for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;i++)mp[i]=26+(i-&#x27;a&#x27;);	for(int i=&#x27;0&#x27;;i&lt;=&#x27;9&#x27;;i++)mp[i]=52+(i-&#x27;0&#x27;);&#125;signed main()&#123;    initmp();    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;a;    for(int i=1;i&lt;=m;i++)&#123;        string s;        cin&gt;&gt;s;        ac.insert(s);    &#125;    ac.build();    ac.getf();    sg.build(1,1,n);    while(q--)&#123;        int op,l,r,ls;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;        ls=r-l+1;        sg.lpos=l;        if(op==1)&#123;            int rpos=min(r,l+L),ret=0,p=0;            sg.tmp=&quot;&quot;;            sg.modify(1,l,rpos);            for(int i=l;i&lt;=rpos;i++)&#123;                p=ac.t[p][mp[sg.tmp[i-l]]];                ret+=ac.end[p];            &#125;            cout&lt;&lt;ret+sg.query(1,rpos+1,r)&lt;&lt;&#x27;\n&#x27;;        &#125;else&#123;            string st;            cin&gt;&gt;st;            len[++id]=st.size();            pre[id].resize(len[id]);            int lpos=max(1ll,l-L+1),rpos=min(n,r+L-1);            int p=0;            if(ls&lt;=L*2+len[id]*2)&#123;                sg.tmp=&quot;&quot;;                sg.modify(1,lpos,rpos);                for(int i=lpos;i&lt;=rpos;i++)&#123;                    char ch=(i&lt;l||i&gt;r?sg.tmp[i-lpos]:st[(i-l)%len[id]]);                    p=ac.t[p][mp[ch]];                    if(i&gt;=l) f[i]=ac.end[p];                &#125;                sg.modifyc(1,l,r,1);                sg.modifyc(1,r+1,rpos,0);            &#125;else&#123;                int led=l+L-1,red=r-L+1;                while((led-l)%len[id]) led++;                sg.tmp=&quot;&quot;;                sg.modify(1,lpos,l-1);                for(int i=lpos;i&lt;led+len[id];i++)&#123;                    char ch=(i&lt;l?sg.tmp[i-lpos]:st[(i-l)%len[id]]);                    p=ac.t[p][mp[ch]];                    if(i&gt;=l)&#123;                        if(i&lt;led) f[i]=ac.end[p];                        else pre[id][i-led]=(i&gt;led?pre[id][i-led-1]:0)+ac.end[p];                    &#125;                &#125;                sum[id]=pre[id][len[id]-1];                sg.modifyc(1,l,led-1,1);                sg.modifyt(1,led,r);                sg.tmp=&quot;&quot;;                sg.modify(1,r+1,rpos);                for(int i=red;i&lt;=rpos;i++)&#123;                    char ch=(i&gt;r?sg.tmp[i-r-1]:st[(i-l)%len[id]]);                    p=ac.t[p][mp[ch]];                    if(i&gt;r)&#123;                        f[i]=ac.end[p];                    &#125;                &#125;                sg.modifyc(1,r+1,rpos,0);            &#125;            qry[id]=st;        &#125;    &#125;    return 0;&#125;
 5. 后言
AC 自动机我用了 3 天的时间来钻研，感觉学到很多，但是感觉自己还是很菜 www，可能并没有完全理解 Fail 的本质，但是能完整做出来题就很不错了。
不要脸的求赞 www。
 参考

Evitagen的FAil树
OI-Wiki
s_r_f 的文本编辑器题解
alex-wei的AC好题
weixin2024的自动机上DP
ying_mei的在AC自动机上DP
ThinerZQ的自动机讲解

]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>A星与IDDFS与IDA星</title>
    <url>/posts/7e84078f/</url>
    <content><![CDATA[ 0.前言
这里没有负边权，SPFA请右转最短路。
本文章基于路径规划之 A* 算法的精致动图以及算法竞赛等数据以及个人鄙见，望大佬提出建议qwq。
 1. 前人的铺垫
 1.1.Dijkstra算法
这不是图论的最短路吗？
其实这个算法就是用来寻找图形中节点之间的最短路径
考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。
在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。
在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。
下图中绿色部分代表有额外点权（默认大于1）：


当图形为网格图且点权均为1时，降为BFS

这里贴一个Dijkstra算法的单源最短路模板：
struct node&#123;    int pos,dis;    bool operator&lt;(const node&amp;x)const&#123;        return x.dis&lt;dis;    &#125;&#125;;priority_queue&lt;node&gt; q;vector&lt;edge&gt; adj[MN];void djl()&#123;	memset(ans,0x3f,sizeof(ans));    while (!q.empty())    &#123;        node f=q.top();        q.pop();        int fp=f.pos,fdis=f.dis;        if(vis[fp]) continue;        vis[fp]=1;        for(auto v:adj[fp])&#123;            if(ans[v.v]&gt;v.w+ans[fp])&#123;                ans[v.v]=ans[fp]+v.w;                if(!vis[v.v])&#123;                    q.push(&#123;v.v,ans[v.v]&#125;);                &#125;            &#125;        &#125;    &#125;&#125;
 1.2.贪心最佳优先搜索
如果我们可以预先计算出每个节点到终点的距离，利用曼哈顿，欧拉，对角线距离等求出。我们可以利用这个距离丢进优先队列。每次我们取出最小的进行遍历，这种算法和Dijkstra算法是相似的，而且时间复杂度很低很低。如右图

仔细观察一下，不对啊，如果你在沿着“理论”上的最短路径进行搜索的话，如果最短路径上有障碍物不就错误了？而且这个时候如果绕开，答案是错误的！因为在障碍物有缺口的时候我完全可以直接走离答案最近的缺口啊，也就是说这种情况在“理论最优路径”有障碍物的时候就会出现错误
如下图，有图即最佳优先搜索。

看完上面集中算法，我们总结一下上面的算法的优点与缺点。这里我们直接点出各个算法之间的本质


Dijkstra算法：高效的求出一个起点到其他所有点的最短路径，把所有遍历到的点按照到起点的距离压进优先队列进行处理，直到终点停止。但是他也有BFS的一定弊端，就是只看起点，不看终点，说白了就是把图上所有点遍历差不多了，他一定会遇到终点。这种在极端情况下仍需要遍历很多的点（目前来说若不指定终点，这种算法的时间复杂度是O(nlog⁡n)O(n\log n)O(nlogn)最优，证明可以见计算机协会的报刊）


贪心最佳优先搜索：对于每一个遍历的点我们看其到终点的距离进行选择，也就是说他只看终点，不看起点。在无障碍物的图上跑的飞快，有障碍物不适用。而且不会回头反悔重新选择。并且使用欧拉，曼哈顿，对角线这类简单的计算，不会提前绕开障碍。


 2. A-STAR算法
看完上面算法，我们能否实现一个搜索算法，让他即能够做到即看起点，又看终点，而且跑的都比Dijkstra算法和贪心优先快呢？大名鼎鼎的A-STAR算法就能同时够做到这一点！
我们来看A-STAR是怎么结合这个算法的：
我们设起点为sss，终点为ttt，对于每个当前位置的点iii，我们将s→ts \rightarrow ts→t的路径分为s→i→ts\rightarrow i \rightarrow ts→i→t。

对于s→is\rightarrow is→i，我们使用Dijkstra算法来保证最优性
对于i→ti\rightarrow ti→t ，我们使用贪心最佳优先来保证最优
如果iii碰壁，我们丢弃他，回溯（类似于反悔贪心），回溯过程中仍由Dijkstra算法保证到起点最优

我们可以使用一个估价函数来操作：
f(i)=g(i)+h(i)f(i)=g(i)+h(i)
f(i)=g(i)+h(i)
其中f(i)f(i)f(i)表示当前对iii点的评估，g(i)g(i)g(i)表示s→is\rightarrow is→i的代价，h(i)h(i)h(i)表示i→ti \rightarrow ti→t的代价。
敏锐的你一定能发现，如果我把g(i)=0g(i)=0g(i)=0，那么不就是贪心最佳优先吗；如果我把h(i)=0h(i)=0h(i)=0，那么不就是Dijkstra算法吗。这个时候我们就可以了解到A-STAR是怎么能够做到“即看起点，又看终点”
那么怎么设计函数呢，对于g(i)g(i)g(i)我们只需要记录走过的路径长度即可，放优先队列里就可以来。而A-STAR高效的地方就在于h(i)h(i)h(i)的设计,设计一个好的h(i)h(i)h(i)的函数能够减少我们到处“碰壁”的可能，h(i)h(i)h(i)函数在A-STAR算法中起到的作用就类似于引路人，引导你如何走（就是如何选点），找到一个好的引路人能够少走弯路（懒的走qwq）。
时间复杂度？在你完全不找引路人h(i)h(i)h(i)或者h(i)h(i)h(i)及其不靠谱的情况下就是Dijkstra算法，一般情况下跑的快。
最终结果是最优吗，因为它和Dijkstra算法的解一样都是最短路径，当iii达到终点ttt的时候h(t)=0h(t)=0h(t)=0，这个时候f(t)=g(t)+h(t)=g(t)f(t)=g(t)+h(t)=g(t)f(t)=g(t)+h(t)=g(t)，就是Dijkstra算法求得的最短路。
可以看看A-STAR是如何绕开障碍的

 2.1如何设计h函数
在二维平面图中，有三种放置可以设计

曼哈顿距离——只能在上下左右四个方向移动

h(i)=∣i.x−t.x∣+∣i.y−t.y∣h(i)=|i.x-t.x|+|i.y-t.y|
h(i)=∣i.x−t.x∣+∣i.y−t.y∣

对角线距离，可以在八个方向移动

h(i)=max(∣i.x−t.x∣,∣i.y−t.y∣)h(i)=max(|i.x-t.x|,|i.y-t.y|)
h(i)=max(∣i.x−t.x∣,∣i.y−t.y∣)

欧拉距离，可以向任意方向移动

h(i)=(i.x−t.x)2+(i.y−t.y)2h(i)=\sqrt{(i.x-t.x)^2+(i.y-t.y)^2}
h(i)=(i.x−t.x)2+(i.y−t.y)2​
而对于非平面问题我们就需要自行设计。
但是我们对于h函数应当遵循以下规则

ggg和hhh应当使用同样的计算方法，例如hhh是曼哈顿距离那么ggg也一样，不然性质都不一样fff就没有参考意义了。
根据应用情况正确选择hhh，你不能在坐标系上任意移动使用曼哈顿距离吧
hhh应当优于实际存在的所有路径。也就是说最后得到的实际路径长度必须大于等于h(i)h(i)h(i)，如果小于的话那么最优的路径就算不上了。这一条十分重要。

 2.2例题
 2.2.1——k短路问题

给出一张图，有 n 个点， m 条边（有向边），并给出起点 s ，终点 t ，以及第 k 短路的 k 。请你求出从 s 到 t 的路径中，第 k 短路径的长度。若不存在，则输出 −1 。

我们使用A-STAR算法做这一类题目，这个题正解不是A-STAR算法因为在图是个nnn元环时，最坏时间复杂度为O(nklog⁡n)O(nk\log n)O(nklogn)可以构造数据卡出，正解为可持久化可并堆。
那么如何设计h(i)h(i)h(i)呢，在这个题目里h(i)h(i)h(i)其实就是到终点的距离，我们可以建反边跑Dijkstra算法，就可以求出每个点到终点的h(i)h(i)h(i)了。
记g(i)g(i)g(i)为经过的距离，那么初始的时候就是(s,0)(s,0)(s,0)，每个点的状态就是(i,g(i))(i,g(i))(i,g(i))，因为h(i)h(i)h(i)是确定的。
因为是kkk短路，我们可以给每一个点加一个计数器，如果被重复计算超过kkk次就不再计算，这种做法对吗？如果该点在最优路径上，那么这个显然不影响结果；如果在，那么分两种情况，第一种kkk短路都经过这个点，那么刚好计数器就能够累加答案至kkk结束，如果不都经过也不影响kkk短路的答案。
故代码如下：
#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define pir pair&lt;int,int&gt;using namespace std;const int MN=1e5+15;int n,m,s,t,x,h[MN],g[MN],cnt[MN];const int INF=0x3f3f3f3f;struct edge&#123;    int v,w;&#125;;struct node&#123;    int v,nh,ng;    bool operator&lt;(const node&amp;x)const&#123;        return nh+ng&lt;x.nh+x.ng;    &#125;&#125;;vector&lt;edge&gt; adj[MN],adjh[MN];void dij()&#123;// 求h(i)priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt;q;    q.push(pir(0,t));    h[t]=0;    while(!q.empty())&#123;        pir f=q.top();        q.pop();        int u=f.second,w=f.first;        if(w&gt;h[u]) continue;        for(int i=0;i&lt;adjh[u].size();i++)&#123;            edge e=adjh[u][i];            int v=e.v,ew=e.w;            if(h[v]&gt;h[u]+ew)&#123;                h[v]=h[u]+ew;                q.push(pir(h[v],v));            &#125;        &#125;    &#125;&#125;bool astar()&#123;	//跑A-STAR，如何开局引路人说不能走就不走	// INF默认无解    if(h[s]==INF) return 0;    priority_queue&lt;node&gt; q;    q.push(&#123;s,0,0&#125;);    while(!q.empty())&#123;        node f=q.top();        q.pop();        int u=f.v,fh=f.nh,fg=f.ng;        cnt[u]++;        if(u==t&amp;&amp;cnt[u]==x)&#123;            cout&lt;&lt;fg;            return 1;        &#125;        if(cnt[u]&gt;x) continue;        for(int i=0;i&lt;adj[u].size();i++)&#123;            edge e=adj[u][i];            int v=e.v,ew=e.w;            q.push(&#123;v,h[v],fg+ew&#125;);        &#125;    &#125;    return 0;&#125;int main()&#123;    memset(h,0x3f,sizeof(h));    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);        adjh[v].push_back(&#123;u,w&#125;);    &#125;    cin&gt;&gt;s&gt;&gt;t&gt;&gt;x;    dij();    if(!astar())&#123;        cout&lt;&lt;-1;    &#125;    return 0;&#125;
 2.Power Hungry Cows
P10494

2个变量a,ba,ba,b初始时为a=1,b=0a=1,b=0a=1,b=0，每一步可以执行a×2,b×2,a+b,∣a−b∣a\times 2,b\times 2,a+b,|a-b|a×2,b×2,a+b,∣a−b∣ 任意操作，并把结果存回aaa或bbb，问最快能得到一个整数PPP。
1≤P≤200001\le P \le 200001≤P≤20000


如何设计估价函数？我们要求出的是最快能够达到x=Px=Px=P或y=Py=Py=P的结果，那么这个时候就呼之欲出了，我们可以设h(i)h(i)h(i)为当前值到PPP一共需要多少步。我们可以看出只需要让最大的这样做就可以了，而且贪心一下最佳操作就是乘法操作。
我们肯定需要剪枝，因为在计算h(i)h(i)h(i)的时候会出现一些无法转移或非最优解的情况。
我们一个状态(x,y,g,h)(x,y,g,h)(x,y,g,h)，其中xxx为较大的(a,b)(a,b)(a,b)其中一个，另一个yyy即较小的。
首先当x&gt;n×2x&gt;n\times 2x&gt;n×2的时候肯定不行（此路不通非走）
当x&gt;n and y=0x&gt;n\,and\,y=0x&gt;nandy=0时无法转移
当x&gt;n and y&gt;nx&gt;n\,and\,y&gt;nx&gt;nandy&gt;n时不是最优解
当x=yx=yx=y的时候肯定也不是
我们可以用map记录当前的最优解，之后不断更新，如果当前解比最优解还大那么就剪枝。
如果只执行到这里会TLE4个点。
我们还能否进一步进行剪枝，对于a,ba,ba,b函数来说，我们可以进行乘法和加减操作。乘法？加法？
我们可以将上述题目转化为一个方程即ax+byax+byax+by，默认的时候a=1,b=0a=1,b=0a=1,b=0，在操作的时候只需要对aaa与bbb进行修改即可。
我们不考虑能否进行最优解，我们只需要判断是否有解即可，接下来请出贝祖定理！

设a,ba,ba,b是不为0的整数，对任意整数x,yx,yx,y，满足gcd(x,y)∣ax+bygcd(x,y)|ax+bygcd(x,y)∣ax+by

那么就很简单了，就看PPP能否整除gcd(x,y)gcd(x,y)gcd(x,y)就可以了
#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pir;template&lt;typename type&gt;inline void read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar();    flag?x=-x:0;&#125;template&lt;typename type&gt;inline void write(type x,bool mode=1)&#123;    x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;static short Stack[50],top(0);    do Stack[++top]=x%10,x/=10; while(x);    while(top) putchar(Stack[top--]|48);    mode?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;int n;map&lt;pir,int&gt; m;struct node&#123;    int x,y,g,h;    bool operator&lt;(const node&amp; a)const&#123;        return h+g&gt;a.g+a.h;    &#125;&#125;;priority_queue&lt;node&gt; q;void update(int x,int y,int g,int h)&#123;    if(x&lt;y) swap(x,y);    if(x&gt;n*2) return;    if(x&gt;n&amp;&amp;y==0) return;    if(x&gt;n&amp;&amp;y&gt;n) return;    if(x==y) return;    if(m[pir(x,y)]&amp;&amp;m[pir(x,y)]&lt;g+1+h) return;    if(n%__gcd(x,y)) return;    int newh=0,k=x;    while(k&lt;n)k*=2,newh++;    m[pir(x,y)]=g+newh+1;    q.push(&#123;x,y,g+1,newh&#125;);&#125;void astar()&#123;    update(1,0,0,0);    while(!q.empty())&#123;        node f=q.top();        q.pop();        int x=f.x,y=f.y,g=f.g,h=f.h;        if(f.x==n||f.y==n)&#123;            write(f.g-1);            return;        &#125;        update(x,2*y,g,h);        update(y,2*x,g,h);        update(x,2*x,g,h);        update(y,2*y,g,h);        update(x,x-y,g,h);        update(y,x-y,g,h);        update(x,x+y,g,h);        update(y,x+y,g,h);    &#125;&#125;int main()&#123;    ios::sync_with_stdio(0);    read(n);    astar();    return 0;&#125;
 3.ID-DFS与IDA∗*∗迭代加深(启发式)搜索
 3.1 BFS与DFSの痛
我们假设一个场景，一个多叉树，树十分甚至九分的深，树上每一个点表示当前解的状态，而我们要搜索的答案就是这个树上的一个点。我们可以通过BFS和DFS来找到这个终点。例如下图


BFS是一层一层遍历，到depth=2depth=2depth=2的层找到，而在他的队列中，拓展到红色节点中同一层级和下一层级的部分节点也会入队。
DFS是按照深度，先遍历左子树在遍历有子树，直到遇到终点，如果树很深那么只有遍历到最深的叶子节点才会回溯。
缺点如下：

BFS可能会消耗巨大空间，第kkk层就有至多2k−12^k-12k−1个节点，如果是一颗满二叉树就如上图那么消耗的节点空间就会很多。如果确定终点可以考虑双向BFS，复杂度降为2k22^{\frac{k}{2}}22k​，但是一般情况是不知道终点。
DFS有很多无效搜索的节点，这里不再阐明，可以看图理解。
那我们可以将两者结合起来吗？IDDFS！

 3.2 IDDFS迭代加深搜索
如果问题的解在搜索树的较浅层，那么我们可以用IDDFS来解决问题，他是BFS和DFS结合的产物。即不像BFS挥霍空间，又不像DFS一样搜索过多无效节点。
IDDFS的步骤如下：

限制深度depth=0depth=0depth=0，做DFS
限制深度depth=1depth=1depth=1，做DFS
限制深度depth=2depth=2depth=2，做DFS…直到遇到节点


我们发现最坏的情况就是答案节点一直在最后才会遍历到，由上面公式可以得到对于第kkk层至多有2k−12^k-12k−1个节点。那么以此遍历每一层，总时间时间复杂度就是O(21+22+...+2k)=O(2k)O(2^1+2^2+...+2^k)=O(2^k)O(21+22+...+2k)=O(2k) ，空间复杂度因为是DFS与BFS的结合体，我们DFS由递归计空间复杂度O(n)O(n)O(n)，考虑BFS按层遍历，显然空间复杂度O(k)O(k)O(k)。
以下是对比：



算法
时间复杂度
空间复杂度
应用场景




DFS
O(2n)O(2^n)O(2n)
O(n)O(n)O(n)
n不是很大，就是搜索树不是很大


BFS
O(2k)O(2^k)O(2k)
O(2k)O(2^k)O(2k)
k不是很大，占用空间不会超过限制


IDDFS
O(2k)O(2^k)O(2k)
O(k)O(k)O(k)
k不是很大且空间限制较大



 3.3 IDA∗*∗
IDDFS一般需要升级为IDA∗IDA*IDA∗，IDA∗IDA*IDA∗就是利用估价函数f(x)f(x)f(x)来进行剪枝的IDDFS。
我们观察IDDFS的步骤，我们再回顾A∗A*A∗提到的BFS与DFS算法的优缺点，我们发现IDDFS也是有着“盲目”的特性在，只是对搜索层数进行限制。如果我们在进行搜索能通过估价函数进行“剪枝”，就能够大幅优化！
来看一道题
P2324


补充：如果能在15步以内达到输出结果，否则输出-1

这道题就是经典的例题，我们可以用A∗A*A∗或者IDA∗IDA*IDA∗去做，我们使用IDA∗IDA*IDA∗。
我们的估价函数的目的就是引导我们去达到这个目标状态，我们回顾以下估价函数的组成：$$f(x)=g(x)+h(x)$$
这里g(x)g(x)g(x)我们可以统计之前的步数来实现，而h(x)h(x)h(x)的设计需要和上面2.1的内容的条件，其中最重要的是“hhh应优于实际存在的所有路径”，那么我们就可以设h(x)h(x)h(x)为与最终状态的相差个数。
那么h(x)h(x)h(x)函数设计很简单，如下：
char goal[6][6]=&#123;	&#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;,	&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;&#125;,	&#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;&#125;,	&#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;*&#x27;,&#x27;1&#x27;,&#x27;1&#x27;&#125;,	&#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;,	&#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;&#125;;char map[6][6];int geth()&#123;    int cnt=0;    for(int i=1;i&lt;=5;i++)&#123;        for(int j=1;j&lt;=5;j++)&#123;            if(map[i][j]!=goal[i][j])&#123;                cnt++;            &#125;        &#125;    &#125;    return cnt;&#125;
那么怎么进行IDA∗IDA*IDA∗呢？其实也很简单，估价函数的值就是预估我们从当前点到目标点到底走多少步，到IDDFSIDDFSIDDFS上就是拓展多少深度。
void dfs(int x,int y,int dep,int mdep)&#123;    if(dep==mdep)&#123;        if(!geth()) isok=1;//答案找到了        return;    &#125;    for(int i=0;i&lt;8;i++)&#123;        int nx=x+fx[i],ny=y+fy[i];        if(nx&gt;=1&amp;&amp;nx&lt;=5&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=5)&#123;            swap(map[x][y],map[nx][ny]);            if(dep+geth()&lt;=mdep) dfs(nx,ny,dep+1,mdep);//如果预估深度足够，那么dfs            if(isok) return;//如果有答案就返回            swap(map[x][y],map[nx][ny]);        &#125;    &#125;&#125;
让后就和IDDFS一样，直接搜索就可以了
void dfs(int x,int y,int dep,int mdep)&#123;    if(dep==mdep)&#123;        if(!geth()) isok=1;//答案找到了        return;    &#125;    for(int i=0;i&lt;8;i++)&#123;        int nx=x+fx[i],ny=y+fy[i];        if(nx&gt;=1&amp;&amp;nx&lt;=5&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=5)&#123;            swap(map[x][y],map[nx][ny]);            if(dep+geth()&lt;=mdep) dfs(nx,ny,dep+1,mdep);//如果预估深度足够，那么dfs            if(isok) return;//如果有答案就返回            swap(map[x][y],map[nx][ny]);        &#125;    &#125;&#125;void solve()&#123;    int kx,ky;    isok=0;    for(int i=1;i&lt;=5;i++)&#123;        for(int j=1;j&lt;=5;j++)&#123;            cin&gt;&gt;map[i][j];            if(map[i][j]==&#x27;*&#x27;)&#123;                kx=i;                ky=j;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=15;i++)&#123;        dfs(kx,ky,0,i);        if(isok)&#123;            cout&lt;&lt;i&lt;&lt;&#x27;\n&#x27;;            return;        &#125;    &#125;    cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;&#125;
 4.总结
A∗A*A∗与IDA∗IDA*IDA∗两个算法都关键在于h(x)h(x)h(x)的设计，如果h(x)h(x)h(x)设计的好，那么算法跑的就飞快，反之就根BFSBFSBFS差不多。
IDA∗IDA*IDA∗的速度是大部分比A∗A*A∗快的。
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>CDQ分治与整体二分</title>
    <url>/posts/f5367f52/</url>
    <content><![CDATA[ 0. 前言
你需要知道——分治。
对于我们介绍的CDQ分治和整体二分，他们都属于离线分治算法的一类。
 1. CDQ 分治
 1.1 分治的经典应用
分治一个经典应用就是归并排序，我们可以参考它的运行过程。
回忆一下归并排序的步骤？

把数组分成 [l,mid],[mid+1,r][l,mid],[mid+1,r][l,mid],[mid+1,r] 两个区间。
对左区间和右区间进行归并排序。
把左区间和有区间合并为一个有序数组。

这里引用GTWZeus大佬的文章的图：

ok回忆完了分治的结构，记住这个图的结构，我们来看 CDQ 分治。
 1.2 基于时间的分治算法
CDQ 分治不是一个模板，它是一个思想。

大多数数据结构问题都可以抽象为：“维护一堆数据，对一系列操作依次作出响应” 的形式。而这些操作一般分为所谓的 “查询” 操作或者 “更新” 操作。
而查询操作和更新操作也是有问题类型划分的。如果所有查询操作都在更新操作之后，那么这个问题就是一个静态问题。反之则为动态问题。 ——蓝书（非原文）

一般来说我们在做数据结构遇到的到多数都是动态问题，我们要想出来一个维护方法很难，而对于静态问题却很好做。CDQ分治就能做到将动态问题拍扁成静态问题。
我们将所有操作横向展开画在以 “时间” 为横坐标平面轴上，我们观察修改操作，发现它只会对在它后面出现的操作产生影响。

那么我们可不可以这样想，对于操作序列中每一个查询，计算查询结果就是 “计算初始数据+在该查询之前所有修改“ 所造成的影响。
我们可以将每个操作对后续操作的贡献图画出来，在这里实线箭头表示对后续操作有贡献（修改），虚线即为无贡献（查询）。
我们对于操作不断向上合并贡献，如果一个操作区间有了对后继操作有贡献，我们也把这个区间的线全表为实线。

这个结构…怎么这么像归并排序的结构？
我们不妨试试分治，对于一个操作序列有 mmm 项操作。∀l,r∈[1,m]\forall l,r \in [1,m]∀l,r∈[1,m]，我们定义 solve(l,r)solve(l,r)solve(l,r) 为：
∀k∈[l,r]\forall k \in [l,r]∀k∈[l,r]，若第 kkk 项操作是查询操作，那么我们就计算 [l,k−1][l,k-1][l,k−1] 里面操作对当前操作的影响，实际上就是分治的思想，我们区间砍成一半 [l,mid],[mid+1,r][l,mid],[mid+1,r][l,mid],[mid+1,r]，对左右区间递归计算，让后计算 [l,mid][l,mid][l,mid] 中修改操作对 [mid+1,r][mid+1,r][mid+1,r] 的查询操作影响。
我们还需要证明这样分治是正确的：

若第 kkk 个操作是查询操作，若 k≤midk\le midk≤mid 那么 solve(l,mid)solve(l,mid)solve(l,mid) 已经计算了 [l,k−1][l,k-1][l,k−1] 操作对它的影响，反之k&gt;midk&gt;midk&gt;mid，同理珂证明 solve(mid+1,r)solve(mid+1,r)solve(mid+1,r) 计算了操作对它的影响，再加上 solve(l,mid)solve(l,mid)solve(l,mid) 的影响。得证。
修改操作？我们计算查询贡献的。

总结一下 CDQ 分治有三个操作：

递归左区间 solve(l,mid)solve(l,mid)solve(l,mid)。
递归右区间 solve(mid+1,r)solve(mid+1,r)solve(mid+1,r)。
计算左区间修改操作对右区间的影响。
当 l=rl=rl=r 时是递归边界，因为这还怎么递归，操作3都走不了www。

对于递归树如下，借用oiwiki的图：

那不对啊，你一开始说这个分治能把我不会的动态问题派扁成静态，哪里拍扁了？
你看第三个操作，左右区间里面单独的查询修改操作已经操作完毕，我们只需要算左区间单独的修改操作对右区间查询操作的影响即可，这个难道不就是静态问题吗，肯定是的。
这样的话，CDQ 分治就把一个动态问题划分成 mmm 个静态问题，每个查询结果是由 log⁡m\log mlogm 个静态问题的结果共同造成的。
静态问题当然比动态问题好做多啦，如果我们对于操作 3 能做到仅在 r−lr-lr−l 的规模内完成，和 mmm 无关，那么我们就能以优秀的时间复杂度，多个 O(log⁡m)O(\log m)O(logm) 的代价做削弱版本的问题，这是十分甚至九分好的，这样的总时间复杂度就是 O((n+m)log⁡2(n+m))O((n+m)\log^2 (n+m))O((n+m)log2(n+m))。
接下来我们来看例题：
 洛谷P4169 [Violet] 天使玩偶/SJY摆棋子
假如说没有 t=1t=1t=1 的操作我们看看怎么做，根据题意，答案就是：
min⁡i=1n{∣x−xi∣+∣y−yi∣}\min_{i=1}^n \left\{ |x-x_i|+|y-y_i| \right\}
i=1minn​{∣x−xi​∣+∣y−yi​∣}
我们看看这个怎么去掉绝对值符号，先拆掉试试。
min⁡i=1n{(x−xi)+(y−yi)}\min_{i=1}^n \left\{ (x-x_i)+(y-y_i) \right\}
i=1minn​{(x−xi​)+(y−yi​)}
不难发现 x,yx,yx,y 是定值，考虑提出来。
(x+y)−max⁡i=1n(xi+yi)(x+y)-\max_{i=1}^n (x_{i}+y_{i})
(x+y)−i=1maxn​(xi​+yi​)
但是这样拆有个前提条件，我们的 (xi,yi)(x_i,y_i)(xi​,yi​) 坐标必须在左下角，但是点在四面八方怎么办？我们充分发挥人类智慧，直接旋转坐标系让他们移动到左下角，或者不用旋转直接平移就可以了。
暴力当然是 O(n2)O(n^2)O(n2) 的，我们考虑怎么做到 O(nlog⁡n)O(n \log n)O(nlogn) ，直接上数据结构，先按照 xix_ixi​ 从小到大排序 ，树状数组以 yiy_iyi​ 为下标，对于 x+yx+yx+y 取最大值就可以了。
有修改怎么做？发现可以离线，直接上CDQ！
但是注意一下，我们不能每个 solvesolvesolve 都搞一个树状数组，那样时间和空间都会爆炸，我们要保证时间复杂度仅与 r−lr-lr−l 相关，要在计算贡献完后清空树状数组影响的部分。时间复杂度 O(qlog⁡2q)O(q\log^2 q)O(qlog2q)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15,INF=0x3f3f3f3f;struct Query&#123;    int x,y,op,id;&#125;a[MN],b[MN],tmp[MN];int n,m,mxlen,ans[MN];struct mxBIT&#123;    int t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    int query(int x)&#123;        int ret=-INF;        while(x)&#123;            ret=max(ret,t[x]);            x-=lowbit(x);        &#125;        return ret;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]=max(t[x],k);            x+=lowbit(x);        &#125;    &#125;    void clear(int x)&#123;        while(x&lt;MN&amp;&amp;t[x])&#123;            t[x]=-INF;            x+=lowbit(x);        &#125;    &#125;&#125;bit;void cdq(int l,int r)&#123;    // cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&#x27;\n&#x27;;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    cdq(l,mid);    cdq(mid+1,r);    int i=l,j=mid+1,k=l;    while(j&lt;=r)&#123;        while(b[i].x&lt;=b[j].x&amp;&amp;i&lt;=mid)&#123;            if(b[i].op==1) bit.update(b[i].y,b[i].x+b[i].y);            tmp[k++]=b[i++];        &#125;        if(b[j].op==2)&#123;            ans[b[j].id]=min(ans[b[j].id],b[j].x+b[j].y-bit.query(b[j].y));        &#125;        tmp[k++]=b[j++];    &#125;    for(int p=l;p&lt;i;p++)&#123;        if(b[p].op==1) bit.clear(b[p].y);    &#125;    while(i&lt;=mid) tmp[k++]=b[i++];    for(int p=l;p&lt;=r;p++) b[p]=tmp[p];&#125;void solve(int x,int y)&#123;    for(int i=1;i&lt;=n+m;i++)&#123;        b[i]=a[i];        if(x) b[i].x=mxlen-b[i].x;        if(y) b[i].y=mxlen-b[i].y;    &#125;    cdq(1,n+m);&#125;int main()&#123;    memset(bit.t,-0x3f,sizeof(bit.t));    memset(ans,0x3f,sizeof(ans));    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;        a[i].id=i;        a[i].op=1;// 1是插入，除此以外都为查询        a[i].x++;        a[i].y++;        mxlen=max(&#123;mxlen,a[i].x,a[i].y&#125;);    &#125;    for(int i=n+1;i&lt;=n+m;i++)&#123;        int op,x,y;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        a[i].op=op;        a[i].x=++x;        a[i].y=++y;        mxlen=max(&#123;mxlen,a[i].x,a[i].y&#125;);        a[i].id=i;    &#125;    mxlen++;    solve(0,0);    solve(1,0);    solve(0,1);    solve(1,1);    for(int i=n+1;i&lt;=n+m;i++)&#123;        if(a[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 1.3 基于钉死一维的点对问题分治算法
这个名字有点形象www。
CDQ 分治不仅能时间分治，还能解决点对问题。
来看三维偏序例题：

有 nnn 个元素，第 iii 个元素有 ai,bi,cia_i,b_i,c_iai​,bi​,ci​ 三个属性，设 f(i)f(i)f(i) 表示满足 aj≤aia_j \leq a_iaj​≤ai​ 且 bj≤bib_j \leq b_ibj​≤bi​ 且 cj≤cic_j \leq c_icj​≤ci​ 且 j≠ij \ne ij=i 的 jjj 的数量。
对于 d∈[0,n)d \in [0, n)d∈[0,n)，求 f(i)=df(i) = df(i)=d 的数量。

我们回忆一下二维偏序（逆序对）问题我们是怎么做的，我们不会二维所以我们考虑先钉死一维，比如说 i&lt;ji&lt;ji&lt;j 就很好钉死，另一维 ai&gt;aja_i&gt;a_jai​&gt;aj​ 很好做，用权值树状数组做就可以了。
但是二维偏序还有一个解法就是归并排序，事实上归并排序也是定死一维 i&lt;ji&lt;ji&lt;j ，让后分治的处理 ai&gt;aja_i&gt;a_jai​&gt;aj​。
那么对于三维偏序呢？我们是不是也可以想上面钉死一维度呢？但是好像轻易的钉死会出事，因为对于当前第一维度的位置，前面的偏序对后面偏序也会造成影响，这告诉我们什么？CDQ分治！
我们像上面例题的解决方法一样，先对于 aia_iai​ 进行排序，CDQ分治先递归 solve(l,mid),solve(mid+1,r)solve(l,mid),solve(mid+1,r)solve(l,mid),solve(mid+1,r)，接下来要开始计算前对后的影响。
仔细思考可以发现 aia_iai​ 的排序已经没啥用了，因为在 CDQ 分治中左区间和右区间的计算已经满足的 aia_iai​ 的限制了，于是接下来我们可以看剩下两个限制，接下来就是一个最经典的二维偏序问题了，做就可以了。
这样的时间复杂度还是一样的 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
仔细思考一下，CDQ 分治一个天然的特性它能满足一个维度的限制，对于时间分治他能天然的满足 timei&lt;timejtime_i&lt;time_jtimei​&lt;timej​。对于本题来说，通过先对 aia_iai​ 排序，CDQ分治能做到天然的满足三维偏序中的 aia_iai​ 偏序，这样就大大将问题简化为二维偏序问题。
事实上，CDQ分治的一个核心特性是通过分治策略逐层处理多维问题中的单个维度限制 ，从而将高维问题转化为低维问题。通过在每一步递归中主动构造一个维度的有序性（注意我们是在内部进行排序而非外部，不然就摁死不了一维了），天然的满足一个维度的限制条件。
代码如下：
#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e5+15;struct Node&#123;    int x,y,z,ans,cnt;&#125;a[MN],b[MN];int n,K,tot,cnt[MN],t[MN];struct BIT&#123;    int t[MN];    inline int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;bool cmp1(Node x,Node y)&#123;    if(x.x==y.x)&#123;        if(x.y==y.y) return x.z&lt;y.z;        return x.y&lt;y.y;    &#125;    return x.x&lt;y.x;&#125;bool cmp2(Node x,Node y)&#123;    if(x.y==y.y) return x.z&lt;y.z;    return x.y&lt;y.y;&#125;void cdq(int l,int r)&#123;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    cdq(l, mid);    cdq(mid+1,r);    sort(a+l,a+mid+1,cmp2);    sort(a+mid+1,a+r+1,cmp2);    int i=mid+1,j=l;    while(i&lt;=r)&#123;        while(a[j].y&lt;=a[i].y&amp;&amp;j&lt;=mid)&#123;            bit.update(a[j].z,a[j].cnt);            j++;        &#125;        a[i].ans+=bit.query(a[i].z);        i++;    &#125;    for(int i=l;i&lt;j;i++)&#123;        bit.update(a[i].z,-a[i].cnt);    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;K;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].z;    &#125;    sort(b+1,b+1+n,cmp1);//先钉死一维    int c=0;    for(int i=1;i&lt;=n;i++)&#123;        c++;        if(b[i].x!=b[i+1].x||b[i].y!=b[i+1].y||b[i].z!=b[i+1].z)&#123;            a[++tot]=b[i];            a[tot].cnt=c;            c=0;        &#125;    &#125;    cdq(1,tot);    for(int i=1;i&lt;=tot;i++)&#123;        cnt[a[i].ans+a[i].cnt-1]+=a[i].cnt;    &#125;    for(int i=0;i&lt;n;i++) cout&lt;&lt;cnt[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
更一般的，我们总结为以下问题：

给定一个长度为 nnn 的序列，统计有一些特性的点对 (i,j)(i,j)(i,j) 的数量/找到一对点对 (i,j)(i,j)(i,j) 使得一些函数的值最大。

流程如下：

找到序列中点 midmidmid。
对于所有点对分3类：

(i,j)(i,j)(i,j) 在左区间的。
(i,j)(i,j)(i,j) 跨区间的,指 iii 在左区，jjj 在右区。
(i,j)(i,j)(i,j) 在右区间的。


递归处理左右区间，设计算法处理跨区间点对。

我们其实发现，对于基于时间的分治算法和这个也极为相似，同样都是要解决跨区间的问题，递归处理左右区间的算法。
 洛谷P3157 [CQOI2011] 动态逆序对
一个不难发现就是其实删除操作也是更新操作（废话）, 考虑有贡献的点对 (i,j)(i,j)(i,j)，转成三维偏序话就是两个逆序对。

对于每一个被删的元素，消失的逆序对等于
在它前面，权值比他大，且删去时间比他晚的点个数
在它后面，权值比他小，且删去时间比他晚的点个数
——shadowice1984大佬

timei&lt;timej,i&lt;j,ai&gt;ajtimei&lt;timej,i&gt;j,ai&lt;aj\begin{aligned}
time_{i}&lt;time_{j},i&lt;j,a_{i}&gt;a_{j} \\
time_{i}&lt;time_{j},i&gt;j,a_{i}&lt;a_{j}
\end{aligned}
timei​&lt;timej​,i&lt;j,ai​&gt;aj​timei​&lt;timej​,i&gt;j,ai​&lt;aj​​
这样的话直接做！
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e5+15;struct Query&#123;    int op,x,y,t,id;&#125;q[MN];int n,m,qtot,ans[MN],a[MN],pos[MN];struct BIT&#123;    int t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;bool cmp2(Query x,Query y)&#123;    return x.x&lt;y.x;&#125;void cdq(int l,int r)&#123;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    cdq(l,mid);    cdq(mid+1,r);    int i=l,j=mid+1;    sort(q+l,q+mid+1,cmp2);    sort(q+mid+1,q+r+1,cmp2);    while(j&lt;=r)&#123;        while(q[i].x&lt;=q[j].x&amp;&amp;i&lt;=mid)&#123;            bit.update(q[i].y,q[i].op);            i++;        &#125;        ans[q[j].id]+=q[j].op*(bit.query(n)-bit.query(q[j].y));        j++;    &#125;    for(int p=l;p&lt;i;p++)&#123;        bit.update(q[p].y,-q[p].op);    &#125;    i=r,j=mid;    while(i&gt;mid)&#123;        while(j&gt;=l&amp;&amp;q[j].x&gt;=q[i].x) bit.update(q[j].y,q[j].op),j--;        ans[q[i].id]+=q[i].op*bit.query(q[i].y-1);        i--;    &#125;    for(i=mid;i&gt;j;i--) bit.update(q[i].y,-q[i].op);&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        pos[a[i]]=i;        q[++qtot]=&#123;1,i,a[i],0,0&#125;;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int x;        cin&gt;&gt;x;        q[++qtot]=&#123;-1,pos[x],x,i,i&#125;;// 1是加入，-1是删除    &#125;    // sort(q+1,q+1+qtot,cmp1); 已经满足时间从前往后了所以不用排序。    cdq(1,qtot);    for(int i=1;i&lt;=m;i++) ans[i]+=ans[i-1];    for(int i=0;i&lt;m;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 P4690 [Ynoi Easy Round 2016] 镜中的昆虫

维护一个长为 nnn 的序列 aia_iai​，有 mmm 次操作。


将区间 [l,r][l,r][l,r] 的值修改为 xxx。


询问区间 [l,r][l,r][l,r] 出现了多少种不同的数，也就是说同一个数出现多次只算一个。
1≤n,m≤1051\leq n , m \leq 10^51≤n,m≤105，1≤ai≤1091\leq a_i\leq 10^91≤ai​≤109。



经典的颜色段问题，但是加强版。
珂朵莉树？你看看这是谁出的题。
带修莫队，疯了吧 。
怎么做？发现可以离线哦，而且 aia_iai​ 可以离散化。
先考虑不修改怎么做，在不能用莫队和珂朵莉树的情况下，我们可以开一个 preprepre 数组，对于 preipre_iprei​ 表示当前节点颜色在它左侧第一个和它同色点的位置，这个位置可以 O(n)O(n)O(n) 求出来。
对于区间询问其实就是询问 [l,r][l,r][l,r] 中 prei&lt;lpre_{i}&lt; lprei​&lt;l 的数有多少个，用线段树或树状数组即可做，我们看作二维数点 (i,prei)(i,pre_i)(i,prei​)，实际上就是一个二维偏序问题吗，树状数组做即可。
那么有单点修改呢？单点修改有点炸裂我不会做在线（分块写的很少的蒟蒻），我们可以利用上面的CDQ时间分治做，考虑一次修改对于 preprepre 数组会造成什么影响？显然只会对后继第一个同色点有影响，我们可以对每个颜色开一个 set，直接 O(log⁡n)O(\log n)O(logn) 查询后继，O(1)O(1)O(1) 修改即可。
那区间修改呢？你确定区间修改不会炸到 O(nm)O(nm)O(nm) ？
其实是 O(n+m)O(n+m)O(n+m) （我一直以为会炸 O(nm)O(nm)O(nm) ）？
为什么？我们不妨考虑一个极端情况，一个相同数的最长连续段作为一个节点（其实就是 ODT 啦），如果一个节点附上一个值，只有节点第一个数的 preprepre 会被修改。
考虑 ODT 的过程，每次修改有分裂和合并，若分裂的话最多增加三个节点，对于 preprepre 来说分裂和修改 preprepre 的时间复杂度是基本一样的（不知道为啥看上面），我们最多添加 mmm 个节点，初始最多 nnn 个，于是修改次数最多就是 O(n+m)O(n+m)O(n+m)。
那么这样我们就可以找到 preprepre 数组被修改的位置，记录一下修改的时间，暴力单点修改就可以了，怎么找？直接上ODT，怎么求 preprepre ? 对每个颜色开ODT！。
不对啊你不说ODT被卡了吗，我们这里是求操作序列，不是直接用ODT求解，我们最后求解用的还是 CDQ 分治大神。
你疯啦开那么多 ODT？卡卡空间就可以了，离散化之后不会有很多的颜色。
但是这个空间很难受，我卡了50次才卡过。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e6,MC=3e5,MK=1e5+15;struct Node&#123;    int op,l,r,t,id;&#125;q[MN];int n,m,tot,qtot,ptot,mptot,ans[MN],lst[MN],pre[MK],a[MK];map&lt;int,int&gt; mp;struct BIT&#123;    int t[MK];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;struct ODTNode&#123;    int l,r,val;    bool operator&lt;(const ODTNode &amp;x)const&#123;        return l&lt;x.l;    &#125;&#125;;struct ODT&#123;    set&lt;ODTNode&gt; s,col[MC];    auto insert(int l,int r,int k)&#123;        col[k].insert(&#123;l,r,k&#125;);        return s.insert(&#123;l,r,k&#125;).first;    &#125;    void del(int l,int r,int k)&#123;        col[k].erase(&#123;l,r,k&#125;);        s.erase(&#123;l,r,k&#125;);    &#125;    auto split(int x)&#123;        auto it=s.lower_bound(&#123;x,0,0&#125;);        if(it!=s.end()&amp;&amp;it-&gt;l==x) return it;        it--;        int l=it-&gt;l,r=it-&gt;r,k=it-&gt;val;        del(l,r,k);        insert(l,x-1,k);        return insert(x,r,k);    &#125;    int getpre(int x)&#123;        auto it=s.upper_bound(&#123;x,0,0&#125;);        it--;        if(it-&gt;l&lt;x) return x-1;        else&#123;            auto co = col[it-&gt;val].lower_bound(&#123; x, 0, 0 &#125;);            if (co != col[it-&gt;val].begin()) return (--co)-&gt;r;            return 0;        &#125;    &#125;    void Assign(int l, int r, int v, int t) &#123;        auto itr = split(r + 1), itl = split(l);        vector&lt;int&gt; ps;        for (auto it = itl; it != itr; it++) &#123;            if (it != itl) ps.emplace_back(it-&gt;l);            auto nxt = col[it-&gt;val].upper_bound(*it);            if (nxt != col[it-&gt;val].end()) ps.emplace_back(nxt-&gt;l);            col[it-&gt;val].erase(*it);        &#125;        s.erase(itl, itr);        insert(l, r, v);        ps.emplace_back(l);        auto nxt = col[v].upper_bound(&#123; l, r, v &#125;);        if (nxt != col[v].end()) ps.emplace_back(nxt-&gt;l);        for (int i = 0; i &lt; ps.size(); i++) &#123;            q[++qtot] = &#123; -1,ps[i], pre[ps[i]], t, 0 &#125;;            pre[ps[i]] = getpre(ps[i]);            q[++qtot] = &#123; 1,ps[i], pre[ps[i]], t, 0 &#125;;        &#125;    &#125;&#125;odt;bool cmp1(Node x,Node y)&#123;    if(x.t==y.t)&#123;        return x.id&lt;y.id;    &#125;    return x.t&lt;y.t;&#125;bool cmp2(Node x,Node y)&#123;    if(x.l==y.l)return x.id&lt;y.id;    return x.l&lt;y.l;&#125;void cdq(int l,int r)&#123;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    cdq(l,mid);    cdq(mid+1,r);    // sort(q+l+1,q+mid+1,cmp2);    // sort(q+mid+1,q+r+1,cmp2);    int i=l,j=mid+1;    while(j&lt;=r)&#123;        while(q[i].l&lt;=q[j].l&amp;&amp;i&lt;=mid)&#123;            if(!q[i].id) bit.update(q[i].r+1,q[i].op);            // tmp[ttot++]=q[i++];            i++;        &#125;        if(q[j].id) ans[q[j].id]+=q[j].op*bit.query(q[j].r+1);        // tmp[ttot++]=q[j++];        j++;    &#125;    for(int p=l;p&lt;i;p++)&#123;        if(!q[p].id) bit.update(q[p].r+1,-q[p].op);    &#125;    // while(i&lt;=mid) tmp[ttot++]=q[i++];    // for(int p=l;p&lt;=r;p++) q[p]=tmp[p];    inplace_merge(q+l,q+mid+1,q+r+1,cmp2);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        if(!mp[a[i]]) mp[a[i]]=++mptot;        a[i]=mp[a[i]];        pre[i]=lst[a[i]];        lst[a[i]]=i;        q[++qtot]=&#123;1,i,pre[i],0,0&#125;;        odt.insert(i,i,a[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int op,l,r,d;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;        if(op==1)&#123;            cin&gt;&gt;d;            if(!mp[d]) mp[d]=++mptot;            d=mp[d];            odt.Assign(l,r,d,i);        &#125;else&#123;            q[++qtot]=&#123;1,r,l-1,i,++tot&#125;;            q[++qtot]=&#123;-1,l-1,l-1,i,tot&#125;;        &#125;    &#125;    stable_sort(q+1,q+1+qtot,cmp1);//归并排序防炸空间    cdq(1,qtot);    for(int i=1;i&lt;=tot;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 1.4 基于决策单调性的DP优化。
我们在讲四边形不等式优化DP做法的时候，我们给出了两个解法，一个是单调队列，另一个就是分治。
但是这个到底是什么分治？其实就是CDQ分治啦。
对于1D/1D 转移方程如下：
f(i)=min/max{g(j)+w(i,j)}1≤j&lt;if(i)=min/max\left\{g(j)+w(i,j) \right\}\quad 1\le j &lt; i
f(i)=min/max{g(j)+w(i,j)}1≤j&lt;i
其中有决策单调性即 w(i,j)w(i,j)w(i,j) 满足四边形不等式或反四边形不等式，这里 ggg 可以为 fff。
若转移方程是 g+w→fg+w \rightarrow fg+w→f 的转移，且 ggg 与 fff 的计算无关，也就是说转移是由一个已知的函数或这fff的上一层转移过来，那么我们就可以用 CDQ 分治的方法，这种决策是离线的，我们不依赖fi−1f_{i-1}fi−1​来计算fif_ifi​，这时候就不必采用单调队列这种顺序计算fif_ifi​了，只需要分治就可以，编码更简单也更灵活。
算法步骤：

初始化：首先暴力遍历j∈[1,n/2)j\in[1,n/2)j∈[1,n/2)来计算pn/2p_{n/2}pn/2​，作为分治的中心点。
分治求解：接下来分别计算2个区间[1,n/2)[1,n/2)[1,n/2)和(n/2,2](n/2,2](n/2,2]的pip_ipi​。

对于前半段，最优决策点一定在[1,pn/2][1,p_{n/2}][1,pn/2​]之间。
对于后半段，最优决策点一定在[pn/2,pn][p_{n/2},p_n][pn/2​,pn​]之间。


递归处理即可。

代码实现如下：
int clac(int i,int j); //计算选择决策j的费用// l,r是决策区间，kl,kr是决策点的区间void dfs(int l,int r,int kl,int kr)&#123;	int mid=(l+r)&gt;&gt;1,k=kl;	for(int i=kl;i&lt;=min(kr,mid-1);i++)&#123;		//求费用最少的f[mid]最优决策点		if(clac(mid,i)&lt;clac(mid,k)) k=i;		f[mid]=clac(mid,k);	&#125;	if(l&lt;mid) dfs(l,mid-1,kl,k);	if(r&gt;mid) dfs(mid+1,r,k,kr);&#125;//ans=f[n];
这个的证明和基于时间分治的证明类似，这里不给出了。
 2. 整体二分
 2.1 基于值域的整体二分

在信息学竞赛中，有一部分题目可以使用二分的办法来解决。但是当这种题目有多次询问且我们每次查询都直接二分可能导致 TLE 时，就会用到整体二分。整体二分的主体思路就是把多个查询一起解决。（所以这是一个离线算法）——OiWiki

我们考虑一下这个问题：

给定长度为 nnn 的序列 aaa，求序列 aaa 中第 kkk 小的数。

这题怎么做都可以，我们可以考虑一个二分答案的做法。
先从小到大排序，二分答案，设当前二分值域的值为 midmidmid，统计序列中有多少个数 ≤mid\le mid≤mid，记为 cntcntcnt。

若 k≤cntk \le cntk≤cnt，那么 ans∈[l,mid]ans\in [l,mid]ans∈[l,mid]，直接二分即可。
若 k&gt;cntk&gt;cntk&gt;cnt，那么 ans∈[mid+1,r]ans\in [mid+1,r]ans∈[mid+1,r]，等价于在值域 [mid+1,r][mid+1,r][mid+1,r] 找第 k−cntk-cntk−cnt 小的数，那么直接 k−=cntk-=cntk−=cnt 让后直接在右半区间继续二分。

这样时间复杂度为 O(nlog⁡∣V∣)O(n\log |V|)O(nlog∣V∣) ，其中 VVV 为值域。
如果我们加强一下呢？

给定长度为 nnn 的序列 aaa，给定 mmm 次询问，每次询问区间 [l,r][l,r][l,r] 的中第 kkk 小的数。

这题我会，主席树吗。
我们看看怎么用整体二分来写。
记 [l,r][l,r][l,r] 为答案的值域，[L,R][L,R][L,R] 为答案的定义域。（也就是说求答案时仅考虑下标在区间 [L,R][L,R][L,R] 内的操作和询问，这其中询问的答案在 [l,r][l,r][l,r] 内）

我们首先把所有操作 按时间顺序 存入数组中，然后开始分治。
在每一层分治中，利用数据结构（常见的是树状数组）统计当前查询的答案和 midmidmid 之间的关系。
根据查询出来的答案和 midmidmid 间的关系（小于等于 midmidmid 和大于 midmidmid）将当前处理的操作序列分为 q1q1q1 和 q2q2q2 两份，并分别递归处理。
当 l=rl=rl=r 时，找到答案，记录答案并返回即可。

代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=4e5+15,INF=1e9,MK=2e5+15;struct Query&#123;    int x,y,z,id;&#125;q[MN],lq[MN],rq[MN];int n,m,qtot,a[MK],ans[MK];struct BIT&#123;    int t[MK];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;&#125;bit;void solve(int l,int r,int st,int ed)&#123;    if(st&gt;ed) return;    if(l==r)&#123;        for(int i=st;i&lt;=ed;i++)&#123;            if(q[i].id) ans[q[i].id]=l;        &#125;        return;    &#125;    int mid=(l+r)&gt;&gt;1,lt=0,rt=0;    for(int i=st;i&lt;=ed;i++)&#123;        if(q[i].id==0)&#123;            if(q[i].y&lt;=mid)&#123;                bit.update(q[i].x,1);                lq[++lt]=q[i];            &#125;else rq[++rt]=q[i];        &#125;else&#123;            int cnt=bit.query(q[i].y)-bit.query(q[i].x-1);            if(cnt&gt;=q[i].z) lq[++lt]=q[i];            else q[i].z-=cnt,rq[++rt]=q[i];        &#125;    &#125;    for(int i=ed;i&gt;=st;i--) if(q[i].id==0&amp;&amp;q[i].y&lt;=mid) bit.update(q[i].x,-1);    for(int i=1;i&lt;=lt;i++) q[st+i-1]=lq[i];    for(int i=1;i&lt;=rt;i++) q[st+lt+i-1]=rq[i];    solve(l,mid,st,st+lt-1);    solve(mid+1,r,st+lt,ed);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        q[++qtot]=&#123;i,a[i],0,0&#125;;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,k;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        q[++qtot]=&#123;l,r,k,i&#125;;    &#125;    solve(-INF,INF,1,qtot);    for(int i=1;i&lt;=m;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 2.2 例题
 P1527 [国家集训队] 矩阵乘法
二维树状数组即可，这个真的没什么好讲的，注意一下求一个矩阵点要容斥一下。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=520,MQ=5e5+15,INF=1e9+7;struct Query&#123;    int x1,y1,x2,y2,k,id;&#125;q[MQ],lq[MQ],rq[MQ];int n,m,qtot,atot,tot,ans[MQ],a[MN];struct ewBIT&#123;    int t[MN][MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int x,int y,int k)&#123;        for(int i=x;i&lt;MN;i+=lowbit(i))&#123;            for(int j=y;j&lt;MN;j+=lowbit(j))&#123;                t[i][j]+=k;            &#125;        &#125;    &#125;    int query(int x,int y)&#123;        int ret=0;        for(int i=x;i;i-=lowbit(i))&#123;            for(int j=y;j;j-=lowbit(j))&#123;                ret+=t[i][j];            &#125;        &#125;        return ret;    &#125;&#125;bit;void solve(int l,int r,int st,int ed)&#123;    if(st&gt;ed) return;    if(l==r)&#123;        for(int i=st;i&lt;=ed;i++)&#123;            ans[q[i].id]=l;        &#125;        return;    &#125;    int mid=(l+r)&gt;&gt;1,lt=0,rt=0;    for(int i=st;i&lt;=ed;i++)&#123;        if(!q[i].id)&#123;            if(q[i].k&lt;=mid) bit.update(q[i].x1,q[i].y1,1),lq[++lt]=q[i];            else rq[++rt]=q[i];        &#125;else&#123;            int cnt=bit.query(q[i].x2,q[i].y2)-bit.query(q[i].x2,q[i].y1-1)-bit.query(q[i].x1-1,q[i].y2)+bit.query(q[i].x1-1,q[i].y1-1);            if(cnt&gt;=q[i].k) lq[++lt]=q[i];            else q[i].k-=cnt,rq[++rt]=q[i];        &#125;    &#125;    for(int i=ed;i&gt;=st;i--) if(!q[i].id&amp;&amp;q[i].k&lt;=mid) bit.update(q[i].x1,q[i].y1,-1);    for(int i=1;i&lt;=lt;i++) q[st+i-1]=lq[i];    for(int i=1;i&lt;=rt;i++) q[st+lt+i-1]=rq[i];    solve(l,mid,st,st+lt-1);    solve(mid+1,r,st+lt,ed);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            int x;            cin&gt;&gt;x;            q[++qtot]=&#123;i,j,0,0,x,0&#125;;            a[++tot]=x;        &#125;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int x1,y1,x2,y2,k;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;k;        q[++qtot]=&#123;x1,y1,x2,y2,k,i&#125;;    &#125;    solve(-INF,INF,1,qtot);    for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 P4602 [CTSC2018] 混合果汁
发现询问独立，答案可二分，并且可离线，考虑整体二分。
我们实际上二分美味度，将美味度大于等于 midmidmid 的果汁搞出来，按照单价从小到大，求买 LiL_iLi​ 升的价格。我们可以用树状数组维护单价，二分树状数组求得最大单价 ppp 使得单价不大于 ppp 的果汁体积 L&lt;LiL&lt;L_iL&lt;Li​，买单价不大于 ppp 的果汁和 Li−LL_i-LLi​−L 升单价为 ppp 的果汁即可。
树状数组二分可以倍增写，注意每次递归前要把美味度小于 LLL （这里 LLL 是值域的 L）已经加入树状数组，这样才能保证复杂度仅与 R−LR-LR−L 相关。
时间复杂度 O((n+mlog⁡2(n+m)))O((n+m \log^2 (n+m)))O((n+mlog2(n+m)))。
]]></content>
      <categories>
        <category>离线</category>
      </categories>
      <tags>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1474F题解</title>
    <url>/posts/7eadb925/</url>
    <content><![CDATA[头脑风暴！
注意到 xxx 对答案一点用都没有，因为我们求的是长度，光一个 ddd 就能够确定答案了。
发现最长严格上升子序列的性质不太好刻画，我们考虑这个添加数的操作过程能不能以一种形式来表现出来。注意到每一个数具体取值只和最后一个数的变化有关，而且变化是连续的，考虑给它拍到二维平面上，横轴按照每一次添加一个数划分时间，纵轴为最后一个值的具体取值，原操作在二维平面上表现的是斜率为 1 或 -1 的一堆直线，如下图，红点表示一次插入操作的：

最长严格上升子序列的性质就很好刻画了，因为根据图来看其实就是最低点和最高点的极差就是我们的长度（因为斜率为 ±1\pm 1±1）。让后我们考虑这个子序列个数怎么解决。发现直接 DP 求解答案十分困难，考虑发掘性质，首先不难发现一个性质：一个段不可能贡献超过一种答案，即一个点不可能成为最低点或最高点。
这个性质有什么用呢，也就是说，我们可以统计对段的答案进行贡献统计。然而注意到段数极小（数据范围 nnn），值域极大，有一个强烈的矩阵味道，但是我到现在连状态都没设计耶？
最长严格上升子序列可能从任意值拼过来，考虑在状态中加上这一个，设 f(i,j)f(i,j)f(i,j) 表示目前计算到第 iii 段，末尾值为 jjj 的方案数，哎这矩阵味道对了，转移：
f(i,j)=∑k=0if(k,j−1)f(i,j)=\sum\limits_{k=0}^i f(k,j-1)
f(i,j)=k=0∑i​f(k,j−1)
矩阵快速幂优化，时间复杂度 O(n4log⁡∣V∣)O(n^4 \log |V|)O(n4log∣V∣)。
Submission #333002703
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF573D题解</title>
    <url>/posts/376987c3/</url>
    <content><![CDATA[好题。
有一个显然的想法就就是二分图带权最大匹配，但是时间复杂度是 O(n3)O(n^3)O(n3) 及其难受，考虑 DP 但直接 DP 十分困难，考虑发掘一些性质。
利用贪心思想，先对 www 和 hhh 进行从小到大的排序，一个基本思想就是对应位置的相乘，用调整法不难证明这是最优决策，但是本题目中存在第 iii 个人不能骑自己的马，所以最优解可能不会取到。
考虑到这个限制只是限制自己不能骑自己的马，合理猜测 iii 位置匹配马的决策是一个范围，有结论：匹配范围为 [i−2,i+2][i-2,i+2][i−2,i+2]。证明考虑反证法，设 iii 的禁止匹配位置为 baniban_{i}bani​。那么反证法，假设如果在这个以外的范围选，那么最多向前会造成两次 (i,i−1)(i,i-1)(i,i−1) 无法匹配，自行画图发现这种情况最劣情况下也只会在 i−2i-2i−2 的情况形成匹配。
借用 _sys的图：

完美匹配至少有三个红线和黑线相交整法不难证明如果两条线相交那么交换这两个匹配会得到更优的解。
让后考虑交换的过程，我们如果前 iii 个人和前 iii 匹马匹配完全，那么存在 k&lt;3k&lt;3k&lt;3，[i,i+k][i,i+k][i,i+k] 这区间内的人和马匹配，可以用反证法证明。
故，设 fif_{i}fi​ 表示前 iii 个人和前 iii 匹马完成匹配的最大全职，所以从 fi−3,fi−2,fi−1f_{i-3},f_{i-2},f_{i-1}fi−3​,fi−2​,fi−1​ 转移过来即可，同时改成矩阵方式维护 DP 做动态 DP 即可，时间复杂度 O(27nlog⁡n)O(27n \log n)O(27nlogn)，其中 272727 是矩阵带来的常数。
提交记录
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Fail树</title>
    <url>/posts/18adad6c/</url>
    <content><![CDATA[ 0.引入
我们在写KMP的时候会求出来长度为nnn的字符串的前缀最长border的长度为Next[n]Next[n]Next[n]，接下来先介绍一个border

定义：对于一字符串SSS，用∣S∣|S|∣S∣表示其长度，后面我们简化用lenSlen_SlenS​来表示，那么SSS串的一个Border一定是SSS串的一个前缀，并且他前缀和后缀都能够相互匹配。举个例子，比如说“BeckyBe”的一个border就是Be,一个字符串的border可能有多个，但在这里我们要求的是最长的border
对于任意一个字符串SSS，一个Border的长度就对应一个Border（比如说上面的长度为2各border只能是“Be”），我们可以求出他所有border的长度分别为ne[ne[ne[lenSlen_SlenS​]，ne[ne[ne[ne[ne[ne[lenSlen_SlenS​]]]]]] 以此类推直到为0。根据上面的结论，我们可以知道，对一个字符串S求解next数组之后，我们就知道了S所有前缀（包括S自身）的所有Border了。

 1.Fail树
fail树就是把所有next[i]next[i]next[i]的节点指向iii的有向边所构成的树，这课树，是自底部指向顶部，最终汇聚到一个rootrootroot点。
例如一个字符串“aaaabbabbaa”，我们可以得到他的nextnextnext数组如下
POS:1 2 3 4 5 6 7 8 9 10 11S:  a a a a b b a b b a  aNe: 0 1 2 3 0 0 1 0 0 1  2 
我们画出他的fail树就是如下

结合前面Border的结论，在fail树上，一个结点x不断向上寻找祖先的过程，就是遍历字符串S[1,x]的所有Border长度的过程，又因为Border的长度和Border一一对应，所以fail树上就记录着字符串S所有前缀的Border。
根据前面所说，我们就能推出以下结论，S的两个前缀S[1,p]和S[1,q]的公共最长Border长度，就是Lca(ne[p],ne[q])Lca(ne[p],ne[q])Lca(ne[p],ne[q])
到这里你应该就能理解KMP在失配的情况下其实就是在回溯fail树。
模板失配树
代码如下
#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MN=1e6+15,ML=20;string s;int m,fa[MN][40],dep[MN],pre[MN],n;int lca(int x,int y)&#123;    if(dep[x]&lt;dep[y]) swap(x,y);    for(int i=__lg(n)+1;i&gt;=0;i--)&#123;        if(dep[x]-(1&lt;&lt;i)&gt;=dep[y])x=fa[x][i];    &#125;    if(x==y) return x;    for(int i=__lg(n)+1;i&gt;=0;i--)&#123;        if(fa[x][i]!=fa[y][i])&#123;            x=fa[x][i];            y=fa[y][i];        &#125;    &#125;    return fa[x][0];&#125;int main()&#123;    cin&gt;&gt;s;    n=s.length();    s=&quot; &quot;+s;    //cout&lt;&lt;&quot;N:&quot;&lt;&lt;n&lt;&lt;endl;    for(int i=2,j=0;i&lt;=n;i++)&#123;        while(j&amp;&amp;s[i]!=s[j+1])&#123;            j=pre[j];        &#125;        if(s[i]==s[j+1])j++;        pre[i]=j;        fa[i][0]=j;        dep[i]=dep[j]+1;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;pre[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    for(int k=1;k&lt;=__lg(MN)+1;k++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            fa[j][k]=fa[fa[j][k-1]][k-1];        &#125;    &#125;    cin&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;fa[i][0]&lt;&lt;endl;    &#125;    while (m--)    &#123;        int p,q;        cin&gt;&gt;p&gt;&gt;q;        cout&lt;&lt;lca(fa[p][0],fa[q][0])&lt;&lt;endl;    &#125;        return 0;&#125;
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Hall定理</title>
    <url>/posts/6cf9e98c/</url>
    <content><![CDATA[ 1. Hall 定理
对于一张二分图，设两部分点数为 (x,y)(x,y)(x,y)，则其的一个完备匹配定义为左部分 xxx 个点成为匹配点，特别的，当 x=yx=yx=y 的时候这列匹配也称作完备匹配。
一个如上定义的二分图存在完备匹配的充要条件是对于左部分大小为 kkk 的任意子集 SSS，这些点在右部连到的点集，记作 N(S)N(S)N(S)，的大小不小于 kkk，即 ∣S∣≥∣N(S)∣|S|\ge |N(S)|∣S∣≥∣N(S)∣。
证明见： 「学习笔记」Hall定理。
上面就是 Hall 定理，下面是它的推论。

二分图存在大小为 kkk 的匹配，当且仅当 ∀S,∣S∣≤∣N(S)∣−k\forall S,|S|\le|N(S)|-k∀S,∣S∣≤∣N(S)∣−k。

进一步推论：

若使 GGG 中存在完美匹配，则最少补充 max⁡{0,∣S∣−∣N(S)∣}\max\{ 0,|S|-|N(S)| \}max{0,∣S∣−∣N(S)∣} 条边。

我们还有网络流的形式：

设左部点的流量为 aia_{i}ai​，右部点的流量为 bib_{i}bi​，那么有左部点满流，当且仅当 ∀S,∑i∈Sai≤∑i∈NSbi\forall S,\sum_{i\in S} a_i\le \sum_{i\in N_S} b_i∀S,∑i∈S​ai​≤∑i∈NS​​bi​。

最大匹配：

二分图 GGG 的最大匹配为 ∣S∣−max⁡(∣S′∣−∣N(S′)∣)|S|-\max(|S&#x27;|-|N(S&#x27;)|)∣S∣−max(∣S′∣−∣N(S′)∣)，其中 SSS 为左部点集合，S′S&#x27;S′ 为 SSS 子集。

 2.k-正则二分图
k-正则二分图，即所有点度数均为 kkk 的二分图。
k-正则二分图存在 kkk 组不相交的完美匹配，证明考虑 Hall 定理：选出 aaa 个左部点，他们的度数为 akakak，连到右部点上，至少有 kkk 个点，所以此时存在一组完美匹配，删去所有匹配边，k-正则二分图变成了 k-1-正则二分图，归纳即可。
如何快速求出一个 k-正则二分图的完美匹配呢？
利用随机化：
算法如下：

重复 NNN 次：
随机选一个左边的未匹配点，然后沿增广路随机游走（即从左往右随机走未匹配边，从右往左走匹配边），直到走到一个右边的未匹配点。
把走出来的环去掉（找到最后一个出现过多次的点，然后把第一次走到它到最后一次走到它中间的这段路砍掉）。这样就找到了一条增广路。对它进行增广以把匹配数增加 111。

这样的时间复杂度是 O(nlog⁡n)O(n\log n)O(nlogn)。
 3. 习题
 CF1519F
设 LxL_xLx​ 表示第 xxx 个宝箱上所有锁的集合，则对于宝箱选取的集合 SSS 要满足：
∑i∈Sai≤∑j∈∪i∈SLibj\sum\limits_{i\in S} a_{i}\le \sum\limits_{j\in \cup_{i\in S} L_{i}} b_{j}
i∈S∑​ai​≤j∈∪i∈S​Li​∑​bj​
这个形式长得很想 Hall 定理的形式，考虑转化，对于每一个宝箱 iii，我们把这个宝箱拆成 aia_{i}ai​ 个点，同理于锁拆成 bjb_{j}bj​ 个点。如果宝箱 iii 上有锁 jjj，则将宝箱 iii 拆出的所有点连一条边到锁 jjj 拆出的所有点，得到一个二分图，其中宝箱拆成的点在二分图的左部，则要求这个图的左部存在完美匹配（即左部每个点都能和右部的一个点匹配，且匹配点互不相同），下面只需要构造出这个完美匹配即可。
设 f(i,S)f(i,S)f(i,S) 表示考虑到第 iii 个宝箱的点，右部点的锁拆除的点钟还没有被匹配的个数，最少要花费多少。
专一考虑枚举当前宝箱对应匹配上的点，如果匹配上至少一个锁 jjj 拆出的点，则花费的钱要加上 ci,jc_{i,j}ci,j​，最后取 f(n,∗)f(n,*)f(n,∗) 的最小值即为答案，时间复杂度 O(n×52n)O(n\times 5^{2n})O(n×52n)。
 ARC076D
用上面补充边的定理，把人看做左部点，而椅子看做右部点，人向 i∈[1,li]∪[ri,m]i\in [1,l_{i}] \cup [r_{i},m]i∈[1,li​]∪[ri​,m] 连边。
那么节点数为 m−(r−l+1)=m−r+l−1m-(r-l+1)=m-r+l-1m−(r−l+1)=m−r+l−1，由霍尔定理不难得出答案为 ∣S∣−m+r−l+1|S|-m+r-l+1∣S∣−m+r−l+1。
考虑到数据范围不允许暴力枚举 SSS，考虑优化，考虑对右部区间 [L,R][L,R][L,R] 找出对应的做不节点，将人按 lil_ili​ 升序让后扫描线存储 rir_{i}ri​，将又不借点映射上去，每次将左端点 lll 的 rir_{i}ri​ 更新入线段树区间加一，让后求 [L,m][L,m][L,m] 的最大值即可。
代码咕咕咕，写太多外部题库的题了？
 P3488
显然的二分图完备匹配，但是显然 O(nlog⁡n)O(n \log n)O(nlogn) 直接会直接炸缸，考虑优化。
利用 Hall 定理，令 cnticnt_{i}cnti​ 表示 [l,r][l,r][l,r] 中 iii 号码的出现次数，那么满足条件如下：
∑i=lrcnti≤k×(r−k+1+d)\sum\limits_{i=l}^r cnt_{i}\le k\times (r-k+1+d)
i=l∑r​cnti​≤k×(r−k+1+d)
进一步化简有：
∑i=lrcnti−k≤k×d\sum\limits_{i=l}^r cnt_{i}-k \le k \times d
i=l∑r​cnti​−k≤k×d
维度动态最大子段和即可，时间复杂度 O(mlog⁡n)O(m\log n)O(mlogn)。
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2018会议题解</title>
    <url>/posts/43fb7374/</url>
    <content><![CDATA[可能更洛谷的阅读体验
很好的题，能够很好的练习枚举最大值转移 DP。
我们一步一步来，顺着 subtask 来走：
有一个显然的想法，就是暴力选取开会的位置，直接做即可，复杂度 O(n2q)O(n^2 q)O(n2q)。
考虑 sub 2 如何做，首先注意到询问的是一个区间的答案，我们可以暴力预处理出来，但时间复杂度要在 O(n2)O(n^2)O(n2) 以内，怎么做？注意到我们实际上不用暴力枚举，我们只需要一个区间的最大值出现在哪里，这个最大值将会贡献答案，让后枚举把会议丢在该位置左边还是右边即可。
具体来说，我们设 f(l,r)f(l,r)f(l,r) 表示在 [l,r][l,r][l,r] 的位置区间选会议的最小代价，转移是显然的：
f(l,r)=min⁡{f(l,p−1)+(r−p+1)×ap,f(p+1,r)+(p−l+1)×ap}f(l,r)=\min\left\{f(l,p-1)+(r-p+1) \times a_p,f(p+1,r)+(p-l+1) \times a_{p} \right\}
f(l,r)=min{f(l,p−1)+(r−p+1)×ap​,f(p+1,r)+(p−l+1)×ap​}
ppp 即为 [l,r][l,r][l,r] 的最大值，发现这两边形式一致，就可以只考虑一半东西，然后另一半直接将序列翻转再做一遍即可得到，利用 st 表即可做到 19 分。
我们观察这个转移方程，多次涉及区间 max⁡\maxmax 来进行转移，我们考虑笛卡尔树，不难发现我们枚举的最大值节点就是笛卡尔树的根节点，转移方程实际上就是在对左右儿子的答案进行统计，注意到原题目标准复杂度为 O(qlog⁡n)O(q \log n)O(qlogn)，启示我们使用一些数据结构优化。
首先因为这是类似于笛卡尔树的 DP，我们可以考虑类似于树形 DP 的方式，从底往上进行 DP，但是如果直接做仍是 O(n2)O(n^2)O(n2) 的，怎么办，自底向上合并答案？考虑这个东西我们可以用线段树试试？注意到线段树刚好符合上面的转移方程（甜菜的想法），观察上面的转移方程刚好符合线段树的区间形式。考虑转移，不对暴力转移还是 O(n2)O(n^2)O(n2) 的啊！我们根据转移方程，。发现 iii 越小，在左侧所需代价一定越来越小，而 iii 越来越大的时候，在右侧所需代价也一定越来越小，这两个形似一次函数，具有单调性，考虑线段树二分找交点（俗称转移优化），交点左侧为左侧的 DP 更新，右侧即右侧更新，线段树即可做：
这就是我们所说的枚举最大值转移，枚举最大值转移 DP，实际上就是排列在笛卡尔树结构上的 DP（注意不是真正的笛卡尔树），有点类似于分治的思想。我们利用的是一个笛卡尔树的性质：我们设一个区间 [l,r][l,r][l,r] 最大值的位置为 pospospos，发现可以把区间分成 [l,pos][l,pos][l,pos] 和 [pos,r][pos,r][pos,r] 两个区间，并且两个区间互不影响，也就是说我左边怎么乱搞放数也不会影响右边的区间。这个时候全局最大值作为区间的端点出现。自底向上类似 “树形 DP” 来合并区间。
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=8e5+15;struct Query&#123;    int l,r;&#125;qry[MN];int n,q,ans[MN],h[MN],st[MN][30],arcst[MN][30],lg[MN];vector&lt;int&gt; pos[MN];struct Segment&#123;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,cov,k,b,lmx,rmx;    &#125;t[MN&lt;&lt;2];    void docov(int p)&#123;        t[p].cov=1;        t[p].k=t[p].b=t[p].lmx=t[p].rmx=0;    &#125;    void doadd(int p,int k,int b)&#123;        t[p].k+=k;        t[p].b+=b;        t[p].lmx+=k*t[p].l+b;        t[p].rmx+=k*t[p].r+b;    &#125;     void pushdown(int p)&#123;        if(t[p].cov)&#123;            docov(ls);            docov(rs);        &#125;        if(t[p].k||t[p].b)&#123;            doadd(ls,t[p].k,t[p].b);            doadd(rs,t[p].k,t[p].b);        &#125;        t[p].cov=t[p].k=t[p].b=0;    &#125;    void pushup(int p)&#123;        t[p].lmx=t[ls].lmx,t[p].rmx=t[rs].rmx;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void update(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            doadd(p,0,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) update(ls,fl,fr,k);        if(mid&lt;fr) update(rs,fl,fr,k);        pushup(p);    &#125;    void merge(int p,int fl,int fr,int k,int b)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            int lv=t[p].l*k+b,rv=k*t[p].r+b;            if(lv&gt;=t[p].lmx&amp;&amp;t[p].rmx&lt;=rv) return;            if(t[p].lmx&gt;=lv&amp;&amp;rv&lt;=t[p].rmx)&#123;                docov(p);                doadd(p,k,b);                return;            &#125;        &#125;          pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) merge(ls,fl,fr,k,b);        if(mid&lt;fr) merge(rs,fl,fr,k,b);        pushup(p);    &#125;    int querylmx(int p,int pos)&#123;        if(t[p].l==t[p].r) return t[p].lmx;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) return querylmx(ls,pos);        return querylmx(rs,pos);    &#125;    int queryrmx(int p,int pos)&#123;        if(t[p].l==t[p].r) return t[p].rmx;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) return queryrmx(ls,pos);        else return queryrmx(rs,pos);    &#125;#undef ls#undef rs&#125;s,t;void initst()&#123;    for(int j=1;j&lt;=20;j++)&#123;        for(int i=1;i&lt;=n;i++)&#123;            if(i+(1&lt;&lt;j)-1&gt;n) break;            st[i][j]=max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);            if(st[i][j]==st[i][j-1]) arcst[i][j]=arcst[i][j-1];            else arcst[i][j]=arcst[i+(1&lt;&lt;(j-1))][j-1];        &#125;    &#125;&#125;int cmp(int l,int r)&#123;    int len=__lg(r-l+1);    if(st[l][len]&gt;=st[r-(1&lt;&lt;len)+1][len])&#123;        return arcst[l][len];    &#125;else return arcst[r-(1&lt;&lt;len)+1][len];&#125;void solve(int l,int r)&#123;    if(l&gt;r) return;    int mid=cmp(l,r);    solve(l,mid-1);    solve(mid+1,r);    for(auto now:pos[mid])&#123;        ans[now]=h[mid]*(qry[now].r-qry[now].l+1);        if(qry[now].l&lt;mid)&#123;            ans[now]=min(ans[now],s.querylmx(1,qry[now].l)+h[mid]*(qry[now].r-mid+1));        &#125;        if(qry[now].r&gt;mid)&#123;            ans[now]=min(ans[now],t.queryrmx(1,qry[now].r)+h[mid]*(mid-qry[now].l+1));        &#125;    &#125;    int sx=h[mid],tx=h[mid];    if(l&lt;mid) tx+=t.queryrmx(1,mid-1);    if(r&gt;mid) sx+=s.queryrmx(1,mid+1);    s.update(1,mid,mid,sx);    t.update(1,mid,mid,tx);    if(l&lt;mid)&#123;        s.update(1,l,mid-1,h[mid]*(r-mid+1));        s.merge(1,l,mid-1,-1*h[mid],sx+mid*h[mid]);    &#125;    if(r&gt;mid)&#123;        t.update(1,mid+1,r,h[mid]*(mid-l+1));        t.merge(1,mid+1,r,1ll*h[mid],tx-1ll*mid*h[mid]);    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;h[i];        st[i][0]=h[i];        arcst[i][0]=i;    &#125;    for(int i=1;i&lt;=q;i++)&#123;        cin&gt;&gt;qry[i].l&gt;&gt;qry[i].r;        qry[i].l++;        qry[i].r++;    &#125;    initst();    for(int i=1;i&lt;=q;i++)&#123;        pos[cmp(qry[i].l,qry[i].r)].push_back(i);    &#125;    s.build(1,1,n);    t.build(1,1,n);    solve(1,n);    for(int i=1;i&lt;=q;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal重构树学习笔记</title>
    <url>/posts/6d897253/</url>
    <content><![CDATA[ 1.算法简介
我们回忆一下 Kruskal 求最小生成树的过程，可以表述为以下：

将边按照边权从小到大进行排序。
若当前边 (u,v)(u,v)(u,v) 两端不连通，我们就在生成树的边集中加入这条边并连接 (u,v)(u,v)(u,v)，关于连通性显然我们可以考虑利用冰茶几维护。

有的时候，我们可能想要求得信息就和边权的大小关系有关，例如路径上的最大边权和最小边权，你可能会想到使用最小生成树，但是问题在于最小生成树上的边权是乱序的，但是我们发现在构建的最小生成树的过程就可以解决这个路径上最大边权和最小边权问题。
如果能用某种结构描述每条边被连接的先后顺序就很好了，因为越往后加入的边权就越大，就可以快速刻画边权有限制的图连通性了。
于是我们就有了 Kruskal 重构树！它在 Kruskal 的过程上进行了一些改进：

将边按照边权进行排序。
若当前边 (u,v)(u,v)(u,v) 两端不连通，连接 u,vu,vu,v 的时候找到 u,vu,vu,v 的代表元 U,VU,VU,V。新建节点 ccc，将并查集中 U,VU,VU,V 的父亲设为 ccc，并在图上连边 c→Uc\to Uc→U 和 c→Vc\to Vc→V。注意 U,VU,VU,V 可能不是原树节点。
通常将 ccc 的权值 wcw_{c}wc​ 设置为边的边权，为虚点设置权值方便解题，巧妙设置点权对解题有极大帮助。

如果图是联通的，如上操作将会得到一颗大小为 2n−12n-12n−1 且以 2n−12n-12n−1 为根的二叉树 TTT，这个就是 kruskal 重构树。
以下为例子，原图：

Kruskal 重构树：

以下为构建代码：
struct Edge&#123;    int u,v,w;&#125;e[MN];int dtot;namespace EXKru&#123;    int pre[MN];    void initpre()&#123;        for(int i=0;i&lt;MN;i++)&#123;            pre[i]=i;        &#125;    &#125;    int root(int x)&#123;        if(pre[x]==x) return pre[x];        else return pre[x]=root(pre[x]);    &#125;    bool cmp(Edge x,Edge y)&#123;        return x.w&lt;y.w;    &#125;    void solve()&#123;        sort(e+1,e+n,cmp);        dtot=n;        for(int i=1;i&lt;n;i++)&#123;            int ru=root(e[i].u),rv=root(e[i].v);            if(ru!=rv)&#123;                dtot++;                val[dtot]=e[i].w;                pre[ru]=pre[rv]=dtot;                adj[dtot].push_back(ru);                adj[dtot].push_back(rv);                if(dtot==2*n-1) break;            &#125;        &#125;    &#125;&#125;
Kruskal 重构树有一些优秀的性质：

重构树是一颗二叉树。
原图 GGG 中所有叶子是重构树 TTT 的叶子，原节点和重构树叶子节点本质相同。
对于任意新节点 uuu 及其祖先 vvv，满足 wu≤wvw_{u}\le w_{v}wu​≤wv​，默认叶子 w=0w=0w=0。

第三个性质是十分重要，我们在做题的时候将会重复利用该性质，它的推论：原节点 xxx 在原图上经过权值 ≤d\le d≤d 的边可到达的所有点就是它在重构树上，最浅的祖先 xxx 满足权值 ≤d\le d≤d 的子树内所有叶子节点。翻译下就是从一个叶子节点 xxx 倍增找到满足权值 ≤d\le d≤d 的最浅祖先 fafafa，那么 fafafa 子树内所有叶子就是原图仅保留边权 ≤d\le d≤d 的边时 xxx 所在连通块的所有点。
进一步的，原图中两个点间所有路径上的边最大权值的最小值 = 最小生成树上两点简单路径的边最大权值 = Kruskal 重构树上两点 LCA 的点权。
综上我们可以总结出一个套路，当题目限制涉及只经过权值不大于某个值的点或边的时候，我们可以从 Kruskal 的角度入手。如果我们想要利用这个刻画图连通性，我们可以通过利用可持久化冰茶几来实现动态图连通性的刻画，我们会在例题中详细说明其应用。
 2. 例题
 最小瓶颈路
建立 Kruskal 重构树，那么答案就是 A 点与 B 点 LCA 的点权，因为至少要满足图联通必须从 LCA 开始往上，显然不可能再往上走不然点权会更大，所以必定是 LCA。
 P4197 Peaks
上面性质的拓展应用，先建立 Kruskal 重构树，每次询问找到 xxx 祖先中点权 ≤v\le v≤v 的最浅祖先，那么答案就是子树中叶子节点点权第 kkk 大，用主席树维护即可。
 [AGC002D] Stamp Rally
翻译全部错误 666.
最大编号尽可能小，考虑二分。问题转化为求经过边编号 ≤mid\le mid≤mid 的 x→yx\to yx→y 路径上点数量，将边权设置为边的编号，那么命题关系求两点路径最大权值最小值，容易想到 Kruskal 重构树，且这题限制了经过点的个数要恰好为 zzz，不能大也不能小，所以二分是一个比较好的解决方案。时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
 P3684 [CERC2016] 机棚障碍 Hangar Hurdles
先考虑我们初始点最大能放多少，由于是一个正方形，我们考虑前缀和预处理这个网格图，然后二分求出最大长度。这样我们就能得出每一个点所能容纳的最大正方形长度 ddd。利用这个 ddd 我们对于正方形每一个点向四周连边，边权设置为 min⁡(du,dv)\min(d_{u},d_{v})min(du​,dv​)，那么命题转化为求起点到终点的路径上边的权值最小值的最大值，用 Kruskal 重构树即可解决，但是为题在于连边过多，我们考虑对于 ddd 相同的点缩点即可，时间复杂度 O(n2log⁡n)O(n^2 \log n)O(n2logn)。在实现细节方面，我们注意到，由于障碍的存在，所以可能最后得到的是森林而不是一棵树。考虑到树与树之间是不连通的，所以我们完全可以新建一个节点连向这些树，并把点权设为 0，就可以直接按照普通一棵树的情况来做了。
码力题不写。
 AT_arc098_d [ARC098F] Donation
牛牛牛
首先不难发现一个性质就是如果我们在某个地方给塞钱了之后我们肯定之后就不回来这里。同时发现答案必定 ≥∑Bi\ge \sum\limits B_{i}≥∑Bi​，考虑到给钱很难想，正难则反考虑倒着走领钱，设 ci=max⁡(ai−bi,0)c_{i}=\max(a_{i}-b_{i},0)ci​=max(ai​−bi​,0)，不难发现题目的条件就是要求满足到达点 iii 的时候满足 val≥cival\ge c_{i}val≥ci​，如果不满足就补充即可。如果是第一次经过令 val←val+bival\leftarrow val+b_{i}val←val+bi​。
这玩意怎么做？考虑最小生成树，令边权为 max⁡(cu,cv)\max(c_{u},c_{v})max(cu​,cv​)，表示经过这条边当前钱数的最小值。但是我们发现这玩意很难搞，因为边权是乱序的，如果暴力枚举起点走的话是 O(n2)O(n^2)O(n2) 的，但是我们发现我们肯定是贪心的走边权最小的。考虑这玩意我们可以在建树的时候求得，考虑 Kruskal 重构树表述建树这一过程。然后再树上 DP，设 f(u)f(u)f(u) 表示 uuu 子树内都经过后最小领到的前，叶子节点即为 ci+bic_{i}+b_{i}ci​+bi​，对于非叶子节点枚举从哪里最后进入出来即可，有 f(u)=min⁡v{su−sv+max⁡(cu,fv)}f(u)=\min\limits_{v}\{ s_{u}-s_{v}+\max(c_{u},f_{v})\}f(u)=vmin​{su​−sv​+max(cu​,fv​)}。其中 sus_{u}su​ 表示 uuu 为根的子树内节点的 ∑b\sum\limits b∑b，由于重构树显然是二叉树可以直接展开 min⁡\minmin，但是如果你写多叉树那我没啥好说的，时间复杂度 O(mlog⁡m+nlog⁡∣V∣)O(m\log m+n\log |V|)O(mlogm+nlog∣V∣)。
借助 Kruskal 重构树，通过合理的赋值边权我们可以满足题目中的限制，难点就是在于我们如何发掘边权所表示的意义。
 CF1628E Groceries in Meteor Town
首先看到简单路径上求经过边权最大值不难想到利用 Kruskal 重构树，查询操作就转化成了重构树上， xxx 点与所有关键点的 lca 的权值。
那么现在为题转化为如何求一个点集合的 LCA，如果你做过树上查询你可能会以为是区间 LCA 直接一个一个维护，但是显然不是这样的，这是点集不是区间。答案是点集中 dfn 最大点和 dfn 最小点的 lca，所以直接维护区间最大最小 DFN 即可。
 P4899 [IOI 2018] werewolf 狼人
我做这个题的时候那一天是血月。
上下界重构树，我们考虑建两颗重构树，A 树非根节点大于父节点，B 树非根节点小于父节点。
那么我们考虑利用性质，首先再 A 树种找到 SSS，倍增跳到 fafafa 满足最浅祖先 fa≥Lfa\ge Lfa≥L。则 SSS 可以只通过编号 ≥L\ge L≥L 的点所能到的点的集合是 fafafa 的子树内所有点的集合,令为 VsV_{s}Vs​。同理我们可以得到 TTT 只经过编号 ≤R\le R≤R 的点所能到的点的集合 VtV_{t}Vt​，问题转化为求是否有解即为这两个集合是否公共点，用 DFN 主席树求解交集即可。
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>LGV定理</title>
    <url>/posts/3fa633e8/</url>
    <content><![CDATA[ 0. 前言
你需要掌握的知识：

矩阵与矩阵运算。
行列式。

 1. 概念与应用
 1.1 概念
LGV 引理是用于解决图上不交路径计数的问题。同时也是线性代数中行列式的一个经典应用。
我们阐述一下概念。
对于一张有边权的有向无环图 GGG，定义一条路径 PPP，的权值 w(P)w(P)w(P) 为路径上所有边的边权的乘积，也就是说 w(P)=∏(u,v)∈Pval(u,v)w(P)=\prod_{(u,v)\in P} val(u,v)w(P)=∏(u,v)∈P​val(u,v)。
定义 e(u,v)e(u,v)e(u,v) 为 u→vu \to vu→v 的所有路径 PPP 的权值之和，也就是 ∑P:u→vw(P)\sum_{P:u\to v} w(P)∑P:u→v​w(P)。
定义两个大小为 nnn 的点集的子集 A,BA,BA,B，分别称之为起点集合与终点集合，则一组从 A→BA\to BA→B 的不交路径 SSS 为：SiS_iSi​ 是一条从 Ai→Bσ(S)iA_i \to B_{\sigma(S)_i}Ai​→Bσ(S)i​​。其中 σ(S)\sigma(S)σ(S) 是一个与 SSS 对应的排列，对于任何 i≠ji\neq ji=j，路径 Si,SjS_i,S_jSi​,Sj​ 不存在公共点。
而 LGV 引理说的就是，对于矩阵：
M=[e(A1,B1)e(A1,B2)…e(A1,Bn)e(A2,B1)e(A2,B2)…e(A2,Bn)⋮⋮⋱⋮e(An,B1)e(An,B2)…e(An,Bn)]M=\begin{bmatrix}
e(A_1,B_1)  &amp; e(A_1,B_2) &amp; \dots &amp; e(A_1,B_n)\\
 e(A_2,B_1) &amp; e(A_2,B_2) &amp; \dots &amp; e(A_2,B_n) \\
 \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
 e(A_n,B_1) &amp; e(A_n,B_2) &amp; \dots &amp; e(A_n,B_n)
\end{bmatrix}M=⎣⎢⎢⎢⎢⎡​e(A1​,B1​)e(A2​,B1​)⋮e(An​,B1​)​e(A1​,B2​)e(A2​,B2​)⋮e(An​,B2​)​……⋱…​e(A1​,Bn​)e(A2​,Bn​)⋮e(An​,Bn​)​⎦⎥⎥⎥⎥⎤​
有 det⁡M=∑S:A→B(−1)t(σ(S))∏i=1nw(Si)\det M=\sum_{S:A\to B} (-1)^{t(\sigma(S))} \prod_{i=1}^n w(S_i)detM=∑S:A→B​(−1)t(σ(S))∏i=1n​w(Si​)，其中 ttt 表示一个排列的逆序对数的奇偶性。
 1.2 证明
我们从排列展开公式出发，令 sgn⁡=(−1)t(σ(S))\operatorname{sgn}=(-1)^{t(\sigma(S))}sgn=(−1)t(σ(S))：
det⁡M=∑σ∈Snsgn⁡(σ)∏i=1ne(Ai,Bσ(i))\det M = \sum_{\sigma\in S_n} \operatorname{sgn}(\sigma) \prod_{i=1}^n e(A_i, B_{\sigma(i)})
detM=σ∈Sn​∑​sgn(σ)i=1∏n​e(Ai​,Bσ(i)​)
其中每个 e(Ai,Bσ(i))e(A_i, B_{\sigma(i)})e(Ai​,Bσ(i)​) 是从 AiA_iAi​ 到 Bσ(i)B_{\sigma(i)}Bσ(i)​ 的所有路径 PPP 的权值之和，即：
e(Ai,Bσ(i))=∑Pi:Ai→Bσ(i)w(Pi)e(A_i, B_{\sigma(i)}) = \sum_{P_i: A_i \to B_{\sigma(i)}} w(P_i)
e(Ai​,Bσ(i)​)=Pi​:Ai​→Bσ(i)​∑​w(Pi​)
将这个表达代入上式得：
det⁡M=∑σ∈Snsgn⁡(σ)∏i=1n(∑Pi:Ai→Bσ(i)w(Pi))\det M = \sum_{\sigma\in S_n} \operatorname{sgn}(\sigma) \prod_{i=1}^n \left( \sum_{P_i: A_i \to B_{\sigma(i)}} w(P_i) \right)
detM=σ∈Sn​∑​sgn(σ)i=1∏n​⎝⎛​Pi​:Ai​→Bσ(i)​∑​w(Pi​)⎠⎞​
将乘积与求和交换：
det⁡M=∑σ∈Snsgn⁡(σ)∑P1:A1→Bσ(1)⋯∑Pn:An→Bσ(n)∏i=1nw(Pi)\det M = \sum_{\sigma\in S_n} \operatorname{sgn}(\sigma) \sum_{P_1: A_1 \to B_{\sigma(1)}} \dots \sum_{P_n: A_n \to B_{\sigma(n)}} \prod_{i=1}^n w(P_i)
detM=σ∈Sn​∑​sgn(σ)P1​:A1​→Bσ(1)​∑​⋯Pn​:An​→Bσ(n)​∑​i=1∏n​w(Pi​)
此时每一项对应的是从 AiA_iAi​ 到 Bσ(i)B_{\sigma(i)}Bσ(i)​ 的路径组 (P1,…,Pn)(P_1, \dots, P_n)(P1​,…,Pn​)，上式可以重写为：
det⁡M=∑Ssgn⁡(σ(S))⋅w(S)\det M = \sum_{S} \operatorname{sgn}(\sigma(S)) \cdot w(S)
detM=S∑​sgn(σ(S))⋅w(S)
接下来将路径 SSS 分为两类：

若 SSS 中的所有路径两两点集不交，则称为不交路径，其对 det⁡M\det MdetM 的贡献为 sgn⁡(σ(S))⋅w(S)\operatorname{sgn}(\sigma(S)) \cdot w(S)sgn(σ(S))⋅w(S)；
若 SSS 中存在交点（即某个点被多个路径共用），我们称其为交叉路径。

我们将证明所有交叉路径系统的贡献之和为 0。
为此，我们构造一个反对称配对消去所有交叉路径系统的贡献。考虑任意一个交叉路径系统 SSS，我们从中选出编号最小的交点 xxx，并设其在路径 PiP_iPi​ 与 PjP_jPj​ 中都出现，且 i&lt;ji&lt;ji&lt;j。我们定义一个变换 ϕ\phiϕ：

将路径 PiP_iPi​ 和 PjP_jPj​ 交换它们在交点 xxx 之后的部分，构造出新的路径 Pi′,Pj′P_i&#x27;, P_j&#x27;Pi′​,Pj′​；
新的路径组 S′=(P1,…,Pi′,…,Pj′,…,Pn)S&#x27; = (P_1, \dots, P_i&#x27;, \dots, P_j&#x27;, \dots, P_n)S′=(P1​,…,Pi′​,…,Pj′​,…,Pn​)，对应的新排列 σ′\sigma&#x27;σ′ 为 σ\sigmaσ 与 (i,j)(i,j)(i,j) 交换；
由于 w(Pi′)w(Pj′)=w(Pi)w(Pj)w(P_i&#x27;)w(P_j&#x27;) = w(P_i)w(P_j)w(Pi′​)w(Pj′​)=w(Pi​)w(Pj​)，有 w(S′)=w(S)w(S&#x27;) = w(S)w(S′)=w(S)；
但 sgn⁡(σ′)=−sgn⁡(σ)\operatorname{sgn}(\sigma&#x27;) = -\operatorname{sgn}(\sigma)sgn(σ′)=−sgn(σ)。

因此，每一组交叉路径系统 SSS 与其配对路径系统 S′S&#x27;S′ 贡献相反，抵消为 0。
因此最终仅剩下所有不交路径系统的贡献，证毕。
 1.3 应用
说了这么多，由于是对不交路径组的带符号求和，所以 LGV 引理难以直接统计所有不交路径组的权值和。但是我们在实际解决问题的时候会有如下的方案：

题目就是让你求带符号的的答案。
图是特殊的图，是的不交路径的起点和终点对应是固定的，只存在一种或奇偶性相同的几种 σ(S)\sigma(S)σ(S)。
只需要检验不交路径组的存在性，考虑给边随机赋权，检查 det⁡M≠0\det M \neq 0detM=0 即可。错误概率在 1P\dfrac{1}{P}P1​，其中 PPP 为给随机赋权取模的模数。

 2. 例题
 CF348D Turtle
为数不多的几个超级模板题。首先考虑固定起始点的路径如何计算，我们可以通过 DP，求解，设 f(i,j)f(i,j)f(i,j) 表示从起始点到当前点 (i,j)(i,j)(i,j) 的方案数，显然转移：
f(i,j)←{0(i,j) 有障碍物f(i−1,j)+f(i,j−1)(i,j) 无障碍物f(i,j)\leftarrow
\begin{cases}
0 &amp; (i,j)\text{ 有障碍物} \\
f(i-1,j)+f(i,j-1) &amp; (i,j) \text{ 无障碍物}
\end{cases}
f(i,j)←{0f(i−1,j)+f(i,j−1)​(i,j) 有障碍物(i,j) 无障碍物​
将起始点初始化为 1 即可，转移是 O(n2)O(n^2)O(n2) 的，很舒服。
但是怎么求不想交路径呢？那么当然要用我们的 LGV 引理啦，毕竟方格图上的走法也可以算是一个有向无环图，而且只要我们把边权赋值为方案数就可以啦。
但是问题在于起点集合和终点集合怎么算，如果我们直接设置为 A={(1,1)},B={(n,m)}A=\{ (1,1) \},B=\{ (n,m)\}A={(1,1)},B={(n,m)} 的话那起点集合和终点集合本身两只乌龟就是重的啊，所以不能这么设置，但是我们额可以这么设置，这两只乌龟一定是一只从 (1,2)→(n−1,m)(1,2) \to (n-1,m)(1,2)→(n−1,m)，另一只是 (2,1)→(n,m−1)(2,1) \to (n,m-1)(2,1)→(n,m−1)，如果不是这么走的话显然是会相交的，那么我们的起点集合和终点集合就可以显然的设置了，就是按照上面两组进行设置，那么 2×22\times 22×2 的行列式计算如下：
∣abcd∣=ad−bc\begin{vmatrix}
 a &amp; b\\
 c &amp; d
\end{vmatrix}=ad-bc∣∣∣∣∣​ac​bd​∣∣∣∣∣​=ad−bc
但是 a,b,c,da,b,c,da,b,c,d 怎么设置呢？根据我们说的，不可能存在 (1,2)→(n,m−1),(2,1)→(n−1,m)(1,2) \to (n,m-1),(2,1)\to (n-1,m)(1,2)→(n,m−1),(2,1)→(n−1,m) 的方案，所以我们这么设置。
令 (1,2)(1,2)(1,2) 走到 (n−1,m),(n,m−1)(n-1,m),(n,m-1)(n−1,m),(n,m−1) 的路径方案数为 a,ba,ba,b，令 (2,1)(2,1)(2,1) 走到 (n−1,m),(n,m−1)(n-1,m),(n,m-1)(n−1,m),(n,m−1) 的路径方案数为 c,dc,dc,d。答案还是 ad−bcad-bcad−bc，直接算就可以了。
 P6657 LGV引理板子
还是方格图，但是这里起点集合和终点集合是给定的了。发现不存在其他起点和终点匹配的方法使得存在不交路径组，所以我们用 LGV 就能够计算出的就是答案。
而从 (a,1)→(b,n)(a,1)\to (b,n)(a,1)→(b,n) 的路径数我们是可以通过组合数来去计算的，就是 (n−1+b−ab−a)\dbinom{n-1+b-a}{b-a}(b−an−1+b−a​)，让后将这个赋值到行列式上，对行列式求值就是答案，时间复杂度为 O(m3)O(m^3)O(m3) 瓶颈在行列式求值。
放主函数的代码：
void solve()&#123;    read(n,m);    for(int i=1;i&lt;=m;i++)&#123;        read(a[i],b[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(a[i]&lt;=b[j])&#123;                mt[i][j]=getC(n-a[i]+b[j]-1,n-1);            &#125;else&#123;                mt[i][j]=0;            &#125;        &#125;    &#125;    put(HLS::solve());// 就是求行列式的函数。&#125;
 有向图哈密顿路

给你一个 nnn 个点 mmm 条边的有向图，让你找到一个 kkk 个点的路径是的路径上的点互不相同。
1≤n≤100,1≤m≤200,1≤k≤151\le n \le 100,1\le m \le 200,1\le k \le 151≤n≤100,1≤m≤200,1≤k≤15。

我没找到题，问题在于如何让路径上的点互不相同，我们需要有一种在经过重复点的时候就一定不会统计的方法。
根据行列式的性质：若行列式两行相同，行列式的值为 000。
我们考虑给每一个点赋值一个 kkk 维向量 vvv，对于一个 kkk 个点的路径 a1,a2,…,aka_1,a_2,\dots,a_ka1​,a2​,…,ak​，若 det⁡[va1va2⋮vak]=0\det \begin{bmatrix}
v_{a_1} \\
v_{a_2} \\
\vdots \\
v_{a_k}
\end{bmatrix}=0det⎣⎢⎢⎢⎢⎡​va1​​va2​​⋮vak​​​⎦⎥⎥⎥⎥⎤​=0 的话说明存在重复点，否则不存在重复点，如果我们给 vvv 随机赋权的话，根据我们前面的说法，错误率是 1MOD\dfrac{1}{MOD}MOD1​。
那么通过上面的方法，我们不需要记录我们所经过的点，只需要进行数据运算就可以了，而对于上面行列式的求值，我们可以通过定义进行。这样的话我们可以通过考虑 DP 进行计算，设 f(i,j,S)f(i,j,S)f(i,j,S) 表示考虑了前 iii 个点，第 iii 个点为 jjj 的情况下，前 iii 行行列式求值选择的排列取值集合为 SSS 的情况下前 iii 行的带符号和。
考虑转移的时候直接枚举边以及这一行选择的排列取值，最终 f(k,vi,{1,2,…,k}f(k,v_i,\{1,2,\dots,k\}f(k,vi​,{1,2,…,k} 的第一个非零的位置 viv_ivi​ 求实一个可行的终点，让后倒退求出路径即可，时间复杂度 O(mk22k)O(mk^2 2^k)O(mk22k)，没想到吧和 nnn 一点关系都没有。
 PA2021 Fiolki 2

有一张 nnn 个点 mmm 条边的有向无环图。记 f(l,r) (k&lt;l≤r≤n)f(l, r)\ (k &lt; l \le r \le n)f(l,r) (k&lt;l≤r≤n) 表示以 1∼k1 \sim k1∼k 中的点为起点，l∼rl \sim rl∼r 中的点为终点，最多能够选出多少条路径，使得任意两条路径不存在公共节点。
对于 x=0,1,…,kx = 0, 1, \ldots, kx=0,1,…,k，问有多少对 l,rl, rl,r 满足 f(l,r)=xf(l, r) = xf(l,r)=x。
n≤105,m≤106,k≤50n \le 10^5,\quad m \le 10^6,\quad k \le 50n≤105,m≤106,k≤50。

只是让我们求不想交的路径耶？我们可以考虑给边随机赋权来完整这个事，让后用 LGV 来进行检验，具体操作就是对于每一个 k&lt;i≤nk&lt;i\le nk&lt;i≤n 维护 1∼k1\sim k1∼k 到 iii 所有路径的权值和，将其看做一个 kkk 维向量。若 f(l,r)=kf(l,r)=kf(l,r)=k，根据 LGV 有就是找到 a1,a2,…,ak∈[l,r]a_1,a_2,\dots,a_k \in [l,r]a1​,a2​,…,ak​∈[l,r] 使得这 kkk 个点对应的向量排成一列构成的矩阵的行列式值不为 0。说人话就是在 [l,r][l,r][l,r] 找到 kkk 个线性无关的向量。
依次类推，有 f(l,r)≥xf(l,r)\ge xf(l,r)≥x，就意味着能够在 [l,r][l,r][l,r] 找到 xxx 个线性无关的向量，所以 f(l,r)f(l,r)f(l,r) 就是 [l,r][l,r][l,r] 的每一个点对应的向量所构成线性基的大小。
考虑这个怎么维护，先让我们不可能直接暴力的去维护不然时间复杂度就直接螺旋爆炸上天，但是我们观察性质，对于确定的 rrr，f(l,r)f(l,r)f(l,r) 的值随 lll 的减小而增大，若 f(l,r)≠f(l−1,r)f(l,r)\neq f(l-1,r)f(l,r)=f(l−1,r) 那么也就意味着 ala_lal​ 与 al+1,…ara_{l+1},\dots a_ral+1​,…ar​ 线性无关，我们可以加入线性基中。而现在问题转化为找到这些 lll 让后从小到大排序，将相邻两项的差求和就是我们的答案，而我们找 lll 可以维护时间戳线性基求得，时间复杂度为 O(mk+nk2)O(mk+nk^2)O(mk+nk2)。
 SNCPC2024 最大流
不会真跑网络流吧 www。
其实就是让你找边不交的路径，并且对 kkk 取 min⁡\minmin。首先这个 min⁡\minmin 这个很难受，我们考虑能不能通过转化把他给去掉，我们可以通过添加个点 0，让后让它向 111 连 kkk 条边，让后就可以去掉了。
但是 LGV 检验的是点不交，考虑点边转化 Trick，将点转化为边，将边转化为点，具体来时就是每一条边对应一个节点，对于一个点所有入边向出边链接带有随机权值的边（因为题目还是检验），那么 iii 点的答案就是等于 iii 的所有入边对应向量构成的线性基大小即可。
显然我给你个菊花图就炸掉了，考虑优化。
所有入边向出边连边，对每个边随机赋权，根据 LGV 的说法权值是乘起来的，那这不就是随机线性组合吗？而且我们答案要线性基求得还是线性无关的向量个数，所以对于入边我们只需要保留线性无关的 kkk 组向量解决即可，这玩意还是线性基，直接做就可以啦。
时间复杂度 O((n+m)k2)O((n+m)k^2)O((n+m)k2)。
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LNOI2022省选串题解</title>
    <url>/posts/a88c840d/</url>
    <content><![CDATA[串串构造题，纪念自己做出来的黑串串构造。大胆猜想！小心求证。
以下定义 n=∣S∣n=|S|n=∣S∣。
我们首先根据题目中给出的第三个条件，我们来看子串 SSS 在放进 TiT_{i}Ti​ 和 Ti−1T_{i-1}Ti−1​ 的形式是怎么样的：

那么，由图不难观察到一个很明显的构造过程，也就是我们先反过来，由 [l,r][l,r][l,r] 出发，右端点每一次减小 2，左端点每一次减小 1，也就是 [l,r]→[l−1,r−2]→[l−2,r−4]…[l−x,r−2x][l,r] \to [l-1,r-2]\to [l-2,r-4] \dots [l-x,r-2x][l,r]→[l−1,r−2]→[l−2,r−4]…[l−x,r−2x]。那么有一个显然的移动下界就是在极端情况下 [l,r]=[1,n][l,r]=[1,n][l,r]=[1,n]，最多只能移动 n2\dfrac{n}{2}2n​ 次。那么现在问题在于如何使得这个移动过程能够足够移动多次，首先根据题意不难得出对于每一个 TiT_{i}Ti​ 都要保证是 SSS 的子串，而且我们还要每次从上一个 Ti−1T_{i-1}Ti−1​ 转移过来，也就是说，对全局起决定性作用的在于 T0T_{0}T0​ 的选取，我们怎么选取才能最好呢？
哎，我有一计！T0T_{0}T0​ 是子串，子串又没有说非空子串，那我选空子串，那么后面的操作相当于就是找长度为 1 的子串，找长度为 2 的子串，以此类推下去。证明当 T0T_{0}T0​ 是空串时存在最优解是显然的。
但是我们上面还有一个前后缀的性质，也就是说 TiT_{i}Ti​ 由 Ti−1T_{i-1}Ti−1​ 加一个字符过来，并且还要求是一个原字符串一个子串的前后缀，那什么情况下能满足加一个字符是子串的前后缀呢？我们从我们选取的子串下手：

只能加一个字符，那么也就是说如果 SSS 选一个前缀加一个字符放到后面拼后缀还能和原来重合？那么，也就是说，这个我们构造的串至少要在 SSS 种出现两次这样的话我们才能扩大区间，感性理解就是如果不这样的话你转移到 TiT_{i}Ti​ 前后缀都覆盖不了啊，是无法满足的，严谨证明可以考虑反证法。
那么有两个这个结论，我们找一个至少出现两次的子串 [l,r][l,r][l,r]，那么首先区间能拓展 r−l+1r-l+1r−l+1，右端点每次跳两步也就是说还有 n−r2\dfrac{n-r}{2}2n−r​，那么答案就是 r−l+1+n−r2r-l+1 + \dfrac{n-r}{2}r−l+1+2n−r​。这个我们用 SAM 和 SA 可以轻松维护的，我用 SAM 因为维护至少出现两次很简单的。
注意一下，答案下界是 n2\dfrac{n}{2}2n​，可能存在没有任何拓展的情况，所以最后结果是 max⁡(n2,ans)\max(\dfrac{n}{2},ans)max(2n​,ans)。代码其实很好写，也是我见过为数不多好写的黑题了 www。
#define ll long longusing namespace std;constexpr int MN=1e6+15;int n;ll ans;string s;struct SAM&#123;    int nxt[MN][26],fa[MN],len[MN],cnt[MN],pos[MN],mnpos[MN],tot,lst;    vector&lt;int&gt; adj[MN];    int newnode()&#123;        int cur=++tot;        mnpos[cur]=1e9;        fa[cur]=len[cur]=cnt[cur]=0;        adj[cur].clear();        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    void init()&#123;        tot=lst=0;        tot=lst=newnode();    &#125;    int clone(int from)&#123;        int cur=newnode();        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    void expand(int c)&#123;        int cur=newnode();        len[cur]=len[lst]+1;        int p=lst;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                int nq=clone(q);                len[nq]=len[p]+1;                fa[q]=fa[cur]=nq;                while(p&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];            &#125;        &#125;        lst=cur;    &#125;    void inittree()&#123;        for(int i=2;i&lt;=tot;i++)&#123;            adj[fa[i]].push_back(i);        &#125;    &#125;    void dfs(int u)&#123;        for(auto v:adj[u])&#123;            dfs(v);            cnt[u]+=cnt[v];            mnpos[u]=min(mnpos[u],mnpos[v]);        &#125;        if(cnt[u]&gt;=2)&#123;            ans=max(ans,1ll*len[u]+(n-mnpos[u])/2);        &#125;    &#125;&#125;sam;void init()&#123;    sam.init();&#125;void solve()&#123;    init();    cin&gt;&gt;s;    n=s.length();    s=&quot; &quot;+s;    for(int i=1;i&lt;=n;i++)&#123;        sam.expand(s[i]-&#x27;a&#x27;);        sam.cnt[sam.lst]++;        sam.mnpos[sam.lst]=i;    &#125;    sam.inittree();    ans=n/2;    sam.dfs(1);    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>MatrixTree矩阵树定理</title>
    <url>/posts/c8836e51/</url>
    <content><![CDATA[ 0. 前言
前置知识：行列式。
我已经 500 万年没写过这个笔记了，赶紧抽空写一个。
 1. 生成树计数
 1.1 无向图不带权
我们对于无向图，定义 DGD_{G}DG​ 表示图 GGG 的度数矩阵，即：
DG(i,j)={degi(i=j)0(i≠j)D_{G}(i,j)=
\begin{cases}
\text{deg}_{i} &amp; (i=j) \\ \\
0 &amp; (i\neq j)
\end{cases}
DG​(i,j)=⎩⎪⎪⎨⎪⎪⎧​degi​0​(i=j)(i=j)​
还有邻接矩阵，这里就不解释了，不过需要注意的是如果有重边的话应该算有多少条。
同时介绍 Kirchhoff 矩阵，指的对于一个图构造出来的一个矩阵。具体定义为度数矩阵减去邻接矩阵。
矩阵树定理说的是，一个图中的生成树个数等于其 Kirchhoff 矩阵的任意一个 代数余子式的行列式，说人话就是对其矩阵任意一个 n−1×n−1n-1\times n-1n−1×n−1 的子矩阵求行列式，注意如果直接对 n×nn\times nn×n 求行列式答案为 000，因为一个图的 Kirchhoff 矩阵行列式为零，同时一个图的 Kirchhoff 矩阵的任一代数余子式的行列式相同。
模板题：SP104 HIGH - Highways - 洛谷，容斥题 P4336 [SHOI2016] 黑暗前的幻想乡 - 洛谷
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=620;int n,m,a[MN][MN];namespace HLS&#123;    int solve()&#123;        int ret=1,w=1;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                while(a[i][i])&#123;                    int div=a[j][i]/a[i][i];                    for(int k=i;k&lt;=n;k++)&#123;                        a[j][k]=(a[j][k]-1ll*div*a[i][k]);                    &#125;                    swap(a[i],a[j]);                    w=-w;                &#125;                swap(a[i],a[j]);                w=-w;            &#125;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            ret=1ll*a[i][i]*ret;        &#125;        ret=1ll*w*ret;        return ret;    &#125;&#125;void init()&#123;    for(int i=0;i&lt;=n;i++)&#123;        for(int j=0;j&lt;=n;j++)&#123;            a[i][j]=0;        &#125;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    init();    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        a[u][u]++;        a[v][v]++;        a[u][v]--;        a[v][u]--;    &#125;    n--;    cout&lt;&lt;HLS::solve()&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 1.2 无向图带权
以下推广 Matrix-Tree 定理，推广到一般情况，Matrix Tree其实求的是所有可能生成树边权之积的和。由于每条生成树都算一次，权重是度数，分摊一下就是 111，所以直接是生成树个数。
推广到带权图，假设图中边有权重 wew_{e}we​，我们希望求解加权生成树总和
，即对每棵生成树，把它包含的边权乘起来，再把所有生成树累加起来：
∑T∏e∈Twe\sum\limits_{T}\prod_{e\in T} w_{e}
T∑​e∈T∏​we​
那么我们如何修改 Kirchhoff 矩阵呢，我们如下定义加权 Kirchhoff 矩阵：

(i,i)=∑(i,j)∈Ew(i,j)(i,i)=\sum\limits_{(i,j)\in E} w(i,j)(i,i)=(i,j)∈E∑​w(i,j)。
(i,j)=−w(i,j)(i,j)=-w(i,j)(i,j)=−w(i,j)，若无边默认为 000。

然后同样的方法：去掉任意一行一列，求行列式，就可以得到结果。
P3317 [SDOI2014] 重建 - 洛谷
这道题是求刚好留下一棵生成树的概率，那么，即是求：
∑T{∏i∈Tpi∏i∉T(1−pi)}=∑T{∏i∈Tpi⋅∏i(1−pi)∏i∈T(1−pi)}=∏i=1(1−pi)∑Tpi1−pi\begin{aligned}
&amp;\qquad \sum\limits_{T} \{\prod_{i\in T} p_{i}\prod_{i\notin T} (1-p_{i})\} \\
&amp; = \sum\limits_{T} \{\prod_{i\in T} p_{i}\cdot \dfrac{\prod_{i}(1-p_{i})}{\prod_{i\in T}(1-p_{i})}\} \\
&amp; =\prod_{i=1} (1-p_{i})\sum\limits_{T} \dfrac{p_{i}}{1-p_{i}}
\end{aligned}
​T∑​{i∈T∏​pi​i∈/T∏​(1−pi​)}=T∑​{i∈T∏​pi​⋅∏i∈T​(1−pi​)∏i​(1−pi​)​}=i=1∏​(1−pi​)T∑​1−pi​pi​​​
直接赋权即可，一个点的度数就是所有以它为端点的边的边权和。
#include&lt;bits/stdc++.h&gt;#define db long doubleusing namespace std;constexpr signed MN=55;constexpr db eps=1e-8;int n,m;db a[MN][MN],ret=1;namespace HLS&#123;    db solve()&#123;        db ret=1,w=1;        for(signed i=1;i&lt;=n;i++)&#123;            for(signed j=i+1;j&lt;=n;j++)&#123;                    db div=a[j][i]/a[i][i];                    for(signed k=i;k&lt;=n;k++)&#123;                        a[j][k]=(a[j][k]-div*a[i][k]);                    &#125;              &#125;        &#125;        for(signed i=1;i&lt;=n;i++)&#123;            ret=a[i][i]*ret;        &#125;        return ret;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(fabs(a[i][j])&lt;eps)&#123;                a[i][j]=eps;            &#125;            if(fabs(1.0-a[i][j])&lt;eps)&#123;                a[i][j]=1.0-eps;            &#125;            if(i&lt;j) ret*=1.0-a[i][j];            a[i][j]=a[i][j]/(1.0-a[i][j]);         &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        a[i][i]=0;        for(int j=1;j&lt;=n;j++)&#123;            if(i^j) a[i][i]-=a[i][j];        &#125;    &#125;    n--;    cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;fabs(HLS::solve()*ret);&#125;
 1.3 有向图版本
现在这个矩阵需要特殊定义，我们这里邻接矩阵的意义同有向图邻接矩阵，不妨设为 AAA。
那么如果你要求的是外向树，那么矩阵就是：
M(i,j)={∑k≠iw(k→i)(i=j)−w(j→i)(i≠j)M(i,j)=
\begin{cases}
\sum\limits_{k\neq i}w(k\to i) &amp; (i=j) \\ \\
-w(j\to i) &amp; (i\neq j)
\end{cases}M(i,j)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​k=i∑​w(k→i)−w(j→i)​(i=j)(i=j)​
即到该点的边权总和。
若是内向树，则为：
M(i,j)={∑k≠iw(i→k)(i=j)−w(i→j)(i≠j)M(i,j)=
\begin{cases}
\sum\limits_{k\neq i}w(i\to k) &amp; (i=j) \\ \\
-w(i\to j) &amp; (i\neq j)
\end{cases}M(i,j)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​k=i∑​w(i→k)−w(i→j)​(i=j)(i=j)​
即从从该点出发的边权总和(出)。此外,既然是有向的,那么就需要指定根。在有向树的时候需要理解为指定根,结论是 : 去掉哪一行就是那一个元素为根。
例题：P4455 [CQOI2018] 社交网络 - 洛谷，有向图内向树 1 为根，代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=620,MOD=1e4+7;int n,m,t,a[MN][MN];namespace HLS&#123;    int solve()&#123;        int ret=1,w=1;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                while(a[i][i])&#123;                    int div=a[j][i]/a[i][i];                    for(int k=i;k&lt;=n;k++)&#123;                        a[j][k]=(a[j][k]-1ll*div*a[i][k]%MOD+MOD)%MOD;                    &#125;                    swap(a[i],a[j]);                    w=-w;                &#125;                swap(a[i],a[j]);                w=-w;            &#125;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            ret=1ll*a[i][i]*ret%MOD;        &#125;        ret=1ll*w*ret;        return (ret+MOD)%MOD;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    n--;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        --u,--v;        a[u][v]=(a[u][v]-1+MOD)%MOD;        a[u][u]=(a[u][u]+1)%MOD;    &#125;    cout&lt;&lt;HLS::solve();    return 0;&#125;
 1.4 无向带权与有向带权
P6178 【模板】Matrix-Tree 定理 - 洛谷
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=620,MOD=1e9+7;int n,m,t,a[MN][MN];namespace HLS&#123;    int solve()&#123;        int ret=1,w=1;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                while(a[i][i])&#123;                    int div=a[j][i]/a[i][i];                    for(int k=i;k&lt;=n;k++)&#123;                        a[j][k]=(a[j][k]-1ll*div*a[i][k]%MOD+MOD)%MOD;                    &#125;                    swap(a[i],a[j]);                    w=-w;                &#125;                swap(a[i],a[j]);                w=-w;            &#125;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            ret=1ll*a[i][i]*ret%MOD;        &#125;        ret=1ll*w*ret;        return (ret+MOD)%MOD;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;    n--;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        --u,--v;        if(!t)&#123;            a[u][v]=(a[u][v]-w+MOD)%MOD;            a[v][u]=(a[v][u]-w+MOD)%MOD;            a[u][u]=(a[u][u]+w+MOD)%MOD;            a[v][v]=(a[v][v]+w+MOD)%MOD;        &#125;else&#123;            a[v][v]=(a[v][v]+w)%MOD;            a[v][u]=(a[v][u]-w+MOD)%MOD;        &#125;    &#125;    cout&lt;&lt;HLS::solve();    return 0;&#125;
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2025_机器人</title>
    <url>/posts/5152bd6c/</url>
    <content><![CDATA[不是，近 5 年 NOI 从来没考过绿吧，不会吧？
形式化题面如下：
给定一个有向图，包含 nnn 个节点和 mmm 条有向边。边有长度。对于每个节点 xxx，其出边被编号为 1→dx1\to d_{x}1→dx​（dxd_{x}dx​ 是出边数量）。从 111 号点出发，初始有一个变量 p=1p=1p=1，按以下规则移动：

若当前位于节点 xxx 且 p≤dxp\le d_{x}p≤dx​，则走 xxx 的第 ppp 条边，移动到相邻节点 yyy。花费为边的长度。
修改参数 ppp：

若 p&lt;kp&lt;kp&lt;k，则令 p←p+1p\leftarrow p+1p←p+1，花费为 vpv_{p}vp​。
若 p&gt;1p&gt;1p&gt;1，则令 p←p−1p\leftarrow p-1p←p−1，花费为 wpw_{p}wp​。



求 1→i1\to i1→i 的最小花费，若无法到达输出 −1-1−1。
一眼分层图，题目转化为建 kkk 层的有向图，每次跳不同层要花费规则上指定的代价，求单源最短路跑 Dijkstra。但是空间复杂度是 O(nk)O(nk)O(nk)，且时间复杂度为 O(nklog⁡nk)O(nk\log nk)O(nklognk)，无法通过。
我们设分层图状态为 (u,p)(u,p)(u,p) 表示在第 uuu 点，参数为 ppp。
考虑优化，首先一个关键观察就是当 dx&lt;pd_{x}&lt;pdx​&lt;p 的时候是没有任何卵用的，(u,p)(u,p)(u,p) 是无效状态。我们没必要建这么多图，考虑每一层就建 dxd_xdx​ 层就可以啦。
接下来还有一个很难受的过程就是修改参数，考虑这个怎么优化，花费和 ppp 有关，一个不难观察到的地方每次增减量是 111，考虑前缀和优化修改参数这一过程，这样复杂度从 O(k)→O(1)O(k)\to O(1)O(k)→O(1)。这一部分我们可以通过 map 或哈希表实现，时间复杂度 O(nlog⁡nlog⁡k)→O(nlog⁡n)O(n \log n \log k)\to O(n \log n)O(nlognlogk)→O(nlogn)。
代码数据出来补一下？
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>OI大技巧</title>
    <url>/posts/a3f4a75/</url>
    <content><![CDATA[
  a0048e2418083c29588730b2cab069405e1287248046a9fadb0bad1f8a268572c2e48b61bf0f57230626593dc238841dfbe3bd549757fccc22662f4ae8d2a3f101871bfd71fae5b14efed40cf13b3a73d723c4b68caa8c5117a76d473a89c9cd3cbff2957436f8bbe8af6ad6e1795fb37a9b8fb0261ec6274fdeea3bee6d01c6522694fda841f9678980ad45c8b06dd090152afcbac37286475a7e0afbd7e95fd60421a55149bdc88089c0229f216df961bebd542bd3ebf58510dfd51f07c7c1651e320c6c4785aada05c604b27ea0b64f11f130befd092c1721e91028d123346f2fbf5b1f5a4adc7d14648e62010fdcf90109f6590e5de074bb9a366bc6b6193ca7ff0c0cc80ff102c48fc1a9fc7c63a09ffd37950a057249ece932acb9ead159ae0e380518124e7001c50e5b4f279df99b28bff23029d8c4c3c07a78e40110bca5d964816d97e4548ffec38ad8e79ba4a655a427fd83bd4872be07590577d03d6432aae6737062553190603e6458f3783591486f128b1dc730b4e82ea0a18aa6b8506dc25ce9825e116a3ebf27b3909e024b025aba2d8415f2b7b590ddfcd4bb4815989ab209cae3e5f742f5ec1dff4e2c17cce81dda6435737b694a3fdd8ba398b0b9994412b6550127a266fbd9979cba93d908c83bdb30b836ed28573cbca27dd8f087524b96ae4943f7c6e755a23a768b2c2af4e3f0e95291b28fbd73a34e2d6c1bcb0d028a972d00f5012652955a3f941538fd4ff466d6fd5341ab418288a1bbcb390a72388aa6b615e50e7c9305d78c9be6a8730deb50a4763714cc90c972850b7203497feb83036a9415d319486bb578bda9d7e7829ecfa7eeb64694f87b900448151fea5630f0ea4f53a5da6187da011a8cdc1e619dbb208d8220ed5e09d3ed3ea7b9ba780476a8fe8f2657899fd590b53fb70c99a4cec85ff7044427ef685a5aef3331ff9e3bacc4eb828ba67ab92e246cc7c41c76224f1902faee9d4ac4313090e0429d1347abdc1ca932ff04cfdf98207fef3bba67fb25d6a5ba4cf1c484357fa190bbcbff79df8ee231cf3c75a5b9e06b0404dcc377dbd607db67234135412053335814a0f6b74951edb654efe8b062aecfb76210e1d0cad421fbf5f649be2d3b43342d52c774d102babb901469bdebc5bb1cf3cd88106d8b4ec6bd912d7bac8c098ce39d4f0ba3554076d8f9c9a253a499332da6489038a7ced4dd395db19d6b354f92b22d9daa8778009fc5cea08ff542c4e8e5a8fb609673a2e5a3388a1e7ec7945a6d1c2dfe4bf8454ff7c0a22cafb1e28abaef834e773727b17ddc8020efb9bc224e66604a32ebaa790456b492b1578369da0895d25d3911ccffcbd73e7a7d0939603ae142b3a63e47bf6d0ee3496bedde894d6a156cc07265c7f4a3b9133ff92c4bfce50fff211236b384833a9f5198b3b8375cda7f36fd5feaa8cc0c29d1e00932d1f9787e90f70845f20b713faf5005a0a1ac246cc8734805037399f142bf3b7b742cf1bd6c3b18398abc2197a6cfcd56951a4e6c41c41178384662223510532389a28e3d717d41c84bf0c6e66408e804611d8f92214b8b5ee154c961c23bfa56e401ac36101e2f4bf25edcd39c144094e607b7ab3d0b5ffaed0259b7fa6563381023a4885978222ef220d823b47bc39be4381aef50e0bce9f66b8fab9a699ff2ba9207b0494b6e588b6fdd1e66aedf9ad8c8e0457c30f59a9e7fb5abeaffc62aa5270779404860ad2555468fc99d8850e2e1e7adf57dd2b08ca478fcad4b2554067fd1168708a4b55dad5cd2d14a87c1a68516e5432c50f8530ec3409df28dc31ec0b7a4ea36d6b218a8748107edb9c2aa63d136f93f3f8890cbc4f8367d19b1772374a8842a6cdf27f31d2b3fdc25147e283812ceee8e950ca051a9ef8eb1cdff50d1b8f1229f067630ae7f00376e26926f1db32548a67f5be9bdff213f489f7d1e004418cbdd1d66883676b4ef565ad2c79dd3ffec3d584c2638293707a2ac9f74e467de842d8b5f1781f03d91f2bd08b92c64d5f7cdc0ead605fd934664c82f9efc68452e21233b758076dcb95ad8370de634bbd21ce8bc1c8df2034461dd1835489cfbbd33ee31ad1b614ea87ae70934b987a2d658c396008236f68931317c91240111f5ba1b72a48e28f91dcbd2e86ff5da5e0c28cb519f7278d78feb907743171e60c77a606c0191976838ffe7a9991ca7564f7e640a6fa1a5b16ce5fe2a7e2657e18cbfc5a0f6d93cff3cf31d7356a81ed633e904d2832fdc2e54c05ff0e4a8996c81e62b9b21d9726f02b9b55481de7778d1e305bec05270fe0b9b176b988626722ef44b1ebe3cd8e76c0222b7175a8db6d4ee62365b645ebce0b9ccb00eee2bef6f4cc29a3279ff0b3ec0222fa9bc8be4c760bb9ca6182b59bc5c1411b2982122d648ffb8bd0bfdb7f6a2050c04d71078922af21d32f97664632e598acf78b05df0a258ccfca908f4fc363e7c64838a40f6711a10984bdf29eb32f4ead6af7e373f36e3f97eec4a051b926bcfc3d95c846091a40093d6f67e5ae44f404691fbfc5c3ccecc6d3ce14d08b7188aef0be7a0257dfc7bf5e45ce58f112507546768e823904911e86225f6770c85d4dbe713e4349387747f9f92fd8bd97c2812c2b1330fcf2f616ff40dc9e9af91e0cfb6f75ffa12df43eeb885e9c7d8484d6f0da919ca19de7c510925e9e62f3190acf3bb83c448014be3f0e73a8fa3506a7a09c6e634a45cb0a16ab6f50e04c724fca1065a022887b44115b516a29a88cb72f936c2b997ef329ba48d2381f15a65eb737f38d63c0e30227867c17dc05b52e8a89c6bc9ced5dced259467717fad46b7de15033a0aa6c1c7a56b23a5361c5bd6b24f3495665291ff1b6700c7a6f8f6a505572af4706daac5115be666962cc8227d17d7aee46519adabab3fde2dc4871a522c778a35bfa956034c6b06065b13ad10ef6aba07f692639e3dccb52d8e7186d6af57a75d8f4922bc4b0049642d32fac4e22b640c605c9e8559c423aeb30bfd3bc086c62d91695965eb451b7a7013cf8d1b29028b4a4c20de3cc3af76f926a4fede5efd63fcae20f70085767ed3246a95a8946240d8d0bb96baa7c46df27bc2959517ba8f302be40d5dd3c7a2123a519fd327805207948e0055f29438b154c8cff5c6cf1c0967e20a5af5228e84f49876558dcec8025f31995201d5e5be2519cd508a22e14b2057047256d88bb89e48dccc8c8c5ac6f7223a144c6d1f9cf27f26b2b96f13d9ac595f7f82366683d9717677f8659d40c8559d2a41e38223dc2cc79ae9d6b7da937503ee837c4f768a26ab121e0ab35942aec62f23b9a48deda6662bca6649ef82174436b4d3974d6b7a7dc0a3558ed286ddc74404507007b17e9d2f3c2a3dc8ff6d6aae840f1437e33b945b4e7a5dac5351b0dda5bf2a83346c09b5245ab3552b3270fdb81758d5393e32215629e9e414bfd27939df830a97188ef139d0cd96c4d96fb9f7ea0308e2ffeb88f58b0dabe5bd33844d1aa9838898e24ad3b07ad545ca67871f27ab9ba58c47a5fec0261cedfa1d16e04b6d474fc3bde3b81f359d29bb9b5f6c7a542064cf3b867e70abbbe09016cbdec9540c611aabaf7b177486473656f0fee12c531efb735a14ecdf41078bd85c86e2e369171ab7592e2bde007c35bdf24b52fa89c80036fd375eeec577c2c8e0f0441e6b148a5baaa47c08e300843fd94767d6990103269f0664959e6171d98f006d2110a3821710a65254a2b863904ebca6f80354b7c40778a6f6ebb8bf80406a78e69081ac93468fbe8060a010386d638d799cfd68e2ef7448c021c1bdd47872606a0f475c0b7838ba62e524deb928902f3a54a9135656744594b220722acf51ec3ee82505b16b0242a864eb34ded4f4c660a3fa18ae4e553ffb0aec34474ff34d704b52aff1543c532a13cfe7834a5fa5eb6289cbb319c1d649dac6993cc0fcf28a09fb1ba715e9b5b4c6c51e8ece9a2266f0216039562bb4e7bc3b7873f5bd409f3e76139815c8154c53c7c1d8467f191ce984a6a6860a83d80c1b663c86617754561a1ea29094655686f464073e52ebb5e9f44d68b762dcd5041a29d71b49a4e5e93e6a1faaaed94aef7365e64d129b554d93771a6424184211687c521634af0a7c7bf6cad774e4874534638d30e06d7af9068c0f4056f08e2ee09242e91ba763f024dc5b8067a2b34d7e248736c71abc387a0a640c76bd0210d8c9190d0fce1ba9cb1294e4f414aa5e472d53a8f0a3c575bc6c5061bebb48b97b7cad057da626eb686bec21c93ceff5e7e354d4b397fcddf88ad4f9989857c2fb38dd0e7f318c505e9274372537a43b0486d624b5ad7189fddda531cda479a1b33dbeae536972bd53110ae572aa98c694a98df4a0766573069c093d4e3bee1f56ab40fd39e07c777b146fa7f21f96142dabbdb53d9225fe172144da092df9f911b70f2637be5a49587ce88e38a9dae6afbc07dc647d9f4b4e88a618bdc8684ab7a7bd662b56e174163c4dbac5b24e25d7aa0d3f0a627e4024b8a4190cf39c4964312ac4029ea10b9be9a86519ef659fa64f61afc9385d8ff0727239eaaf7c823cc1ce1a22f18d36ef85cff01a887a98e495386fe41fac1033ca2c350ad4aca2230d6455ef87a8370bb72b94203208349505183de36bf50f2efe94ae5c5ca3040d751347a8e864f5557fff26f5d4361436b7e43bd79654ab24ecd39940e90d326c15e1f6767b605e6882cd0200ab4a087d35a7922985432055159baf2db9a554cc50ef30bb04ad31a0fd958bf6651f2a8d059caefa4518f2744c39063a2c5ea4c337d4516fb3d01e582abc17996a9ca442c9ac940ba92e9fe4376a91843d15d10fa34004dd8ef83dc4e46425df6cebc04514f0548255c8b967b14853c2ebc560e62cc7602ffb3a03ffa17258cb257530c648943db7ed1d09c8dbe45a08ce926ec900e640affdf616db3cb37136fccf7c24c928538ae579d607be4003bd084e28d969a3cf1dfe74dd08b919d0cf58e666f5b1229a1b62f7b5336026f8407ac4c024d5e8499e6f7cf307fd3a98b46ecac6d522300b6d01686c64a3f9a3f25ae8a8fd9b1c8cbb562e5c09b8e960834aae410e7f0d18b229f8515c769f5e0be72bd254c0d1fdf17fdd5ff6384dedb05e9ac2bfadb610aff7e68733f56c68bfab1c672f639f1ecae1ad4d10865b5f2233cff5f7537eabf1e17ce0b0d81900daac02d0ab7e376ac38ee28e43a21579922c947bf162901cf001012d021917956ab009b378aab056ec0d91fcd4f1a6e1fe24daa5aa3fd7e65cdbebc1974d94867579cbe5f1c19751a27f5be165424777376857bde60fa5e65fd6b0784776f3679650179e6f989a15691de76e51216c6c6c4bad49841f6834a9be84fbcfa1b141b3b8fbfb028b6c76e8217c80cd43f2f37b00abb73d60b9c5b9bf3c08620754d66b96d6d96c4c13303adc89a6d854fe32a24237187d404cdec96596a27ca8dab6431d9819a8ce53a105140bd32918ce0ff7da0e573900916e162a2b877d32789feb66c2f08107c1e5dabb9b6ebb0b49d1b48865588b8c86d8826c1e6dbd799a18d99b89db53bcd038d3321cecd81a93d2e1df503497bcc36b065caba9e91b743aab296487b9961385d1a31ab7697ab86910c8463c56550fa22272581c91462b66534e7585e55bb1f1982e170f1cb17b5cd71d4f86d632a02182e9b8dd6a22ffbbfe7f022f5c2e8a72ba8a1e8649e19490ae2496e27dae0b63488f5737bcb35f59bb83e276cd786fdf76793b0b91f3120be9ae8964a27948aca7fe7d2b8adbe1fd9af32c5a1a8e558e0fd097b0161ab045da48d2f90a1cd634ac446996c8e920527ce4d81b01c918d8166cdaa49964292a6dbf0cbc9e47dd0b48e41a7087cf01153723701f2640e7a11176bd28bcc46de794ac1887bc908b52174af1dd6f37e5bea508c9f02b43bbae22079a5bb28d550626f3bf9c0d9cb7f529e16472fc6445dae0e0ee45a2693bcb936c36c9d1783c27610d4f54c72c5ded5dbb981d9e393dc7d5b2dd6ada1f8efdd00c3074e1f77b29ead0abcd5fbb3e11335e3813bbf5be5819842df1542126f0649a119427bb89c4b935bd9ea0e462d380a7c182b7d3ad223f83fdbc26bb0c87b1a380b795e860efb844296ca21b9e7f1d7eccfbc7a54c8bf5e4f2bf2b76a18e2b01d741223f6f6cf76edd059e709596f13b048edd73935a53fe82ecd27b12949e7368d222db8e0a8f8162ad418e85fa56940238548f0bd5171d50de226731a1cc3ce3214037dab5911a885f3228dbe1c421d14d0b518a67f4a81b1f02321e43756ab23bcff7d29be8a2632e5b345d83e33fa3e9d3a19f8e4fbb6223a13ace11b07b902e4c537a1ba951d6af004d48539d212e07a11f7e5ac70f3f8d811aeae7e9f1fdc2a200cb6793521150e755f23d1cd4f313518cd05bc0c2bbfe64ffd7fec1af9c84a0626e5e49a83996a84f41998792239f74af9f6aee8abe18ab9c509a705867cbeeae2ca3b5cd4a45897206dd3641d9915031d29e9ef5729711b630d7a0137c132086e6f2f72e44a25c98c59a4eb4093544c0fd657e01b0d1a129ad1719e4883e62d898f508c35a28a0b1ed0b84ba7845118371dec00e5c99c00c53be618172e988e813bd567ec650b3578856b48b3f67cf200718ffad65c9784e8a1c8d70014710eb8d550b9d0827410f60eb828f97439af620617b89052005f41bc49661a8709a61c2e4a80baaf6dfd957b0a9229b9e2ec7b48a7113dbfa5fceed76ea17ad7dfb74894bff1ec13f01dac00b943b077dd95e0a8fea4bb713b644e93189e982e3fa2e9f80f4a9dc0d67f917bf4f5e32d7a4a9d3aee992b77d51b4923fe21d30ad8ba2ccf3f80ea2c556dd536ac60400617bef5224aa8de415d95d0738ca3a28f41d63e050a911887cd65edbab26dfc0e2f3ec377fc93f3c869b9832285c065464b6d9d29a32a8d4219b8f3ee363e4905dbda84cb4ac06ee7e626d16c486de2a16886ce2d9af8998fe8772035e848ad8036b832c42a7d410fdd73089b43537ed788fe455be2a2579be96f371347df52db28b2f61a44fb813d035b01a8ac161ad30f427fa278eec794fbc7d06791adb27efb59d600c39fd6459d8e915dbfed9feb5e0151b1b1f1f0b51a5704f9971f1eba53e51107d465c0deb29ef37808c4764b78f320868c54023c2acfe4a69f0d21305b55784297812e91bc8f717f9a59ee8ac84b7eff0974a79015798496fac1a459889adb5ecdb2416f18c05064470cc81b01cbf11b3c13f7eea351f63aef88e000846277917786c2f84f04295c3a6968c0d31c9807c70ccababcf85ec1b604a24353fad2523d2fdbb1bc335e77db9af6e0dd7beab73b8b40dc0afe3b08b8c1453dfc472a1fbd532654a77efa6ef14c2a3bba7a8688768f2249b3915b4e7c5b52028030ea151c4660257798e40f6da61a402b8c6f32be56b78924a3d64df21fc52b7c0d23766239255fce0609e1d34db12beaa80b586a7ddf7c3f825ab09d883f94c5073a9767d5acf0542c9eed48fc631b4fcc9093380b19a462fef07401e8f16238d7cbfeb8d4c0aad1098b6f180d2da5f5fe4c0b5e6949a12842e23dd61b6af17331534f669fd06bcc689d9b4fe6aeeb757fb8c37fc1835c964b0b5beb4004d0384aba8b64ffd14952066ccc516f6a5958096ab37b93e149884267be4f639cac604a1e6b309924d9b12333c959a4d2ffd0411ded80fd3aec6c5deec0379719570b1785e5934450bbf3f97a7ab41eb49b48a61f36bfd83a9e8a1e5256d205875880d8baf79fe196b24330b32965e5a64535773e82352f1738b4283165b932c3a879b957e385e1ea32325da535c6afdda8a0fa183ab5a01a07e413b89c1fb962e44228689ad1d726f319b6cea881954de19c10cde0c2980c0fe79f3c572f953255f9b64591f701be603ae089b8a4a0662ce60da4f1e5e5d3b703d29e7218b47a77937108b78ef491dbd2796e4507e0e57d2e545e7456fddc2bb32301024728a587d4ec6a1c719619d59fb89475ec79961bc8b6a6b3868dd5f263b4a54a7f744cde45e8d36c0edf315d8088442abd9161adfdd7468b458552212df9ea8b846d0808f0fa9ed3d6a3c1cb715f2410f5bc90ba50feb2e210bc1bcbea675ca6d8b375097406754fdff017f34196a9ec7406fc879beafe624fe5d990ea4c27d9d6293a14fe58ff72844ef2f8862a2f7b66cf454ecbc87d4c24b94a2d9dfaac856ffca5efb0ca5128d1ce615930b80c3f840b08a83e6331eb4a9a2db2c2cebe6eac1fc2126610f8215e2853c3d7c90e22e21abe085fa4e3236e82385642dcdf0c1a1f44600bf7e60f33042118fac9be98c6ebf30bbc6247917ccd3a2824a020626969e0ee12e55b61abd20f0c76c0c0f1ab5e69a289ea5ffa83d7fdefa3ef5440249852bda1e91b1f62ccd2950da3910c9b8cc38194535771928ab56b966f2a1ed2845df6cc7d852c5bf4b8f2efd42dcbf650a8b57b4b7d14df548925f8f210c24f421d245399d7734d14cd6d9a094b36ee9631313c76c869f797fde7e91a708a698440e68e6e9b16d49f4262833b5368194eac8338174ede722de6901e256959611a8256d4684c7166f1d1b1e60aba17917963038db6e3265469e96bc08b71e0e1e18d9f9020bd13d89609a13c4d09c01001981ea52e93f1e6888a765619ff21fa683cff4237fea9b828b539449e09704a58bdf2b1f4baf46319351dd7cbc434a4e4514c9349f659dcc940299773f0d71d3901f814bd768e436ec9d79b339f19218204ed6e20e0b94c4cf907768713432ee816eb397606dc43ca000adc4ab88c9e821d1918c960676668c9edcb7ca0d9d1e87e72b807e0558d903d38e83c148977400ce4ad803f454b1fad68beac61392db8b2712fe69d212f83ba833d1ac0fbb669d695414ce64f420b13069356c6a14b1a2c09adcdb1bd849b275e7b332a6326c665bf55892a6e191efaa3b077b3bec272f723a9b055feb94b8c0f5bc018b3aa6fa6870327ca6afdf515d86897382b6f21bc8b9c7054c23a37779694e26c40d91854c19bce4f3044a56165d306561f017d0a6b825b1ba5fe93c0df208adf9c33a51600ee6498e6b73150a84d138ee6f4c335a476731cb55bc59697641448439dca0cd33ceceecc878ebadc9fe4a028de48bcd155a41d69d19d954a939fcbafd6ece9b0e1293e3d7885540393c9832d2d2377c95df122226c7797e8204af4608fca419937c1829093e2a46fc61b91d37321e754f0be286c40c2ed1b0cfd07b2988153334c97c342735debca2afa17d12e2eafd3c3e2135c3ca902ef1b75a24b33291eaf19d20336b3ba37f41a63cfa73a1744f0ca7089d805e3a95540fbf44ab303fb07d84ac6346c3391f47b215295afc6e970ee2fcf39d9cb93c80ca0858ebd9b17a16f4fe06c613ca68daa504fc5ce4bf9d42dd9f708a8849e81df626b4daafcfe5f84cd5ac35950cccbdc8ec93020821979ebaca778d67f9e2d0c374185d23781471d39e6c508476ecc33cd078e43c083e9deb1959e0ab789e0eeac592ff3ecf74a9ad2cee33851efb4ada657abf790f3d8f339e777ac6f05d18b18b07a4702877164483e52cdf58dec54c70b8709bf0882351506bf751e09b85e669c5eaea67b350a7f9692ef7952f110d79478ad9fe310f3436c2eb6bb8d1976009216718a2ec51a0c2fadae35b2b8c8c55a4793441d29be68a0a55ad15dac2dbe93a86ee95da783e8c9ac7f1a061e5916785c6554b22cb08cd68012cdaff167149c85d417862eba92d25a6d909c69a09f77f29c954c07f1d16199d2a83b016f1b83e99fdd4e31940bc98b24a293ec93fd5b5b1915d54305fce7d96027729c0bf3ea75f8541630e648c837958fd2a449e331e4e6f4662c4c85ad11ffe285bdf1160753fa7ce959eedb89b04e31c1af725e86f7fabe48f74a132f35e2db4803481d856310a93f46980fdfd5828c35dc29bee969461f08e7102c9cf41a38dd7e6ec925a591f668e8fcdd009fb172b09f32704a324cbf44dc2ad788898de449e1a97ff5b325f100b8485d9b676b653d933c34412146540b932a950925ee4191c27562ce6fcc30b88a7d812a630674ed97cb105e21b6e612ce1007c3d75a81c3c8fd4034960801d7b3c75ec3ceb4ea61d800deb0183960d5311900634e8a0dda02fbd16b8283d8cff6565971d14e4052b5067173b0b9dae2ebc2f0e5c943789c7ff90d9b5d1b8f7ab92bd9730c27efffac76ba7d3f2d20c0f5f48c6c776a30ceb4cba6731888349360036b05553d69dd6df22f98c84e85d75a675814f3df6e0a3099adb5af201ba1c0a46de351cb40f01878571059e06e451d925cf7e7c2c6772fc39d45120423a6142139f8b6828d8f228fcfa7e9bdd0fb2a6a4a15f584f9cdfb26dba1362c1962e2f71ba62636fce9295e0b0c8d5fa7389e1860cd1784a72ced39c4f4a2fa75d17faffb5c93005fe632e23b11f2ddbe2e44e31c8783e5bab5d4320af5f1fadbba564182025033ce980e6dc727b45b957ed3ca11cc54b5d0bb356da30313b45c94f6a967117583ac36ac1378c9b63977d379f4e5b9b12d81a6f6f90ca8417a078bdfbd519bda8c21d1a0a1f8e82a7deb4f8abf91f61cba7144746d950e78749f6f6f93c529452f184b8265f8510ac6c2e0b7ca8cc919f92193db1eae9d86a8068515650ab96c1cc13aef9ca140e775f37cfeadccb769c306c9c1aecc25fa6b2fde256aa7f12f8d18cb787d06537a371f63ab4421b6d46d77431ec609c6c965a07242751940f4e0d79f13ddfab6a69ae5ea0af0620a16c9369bb91e8ee5abd8111b8ea88f9321244c5e7cb7a9974bd7d0e399c1d0e9d74882ea32747a1ad4137333e63344d4772852f15885f27d9461c880f7cf3d29feb0082a5fb95657cbaa6dffc55241d82304d90855a7f58b4baed2130eb2508b20a3acb58efb735ecf67e2c289e9b80197b6d2d38ce676fc6723a0bd4382d132c6a0f04e1bec9c6e369ea964a6f885ae2b4eb5a3e3f0887a2dd3ae96c39bae51c96e285c074bf45549f0012986f1c7a8b4ee60b0e49de24d08a015a45be98987479bd679b5c181324c2f72f1429cb8a2ce943ddc1e7195426e6dbf4402b63d2ba19ece2d83b60116663f725944793793606d6ce953b8a4950d8d544f2b63e7fabf60f3ee19da480166aae4a4d2bd0d8871d61a39e1bff3e6ee2278efb53a55f37d78c335c6576c25de4bbc3e9b3e3672b7d15572d08d850da479331e29b708c135cf56258eea214cbc626904d28510dc25d2a03f8e0f8febd5007a971a57400da0df5757f504f6e365967c3eaf7a1d963abab7ff06ff5dd94604ad546c1a8dbd71b025618b6d3cbd6c7f0cd55888347e591efa41ec0d4a0eb9d7b901410c6e56444e6e9ebb1a0ab92db9a6839a34c5471f5363eb974d1798d415cc5d0294377bbb39ba6f80d99a69fea4270a94b86a6ade981864de6f5bae759dd3e7a5e460c6cd15d91eedaf4f2521c0cf4ce3dd49d7d13e861801fa83fef094cc6ba83fb35741feb379ad9026a7107582019d0c412f62457ff511f2fd91aa63e8f28d0ab085f6b55c2e6afa9cd10fb6a6e432ffa3329b611726b63357d671c3bf9326617ee578c7445c64ef698f51320485a12396039948ba3a11d62e50a76939c244dc07075e21e35a1b0f2c2e66e813906386efb7669f71541f0466b5e501bd024ac76679f5a7df9679304f598f53e9ae8c54f29b9f464280bbb89709d0b0ad1a92b4972459dffa00cf2033db2463fd2a76bff0bf295f223a039ab7ba9785da31c40587b0b664416e8c4b42dc01d08cabb48ea2a24fdbc4429fb4fcd9186bbb9987b283ac181ac284da2ca3112aad1e2446b18383c1758ee6786c60f4268f88f93588b646b1b7a581a0308490828379dd87602d946cbe39c25e761ace88b4cc53a79eb57f976b916cdb4a1b6f6cd8b43e3fbeaca83ebcae1dec91c61890dc3cd72ffb7a7c5ac3d8ffdd115f8e26be0477705d7d1ea5e03814591441d7a1b699a4c450e69a70ae954a486c3c0463bde9fc02b956b1f6378331a3e0d4066c29d15c6e4ae89369ccf5395143dcc9e174d5224d0e85dfe912c353a3e01ae23818e196f2b424dbcf30846d04c185555980c5d35a6a85c149bde2286cfbd30fd73e6f469de608d99de762255b8e1ae3f08eec4e26bb8d9c2dacb602880d3c0b5fb625717fc0558ce861969654270173cdd94345dccd25a1c911d357af3d70e04b8d82d25557421761f8e77237311cb7e69a70a1cca92322a9fd0dace7cb3ce2cdc523410aec319da72b55ccaa06126a7997b7b7abe96a9449dceaa195435d4e24ef907cf25d1fe5c7cd87c3950a8ab08617213adbbf054073a3950f0a93eb70ee8961ac8da081f37a28f8597c1d724ee8788f0505de4db921cb5b02ae2a42160c814ea6ea0750b31f12ee898f3f5d1ec8606a3b840ef8cb61d0a565f08c0ab5d4c9f09dfe3bb1350eab6264a8f9343674de2cf8c8ad00be548e7e50b5920c728d4c5d5322881f07c4a3d6001f88ebac7995320744fa6c214c9b8deb01e3e4352d8f8b51f8682df758ac4bea969767069a69d31a70191a8f7be111f067a9e215e994fad6ca6f09238fa6b135ee2762db7de77fd15bc8c263a8a50880ed5288d3eda7ae2977dd7763c396802e84f178f06a29aac5f2562e2307cb073198ebdcacc88811328c128a6326025fa6831024f5a2968c8a6669fa58e1f5a88d90ea17082a131f1df9c306c8a2bc5951fc8c5ff01c171762f73e44e48390e4f20d3ab7ee2f5d4a414916fb510fefaf20e09d5716f3675f812c42309dc6f20c9a9d358a8849f22e58305a8d2047d897b678ef8855b64a95487155d2db60afae9855ce1b6e8e1a56282c50a660991624c9a9148866e5f29765b1bd2f8c132ef76f6da1f1a711f3c54046bc54e195946ef14448171944391072e7ef32123dffdeef62aca3258db8b40190883e2b47842f0e79be2e6052a45846549d2c2f0ec27d2115d3146825ff9b6500fb50f18abd1cc857ed18d204bd6000efda1573d79f726fb197d233e27d3e8de9fa0cfd3a124eda5e7b4c53d923181b669fb472a635efe3e830154645ecfc1b0980b6d0d7e36549d2f148a03774aa1b6b63327e6cf84992c2b3ff79ef4d7780f9c7e57547ba41f71b7f75581eb67ba640a78b9c40bccfbb9bc151c91934fbe5cbd738a6cf57364530061116d28dda3c536639149564dabaf24a77256d544457206922718ab9871a8f3659a83b5db269e0718d4a98cbcaa67dfaf10cde51e8dd50a438535765658f82f4dbc97e408b14416485101fb44ddae0e0b215f6fff25c90d7a85608407f193f870ed39dd2cba7943474e2242642b3203a831a76c885ecafe7b2443b94bdab60a11cd0821e469c7dd07dca6dfdb76eed649509823b4b8ea39f9b652a8ce76c3a9159314dfbc6d62216f4156a8e8ebadd2b60484762c2871d3a2c770dd70ba664f30a6c27a0c56d87ce0879b4cb21ecab9141b6e9865883f951c535c85d350ba97ebc2a62195882103561da07b2de940f1c0efbcae56f7e9109b9bacfb8f38cacbfe9080b832e988efee212128b6f6a1facc2b4b189be9de5847d254ab0f9fe6f895e6f50ff37c1aaa5d461f96262e16adaa4c66df899c4780ded5da02d60cd7fa7d1bae153c944140e6a53dec63b02466c39b322ed32bbede4973794675b60ad102a0b4d0d50ac9b470fd41c5acd31a07d5c459611e773dd31ebd142443fce212cf2afcbf169c56cc2d46b77397512a9cfe58e73ac0d813541d16a0bbbbc6179afe7466bef1b06cc368df3f4405a73c41a6a60a8a75f20216c75f36aa57a98d1d5dd12d0b1f64d6be1539be6d8ce596618d3f9926be20ee40001f118160224a94bf3f3f86bf33489b520d0feb1142e10a46d07377a5e7b7469cc8d230df9edefa347f52cd72d1b628813691aee1d4630571f2dc1cac5ac26e6530e760d1956b3adb7da32a1d171b73ca73bb5c5b8d1293256e67a3728d0949d201b6ebb743cebb7a08a3c01758e84feda6fbb38e9af2792d21243063ecf75555759c43d07f5e7811fb289a076e8eb71a0ea9dc0bb85841c0367862b0d8adeff0a5af2cbaa5b3097215d68ac04e13f67df1e93bd561afa96a474b7e89d48ba278ee2c09c10116381ba2caf39c198a8d1ce967b92cbcc39533b30e0c099186e852fa1a0cb67529dd89e82f4d4ba0049924ed740e85b2e60db65616f638b39ecbb17b2ce1c5d95821e17f717c8eb21422e402f3018582944e815cabd90a99c8d2827299383e1df73788c471c9b0f0565eae22d8a49013c9d5782aa20fe1aa1083468152a255e2c694a70e4f82cb2cee4b8f6df3a800e85bfd438c153ee7c70ef3420b62e29a20a8b2a6d521e18cdb778dfdb6cfefde77f0908131932db51546f76614ad3920504555ba2fe6874f2ea63886c17a434d84c71dbb17aa26ae1b528ce55cd5385205cfb1524c8b32cb45fe0269c86de937e03dddb75920eb686875d9e3722539fc781589bb336bdc6eb948bfa1235fca823dcb6bad631d60764064436dfe98cc277c3f5e141981996eee703305fad25c0aa58c3d1e5f487a014a49d49a45721a5b9d150bd3b657e647d16d145d8890d683aaa884a500cb9d66be79c46380e50e530d63dd6f93ffe108fc1dc54235f05bd159fc63b571d4b2dcd7f714733b2c9df141b77d7fd9161cb7fb0fbcbd928e459d826e392147ea676dec9114144a590964244fb46736ca2fb6010c63a1450a89bad787a27ce4136115c0039ac1dd913e9732f857363eb1a66b87b08785a8e2b09bd64e76ff97490b1032ae44a50835235b76a1fdbffd11b856d59bdece8f3167769b90999102657a4c6338c15814dcdb4b14570320d48e6e67c0906c334c51c0a8b641b4b7bbc116b0811138bf03bcbacf861194a725ec83b0351721b2dddf06cb88940862fc4edba5bf797a8b290f77da3cc402221913d4a3e2406a3b326ae3c98ef1489c13af65d8c62a5bcb855d9010b9d5527def77bf86437908d245ef81ab9e3555925519ae273349de7edec4f96723284c8cd959981adcc2842f0c811d91f54c05a585d30509e837e04e4569f319fc5c20e548a8f081e88108ba5232e1ddbc1cb9ebe610b32cac483288938cf6af3c904cfce8f7adb528d010e0c13918a236fa13093c48121367c5e338ca0047bdb642b7acfce710da71a53f0f59450a2316e04658056e25a74645fd4d6878e805394ef421024598846f5af4ff970cdd0e60c50d9badf346e11ecd2b7f579014ddb1a2e32e5ed7df1dd12524a8b06f498a394048afc9684a331e49759f10fc5d44cdbfec023827862b7c258c95be862ecd35c8384adf6e998b4a3019886de401f4128ac28d10ef08d54cd45d78a9a5e4563b7d14e78fa147bc8c9f436dc636a6ef19137f712b4a8204182030757eb9aa4e342f1ba590ae7e23074ffa488e516ed1147c5dfd2c81c6c1aba74d8e09c7fe663cee48d92c695e6c47f9f25285f0a5374732b9783503321407f3efcf7c1f13993dbb0c64134481b512537d25701c7e5a20052ac1dc897d4063aa11277f7755886621ecc7ea817a0a7932004c2bbb0b6d672293bf23b3c5a4de9e31ac72f10e57e35514466039ed9e6ab5b7db43639337ef33a7bf8b7d34a4d62bf7c6825e6003d75633b58481377be423451eb90f5602b8e279886d0f293f94f85d06f54fb277cf06d090dfc3a1a3d8c0e94f3043fbc5efcc63100e9fd61ed8d95b4228a5fc33acca1a7966420bed0c7d5b8e9b590b0187dd025b163501a7d818ed278b25dcf50919bab125fd64877182c5acb325a9ba093f82d74c348abf2855887026c16ff074ac04b586d3d49514ce545d3498c22f951c75aa068a59f39fd9490d033e1ef63fd6589a877174a5ce32438afe9c886ffa1a5c57f3afd16a878d671da8e2eaf4b1451e6324b358c0a06a7d6c70f102de975bea661290ef84f1a4653b57255ee91a6b30129458815b50d53bccbe5e027e3ffc8b275d41e51df7ae67f3f4579c1a39ad857ccb3c9f95bb7f243fd6d839e49eb93df6fead9bf4b9890137cac0472423dd6c43a56199d2e26b93cb492ebf7c07cc09fbf71492ca0d1282969a0f34f8765e9973cb35e03d8f9591747e4fca670d3397ab45b489df0017582ec2dc6dff2e6b42b8fdfd39f11911ae5823132f689b74353be2ab9556e465a035f066a19297344d7d38fd286e1ca4456cd1aeed1df34e315b6d6097167e2040ceff41a43fc614d63f642a3b7f1d1149fbd8550926df5d4a9563bb11b2a92a3051aa08f4746296eb1745e08610796e7e7a6026c10efa353a8cc099a5d026612816e1712c7875ac09c9701a16f05f58fd1d76fa92c588ba7be700aa009debaa54b04e11f517a2b012bc83b5d79a86103fbe5c1f6f31af61bf49e8dddefae0a5902a9977f8231b4e70ad7a07497f339e5efb210ddcbde3567b3a447d66e29bb4dbc75d53086d3e1b985eb0d3431cb1638d5f5f8758028202ca2cf573e4e647b125c475f6443620efe79cc71d420d53fd943470572d25f3eed7f2fe53d134feade20ef78c639e6a31723d66224a89425e47d4219c40de15d2a17931aa5b4706351288e6996c95c36530e096b7598fce1a43722008344d28aa23a43e183bcc6fc8dce610c2e5e47e6b1490a3839a00fd4b198a8b37ad097a012e342116a4813b785531f67b1411b73c52a5a5f4081fa666fee99cd0b892edc8182a7a75e2c0b0f6254faa562ca0f8aaf58960e18843872ff7aea927af13932f414c52606c776d04b3ee0bed61ac9be72e6761b2be3e6bc8aafdf1311616dd1882ea1cbeb033a0f36785108d4d6e4fdb6276ac1724fd5e35d54b4f4b59d562496963baf780f935bfd36094df4c9ecdde011c49c777585208b90e1760f2283703ce51279572daa651fa1631fa639f6a8537961374970ea9ebc0e0807ef7dea65f1e69bcd5a34c557a701e88e3fd191b0d9422b357f430cafad5dd4471eb0d8fc1041dda1066766a6e448db6f96fd6e436e07650c38584220cf47518aeb48ba25b62b5de923e6680fbf8552333bd3f390a2f0286e7417bba3874923cab195597fea91cbbf1e8df012e9d9ffb2daf8e3a1e18d633e98e06fbd2451dbea3171558d405b5f391332aa80c584aecb0a85402b06e4aeff954b9ea71736811bd3b53e780db591efd7b653c00824d03348b79f698ba723ddae4902b1f656e1e7acb2a09e3cbe772a9c0d31cbf765676b28a4c56f73479eeda6c51ee9ff6563ecaf4fbd62962bbce46cff709a05e8ed7279d5d98c055cc19743ac509715ff96fb7e7761a8bd29790b6c5888c67a2c3a64e98bb3671132d8f20e88a34ad9391d4af2a885bbb76247efe25ce82d4cb7726fc393736a77e45064c9a36bcb25582c47ef5a5dbc5cc041d96bb0cb428a704801366ef8151e1382c88ec524a614223f8f14e400297c686cb4fd1ba9d84b3c603af5172e76bf5705af9579f309f71c7339a306f74bfe91344492a962127edfe9349016ad7fa163b9ed72eb08c81bb6b2a40dc9f73b33513c7b0044c584695c0b19f9ed768fa0584c0760535cb386fca89a1ccf1b64b4d00073f90c15d3e60f8cf44d642852250c37086fe962e6e11de543470040dab8cfe1656038205bcf939f4daa367567634311ce7fedae8655479ad5ae7ee2aeec93dd3364bc32e7b22fd5b39e7ccad088bc9f8175d77ff3df3c82edaf258bb4fd9108feeefe69bf6b7dc6b5b4e1dcf1408fdcf04dca09715fe6548d3233150ea90f3da143da76748d74f9e32f9edd66630c59b3cb4f268bedc474aba791b5b361b887cd846922cfa9f8097a25ebb0369bd44a5256f9ae6d6f83c380e9ec2d72a9dd93562e547ae12b8eadd0c16b5c0f1bb8b2a41c0b1f3cf515faf3a106e358c5e352f39ccbb79030bde45978b67fc927fbf0c087cf01582fdf2651bd99e5e3e75f7ed9467314671eaaa65433e193f0d872daf1ea2cfc750a58710a6fd8e0aa33714262772b5a44d5f9ab03de2682a5d4b2e81b1b024dc4ae907c83dde29ddf38d16d48cc81bf3b9cbac884aeb43971843cd0c977ca057d43403551515091966363c663be1633a87e5af897927d277b4e1d4737cc3bfcc8482cbe77092ec148101c15e39e73427a94db0707fac63129478a1e7b2e17003c881277911014cd20e40dad0828977420a60ecd66095b3b44f51a4010a7785e633efcba71ea06fd075e176090c30252410c4f60f274173a6e70cca145b09925506e0f71648b74e35a1bf9437e98dbf1976366ea5599a2d4d4fec930a7e5b06e922dcdf816336ca95b4a6313214a9d0eced10da8bd8a216db500afccfb9094626a45c5fdab4192ef185e87235e19ae8f277b1198a790208a1f08e12c9f355fbbc623ce316e570b0d7fcbdba9fb9e1dfbddd618bc52d0bacff53e58de794048fffb017805b44c4c5f3663daf2fd90ba4069ea5af604e7c107c57fe4b0d1dd176010104190a661aac211f71828c82d0f67fc218b5b6eead479451acabd4537725c61b4a48803e0b4030ad96ecfae7eab7b2369ad09621980d9be4cc2251665f6081efedcda9c6c919710685991e1d55d77500b9630dbb1cc7fe0a90f21a2bc26f905bb6023248daf4d47f73353a7b113ddbffbc0f13f8ad5f2beb4606632c64c087db01d2f5c4b6518b60a2105fad88ce3ddf06c61eaabbe31062c2c0d29f17f546b96c7eea4bffc5c91bcb89c85871083cdab5824734ef1d7bf64b62f1138fb8fbca765cc798e2b3d745a5f853a4c56c0af34dbf15242e656e94964d01fd1a7240ace6440ccdf62e75f48c4019bf4efb66d56e281eb810ec6baccbc629d480628e4f9cad21aa3538232d44609a66e490848cf331356276f613d55935fda0762d00f72e81dbf15928ae0180a65b2ebd9dc1ef924d34636d04c3ec5b8759bfd54917b438a6ab9f1660fe77aff68d4b65f7782eba1eff855486d5d590201996dba512e85e12498f84aa2055a2cb6748342dee6fe0d7dd89c568b3cfc35eda32203b05949734a8a829c4795f41ee742d3b53e70538d444e47a6c8abfdefdc4bf9b0d77f3421bb3ebe86f5a6226daabc7e999f773462b46e963328238b4def28aeed9b2b0c551a65753302d57efcea6a977d209a6250a739b9e74b279a0225940213942b3a9e4efca10ba2377ebe6ed2fb4aecf30a9c401ac6684b26f96fd25dd1d7aa7494499cd20be744ff25a53df59bda55e5ba48f1b79ef08b8cfacf0f0fab05c88c1f52d1dec983df78517d200ad18664eb8ddc96a95f043e0e2c40ca176626d3135162a88a477112bd7f49a94bc6f6dabbd29d8a634d8422d4c9acf84d66ab75770a11c70af6631665b61125cec16741e75cd747ea406d7e33dbb6c9f5627f42b4b3b4d30c681afe175bfd81118836955028aa4e35da3c87d47364d230d9a9d31a327d9e0950da02f25b2abe800e18c0441e71583b01df13bfa9da581f66890b1141f62185a8b4567bbb2252e02c11dc94a425016cff5808d29039ff9bfccf147acc0f6588fafebe342f69dcd45da192c46df6c0da892376575a5d0b05f56fee7315f6bdd6940cc8f2ec0d3f202e5668af57baabe342c63f9b80ac4579df3e20ad3bd61813bb759295031e233901ec3f905b555ee8d21766bbede1bc41de304234e0b326267364b6ba29c40936e014ffa2d26664c0e40e85dd3593689137e569dc5689ee10386280d0fd48b2f3b0e70f136ccccef976b1804d3304e5c11049b1f5d0ef07821f368d8247e8ea798bc540310be4d1c9a528b3f182ed70aef99f09b7bb4b575858001a05771e0084a70f00122a2da52d0d29a9a241602f644b3860ecaf89f7843301eef6f99afde6923790b14f90a6e6045a85ae52f1b36df19e400f8f4743490182a283d0cbd70a8d5c803f51317e189b9cbf02440c4f5d8a3a7d6d9d715367e7e9891ca4f25a4f0df84a18bf870887bda4e55c49d9f805a66aa3c023bfdadbedbef422177e3e713d79c0d62d4ddb42d1e9cdb8d652f39c64b7a73dae64d9bca3cb4f8b4afdf74b87d1e2d5db5c62cab77a4e52b102db0b320d934072eebea9152c069e1b96eb25cfe2435f11b3c1cdb53aa97523372c125cd3bb5a5b22f1cd5d95221faf0062a3ea1fce01dcfed101ffda537fa3bde5e3858150b9740507667adc2da9c00af1869c8e64c76620232c0572cc704f67dd7205c6ca16909b7186e9b5abe5c0a7086c04c6d154ab88f740a9175e4623c7e0ee8c6e0f0b31866537eb370d1107545d794dcf0c79190d3339e3843dc00acbf92e9c0c80fd333578051ea3bdd029c4616de358523737e3e288f93d57a846a1af4df4f53efaa606a0197d41221ea0541e0a3adcafaca9681a67dcb5a8df111d4330dd869e74b5297aa14e3e407a5f81ffde9c8fed7e9b3617a91b322873d2b2bd1b61749e1b81fc8f34daa3d3d3922bac792ee6237185765b8753e438dc0d995c8397a994895adb5f23f1ba533e5a40fa8111f33a2203fa5e46201c377bd4ead13a8bcb2bfd40c5be8f3305df9242f987ca64bf990123f998641e71cbda1d9f8080a920259c027f36792edb257bed82851fb441348939c459314a6d8310a821e319b22254bbdff194024dcb3e59c2034ebf23c77c949e2eeedea6e19339f5637fc96082c769c017233a8e45f4330634dde04435cbe728fcd14559137f00f915eddac6d846f565616bdecf0deefdbb4eb5e69b082350de967cd037ca284d8df9c422ae921ce1f37905b139c182d60153f0222a1c709ada12a40f4bbc6da90d10362a09eb6f521522acf183f4a9b752ad05b9f4cdf87d8756f8e60ab84c48a049cf9da6379025d7c4f70a8c89670fd9894fc1aa14daac2ef8b67766143c238338d4ff2b8f652110d09d8a16d74f3076b732b668aa9d1629c113c660831b235f8e95957d28c12de359d8684b2824a2b01f6957d6f6550f2f6c2e244108c8a9bfe73ba455c2f48b5b86e61548b72460f25eb645f0f02ec1a8881379595014ac6fcb7c3f6799dc5cb4d253835471cb47ae4c1f48a8bf4163e861292c78cf3094c28b6d2fced0b7f14a42ea352036f775106c88e61fecd16e88beaae4fc176a00d2792f58d0fc5b2f2ee3e45389cdd68cc073e5da5200add17940b218c264a14d5c03d1a04ebdd8e98cc2f104d9ed477af99da28482bf1a4f43571b47a198e9888dcf4e76009391d948dd137072dcab4140e4abe0be30bd62191c9194b800cb45b6f31c3de117137806354e51e87b17eb164d952a7e2238fdabc40caa2d58b0efb60429735cf4465a9863754cc4ad5cf4ef19d19f7b2e95eb66d407eaaf503330246cbdcae94a103346c67342de58440823414d2ee131b536dc1aaf05e7d36943c06c0018e0827be12ddd828237ed567824ad1f33da3e471f3394ec6e62d6a1acdd47030ca046944769262608091f2bcbace2770faf48ad003b7d85edcf0c805fb1f22ba8334659f4fbb73456265580474890873a69c4e3b29f6df72b52684b174b804ae7999bd911cfb352227ffc098a839ac91e9e3c53ef5c5f3672319ca05f61ea18866866c344fc3cf3e7e46d41c85a8f8354d0adbc426534c02cdebeb32a5950763e3e589d9c68596d04ac68d0bfa8b8afefdb0410d351e31abe4997f4a2d6f84abc58dd00d981d12be52e31217ebfc19318fb2dc2c99775eaa547f0ef91a1ca0f34c47f2a9327552d4ab653a15470937f93557fda16cb070f9ccbbcd25076c72b372a0914a9b07af4af07694b839c40320e1039360eaa9ae1c788c0a7a7fce5371916535a1ff403479704fb111c2bdf4646b34e580fbb4cb2c97ab2281bbd89e05e38e7fa11a119922413b8abf5cb6ec621162b319de4a82f44247a3e4e495dbfd72ac50edc40c8f7dd82f55551d750e87909027a670ae4447d66189d851f9d3cfe9121c1d1df4fc286d6660d71033ead7c377df2ddfaa01b30aad4758af02a03e0c1c8143e6d7dce4f047b662ec260b9e45d144f24251c1de9c6f77f41ae487be0f98e53761cf8791bc63ddbe86041a2674981398512323690c52a3b5e7b234d2b3b5ab9e914cd6c1194cecd8cbaec9efc8ced2203fed6c0814480baf6c641110541fb8555a59352e89c6862ec2504a7db04e4b554d52eea9cd5751af3ee76d54e21d1f36661c2fa718405d3710f59e8a854e044d0759e9650742ad3ad1c97452b42c0f0aa7ef524f50997642a1742cc01edf2c54a51c525ea129ebfce03e7c45932fda7016a5dd90a4d401fd2717996167cebb9449c93fab9fe0d3ec6fa51e25d54ada84a99f63676a7f5d011a06619452c1afd37b63dd9ce8d4bedaa070dc049160e2340695303be90c1a08571f69fa559873bc49e45e971bf5e30971972035c24be24305bf00fb0326f2eafc716de7a41d82003eb70f6f089ac505b66c73419fd58985efaca0bdfae5edf9afc732f6ac8c8b29ea5b279e1a0946fd8fb873419cbd2b7a623594a7f7ac43c84f8a64c790314bf1db45e466bbff911ab76968f0857060b6edbf2320898e1726b9c29a1a5fee90fd9f3f40b189196e09b71970489a9eb5e28ad6b5edc901fa4c920fe69684029433827bf1825beff4627726d09dd4ac992585b8baabbe23aa4aa8dd119f0c6e3fe2f80cea4efcc5e6dc920406ef5c574d59dfc934d29bdc8e33aa56f8a6c8f8369702d64f48ac51b981e5464668c19349226d72171b13c7ea31cb97646990bc236779fc56114224c727a833da340fd4ddfb9c26f7f3ca2939d2105ce0c7b9388a5f53b66086b4a69bb74940f97ebbaffe1cc934439d48f0ed4db29778c3386484dab25131e49064b21bbac0ae99a8f15ed4ad3b8af6d7c59de2b25a0c8beee4fd60ed40927ba278602074e94bdcb5ca25dd7d3f61cc57f41e6f96853d437c902b2f78a37a55d56c892f524f65f3c5a57723b41b5ea3f857dade846350fdb3e7277a885dae645cadc120a4697347a1fed3d1d3c0e5d712b34c5402ba4703a7d459d51339a0bc2644b00c73d39b9d424bb6323d0e1e54a4477dc456a0d1df4c3a24e125c2ec20ec014660fc9905855aab80fe3769164a5086029beb97468d1441e9ee6466dc1891cd071fd7fd03efc4e57c6d261f1bc9dd78a09f31b44c4f1eec5231edd3330c6278049fb2fc8e3d00d04b2bb467f5f132d39e75f45d9a333dde9930558a91e9130b3c9343d8dec5fa7a4674c2bffe7e238fb63376261082ef7859801bf6d2fe2e09c3565fc4acb96345969eb88235ab7a940e02be0ecea9d511279282988cb368f7f59ec46f6c9b31f59aff1ccaf579fc7e483502c3edc27b791d830c88d8b5d276f6c08064d91462c9d15612cb4a803a6eb6d6be5b3bc0883e8c4c8012110b8d6688425f736b1bad85e331038b6b2a543763b19da1727977fe5a91b724aa1474b160db0cb58c93f0ec086bb1e1c97a5ae3a06b887e43a8e8bb7e9ede92ead31dee36dd132273065ad8efb3651e203bb23b27507e1d2c9107b05668dca99f554d969db2fa0c2138b974536a3a1f4da10d0f05c4164fc685002c9d6f5dcba8864f3c8eeaf27a829a632857e8bf9f22b72f8813d6c9844121f7d25eb3a3c1537828fa99ef8244b26e91c8d14001ac93f979c0d581f1a3206a3c821b925ee7521a5339d743ed8c4d9edf2ae11f13811976c674b29bd573933cd8081dba67d098ae1c0f945eb959c7189a21ebf7f46ac6cc2819a31d4552b78fb500c12597d2406765574ca421950f65db22ac6b45e2c18a8302507c6bbaf843c69fdcb94ea4b6f161c5f4be1cd1b2896b40feab5e60de0bb90819873b6ca97fedae388ec60283fa930eafb5e6bd38085d2295f31ae16006d769059be6ab2de754752ec5bc8370df24e02b7b24e2a1774d3d1402e5053149dd5975a38db3b6daeddde18866025b6146f16182353ecc736529626184ec00b94024694abc19c07e385b398e0c91bd4af95ca8977b9cabb358032f18bce8acd74b1294a162029a713f84ae315408935d2abf9a8e19bcd7b093447ee1f926bf0d3897990969c9e559d74c01d8c5944784b3aff14a2317d50e9be2d31866b80fe41193de9934c790570975974aa0984f0c78c86ab3742009761ceec1239db0ff6241c13e798404e2646930867d63bcf43e458e2355f155a358af63b29947ae769f1367d325bb5768b24fe2eeaca0fdc159aa36265e9e1caccdb3a6b43740989bf4fa1c1eb5181b82e0c6d63bae35221f61eb16d6bc2c3f049407922e5a96a1d5a81a87a1b649b6e2156b4f2502b0e2fd53608543e561b2ad2308130565e475a33f8fc7130f76e838bd85ec7e286b0b4d9ed2cfc25b12e5e5e74444b59e01193ca281acc8d6072be3cb8c2a7e59fcaf18fd5f966b94d0eb7055c75a46fd6f2129025c2aa99c4d39d97f921704d7162193fd54bd2ff08d695bf5699b464cd303464d5751c9abfc717026fe9c49198e674860cd7ed270de4351d1c58cbdb9714f0e5e3c27d6d75f1f067e58c5b831722d856ecba328e286b5f3c2330723a9b9093d04961d67f90db1aaf937eab7b613c1c9ccfd91b7774dd50d310b04771523f37253b7b34c68e4fb55fecd25ae5725c64b5752fdf6c9c842cd3279cf50840475c36e2e32a98eca71bacd1ffb5c2661bd2cf58750d92c57c80242d9c3ade67acb486244435101c0c1b810f004f5c7a7b0fda315fe023a0f4b81c34fc242ced76fc660d7fd22a480ff3896069d7b0184a4cf2a23793bae495c3665fe4297da5d93f1252f3f5ec062c5c726092dcba6d01e3ad26622b414afdbc2b086122b4d9a926cd4cb19b2a0febc346032b3931941c24818acd7fe6a9c6c23a9486123ba1580aadf173eff37ae2a214328e709ecb9145e70471b592e0d2d09ab94cc4b986fe9912d102e446f6f594940969f50b4880667d5028008dc0821f270b2d874924200a01569e603257343f33ab7cb441ee7a0c889b734cbe8ec5b40392cee33c244aab4386eedf86cee8d7756c90a00a0b091acba7a83c7cfa0f0ab33d0f4ad5e047d9711ac4e6005853f0eeac0a3d0db1456d7a5d6d379043546da6a8a270059c3fcb88eae39fd182b079e703fd6c42c1b11c2f9901fd115ed090b556a3b367b9b2b55c8cf9b155c1502d4195ecfae1fcc6c964127ea35f755002037f63de6352ed5f950b1f6ff5f1d1401fdf4388fbba00ae77c6dfbfc32bc3d042baea80abefdf460a2e0ce6c9ea8ac7b25d34ccaa6798425881c09a7ed0bdae66adb21e780109397576a839f3514113cfb460b6ca7f7b623f64ceed916cc4508b045fd26950210a5b4a3a0d05dc4a131ce28f8fa1d51d37e9d429061bbfddfc43343d90f9906c3566a0178f551a7bfc5edec14561c563857e3f1f68317599ecb9fe013c8777081d2394871c9d8495b0245ca8dcfe41eaaea176b968894b5471d032499a97bf85eb7f8ce68d4b3ca1df2fb680a3e5afdb125326f6fd78d65573d050537cb01f1d594ffe620de2730f4b3879dc8c874dcde05edefa802fb18c8e2a7fbd8afc6e63a928238499fa464a7702a4e0c2af9a205fea20c30be9a00810f07009a81ab77312d6168af2df2c5e9153d5af5d2f6d16cb2904993127bf0e1fb43938a21e4ecec5caca31c0e87b19e35d631a05f6fa38e69531b198803fce892c3c5b54d10cde3579139d9c3e7ac06c42f98bf7f0a7d279aa2851300f1c29b90cf69631710c50410d18bc4292122a9c6b683ed3f29da45ad4576bed6deff5294e8c381e6e0dcbd00962e181d1e3e78646435a114cf1bee389dd662eddc1b5c746d569e005aec7246ba92aa20dc1e9b51ff13eba56385d9ea1ba1fb4defead36913cd4ba5c017a840687129a866c5f9c8d575329985ca35cd3f08d51b24e5dc9db5428ef7e8499ff16becc7d437ee403accc94b99b24fdc766c53a8f9b2ef63531a44d6cfb697dc3405bf3f3b1f5d7a04dedf400f19fb64e02551c1ec8f5693685480d967e7fd50779f6ce7afa4f8be164b5654c3c14509f9055672288a0e3d1c36a2680ff6a8ebbb0489196e5b1f00e22cf0d7a4fbf5d95e1fc9617eb5ad702564c55945667ae214f8f81fb6c5c1f41d0e1e3088c6ecc68a88aaea1ca848e51e479d3fe8e8144b277185612c95ff64175cbf18a70a0b39fbc1be6b17f85ffd0c8396e3b90be37ae20024af7586c510db11f84c36bca5c11c9acb762d75cb0ade555ff6759f7e50c18f5a89f26d6abafaeaab015e35448a89d5cef04ca979f3cb31e22cf31236ed2936a57b8ffe8677357d75d7273002bdb462fe20d7292baa279ce0ea95e6611f1fb36e964eaa1a601e9f0b5a8838536c6b73fe677e42ce34e0e3a179fc80b839dc349fb755d4b5bc351a5a5fdd9101ff2834122015a41323a400282a489392e390bef9bf648d2e936f0dc27a632b496bde84dd7c4ff3f7b58df3e147ebb9519c1d6cce23c01e6cd9d4903053636e242f800382e6f5f651c8fb761ee0ce9e2b22010f2aee7d626853717424943f2d18e12b26e53040626698ffd1995c0b6bc8ac1bb994be2a10f1ff1f4ed20cc905e57634631b06439518c5b22c2396e23d4f0679d07bbf2315656f4c114ee117be664c80c3953efb2ab6f7d8e684f3203a37e6109c91045692303748f84f52b306bd611a182a2d4fa5409f284f5d9a7751f825c63084315619daaa77f2e852369449892cb403d7e49f0145b2e018e14440b4082c47f4890b94b47f7b35c9583405f4e572d0733c6303f302e4e3fa79a20efd63991008d9de1bb50dec2ba31b175ff42346a6a653d7275a358a7d05b0de1c8e9a5c47ce39996a06817564fb3a60d7fafaee325060c0a77c3d81d6c303a81974e4ab08b5f5ab2dca2845e35ebe000d78a341461d4c23c33f2370884227c30f44a59aa9af088738fc35ca460d6032a99d44859c27c630e1f6666582afb9cf91fc63af3786ec3592e1fc8e1dd52dddab848bad3c207565b9d8c01ad5d3de784f2387cc8e72c55a7aab0b05c31264d3bd312ce126dd3725d694185c9e111027942137df4c68f08514bec7ea0ca1e0ef606ac2699f774b7b2d5ca85d50e7a29ba7829ac66c77eae90d3f98419bd16ddde5f1a105c62fa60fb74b0e878ff3d5a2234ec0678ed45706f09982b8fd80426ebe7fbc384cbfcb9e0675bddeba8c14dcf9d93193cdb88f62ef9887fb8672639f50798d4c497b5b3a920fa3d604e7afab3e701a3e7d2802f7b95e7da7d2ee514144fe109ae9c427507195985268fc7e22001a2334c2afc9ebba7a80fc4f2fca64211131e936093969c0d5554d8e29bd20fe3042c84312f81f11850f08709be0fc145bb239b8c8cd5fcbf442cd991f6e83c2e53947d8e9f96637db9c77c1f5dfb862f846b51c9ca037d97d76b95d645387cfbc19dd6d657a97fc4912cb042ef54312cdf0905d4874d10d87c3089bec7408f3988af989045f78cdf8de9dc19ae95ecb248cc3d39c5e3916e0b56a610194a19511871b11f8ea7803f1d08922e064f900e15040db6eeea74bc2e076d16c443f28cc5ec33f631938521ba0a99d9ef4d048845a7108b9243e8ead627767891c1af70c799c4bdd125e56d8664eb40b83f7ca22d7b693df94c82cd06588800c267b65c08fa2f6a88c57276618560166ebb7403ba472286cff191887a4d1e98824c387cf2278c159e035703ac6a34510b90448a9d31bec751556b39eed9fb5fc4635d8d1e2c965fe2fe76c2cbf41694a1f4ad45fdc15e630dc6be847e45dda782c4adc14610ba2f45d72570df45fee931574e7a4dde1bad93e0083cd8584d820952e9a0f382525c5f5a3894277e2b92ee0888b793342eb968be9937ff3849e18af6b40d308981e44792f0f9cd81425f4028ba3f239a04d12ee6df65d9ed4e7e4a47b91cb7b8bbab8b472041ddee593b718ad545e08420e5e50e62476bcf0761196895cb9255b187c5c74d36caa517614b5e4b994ceb0f7f882c41e58f18089de2cb97970893187fd7bc3ef7ad7c71bdb755b5202702d90273bc0b4ce82267348d7cbe77b5ee3681afa6ae3310c7c3e9d8e79f6b29f0081822d5f417cac901da4fca1c7317c2a4a00f87fd9ea0d88a85ecab57484f132d2a620339a394f2a42a022bc31ca635afebc2867a264ea20233704eefb307ebf149fc7ba0259bde707a8a0183d15ab142eca5a73df2add103c2e1cfd9f9c0c8bf89368fb2790ce3fbdda2aba7edbb3c4ee51dc8a5bfa1eba71552d94380208d033a1161ca280c7aa7cba95ad85f5a6c355cf00daeb0a1ad0b55491b1eac49ba4a114a8cc2d6c30d9dbe73957723dc2771a43cc6603e120b5293f22b27ce5bddee9eedb9458e58a1bce886b66c21cb0d345355438f2810395eef063eb24a88719aa0fe9b39f7bb17caa4e51e3fc01f048405b9b5f7c5211bc65ea321763ef5b002dd774d464f5c96217a173c4f2e5ad151c9ce9d977a94ad7369a0105534d0db77c1d2260784e1f7f1ba6a2e1f7ae899e87824e8ab00c2cd09a140163790b71b3a029766e1e805b2947af94a51e3e9ebe9af1c6ac44e3dbac9b031836eb75a922a1fc4d86693dab92cd814016c2d36f603ad0e96f73d959ba2dab2991389c10da1871c082e81f3f14c4b663df7acbe9c203c2263d5b629f68c82384d687906c168314c0789b153764a5b82da82215c22beeeb968457707891482e57917da2e8e979d295b86e3c2cf5385bca329c747596a3ebbf272af32fd79a419407bc11f5e32472a4794628ba71fd73a02e7517ad95e25c49e14cea5db9358c21ce4f7207781f031689437da39ad9588dddb789cf8241f2b9660860bb419b75bb4beeecb445ac5b338f5205d5e1e0869501aaeb28202c535a2663ff6fa51399016a84458f2896ee4eacfe571982ab88d811fe52a0fc75940c9ebcae81c7f8939425088d6a8f949c312d30bc99f7fc7875d08f9e03e8d335f47eced8a43543fe38046fd9f2be38d656479d803b06e5358bf757de7599c3adb01f01f0f1560afc9fa671310c6ec52d4d72cdd51f6310f414b740c1f767116c10179223104647fe53b6b54a9d6f606e754befbfcd2b1457000b9766035959211d51f0ca1ad131cf8a05842909e1f05953799bba26cea745d569925adeed94501b9101af4db8acc3f2f2878d5d5ad4c87b94734a007ec1f1624ea25b820ecd886bc83d389dc50a87dacf7fbccb6c0fff186095154f2415474b64669389ae43d8e83531a4d855d771ea0a79d5bdc74533728fc50d654b454721183f6f6f807fda5cb3738a30011935a419c247c8df955f80cbbc5a1d533a4e875ca07c9bdc35feee3f5dd6b5864a16c6d5cf8ede61f51ae5ba36310d7e3de1e5a85af12c37fccde4e1ee85839c3eb4f1b4d33d4affe20034a707919f8ceb63e89faaf2960fd4465530a1dd86b4572357c0b93ed5d4b95f251fb11cf1501139a50317bc85f7fea5c6af45b6adcefe8be89ea4ac3f532dca74fa073f5f2f8fd99d8f0bda00afea062fef34bf205b5f493be910b1c969350a84bb69bb36a8977c4c698fa3365d89c807a30a1f396123ba553ceab95123e8febd40b6c5b21eb47ad36e5a5c94a5d2e92f8eaf3b589f218e50e62538883330efc9ba6310b7d8d417f3d2cf0ea15301751e2de5ee40334305846d593c62fe83c3de1b310e54b62c80bbaf5bc3ed5f36c97d3aa9640ee5660b05fe20be2ccc860259783be6ebed690081d44ef64a3af51387ece150d84bb859cfcdd33bdbb5dafc0324dcfd8d1b6ff4d3b49832dfe5c42542389a2402b518c67e80283524778d4b50fd82639976d51bdcc4a86a96f855d105e8ffc6e703c7362b5ca2c596e34e4c0633d546b8618c9be3833f24cea1148a93594cc87bc8c1fc0275bba2dd2d48b0266a1ebdacd2bbfd475968b563d28210be92c2c2e527a105903c722542ddd016a6cf18021dbe0b4dbbcbdd3546454e102fbfb3c0dceeed3c85d40e99ed3a7f7bd63e7ae2390900e3fb57be21eb1a2a75dfe341b4766e533a4ee05b09d0fd61d4c27b3453a9d5b893678f94f94d9fc9c0e1477ef5bac2ffbb5450e089b3acf1b5bba419ba208097eb7e16ba966fc8ed7bff93defa2fc0d27713591163e264d2b8676775e3e690d4f76b2c4614ae1790cd09584d8dc0a1c31ae4ebcb6ad5b7ab0243799a9a2eed42bf1e2335c8f69ba86e1ba2cc62ebc38ce4da1b8193a394982d9fc44539b599bd7c5153c0855cf76807d1900d59b9a57a7a29121def32df5196c6515a9a08a9d0a2319fca5379bad7ba971c35ca4d408a794f0a99ad0d62c4ae17beacf3fb0fb0161e8b9a6fc0fac9539e503fda83e810a573be2619172f45f8e5b5a4dbba6d22007cfb923945d86686611762e2f6475c071c51d85c328993402cc42fab95570c1280289e2e2b0f5f7a35e1beb5d0b40973d7eb58b5dc4aaf9c38bf2c8cb21efc1ceefe4538bd6d4aac9e7a1fb6f11cf2637bba4b6061dbda18df431418c7592a7d505002ccef03ea118d03a6d099cbe6b499c686e5950b540f80adcff2e2c4de1c7a6aea7263a1caf3945865eaf5b0dc7242129da7918b48c0158d9c9edafac0810f83e90bed365388a19b3d739b3f3372ed76ffa6b3d4a0377f757bfcefd7661d4da11f0e91d815c9612a24d0c7416bfa1a5d9aea2335be152ca6e83d6d6eb8172110785d7bfd77f7220d02be6a8680f1d2e84581f100585a181c276de120eeee9ca9e75d72d78838a929980f23ca1f251cbd3a089c0cc30701429a531622b1c1f29e2b59c0fafd0575922d46718e850dec22874129330a336c31dec93da6f3d5bc8daa1c33fc196ff92a5614db202e426d2faa76bcf2c886d5c2954ced9bf5796afe4aad8364f594d1302d66d0031832a21473106e2ed3235c6704375ab9de13ca174ee98c58a036a56230cbe200753658ae3dd95a8bf47c3eb5faad8d8d381aef61089933ec2fded4400d7a507ad519914bef2d438ba5c45b7be8f9c9e594e44421499c783bf85c0965b290ee662686ba5efb6ef553f4be54b975cb12865180561c5a1177f412842c96a256f38d217b73357dd87815e3fb4a3ab955a9e10d2aefb9c995b4ba31f22ba836ebbef14eb771a141813c5350d500b53087c73e4519edb665953aa92c0c712e232c5f0c892a8a2d18d533707c1efca097fb9d16fd1457facb60e664d51da439145919687f47389ddea568e1c85ee5b9c28009a8c4612e8fdaf8bfb97cf65a45c73a2e980da99d3eb04c52eecea0994cece8695a900727584dccc529078f6bb07c8dd177d42ac752c3d33e22a5d0f5976e09f09d0e6c4f67b8284913eb6ddf233cdb8f326e61ad8fda5233fe3adbddc65ecfa821d8aa10ad942bea5a9ffa038e25cc2719ca043d380d44dc45adcb7e3242a820bb497fd69a2c4c68cddc4e7966dfe4ec15c8c6febe3b2020025b5c437120ab81615e4a3b367d2020619032d836526f228db749e98a4774d1d7bc576092e0198185553d9b153d3879232920d30df0b6558b85879759916a96f609c9e184cbf552db516a08bf77ab7b86b89c710112ec1d3a88d9b7ad527f4beb741ad743e446e6c1f9b1ba60131b499c008b9ddb6667b6168740311784202bafa888499a57980fe5e20ee5929fb96f961cac9a1640877d17b4cbab85a3f25b9dfaf68a6e4e4eaaf069485dae82f31a296ac75c76abc97dc43cb886d0df0cf158856771163f026ffce3f1e58d7400cc2209b3b0685ad3c70a769033c55b84e4b0f100498bc246798f27fdb3f931562006f6daa7252d5fe20d1d6717538762850c8de830a5d8714df0252306bf71026c2ccf7a3c8bca292ff3a0445dede51bee8a4fcb1c548280c1f6072d899aa7aa19b48a8990cde14377fcedb2c382649954d5709a7c966b6577d6c4bbe87803aec9bba75cc99318f37fa1b4e13e7eb6df659e32bed6a0f46904b40729d1c2454b07fbdb8bfe48c65b0b639c68d5fc288f4d2a555d05409cad18e51bae1eec41dd1bff29aa28c42a1338bb7e8ded389e227784ea67e43f21addc8869c55283167ca85232c1ce70c46e553fe1820472a061f81e43a98a86312e92107c1a300675048c9b20f0e5cc4a39d9ccdf45fc48e8defc316c0441814820ac0ce3e081b6099216cf9475cbb12b18a5d0b3d357936e732b2b257a9af4050184358d97c478e405358fe37b19812b8e879e4932938c138d225432c042a2fc0d0b56efbe2e0d80bc6ee0ef212df0b73eb015a48baff032fedd7f6ea174b51a31a4a4f3bb34eb09f0a37dbdda451560d3e768c9ee1258d091890b54b872b1364f9ffcfe45df2a7c9d0ea12e808cab56d0f31b42d5b5a462d7d0cfc9b8be2ddec64deed7e6051769aec9b177ee0107dfb24200ff892f452bac8609627fb53e19aa82d070d47794a04c686f4b37f2389c18f81e387f6fbeeb37968ea80f7926ade345598425e3403235503b871ee041c0316520039808f6382c0f71dee10891d4b50e57699dd2e40399711f539e288f16247b239eee948e8f1f4ed38654b41b8d0273a6e662855a91cdb33d8e55b435271de07765fb1b0fca9de706b7335d0b7bfe6e263bb531a2246ea28d0b11aa7be53fbc11f29eeb6266d83e300fa7f0d370a6112151cbcdd08b07b1b091a927b5f1d9d7705026a8b28b4092e927d1913dd98d7bff291ede2870be311c62b0e561d173147e2a1936a056fb67df1c2c330d3f9c01e5941b9c982a1de092271e091b5c92790a71eb84c621ca78b48feb291b28a5d94c4f533dfed303b24883ba01493efe7d8efe9fc6bdae6b4310b8a6c0c78beb5c1ff0ad5500b46d7c10217f59a9410b94e36c58848fc5838891f28ac2d20cfd05182053c23230660a92e66ee46c1caf6cca273d29d7f6b7f124bdd0ef2f141d35718070137609b83a853ba80bd663bb6b16477396775f7e0367e8aab1c9f3d7ada13b1d0423f24727c15401cd2b27e992a08808db5081efe3871161e07c6c4bc63b436dd86e2e89de03d396047489d731cba926b7d242e6eab2c262abc0c1c660805856c2d5efa4545687799f93e1bc05143c91bbdf54b0f7d6544553ef44bd7082db87ea2bc09daa5e10c2adbeb7181de51f6eb8fce6dda1498e9dfb21e40d8a9c1ce02c171ec3541b989121155a7b10d66bf29f83c3dabb15a8a50418ebca9f61346e5c2c868e895b02057b341358cf69eb0c54d18adab23106bcfad299c810e90346fa41b87397065fb209e2b650838e76e5b4de114183a880a631b80c1d826b94ef488c5b3f203df7ef8e0a8e3e4173c53f182437775aeca8d093a132b913a9f05fc19e998724cc39f501fafe8bcc747e4fe73c58d41236746ea3557e86d944654f2752b7e4ff896a3fe683945ffa421e27bcfddd13bc14b38aed2a355b0dc98dc2e0fe1e12cbc6c2ea128c8bba393e961ab405d2af14e3398bfb9e5efb18cc238105d921b32121ccb744527963a121c136a60ddcc428444e5d90787d49028171737d467b1619afabbc1c91b6577f3ed18656d1636df3403f80dc2df59f3ddccfb5fcf66709cd1e5afeecb21e30f1e23e8a4eb8108e778dab669c7b80e70b3c7dc3a4a6ce5162786f55582f55057a296b2e25c520558ec84627761d28d16e1d73eb40176c955580719ba0696bb107069b57ababade0ee10f852a051cf4ef3ed9cb3b9429b46b6ad344d82e5df50b7400bc03dc15ab43ac403157eee2b712e85368738775e008bf71d13fa80fb9ce72038a44e74a736505a34710c29da2879df3c4a599490f7ea3a4fa5b783d957b1486404702bfa5885bf2d42fea2aeb8ba323e543c3a4f32f3d55e643162b774b3c3ab3915facb3ab3a166b54df87b3c8bd73926db1c9dc1c853c760a7fdaa6612dbae4035e3efd3f6daf262877919db4ab941973592f4b2741be3e2406b05580dd6b39b5d8313ce8198c51f2d45f6a0286e73bb1ebee60be1cf86a814250fecfcc3f793bfcd58c182ea29221ab76a174f598b21523849d594429782c53715b601d2625eb160c5ad35c4fd9046c456be7b819e5a03077d6584b97c96a5144ea749f19d087580babe2cce09599f3ce12958e1a7e89eac858ea644f22fa66bdca313d73c1e92ae622c145d4413ec9cceeae4eba6aa5d4c0cbf7025e490432c5414aa5cb5358071bddc8a567ef5c34ab04c72020c814c0a1875b76ed659ab79a803217c71af2a606aa015b92ed65a77280839a8a569919b3a6cd5f1e8038c6a95d9c49313fd6f962e40f9150f7a840c7ced2a8e506138b061cd8c94dbf0acaa9377b19ac057d93efb3292e26d88b62adbab297fa735819f3d57b67f6cebf657897692fed8b7f8a9f74f4578cc35cc5288eaf8aa0091ad10eeef108cd2978963c9996452232094058567b5a23be9db4d510bcb67a853d661fbe3efb319a7e74592c3401414927244c1ef2c57c87c35954b72468ff9a4082a8c0b1c696e489960c2e19a8c704dd0f292336000fe88fbbcab78c9dc648d69b66e85b2b8399f201a51b0545b5b63de252df63a591c1f9b737ee539a1e490c26001624147e8bf80d1707072879fa819716a6b8672eba9af1edad8fad9a5aa86dc69222a0e8209c083856b814cc5985554cbfb0651dac4a82a9852b0870ecca2592beafcf1ff73d9861f92ec791e907dee7adf9e13cd5fe79d0d8c36823799043f5cc18a932da052bd2ffbcf89bec674873a6619b25254a35e388ab73457c22ef948ff04279b2c49eb7d7ee3999e42b95df543e0e57c725986f20e1fd904cc058e02938c01f551dd85f1b72d09d1e044690309e06526e49c005adbc57201399959402e0e24d00ba8b10d2cb77fc7f3687e56739a399837339455f627569b136f652e72ee439fc4af88d06eb3a8dbed8bc9cfd9b61e0a0f8e67fca54a3e4ebb4ab2103937be207a732e1571e302349a52ff360a9456d8d078462a2d5fe3d3df7dcbbff4b2dfc3692cfef4c5d1ce8e008655833e213945b21ddd65497683eec1bae556418d809febfa1c70aa580682cdb1b99ec36778a5bf7b0c7aa4cc0f3e565bebf8c7824affd2cfdff04383ee1b4d1f6e7d27f47547afae68757bd3a35358bd194371a84ae9a0b16aedf1456e6f07656a9ea7963fdbf26a3a619b71ccc79f614577087ba2b9cd34c5651bb0db6714ea3a4f4a2114bbdfd9a4f7a53e59b48785131440cc94fb639cf6fb180a52414026147d845485a4ed6e8d006f6245741bacdd2ba230d42a0209793e38184576d0b72f82778046f52f1d58f9ba1f0d7c274fa72ff87783003fd8db88f2a1e874ea9986d95885a92d7c30e50d6c133c5eff55414a0e7227aef5bbc2c78b9cd0631ebaa25910873318d3b4045dd922d3784dbb212ecb0b9e5fcc5263d7a2f2775f9cd340bb3863e5840db3316a242f7d96febf609819b1d771cd61f1d3c5ea3cccc06ad0365cd4b816be5d12413ade4450ea5848f1068894a2a38fe03a45818499096503b7de62105a84a8035b8b028f9edb92c01d02e5a6fbcb54023793cd194245f7fa268113765eaad4c95274ab85ce4e8e9186f7c2f28973acd2d302be72a1e1e3dbf8ae1faa31660f7afe077a913ba617ec81a45d9002768881f539ecb4e667a19b5b2b940d562bf227580e994c3c238ba71cbb3369a17810ea2da530151b194bc3953c4b145adaa347820de1b219a52e83b060eebae7858c5ad01283e0b415f6c9a7254052c38f52c2fad3e40cb68ded6353fab207354d42b02a6d6659df3343446dc83141b05585841e5873e16c5fd96161a1a32ea50ba45f69a722c450a5be0b2f1c15c6cc26babd10acda2774641884d823041ea4d587af41f14d4f61316cf70a5112e3a73ac9452131f1af29b408f34dc2d7ebcc777b02903a2fa1210b54057407f24aae0de9660793e9be24754b82df92048be9f35d61d901254de5e6fa04598998185a8c8e514e0683fd1627750766e7ba0f21372cee2244e4733a2d92a6fd3bb31714e9163c8082845f789db0b950660f994255e73619aa21aecbf138258a551856614e0be9596c8c3855d3fccad647ef10f7c40ced8005f5ddd5579dff577047ab29bb94955e94c300c68ca4ac3fbee2f2deb6ff46749ed8a3ddcf6e64e3bbfcace0983d123da6fbba76a652d2420dc9f437093df40569ede3c0c00a33f3df309c86957ed18d7a887651182af8ef5cae850f827a7bceba231cf2f0d49cbd9e8e44e5c6e2eb1f52368070c483615e840dc5167013399448799358b1757c267fa5c2286a3c5cab44d3461bcc7abe54b778ee108946a1d3548950c40d5e7d14148ba11a056a4410afaf813b90ff748369e499c395de2f5a051b02451d21d20a29191bac6ba56dadbc6f2cda8460e409c06ea82b7ba269a7c18c4ed4ef55717c8b230940425fd9a9eec6f1088ee0c22f53dc4618b8a2a4a02ee996275a287f745c1ca368c638787c51f70afd339e15abda05c59dd599b447e85296c3ca32abae490af931d512d9c3615129e266b4b549b1ae868885373189e024b40e01463ef70bdcaa132e930e4011cc186e5a97a52ce0c97cdb6be65f9e2c793866a78f4f838b9f1293783723aad4564c3779a081c11e5f639f2490d09d4ae4a341bbf82598921ebd1de085d1c7aaaf70bce04ac0db585f61194b30cf7feecda33217e4fc0a2c379d6a9bb72fc76b86238d7052fb2005b334090222f71c99c3c34505d85b6ecfa5f63db1f7c9dc3add4b37f9cfb5e31954728b6d44db87f04a36f69176ae9f39939192cb26b64bc5b759ce020c99f33d9eb4fef9d6fa8a4f91ff841f7e35a60b9b97ebbaa42cbe54ad795df36f6113ba70e5537f22cc2c92384f317d939c3efbc978b15672a65f1d600f9248a325fd9db9f17ad8c0cc368b2b169b4b2e1d761cc51e772fe70a10ab921a155524b954c3ece6f865fc0b3578e5f57c2def52283ead6a74075c31ab8390ac72b8825d3369d4eff97f743daa85abf034b056d2e09bf71c38fcb1c88169b4738e2d59321cfa89df8c749ffda3fe939232d2d4a9a057a3aba83c6f29d0ce355463a1c5b3408074523e5d23177139bc2416c652c676c1a90e6d74650bc4180374e7a2201c8d477d428252f0cc40dffdd400d1e2bbce00bec1e313e76cfbfc67a706cd2ca45b23a946cd7eaf9d48fe346c3091f4cb66f12fb9cea1d72e0c9793750750f86df9863c01f9bf146af5c830a08eaeecde4a9ae7451f7fe7473569e2003c34e211ce23ec4385ca5af6d3008fccf7ddb5a240613f8a89c544d61c44b7f4e884faaaaf4c0422e8d4d2113f38f08c285e165320d6d63afcbb70593327c12f586b45ac50effd88108d4e02654e49a35b3b7efa433d9c85006607c6a94eeed3e5e20798c37efbfbf1d6aeaaba7d508982598de7d92c98cb93b2e19d999fb387aa27ac5b3183f522aab9d0a3b3c7a0d19d8369f3a5145a68d6245af3a873571d6c28f4ebf1ccbc11fde6f772b5187974e4ba74cd8bebefa66b8b86b91325baf8435d156846e845d4f3d5ba34640831c83a9a4526c33debb441d39ae5aeea8869be81dffd11f95232f9c5b66677a0bc371562a3abe81de478a1cc6845d4d74b91cad3a0a437d616a1d5b57d89d1e8e5b549089857af8dc79b52c00fbd190706b177dfcc2764eb54247a1db184cd886af7570496dd65b1a4fb7571e6718e657c9f295aaceefba4cfa6d0f247d92e9f6499973b1395af82f16c31db9026a2fc50a5bf6a4014798f9d9390e86d62cdc6438a5389580f92a631bf54ee84e4872ccd11f7f10cf34a988e16d6da12583b56324be6e911b8280c1c0d081af5dc01dfcb06878f62267e4626dd9c9be9615247b957147932ba4bfcbadf91f6d83843e2a4a75fa4b0d8f1e3acc845d03cb5c01295e64c497cd7ba6cc499d43b8078ddc0b60a9c860ec8bfef0ea3b9e1aa0dcf9357f34b96b6d45edeaba6e2141b8d3264366da6dcf5d4eaedb7ecdc7fa16f2c23aa0f455ebff9135df2406e29cd41cf7d301339b30118bea3d6a9cf4633301e23aa449e56d14274c464a96efbdb3fef0bc45e8f870840c6d504f372b188f015675c743890ea850e2f6f17bfc198008e4ffebeb7bc01a859936ed04e5fc4970cd5d4117fa9b7b8548541e67f7c2eb9d9c95953e83514cacc178aca4932998d047b40ba9fa0dfc921878a8b2320a5cba4e8cbaaab05c58139e4ae73341d35f89de099fd47a0a161dcc3d91da47d88f14615a463f8c217b72d4625e98ff756071a347011c9a7493d2ddfac3c9e440facc598527d90d248422809858b9e259a95c627e2af828da6a8b6563fc190431b2052b215811fbeb954a1846329e86a9a28d9386f156eb293ebe842d9801dcfc1e2ab06e951efa79bcb2048d2497947844b453ffafa6c0a8574386110901ef6fe2a166f1c983ea4aa98e8b6500c544b97b66aaa4f477d816208acf60da60522ea9995dafe8a628b19efa2c928f3db694779cbd1d048699ec2ac3934575b886f6155c8feef86c8db252b271e197ba5e3b1eeab677483cf1ae1f4663906adc04115aaf077ba609b108c93790132b6db7b695c6434858ea533f5daa43b335861cec12f4059d335806ed8052c4738785d85058ff2388c238775b60e363c103328466a193f7b0bf28c99252b857336f705b103ddae63a097cb93823b38dd30489b6071fc2ea890175d2546bfb975a8d71f98d93b9dc6fdd7b02527f22dacfd5b8a6b913165a226c217319350338d11b8e66b1ded62fc094419378e038ad1bbc8880b4d488d2445c98db7d8d9fcf1a1ed11838f55205edb4de9cc07d9ba3048ae5f1677833cf81006333b41f9f989b02e09290fe9fa96aa795d2e6b620e3833b8c7d1e56ad0ddf75a100c0d67a4d5fb7a3407028c0bcd8526f1a2960e43695a4f1a998d7d6a9f0afccebd0a53c5b4617d0bb7f0cc0174af7490016cb7f07e2ad23f1cf0a68846a72822045e22c1ba9778cea9967e50bc4fc47ef78f4ce5cd3e170772404797bbbdb95c3ec6c69fffff87473b4820a139310bafa96bba5f4dfdc83537be35b5a6f2d21c407963ddea4391ea79f14ee6f22560867010ec9b2acd7372dbbd452f91c16c7f83211e2400d3abf7639aa07bd1210e67aca0e76b91352fe35dfc2b6cddafa491a2e68999de2bae683704c58f7ae758604860fb3f228b9619373194fdbf76bf479914f0a0b08eceba7c5c7d32ff321877cb234eab3870a9c74baeb8f3ce38c49ffc6bf4b79ca48b80ae59c97bf577526d229009514175978f3b7c298bb01c6cf05ea0b1e22512785df7caf6261824f346080be367b0df5b0a6eed4f5b02081915e22f0c29e7459586c27fd2892878ee0ce2f90fccb346ab5ec45abf462b93d3fec71d71813c25a3dcdc23cbd1a0a9c07ec257cbfff6bf009e2a63a976b7cedfbe98fa6f05499d88f1f80d6e90c06239ab329e1d393b4596375f044ed915c9f7d05bdab80562baa49997c8916ac3faca83c831d7431240bedd421d00f0d3b58ac2ab5e23a57fa8f7a9be0dac254cb02fc288ad70d4998208b4fa0d21ee720ed58fc0c39fb89ac7788f58069445b743d61f70d64759a267ce02794dfb380782cc3b4d42e72be6fad99cd0dc0f407ba63bc2bf669c7d620493a7ed6a37d3af5b7b167c2b8d3f988793de3b8c6c5937e1939fcca77670e5832c75468108efcc3ec001f41f8aad79e1ff83a2405881f789865b22f8820cceb38e429b444c975adc7b99f6e23bb0da98a978781b8765889fba2301de4458d96d6e591cb39f28d805275762d1c46a3eaaeee4317b896f854de58d320e8a8333d14107728c726e4fe2bbc9ba48879f1544668184f2737748df9281621956e36c690e4fbc73348bbac77dc8a7337f591eaa2c3caff3ae429b465ca48173587c05e39ea04c65c7249d1abca401d9f392057d488be7163a6639e8af70ace17ce27a47f498bc4bf9f019403a6af6a5a26448a789cefa15214d181e0ab6d7e33637724c042b2e1a3ab8c8c2b4414080cf2cae272521b7c6f2e79a725b1bdef029a83a71171b9a457e8db9b4094afb92409b804ad680af415104c4154bc45f99e7ddf43c9c63fe332fb16bb5cb457e223169a2431601c0d2d1b3d1b7191c4a8c7b8b0d3f7a7e9df93894b436064f7c81612b32109dc6bffc823718ea9f2c7392e680f36231b0256097d556576b529ff6cb4a1fd9dc64f2e8afa8ee29f0921d67db26ca5ec0dfbe1c4507e5e77fe574399fa980648218b171e4315f23141052c0dd7013d2ed07734c23e2cd94138fca6af771cfc0cbe68cae90aa981c486e4f9de2de78bfa2585278cea36eb53397b43eb4b1b2ef670d125538c94be80fef0d1e1cb69efc708af945ce21392affa06485ceb880c404801a1855a1bada221346bef6f6d8f1c929d29b53cdaa7f522e3585fdba712dcfa152d8661c8df40d0cfe661b427dee8a8ec238c3989614f9bc1acacf89a8aabd263031033e1d00f4318d36d9ccc0e19ee5f7b4e8c49b59814082710c3b5ba9d9afb389e7021cf93950809f8766f9a754b8800ce125b6f90e6ec600f25fdce9ee28537efb194646e10e08832f425d0f82c0d1260ba8eccca1c61902c097d7675bd07a2b6ee0f9ecbfe81fca6de031f194dcd4b1f126315b14cab0f5779be8599d825252beecc524b843fc0fc8aa54d9177f7637f9a11b4b2acc4813171ea19f402e990be16904bca30c07d2669a55c934597b635672081a4d359a4c7c24601a891f3b331ffe48c9c53841b4ecf6c5b73ca0ffaf4a2f2b3505fe6ecd8f206ec6d0372de08bd09aeb85c2b331b66fec429e93e74b2004bb6720172c2373914254bee9b19ee49850cbe78a55b945da3e545271f90572f8b4ef64cb1c1ff834250a15ae1fe342480b785bbf58685964ebe6d2181f7ac31ab62bea04a4a395c6b7692a34b8889cd2ad02826b9c9589793897eeff2b3da60d70ad94db97521295d96dcf24ad691b88e99aca10e8cc448738c3ae45f5b7619b0003761de5cfeeabf6c4dee936521a63ed125aca03b634b9f33c937af413d30e9cfd9c26e6d2b5bbb7962d0b91ead52f0d54d89ee66fd69ae0a839cfb6843fc1b6aa9929961743527f4ee511424c040cd493554b4bf4a6f403c9c1cd3f64de54ea8776e25c3b84a1c8379566b3d42008bd3a05e9be8978097ac1408beb3ef3517aa328cd79da6c4248c1e01483b8028492a8e822ab63e00bc1b04b1da92b761b653fefcf3c2d6267c94d6683709c99043c5c6680605a4c0c81d5b66e4f2e65f7883616569404caf20939b04aab94786cf6c17e3b65739c8ad10a03bd063b02fb4786a5b73f85b3d329e9ef4c30b927df603474e33754e3c47d5555fdab8065721dbc7e5673ef33b548e7b3493c07dcd765bf253fd20093222f0ecc77ff3bd6300240040b856a457460314e557813760ba828462a3aaaf385bc63e8304c10389422e34f6aa341dd7d3d81cc0c22c0fee72dc0d4de86ac2a12f4bea9a27e0d6458adea208ddd6ec5d6a0bc73bf1e175c6a02c3ab919497ac6e58d16de187ae3baaaabfcea4501823e3125055bafe6dbd6ae005879b190c95052f9eb02dca030d4aa5a88aba743413805b5dcf6fb833f0f647bb7cec033dbf67937ec15293a9f79472e302fe23adb9c2174c260de1cd71c2e77f207b29054e148d6ca97c79283db91f29f6a64f8a36ea64688d7fd9f294efd0953c50b265509b1ef96542490d063b90c91ea1b72e6fc6230611ff9219a4ef1ecb55bd921af1702c38ccf8f610d2ca9f11034a9cd6d0c8a77e68bf0a2e839b147e8a03e39a038f86d9cbb9aa220ebcc657f97531425df5a3d9aa82f7f91684e733b8b003cdc84cd3ea9071d2a998294440f7d3727ea2fc488b01ffca9d336b024333a13e900666f519387a2f4a877de8a82199ac230843a07d074d42a4498e2a062d0e0b73ff0f530add8dda84ae0eb6c2c4e6780f27bf6c9e4716302f7060a97c4baa3f14c0556c02c1e4942bb9b804d078bf90fec72693dda440d65ff37ffc8174af769b0335f11a8bfd94813349de1ad60a18b0a1de9aa50dd219c4caaa11ca00eb7d56de64095691af936fbff37b9fbdff92b7d55fd033a74238cd7c3f071c568dadc990772a5c91ed5e124ce59cab0e326fb4c0260a84d90d45e8f3fbb6acfca32d901fcea6f52aae6e0b83196c97b0bdb59efc73cc92f961746bd3c4bded913923d438f53848ee8aedc5ea6f3b162effdb6515176a4eecc0e2ee02043370896e459514beb0e8efefb9517f147671187a8b9bbb1ed99c7c13213f2fb0681e9863605ac2a188fa0916c079a98ee2cfecdead8dc3c564fbb0d410b1154495eb996a40172c749678e165b384a8ebe74d15e48802fb2fb43d55abeda1402624991ec2b835e3471292b7aa68cf0f3afd93dc1c6aec2efdabe67cdd372aa6677fc386fcc44846c514503ca94db74b109b23449b89cb9847c1b964e12359b3e0c68d7f839cf26116a278a0b412a96690be2fbe337cef7135de33cff56e7248ca00ac43dc3bbc9778564db8cc0f65d56cb5c85b19631df49ecd5fb6bcb774c34f8d3a301c79985bdc7cdb156199e5ef1c84c66a5fa7895162591f6587df5563e1ba73baac2e6fdad36c4bb1270ab9cdb9c80c5e0945322171f84053ec690d82ec32f9708b8d7ba329758435756a5ec72558f7850182077ca2a9e9b4e95f0bbb1957ff0110f8b62308e83a0beede7a4cb5712e3505e32e5629c301884cceed90f7df584ac75b226c19a12cf3ef90289d613340f723008ba6a14a46371396d2be171b26a293a365d79a0179b4cbd5e8a7d94c84451835c1d6eb41f4bc89a4abb544cc5dd67ef84120869b1f5aa0a6a9e246221e847850830153d1737a040a9d224ef026e01849932f046ca179e7a6c24e6f2676f25ec58135ce6ac208d0eee105e023124ec79ca2513e18ba0583adcafb3b12cab45261bdd2c8be2218d2326a107c9924fb14875c28ce6b737b891512bd5fdf83df62eb868c3c1489d337e2d32166fe429124932f07f3390d25f76139666376b0dcaadfd118bd01112465e661e17a1f35ff4831a9caf979f3c432aa3685ccfabdfbeaf0dd553dcca21288c0ecd0cf94d3120e1f939d91d793a7ce9c482e168322a66caf06d63f60330e63156c0c27fd482f13d754b69f55995b9007dc38a216ef608bc0d8e71575a7745ee7e1caa93bc270a5f2c02e91e26dfb672f050a6a83ec24d88da0cbfc7093c755d1f707388ed64e6031882c71c57501d11f998b9dacb4cbdbb46c0fce2260ac5de5100b0bf8733eefad30aa3a7b78afb9378ef4799388b08826cef5e780579e56c76611646f539565a77d1ef1c6d2f07b63b2143526bd9778e310011eadca175be9eed5347c6a10b101619531168abc9b04b5983f1ef5cdc94b912ee3ddd8f8451b34680c36c9df45b04c9ff96bb4cf924453689c605f6b448e4fbcbd26f42ee550bc1f5b1b82b4a39f1a963e8f77bcbcd1a797c689820dab4aa5fbb56c54e4cc01bf4e4eb1936ff43b6ee5bb2f437f4819a84dc8041f4bdcc42a40809936b98e6faf8ee8a6f61763fe5d067809d2728f27874a7787a4585b88571b10c75cc0a45b9efdc6091ffa3b213e70e4811d206ae10dcb2b9f4d57c029f0cad1e104b3dfc28cc00dfcab1ee85bf50b22d75374bbcafd3cef71ab041152b96e96100fb5d163b013b463b3af6fc653fa7e3700f88aa49dcdefa7586e11291434881665c44a8a69f1039db197e8502f46ae5afcaf1dd2e113c8e33b7bba8107753651b94b65187c413d4e18320689e6816807fc7ce98e1962a6ee92f56cdae6454d76a7a8fbeea519302a4c6dceebc20bdba707467fc159be72944978fe00ab6be5cf89f20f374fe04e68ee99d4a9195f87f5370ab4465181500bb7dccec726b441f51082e82fc1a468801258fce5d81d01ab314b1606e17f8b52576d3018ee87a4ff94b3b7f2637ee3386657ddffe6928e9a35f2ecea5ea8b9721e13e1a8e87771e5e0492763c819cac3d856fba9e78458d9eb28ead4cab704492043b6fb4b888f86059d8b0c58bc200b7d85afa895e3ade613a84f4d342118af926112428258c2a2f55b7f73cf2de12b0acd1673290902bbacbdc1be3b6dd35ec235d60ecf6ec898c8ae41f550da34cf47d0b648bc59f521da63da7578f28b2648de92f83be338e4552386f8947e93a3a7fbeb9b6c1ba5c7a979439ec0eb7d7eb74c5b173e7fe7dc2be51520ce08799ebc1e4c320ddbd0d49f4d444bdfeebade96e415bb52b07e8b9e483fdf37bf6adaaddce554f7ebb5386b98a1cc2b681e6e589fd6a7f33d0ff90a5aa964ecabce7e6d6325dfbe76cda18f44f8e21e4ac5eefa2ba95ce2d805bb364a08287c4bcdf96c5313c4bb68a3112b8099e0f36b72af354be8a32a20d706f56916196a8121638ff793ce3a07637f4501b86cee0a5446f16955995d34611c716fa8aca4763783eddb9b59ecbb9c2a4a206deb19be6724f7bcda288ed27c7686fa80ec9971358c7fceffa95ed3dc6b302604c7877e727eef6e30f6845905cc689ac0a2f9307d566ab23763826f67e2a3c5f36a316d8b8071bb92ada91631cbc4c39e5fd7f0cf255e02977927e41f575935a210f294f5727df08e0262173c7c9b59e0686983581586cfc3c3762dad3d5c393fb344f542f0bc2ecd0b14a3412b4969158a847bbc14742bd20a7b21374efd7e836a9768658a2cb516ae1aa1ee077215a68aba925aef3d7572d48767a6fb89cdb437d199a56f9232f00caa201f958c75784eda056f3724dbf8d145643dad07378ae6f8c4b9978e4e3d5bca2d0edf49424838fa8091ac7740434a1a7c384eab26102a1e8c90fc850f36980cfb82d96d6a843d2c479e5a46d3ed9c17d885b17ae7194ce7d1a83cd6191a4794ab5a4dcdf3bf1eebaa4023942cccceb95298f1ada367d2827c338389a5ada8b1d2bd305e1e2c72e864440f9306b519157f4167ecb4a02be01b9987c0655bfee42879a214dd6f6ec911add0f49433098427e85dc32efbac66a56ec00934a148c969a0d09b04b011416470227f471205436d240401e06bae37c22056eeb93a530ca3a4fb78dc278ec68470f48a3a08da2007e50423a18ea75914197e554279db68c9303e34294715a1a91dfdb715efcd522b209a5a26648674f3810ab571df3d55ef02b82ad519bafc3f238c29b739d3126dacf472255e94108e973da0081fe89fee677e0c261d48f23c4fbe9c28fb8dd9f6181b227d7b892dc7138420c223bfe4bea62a4ca60d40a1b6763bd72437a497c6ba4a3c0bd682071658bad0b046e8aa79e854fad555b84292aec7144c036bc2069714f5255a65a87e17c68566de2f96fee53f894f405d46d225bef65624e598b45e446dfa357f13287b38ca69bf65b1603c4061d5149dd9e07e2debe5522b3e7eedfb644df477428f0dd64751baaa4245cf7a07f7704287a195e76b9421cd1bfd69fcdc1b7dc5f91058c2b5941a92fed8be7e0e2baedac44106397a761075e5e52217100bd34b64d576d937ffc74823a291a699664b2dd3e0d91073c0a8ec61b811a17f44879aeefdf1e2ed3d5fe4160d3b5157687d80b55d7af0f5b4c825f84490c9aab4bcf0e867b2cb41e0e1815df87775ce5350b459656d86300427eb492f0c135deb362f64ada75e835cc595e8c4904c41f884bf95b370c4711b27674145217edac55bbc00abc7e1050c4bf6dcf43e4ba3c79eac5390ef064a37fdb3184abc4ea653ca12356b68ec4865c5e87f6479a21c5ad86bea06f6d72652e6eaf05c5154375d127aa28ee901795149f84c7559eda67322cfa11f617078353f87ee895748afa6770c86d7459fe13ff9143ebc76fa80408974a71fd5efa151370d247d4b9c31782162feda07a3e29ea252fd776ad32d060e9c6e8f26f254a0e59c188c94a768f3e854a9c356dd4e6d5245bfe65428038c57de614c45e685cf1d10becec83a8b946f86a8b7aa4f1e38d7447b8181ad611eba70562388463972f23015e66352f1a3022b978dba3610e172fa028e285bf48d981b8f1a8a6958c995d6841a836c20e592d037f274187cb7c9ba201604eeabc1009651e12cc0365c55988099d7acb312a1505edb328820a0aa0a7c0912d64f81f8058be62f49dcef6ff96697b46823970af0a0f2703ea4b9e61dcc1348d24a6c1067c839fbc916dc407c369c3b35afada8acf2b890b64d6033a364c2277f73f2612925267659eda0cc06329e923a1ffdae3e6976bc951f10fdcd00b1f0cdf4b6c75da3adea564d8b0e1f8a09f341050f8b0d46d43d980db52665b8c802f42957fe0b632d09322849ddf5418d927d418d465af095f361fb6860ff85352700f6d86ddfddf8755dc8af9fe04f75af293c7fd815b023b5c9cd3118022980db29bc1e84f78ff4b902a2de258a990a90d5aed6f70384ca01fedb6a0c3deb0eaf8b9196ebefb115426762d8de23157db68e9c1b1794240bf1e612b0a4f8c0f0daf04b9d3af354b042d33e06b94718e0ab0bf4655e8dcf26a9c30e9095031cf002c5e2d5adc7a8a5e3886c363a4639dd0e1734d089038ea2c0001c13939a1302c54dbc7a8a64bccd1d8467975af4c4f24df16a700e95569dab44980b7cf0659a3b0d58563803938ab8b1b0ea4b218394dc17060c3131c9679b3902bb8082c76924972f5d09f61a2f2ff1268e343e237943c6d6e2c1c9cf0fe25bc7e5a29f8dfdaac4286bd2e03b82c17e508024c689af7693162976d832b6c340f846d68148304352bdf1ca30d6ab8f3d0d16022b9cd9e500a90cc81c4fbb2b48e83f5b4a39d5fd014e892a5c099b25c1f15108dfdcd0261ae10595dbe3dd1c645fe71fe11126387cfb9fb1e39e4c36b88b5bb70dd04b528bbd4e40ebb222dd51828a27c62e290b2234d8c72d9773478ad745eedcc7f5cb461f158daed2b522cccfaa0e5b9415d3a57497bc1b31f09c6da25d253c61bf8b56be07380094e34769c078fdb7f9ba6a4720121c605c5dced6639e3a4ddc9fa37136dd5c09fe96b916b6e4f109ba70064076c518c2430479431d3d86df507c9403de826737ab22c7665ab4a26b385820dd29aca2f7b1992d91ba46aa09c910f90ff2f47c3a210e4dc1dce382c37a05a9a11a54677dd5e1b5b2872563533d91030b6446938cef99692c3f04381737bf02b58a4c7bd5f711ddebda1b5d505638d62aa56575afe3b287d571f17fc7ecbd0992607622f6fd6bc7e0030e7b56f8c5d4c824667deb8d3782054332eb9e676e32327bdb9a12e2c8f26209de3e1b3932ab48eb23d1f65ae05e7bae34b6c1a7b0b891a3b62a9dcfc335c443caaf6c1f3eae43b4f584424ff09672a1b3d3c0b440ba16a9d85f76f32048b76cb8acd7dd1c408a43b57cc8baa3d1258e361d3c009b831b728e8287df3f841b22b054c81bff49f9319c4616d8c1c1a0316d9fbf1447f4d674d7621c43e912ead2437756a551c31287bbef8249cddeac6e5eb91031394885ece2d9c724d85f9d9cc0e97bb1def7b0b9ae3eaf0b497d590c2d162bf0c9d9d3b5ae8a78d02fcd49377e042bd43d35e2879abdb0af07b86fd177625702586ff6dfea401830c29ae8436c44750058dbbc40c28b8c00b5cbc3e2243945c15f66a8281da252ec1ed2414d421903cac10a25516f40f4f89d12a32753f584a59bd14246dc778b440fab9f09c689046940c99adbc310f8665573634b828a35eb7f2a1ae5ea7b14766d4a7ef01262ec53ffea86f8401baba7a87224c88f95c934082faedc13731521c0ca85775bd1fe3783044452a8513fdf0041d51e8a5e6469e6a8c167668b3413668b4dc8d3053eb946b778630494536cdf2e41a510cfc098d65879755c9f0e65acef277de5ad8d89e159fe2328bdc5c0d3ea55efefced755cb68429a1b479a16f4e0ab7657828cde80f9e15294c1bc3dca70262c929348fe12144174a314b087a7c17a6ea38752123a1afb0cf0ad74b46c39da38c1e265024d52a910ee2d8dfd11177c309ac5cd760a5a5bdae38e1098e607be09c398f665dd1f87dd73f290e31d6ac9bd039a83ce0271ad26a6e77b9993a17d7ebf3fc5f6a497216edc17625a07a4918032d7a6756aaca6656ac441dfd82d718f1f52146666b0b9a05f31fa7374de4edbb3a3c5ad877c87f4666688bdf9f6c551be215c6a5783a5473b728d28e83d9c808fe0eacacd3e2121dec85e2ed9f0323b12937508df8f5a4c0549a1ac9e73275fd186e22e6961b79e951ac10c9ac5c821ca09a08695e5541f352acc86fa0e365c4e0935c73d9a9ea18f27e9334c94ab938e9863db2b23b237e7ab17ae1cbd6683affc4f108f1bdff4bb52937e97f292ec8336175c2e517fabb65a6208a7ac4027dcc3b952e915cac00ce4d0915ecba9e6ff1a90449bc10a3b46086c536b1c98050fc7465896dbda43c7cbc9aed2d15e1683a4791a42d046d85072c73c28e9c1c31e9813f189755a611f7e954525c161c246a7ce716a9bfb0593c81769fcf15f3fdcffe21e50de65dc8262dab86916efac5407e7b9826ee452a6a3f9becae242f8c2ea19231d03361d678904ffdae693129c686c7f526b902d3b0b511f3e37c1f62db5cca6c3d81689edc027de7fe372c59405949265c7c1c8de9c1c52a4529057cda463906c3f8c4c9cf166018d08022a608650a93287f91e871744e31ae29262b93e49c24fcffdd6a9c2e4c4c6cf7f3bdffdc46bb7dba07b8b35e474b657ce2a50a8dd32fd7e074d2d5340dcd75adbce746eb954241f2de74822aa60b5e33470d714be1e712a93335ddd861b5e3685e6da6a7802459c31847782bf20ceb789aaf1b83d444bab2801e0180d3b04c45bbf1ec3423ddc52475d35a2163526e7696687fcd7b291ecc98b671c9a616783c2a7778b19c4a9f9e33c6de3555b63c64eb4be04d94a0d0659ffe2c74e567852b0ff2aca985be5f6c0ba945a4bc2f7306badc5a5d472af71b562e70ec9052bb48c6cb70bf5c29b81a7098384d08988f7e745bed61a25a563327b32799fed2cef137796716a2e47f5dc238b98ca92a5df2b6824fba5c84cd2c42c2082cd93f9c81518d8247f7ec4cb19537282549b56fbe739a55adee284af5e61044ea61f8631195bb1ba400b9637fa4aad245fd328d972d5099114f3b5469540448bd3b5d75c170284451dee85d5ec1654b560d30c555a7219551bcba0eebf112774c0942e54839d2e102ff642020921e84619971eb8992e1d30d2e297baa3d096a1e79f57176d8844bb2d325ba1c6294dfbc7bc37149212c83ccea2b457e82039a5843e20d735a4a006c1c8a867a35ac13cca9e4322c72de2009813ad09c7017f7b693c6d9a47d744ccaa7698ca130804f36b42c40cfcac7bb570c4e6084a801f396b3bb1a182b11b3ffeeee5feb2c55cb93a4df1558417d92c21da741091e4268365859c9829ebb6afca2ad002de1ebd14ef6ecdce6eac5fcd97fea39feef3ce7e73a027b6d53655b208b1024c18c31f7c114ecc13bfc62bd8e3731ee5dbbdaa3bba55bc8b230398dcd92fdbb3c5bfaa6dd438091b917db305941b82b1ae32ea4d8c0ff7208dec05f1faab91a59c984c7874c9f1601d7f8033191f224d1eef1781b363152f2b4543d1c72abb2f8dce17fbbffe5c40c5edc1ee6cbc68ea7eea8659ff234b3e7f6621cc6245edf7cb421cd10d20c9ace6052680bc2dc5f6b07ac5488f581d17ae230f86056eb00f2fdc190582e287f569295a0d86186d8998ebcb1fc3b23c42d773d558568b25889b75ebe201bcaf8353b0aa2a6840f78c0a41fe01fba03352bc4fdc61e3d7da830bf47bc9f7e1b3729d84e1147a01e978bf26e9199ad5141e0e234676ae70efe35fb69c52adb8d0b7d6003599f182ea8d76f11ca7777ce3028c265209051f6f24b0dc52b0999255446d750a680197aa24bc52279b09c09a19381a275acb87a6cbbde5d27b6db67abf91275737a05e84c782a4100466c662c7db4fb8d3821c09de1dac92f6ea47e31a4f352dc12645dd4d08845e3adfe592fcfdffc161e37484edc43b29d6be41c1f2a0c20b6121315ee72db055d534d719cb73fdf0e39201b60cf046631273b2e8c4ec19fbe252eba777620c3d17892552eeb0e2cf34fcfdce75a6c6f21678312bc5445b71b7203ab3d61da45b9c0cf33f89c147bbce34e34575d7c11e91d575c7a967f9d0befb9e8dae14be8c56b176e91a1ce9e40f61db32af72d8603a75d180aa746616d192d2d042875c0acc8384f198cc963c3a917d75a225078ff70942893781efbaf2ce450a4b0d1aa482c6d12c674ffb62ff71d9386cd66259c2aa8c0b9540bfcf7e55abc7539e58f564a86208975afc848a8909bcfab6341f19ae486cbbb2094f4213902ef0f74ee01475eee6fa90903953d2dd065971f551c4195a68733b20fd7bf2cee0476e2bbc6bab90735e0c28e2cdef6d3fb336426939e379bcff5c7c6d9928d86f2a50b18938932c123af1071f0633b8f101166177248b08c74797d611173574dd0ee69788d396e481027343626913325e4cfdfe1335214d7eedeeb30cc236e4ce7d7e74d2a038bc4719b8dd1c14fc0c40640900129af70aecd8ee62762fd5edb5ef2facf0f7c44768ea58d031bf335f5cfda42798bd2e1b3e8f12edf672fc8d9ee61f562b72acb1258d3bc20d7048f24faff5251aab45950b5088f5c87f35b69a7c77c15978505669835699a2ffa610029a73cc968a60507eb89e91c2aad8cf1a57fdc2ddf80f1cb5e5818b6f17a53a4f1a06fd82742701dd2710083790137c3300b236938423e7115e6591746bf6f2cc5176a46c326064f1d2443b2f976838e57204ae63c36b2733f814e285f60db258b5df7cac747992f735ba8f06f8b1cf56205438d297ee6d3b90f9aed0a380500b72bec559f7ba6e0152bc7bfc059445d2b90820a7d3663e5b73c0f6f4b4d6cd5eaa37cca4f19ac9cb9970c6a5245c8a379c22c0b9814d04cefa10dbd60b0d462d5dfa9d10e1a1ebaeec48d2fa5af5c4cf9032109d9ee58a4fa37b59fbac4c23710fd5966746135629c4bddc6a390c5712e81acfc695993938449a7633c6a9c562c52323a3d146d68dead4dc182389975dcc8fb359b2cb24372af74ec939ae633a4825be87e7c3764ad52ff3bb356cc11eed3b2909e88b299d07ca19db3c9b07272ad764f73e8d237ee7cbd262f73be356d6070e1bcacb04668718f00f4ec837825523662c58d6e96ddd5473aac52ba64281db35a414cfd6be2a59820e1f091e34fe55fb3421676170aa5092ab9077f4576b5686c7a936774bbba66e7ff9f3dd4e10af3b82bc7e3909b2bc139297a726ea071e766de69ba8803ebceb3b808cd681a86c901dc91f41d1b4c6c1dd0d3e0f5451864abf913b26bcee403076a4190231790df9c4ac131f2d7f439e63b02ada7fc6446221d70085e26aa6d62f7538d759c35468425452819da956e8fad7962ecfbf4331ebe8c30c02b6fb9ab1b635a64b6f2c8d520fb3e783fee0f910579c66944b3a51de7e88a967bdd2f18cbeec2e9b6b49c11f70570fe261a5ef2dffcafe9512efd821f248e5c56b981d5c6e83ec496ed8b3621b0d4772c6ebc378ab552a22e33498fdf25d3c5a2b36fd61cf25289e43c09816d2d589e393ec0ba824852f6440bd803c8e43725632e28b5af521d0d01e6c2978d028743069fdb229523a2a664e61f320dc44f1747f7cc700854a173a9f8457f8222f02ddd60bbf51a83e21c9e40bcb5bd73155129689227f1362f2f87ffc66b782cb93a59bfc0db1496c5c496a3424acf86f75e7c094a4c0021967b4ad99d0173b56101bbaf6415e1c5d730c0cd7460ec3831dd2fb4cf5efd5fcca59abba21c213857d37eaf2aa4fe1d9b8f1f7a43f41390deebb09f30167a2406d5d3aeb3923767b4712ac2dc4645cba32373d975a76b6a7d64b473cb71d5dffbf1f9b2c4d113fc1f2acf9e72676f306a540a0efd2317ca189ce39acea9d5e6250956ab4f9fb463b6481500dd5e4926042c972b1aa44f0be4f0276dbf8231a395939cc1edd386e6414feebda7544d64dbe657fcb153f37ec7f882ab29ca103dcf19e8eb15568b992d1b5295d3b65780763d970d9c76a3e84e9eab8c0f135869c103b3ad616e50ae5495cd501a315e6ccf5be61aa770f547b082314729d90638fbabc7cb192a32726e89ae657b35db264a4903953c01e1d3fd66c772acd2fde999bfc510c9ab7d81614a888ef8df761c77d500a07a0c9c4aa2e88057fd2af8ad76174ee7e4c6a409cb9fa57c29d2bc9f4819f3a0db3c069a83429ed1f3b175d69b520f5632800b65db4a669f75e6e1947272d707f0ff3379d57e4d898f228717cf2b56f6ca88508e9a40a48b4a26899c82d90a4ac9ffd5dcbb220056171274d361cfb9c69afad2113522d802649b6e09625f2b89ef65f9c3f58bcc600cc77bb3d862ca6497db87d986c1bdf6d3d0d3b08bed3a34ee07c755a752aed34d89e3c94452a6a5c0955e835d461d124cd3cc2096fe7e2d026ca5eeb37148a9aed114c3a0a1525284261f23bb65c015356d83bbb7a34047895e23babba8a59cc4d7f1b82eb8b9ded966123784467b88a0562e8911814afec8286aec7fe3a641c79855eeaeb9d735348debd1ec3946b2bcd9968fb36f36a3602da88aae4ff35bdbbca85cf53a96aacb4dbf3b487503d8d563929fcb942851077dae463a00668d9911632b3710a9ee37a96bd9ef27ec6c13b64f4945af83203cc46e1221526de93a5cbb9bd4d1a51d7711a95a607b971824af4de17936398292fce48d81f6f00daeea5e3623cd79b5c6e5d6c86a3da254823dfbe1be1c67273bdba712da2099ea7227dd3b27ca40045018a5fd031f93ebfe3431412c88dbd1c7b808fc2c388eb471373f43bd20272e42c2467aa1e9d85c98b0f07d70c4137019b7648c0e1ead7570e34ca6811882d75265d35396824667f526bb557ac47429fc2061854fa629ee49f4f3da8e30faff34914d02562eb9b7e543c9ae9d024e6570f63d2dddce005bcfac9c494cc0876bd4808bfa7c8903f173939f744bc8b3109152b164e407098672f9a48e26d45ed4ee8f58351c81442a41f81b6a65e28b0c6861f0f934c5d84fc8eaf0a0302bba968b833e69b6048b8238fe55b2fd04e5e66016823d16ccd3c80d942f189f67b30020852f653fb94e17d948958e0a7681539d0616ab3db422c569804aa6a30aebd704ee6cc02d23e536ee434b2a208d07b3fec0950d9749c910c897fb63f0dedc4942f98c381f49afff6f2995e33a6e74b623e9cd74d84a5687bb53f6c43a811a24fd0cb3080a4e9702bab9afc6a4498457e7bbd1a34bbbab14e8e1cd42e37eb1a6b8bbf43b3a5fe2fbb242528a42a1b27c0b924f22955c5e41d394563dcb28c8f96872410ba9ab3ae6da715185b5fce0bac5ce51e52bb5d02aa7a3c361cdb2d3c751ff9ca6996a9914faae5f388e9a8b4f7107279735a203fb6396d9665eb5fa44806ff59c8701e59925ffa4b7a46bf456867188b096e3397c0ead2de8ae1dad9dd89274dac1bb98ab2576de74b82a13edbfa00d619cb7cbad36fa51f80fa14b17aeedf8bfcf4c51f1e3e9945e19b0722d86150f200c78bc5dd65bcf7cb3a93e9436f4857666e2b5ce109a15aa7a6b4190e786ce2b58412c8e9ee86d9da055d4645700ee04c896994b7e6850ed2bda59d3cbdc82942fb1af4677fe53aeeb36caf3babc1ad4548406b58d2f6af02561ce3d14439b8e35cd93b3530cb720c57fd26ec8e3930804ac2193459def26d612598bfe36fc1e70bb869a5035f95e1878e922aad3479cfdf3d19894a6a4bb74ba06b697062cb0089d9b540537bc744dfcb6970deeb405278e7d64d08c2ed749459beb2adeb6779b85808bfe0657b57a684ab5e38032998af83fb2fb1a1a18f0ca674786579ee2062836a1badc9bf170167277817e7b6edcd7270ab107c8a775a766548cb08721a57f6a36d167e916b95299774fd1d6685562df71d01182f83370d7eb7c6d7db67e4672e62cc81ed94ecbe02d109a519c11ab12a59ec0fed0ae858d3c0adca5044174580bb88f53405f7d1530201687dc760d99190ac7e5fee5ea4da693d8b5149471df535b70a89788a23fb809e74f5011ad776ce3bb67425e4acaf345442609bfdaf082891c1c8773ce5cd445d43fb5967fc12cdfa238bef0e873f1c4a61e515cf34bb423efc9bb3f2ab4d9026e70b30d64f9c5c4c91cfdb9ebc3ee685a340d65c92fdacb063529a831eb06f08627781fc4162f95b8406218d457bc5142ac55cf238e43c7ac7b04a4e5fe78fe820340ac14778bede8b371f3d866d3335adcfd22e5a145ad4a71e1cd5699309ccc7f7ea54685af87534436d30e232c0658ee14279d6fcd03a6b518eac40d4b17979e938af36b4d638db0ec025066007590230d96effe03297a613e18796d079ab245178e7b4e253c95ad5d6ef78c0b38a1ad37749838696f0cd008491b433560b268407a0365009cc40ed451956a1672339821ccef78b0dbb892143bf0010d82836f2d16f872803f25e93674492c1fec1b371a5b9ba6dc4265864b4018ddee7dd290b0a4e49d6b26bf790d4aa3d543f16a692bbbeb0c044b0e032b9e2391e050048e0b722526684ea4e072be1ea3466ca78a940f6f251d5f13eec0621eea00a413f2afe3feb8eb92ac65e950aee4a6381bb58e57c0b17fcc08b2b339d1bbea1a887de781535a7792ca0ccbc17a85d7c5bd9cb7c5e96d5e76c65f501e7f254963a4c11508926f02719f268e1c637274c96d05457d0dfda9937f965c10b0938be9bc098727fd0a06d55abd6c8a2a12128a36390730948f168fd58d2bffeae20e234a88c790203c1e84451f4ecba892c0e03134168ce26637cea130009106439ee780d6494e4a0a3acbc338ea33085a1d54efdb657d75a4dc5830b75708061f94c6dfa5adeb68e95fa9de782386bf6f71db1ccff3b555dae6b63c78dbfdd82fdae55f26aa50d24eb5deeb25f587de66402912788aaebcae425e2bb2fa047c5b4da7f40493d751370b1e99cb0d3f662d9e42c1a41baa593b80d4e378acf591ef40d1027bc072db78f9a6529835eb57465f9eaecce194d25307eafde240423f292bf77f0b6a114048cbcbf96bfe0465eecb57e97f55ae72ac44c46eb65144cac88e8bbab51ceae57c98556fbb6c7bcdd924ec08ecec149acc3b599ffbf594466e6328b3e77fb9a9af16e012a563a06397215ae4dfd1ad750db7df179416d38d9dc870fac668a69665c52cac64423ee12168f382a79fba3d822157482c28ac1ceb5a578721477b34fc56088a7ecad854df8a66951be5f1b6dd16cb84eefe63cd552d45974ddeb533f9475a2e748e3c1f922ab0d45d6e9e98e7a4453244b02c74ff2f61bf2e9fa9846967e4bba0c3bb1f0fc0b24be90e540c5e1ca159b830739e2a82e040833abe904c6a2059c7ceb8c81a992c50812578369d80cd7e0a086c5d94f3e217487742b17d98f0f1e2f5363dd8d0dea1fef97ad25251739325e748877d3b3f6560464852e22cf817f7302f498b11fe1859f1d912ad99dffe1e2cda8fbdb5a9395c0ef27dfdbf65baea93e892dcbf6a20d78b3dea1a841c242473f00924fd5541e0d7ba561c20c4d42e297f16e5086a609e7cd96ecffe650e0aa5fd369f1a7710b61d06b58b23a7e7bbaddd29d9e834f5347b0af07b922f4b7a8f345c48dc798351a7d593746bd57e3664951c2e6212497486b10d094b92645c129f701334c1c1d173fb0e039943e0bc72055efd2d72f9a3c76635f6243c77bed2a199e4a1f2f3eabfee51626c2485f690810dfb5a73304104c88c14dca3c0f89c6d49ccb498799da5670e55127fd99d619306df2f6629a11198d70985674aadcf3e0f16a340363fa2bed72f8f5bc8189d293028bdf3a6671d327a38fa3c11d5bd384eb9609907b994611ee8257242994244f40490a19dd9f2b5603d5daac34729ddbeac2c246ffb43bc9f86651b20eefac46c3384dad8e9ab25a69fc365d1d48533d558471c6698b84bccc288bea2afa0f0303cac754e73666f5280ce321fc8f9bcaa263015c560c73a9ba1f407a8b757ae1ec1b6fcd167763a15bc98d24ea974ee41a4582201e30c40629b643c4f5f9111e191c858899cf53f9e9d34b9c204665ffff8cd41c6c611cadba64dd4c9b232a5875073560c59496800887e145e38cf22f9eb5fef555b77233727feeaf50d4152e9a2efc190c1e3c27a21d45936310f80e9c3b9e8e9a98723b3fddd2bdd5db02e4ef4a208e7cdf4e840233cba886bef9c19133c29132a0234b923cd65e375a1ca0889098b9bae3a506825f98b182d36ba78e03abd14e4f9ba40e04a6bb9721b87613cace4fd632e221c01e38f26c688327f99f2660b62c5cd53f1ede5ebe6f613c3ab008c8355a6a28850bfe3aaef053d6aa7462590c84f0ed805d7ce863e2b39ade962c298e1f72d34bac331cc32032a73c6afd84dea8580067edb80d213d004b26183b3c0369e04a39a34cb8871e7785fd49c6310e520dcda6fc05585037b2130df0ddf466a33722da530601ffd08e5f54398649075b5de8d089d1f829fca52f06aa99ca9b2666324d477a2fc495161167207582ad21a8d4b3131167ba407fddaa9d6814d74ed58d5ef1bbe2198610cca2a6f4230c1b42aabfb3720d6837c8545fe2b9856b02a4d6c4ad2a478b43c134e61ac64096eae1293f06e69f5cc21ada54a2c422b6e532c76330e26d8637ecf122c56c1515f26271ad5770ec65e89a3dda5370fe4bca41fce6138a1da606c4dc61e2f28890e485126e2c03ae29dae50423c12a9098267a3a3df8e47a06aef40b172937c1a1e9e1ce05c0b4d042b0f85d50148820480593ad56e90f543d578df3b8578b38f2cf4b0e79be1e212c73d6bc99637c095457ad10dd486d05b04cb511287d3982c54583f4c2142667dbdf534eda66ca146e7b84c15055dfa8ada49519c2a77e3b4128af731045f494ae188ca29755437bc15ee83a96a1447fdbd935de9b887b277f9a2b73b28d073203757ae8db31737f42cb23316761add4bf9b25cc8ac7a7e65ec4e9d2680ebee6bcc6889a22e8f2e4d4a13e1dca390b96e27cbc3f0b552d25cdd965b6af5e009195b778207b5d68e59a8eaf3ca20634d98ea4bdb104e8ced212149cd49225d8302fd60d38c283c1519fb9b09f19301ac758c2aaeab7391ad0a6e4fcd9807a8b3598ce9feda902fb56a6da23eb027ad842f2426b41bb4c299b83b841cdb7fde87957e44330e34031f77de060b6441c9203056b2837ea392ed57e239908a28ffac1877b53fa055b0ddfec7d55b8f1a3fa7ec72f0407be4ac6ed51406bff47f91f8609b0864a917ba47839f6b3a5851d4f614c4d8ca28f23c9eb26f076c9f1e72b3ba4174a848a4b4000e463e7d5c56c6197b639722b323543ef111a2b3b278ffe701e6eea83f97b81e968ac7364d99595074217b007d72f0a6eba3597418d4cac9261efd539467b5d5a986bc6af9f1c5f9c79190472bd7dde0f85fec774778fc2e2aa1fc2f0f2f339f8880b1c5cfb20db06046bc7f75668da0056c84cd166913220e30b617aa4855b1b0e011990620aeb5ffb4e63ca9a3ad22c8a866589e2159d51bf6a1d559085bf78a810d0f99d01015165145a0371b452afc8ae4825a0d11710c5c801ed48b02b1999b2b147d5af9b1655b818d4f7f495a3824680bb5cefa298b940f062ed941ab61d2a4c4f706d44abc2d9614becbec485a736c28190e94366f625fedae28b510af23316e54e22d51296e4469394e683e12e193f4c84e4dcad3ecd9cea53ed88aaa4e368686dd6be4c9fb14170ff7713caf5e0dab956b072ba078063d5d24e808e89ea6e6889284adf3c98d16db5f58749959d96db740ff2706876699a598781af1f622639741cf57b211655f8a94b2a56b183ee2cc6f5566addd3c0f80baf808f73ca298c007163f6f4a949c73df73cde991a7a91fd1bf5bdac5aaf75ee760a2faf62adea58a8f946a879011b7d604c3342d07df7294c9c07fe38b46ecbba10765b727f1c223bc96e99cea6858ac1050c357bb6ef008ceae8f71459058f8bcd57235989c7ef48bcf3bc9bf2f8530157a75b4771c484255674e71d76d8ef653cbf8027f7a62cec9afca3db3a65d3c2fd75bdf6b9a7830a6d02040e342361180ef221f3fc8524ba2b8028527e1e842ec143239e88c7c8b110c5b0a8013a5a1b16f2843bec1b011c23307e7b4d09df8e41ec86ff436e0e4b0d275c549c15fb7e6fe9b23229d69fab136c4ce362d17fec33ee4d980a612909970576ddf70fbe0a774500146daee6edcdccbceead1a026a6ea9e1a323dc0513e2264dc6dc3e97f73d19e9d7bada38e0bff9b0a1c548b82eadf17b97b123faa7bc602fdd967e80c8eaffca8cf60acb1d6e83d452c2244b1eeae2bb8c3465351b65a213299bda4eaf4231c695f5aa92153bc7a9f27fed94e6f1422b89c7db89a84953e6f02bfe89c8c818164cf1f991767d66ee1770c77a5937a01e3bf10824e4c098bb3c6d01ef542d00029d04eeec1f0cf1f07c31911db26a0e7863fb42f54e357d931b39bb4c06fb424a9f854e15f3ef60f97f5c23115dbc4d0266781a9742f4dbfe48fcc960a2701b81a1e3787508c9a7f6ce84497b46e0e9a4c230280e5bbffd5e122a3a2730e637382f38238de0b94ca6ed4f7f67c47dda225061d6bd13299f5e564c247be300a1a58a5bdaaad1bb5eb9ebde9b1d8958adc02d45c9399c547447c22da7b08c93d64bb00c8b217fbee0212df0907adcff0e9164c711443a86fcc8ed8143188c149d06100674a4c165ef2f9c7114793875d329072e4617c64bb3156f56528850b8e0b972df53ffb1486877f3b5b2a95b746a123b5430f7c0c703fd85370d0751b28063d0f7259b0583cfd85dd27f410c0888c63bb3bcd232c2093c51c8d576f05fb082418de64030da51b63526a19b70c7b10a597851d43c406bfbe95d42178624c81986316b848fa3fa599ad68a46ee3fbe6327fb434f89cf0045e460609feb1453608b9ca0f55f6cd29b48e63e6f3ac1396e1f3c0216325f56b53c561147c5972e3d96e15482c70cf6bdac665951be2eb2cb472ae523ccadf87f2d20e4ea406912d2480148295513235bf5dc620a3c7297aedbf090e8e9f245722a436297086c9dfe49286f31cc4b54c39d5e2e97d1cfc12862ed368154da21b31d1b91545f57a3f71a183c77cac70fd6663369cb60e5942802d12e23d16c53c79f245052df95b20c2dba796381fa8234fdb1ae736d4786c7164c55ae95d45f063565466891d838931f53c7ee8b202477ef8839517f4dc3706deef32730f0a4b16bbefbdc1af021aec1c5d82d489335f876a10d31b112a55c5e3751bf0685da3ec6382a59e243ea112ffb9949896919ad23394bc2762cf58dd24cc2628fb4755928e99cdf823f27afa83e528e99008c6d95ac5b86df208d4951a7267cc0437e1c415eabfc73de31b200311a21329565f30546e7abc30d63ae9789f9b3d44a6419c3ba3606629e5dce3f876f9f72e4abc976583a69379e4551d4e9ee8912ace0aa8f269aa14d3003b571fe0e794b40fdbaa029fb7eb739b3c37beb7bb7cfa5f3a22bdb911585c158fd6ae3f6f4ac546b253ac07b3095a42e6b5f41b7b493c9fb5e667ed520562f3899b1a9cab2fbfdb93460f129c29bd6e4623fd83062e5901c24fd0e467a6b1682ca3f3966270802a8e158a6338dfde057ec07b2722af0f83bae344fdb46b0d418ccd53742fc14ec94133eb17067366b8ebdff977addc85dcea4bc113546f0c3e1f11856bf3e1d344c6edc2c9b1450703820417fe7b8a4de0c0bbda621128c2d7378e285281a80fbe5c455f7efe9c3719b54bb86a088cb50b7ee46f9edec88da452902e6811bacabef9ab333ff517302c3faf038820292ec140f9b6f06b88884187aad2e53b5fedb3ac49c907348740f53aa6493908b12b0e4b0afe0d6adc93c1609998e1d50edcf51a11b13906b86dfabb25186f6ab99fd7ee0eff0c401e155523b063289c022eab9c8976353e94eaf990b0e4d97e8255694ef8b4b5692bc65be4e5c593a546f7870d1635a864336272dfbad3124d73290c168264be173ace210662b634ba01cefa31388a78826ac188e03eee1aeaced5d0dae27c5441046af389fd0112fd8cd8618edac395469918f4ae7d53ce3f83c068df09bcb1324664271da886f18e168752e9b84d919230a63d81e5480df0f350e35afd72b3fd2e2794462025b3572a5b9f9a0670eea459f9b64c201246bd0aeb5b57455a9b697eabedd9f5bc2fba6775f154e27dfcc7d69bcf5252fb6537f0c0578503b96807e385ea3b28e490e5af751e8ace66d1ccfe2cbda4ae317f4b22889be188b1960b2a585278ae49b0161569bb8478c12a5b0ec22736c7848705716629fa2f8a3956d7a684349900443c3976ffa28eafb6035e4befbce442973627334d76ddc1e882237cf5b19aae2ad615d3b949f9a9d4e4493a03078c31b02af4e015b4711362b0519bb32b33fbd572e9eb15aadf9749401183e90b66983079af5dcb3c9e86044613b9e1f5b8eeb1113377f4e1271053c94f7dfa796e66b0f35a36d0905ea77b50236a62abc0593b8db84e606e34116481a725a399cb9104acb6dd09169d604caa1a87315c1a719d2200c987c2daa795403f53cccf8a8997a6057175531a7b84bd95fee235962d798994b24756461839f431acbea95e2d125eb1d5fac3eaa6b06a5b6e0dbcf9688038a965d9d2d368955afc360e275988f79edfc61fe9a82784430a9d43609005a2842e80f993aff2d8dd1df8cd3ebf857f5e6a6400c95590c7adbbd3ac0ece22fbda99101415029eba0a16e1d35aaba6de67cbf3cf15ca528c44b9373713eae370d6b1e6a935fad8f753c9f0aefa530e9886765a62a348385f2d28959521a629200959821027fde791fc6503a5fca5be5d8ee07c6ca43b836df18365890edaa345465e2e2805a3a71e19aa4fdc89a35a9fd10a912e6f1eb6ec160b9168bfcd1a2428cd4f00710c76f447e9678c4e416fb71170414a8293b2b76f73acbfaf5f3473a80f4b2e221ec513e23b01e11310def783ec4410fbed528d7e72a530af3f0cda8fd1369074d474113fef95976ae3ef46dfe427cbb589baa8cc8d19749d2891e57598b6ed0b3d181ee6feb00fe1c113db60fd31be184b7f2e5598e6da359595032ec8ef59603fef02a9202d353da99d40dd852a27f7439f282aa824c93dac8096c1bf4079a1a05e31045290fb17e0d5db620d09343ef73fac648d769e889f9b9ded6262fbdd44263c955d88bd6f7f63025d2a6f5f1da4e2b18d72c9774fcd08395f19055d8284ea96857f9bb287405fe42ef6bf54e088edbbfaa46e982425fcb3297afc66b2bc3e2454ef756505317c7627aa6fa5537ac043a040ed1b6800b42db0bbd68f34dbd5fceb0f20a77603bc1dcdbcb06f943b3b9a7a78bd61bab03a0e646021aab2419f65736434f242f999dda9b1399721277058d306e0529bee502c3726158f899e4a300dc0f41b99501d52d7186ff8bb06a52fc33b1a9c158f084cabfb191fe2300bb69a37f577515c280c7fcf7b3273a2b1fa1c2b4b638d9a46b9c2c8ff00667ff68b8d02c9e9921d040da42cd9fcae4a1b7fd364f073ecea34e92ec30adff9b6e5f9f632f61d71b3ae5418e4fa9058e5a850fa04fe48460661d35ee582109644133e36ef9d1495deada8ed69c4fa99f8232d205280630bff5a2b8b3276ab86d9dbef6df23099c5492430022d26853260b21f0934d666edd58013de3dd0a9a0980ee9e6cf2d4abb46186be72d1d0bd64ca20b48d30cdd81d8a369900919cfde0ba8836418626eb8513d3c70fdcc805220a0ac48b8b9e7f5bfdfc50ba5eb230efbcb4a663ef989485a0e57444406c360038dd3e68aa9ab1d869984a16bcb6010153223bb4843b1c6c93baaba3fc07ebc8073eebdcbf300aa462eb953928f3cdcac6b55c3f9211a962d5d846c660ebf6c316fcb8405c4eed6d5257828ca032fea3c3d01f788ff07a387c7f1016364a6de6593942f47599a7b08771b1fc383a3fac6311a40a4d95a081db75e92cb8c745f381bc50e51eda869ec68efd61667e34dbdf0e0b4cdbb44516f2fdbbfdc3917922e53e8da2766bc2128f638f502b101665579fa7fa82fc95132c1c8b8fbe1acd56a201664494baee7292f51ed74d7752adb7b1bb6b3d282098c3071dcc292bcbb4a3e16fe10da3ce5e76e87c79520ad9fb85cebb73b24955e6684a33a2ff0d26dc9d8d9f3d19e0e15023dfabb0390fb1b10080a6bf2c59859f06aae9c35dd1242bd5b9ca8c06b1d80a8198685edf19f39e268e4e6929151af140e227a230079ff37deb2a06a28fe803ff039a37ddc76ec3755b497e4d5390ec6820e12cee6cba7b9f1e0fa32f843228d051eb0b7e671957e39ba344dd687128d3d4b86d297d7059e41144a2641766104140623b886456033e2e64cfb0366676cce391d645fcddf9ba246e2a82521f880922f0a34af69d7f6ce3faf1f7eaeb8c52dfa8bbcb3727285bbe4c5349989aa6590a8debc2f8021074bd97e49760131bf311ba1d310eb51e60732209c971edeb04be65c77bfb47a43ead7062dbc74d4052c0f9e51badbd1a205d90b9051985974cd65a25582685526a5723d9b4ce27a5d8897a5bfd14e7ef52e5271491f007f4626e3df366da0677be306a32517a726d50ca52fc4968c17fa96b834e6c1bdbc97e15370c4ab1a52dde67ab6388b6b1915899cce1d6d1d5250fe362779d97fdfca705e6e3f3aa807274479ef9d142293a4fa69b6fd75c22509c57290772ede8a0367a0ae4a3910ff4927cfc1cfd52d8b7c8b07b4d72990fa1309bb39023f4f844ba4d5e4c9f77f877aeb19b8f792dc5ceaca7e33f66c6efa79d4774b0183a5dfbb404e3f126438552a5e2cef64b99951830c80f016526d981fadfe0990a1ac1cc673a5fa9aef8e8fd0b1b92cb7687101383c974ebe4ab73fb5686e700ec402eee33ef64a674f98df7674ef72fce6919e0590eb245c182f9a23b03db63405e2dd58d97af13a98c718834826ddc57b403f8ba6ff838af9c4a4f13759422ba2558733ad66a4e59a499be1b0644d8cd0ab6182ea0413778ac642fd4975c5cc320bb67ee67911973011ea266fb35a7971ea9a63aedde87f4689836dfc432cc7fa1b6725239636d37cdac9a1e06c6a7c8110ec64cb3df593512fb41fc992892f0bab14dc4d219d468446bcd6183b8af8129f12e48ab95b635b1195325c93c5b320fccf8d5fa4baddbbd9ee3d9fe311d78044d9ee3a70c8ae30cf2ba3cd628fbbff1c6716f806cdcbb8efcb031a8bdfb9b225c65f2f33c4b22f899f266d3a842044ecb13caf304eedad6f981cce12f55d28dfa21fd92a59af6abb7337cf2fc29c715a0008330db41b076a6a4081a5395640ed7ec0bcb6367bde540359d9e4b642890a58aaa2707db42b4b2c3f0ecf7064102fbe8f88dc9c2f9296430dd09e2658d04a279c21e2dff3049a165edda0acf5f17b47c15088f90bdacb0169741ed191aec62eea46e4bd2f29de3260d53e4234bc499f8565e152233c73b89f3ecf80c97fb8f8403ce90991c96a51e6531112ab6430a5ea342738970a88772c0adb4086f5532cd50405eebfef0746eaff094b0409b95d3458263b0404ee1fcae0f48ca3f351da73e8bb6d33618314dee37ea79e6b5ad256306b7191b7a530c45f60bdb1d60ade78123952da61ec9690598f12f25559b079dac6ef40fccad8465972d2a5648e338d60aa617c5115222065726241f3580e0e3c2f940ee35a4f085ecf34a3b8eba0450bea508dd59c3b41d06f30db5d9465a579bba062346a8291e06dea4dc99a444b3e12a3a66592c1a2da71790a727e4f6db7dd824b435ace7fbf29f77a3e3ca53e66488b14997dc38a1781f2ec6fc0306bbac8f612fb984c11772660f189e66adef791f6e74e1422165e49d4fb82471f74678cea079caba7b16ecd07015a9039aeb44afe29246a7bb6f4eed6b2271b7b47ae8446a51215fb422173c156fc5602d7a0968334d5c142dcf7d5e3f342a9515e3ea3eed94b8be8f7acfab4bbf36242083b379b11fd73fa57d43aad19d297d0ab318861e2b48bc6a53a229fb95773a109aa6e93b6a798fc64efd460ad925c982ce7e28b3fb17ceb456bfdc55deb69862265d4a67453a5a6997ecfe9eb4c171baf18ca3a8784dd7b4324dd0506fb418e8e06ea803e861a515bedbc6659e673970562feb7ecadbbdf7aac9d7d4d75b6f0d8fe6e09be83a7bd23489d5c8da3b25e8589d76debd25888d04bc440c13f466a58858646a9f2ef3f852e7142a070bbd655fb8f309a17973776dde5228604a34e625426736e0b7d860646fafa1a5714723df7cd4e689afe8c83934c7199350b67e6d6611ee00bfb7d426f7543094383a8fa99df241d40641c38e346f79b440af7e7810d72cb0f063956f16a88be29bdc4e895aa667c7c5b072eae830d33fed6f6c7165af99f75da8e15a1f42ee32c4833a56185ed5dacef52778afc04aa3d0836dba8d0088d87844c6dc3627b2e57d60d39a174225b43f7e409d38bf2e662cccbce6cba4c8010caa70b012b311746ce5116c54c7a02c093aef5a4d15185f66caffa69dfb40fd5df6201b4a35f03acd0f0f2ce576dc4b6167847aafd11d0c16bc0a421a1e0d0255384722cb5e59dffa484685f219e33fe83ec73ee8034c2c60d70f84b7d09f9acab79b13e2234f20acc1103e1b23ce22fb4d9fc48d471d1eb93f6a14137f7597535141af292fac30e7b7f5887f05bfb500d9b32b591673b37a181bcfa2cfd5520b620be7028312e527575162cd6579a3e9446d3621a79ed405e0367ec5b680c9647fc96b6d38f9e65c6e7dbdf217cbfa8bed3ff0b220aea3b887f473ece595860a154209aa6b374c76d104aaa374b438b28d4e0c5aa96f9b0d19f35729a77aaf20ed75cff15f1a990181f653bdc61b2ab084bf9abca59190178abf617dc7e11dde52de4bae120417f299975bcc2e32ac0c4e5d143d7790614e52afd1c10bcbbb498feba355ba5b53a8f9ec72a5bbc1bad43ff6a98cd63aa98a4eb053eace569dd1728bff7de21f0b00a146b364ed410ea144d7a7190159380b5df679f58740830dd3e53026e30016eda68ede52cb4dac16b757f795f560d3b69c65ddac51db67ba0375dc375958e0799582457bab53499f80b093ddcbaef185d73a0d462bee7cd3ee2e7536202c48ae323882c650b7c236ad3f398cb76adffc8dead4b039b3768ee201b95e5e1325584b23ae5c6145ab330fd7630a8e4649fee3571bde4e2661da0b12d6ae3f351718e7810546b54455bdb44cbabbe10748d9dfb00f59d5e8fbd48cd633796e2839fe0682e52bd4d7d410acaa6323e46debedb6bbae1a81ece0872c15eba135c4d144e84592510c70c79ddff226c90f5dd3124b3f1c1624df4b6fea82a619728553229742a162a0a8d7fe84ce33e00e7cc7e24ed9c3e3654a53f1a069e20cc1751df55dc16c77aa8dc67d9e01e986e3312ffc139ab29f6449ec0a423f47887f00916257592c27419f88b7f4734e9509936203144fdef28cc4e9b5c73b350fcea9a195a0e7ebe78037d9d8298f527ed10054599d111babb94f448c6d407dc576de7b3c56596aab441addba6213414ed9a53a4505653c254bb8e1f5927601dc0db254fb9afa42abb95c5f63d86e5765bf49fbdf533ac1b85eae8540d1f20b408616e8f1945ab3311cbd3ff6ec06aa1d24bdd8f32460a6874a0e957ca2c3ff6a7485354e3413ced2512df28f4c54312b56f9b2214c6f7f9c80438acb7bf3589b387c4672a8cef72fb96a809903b2185d8aced32f3fb5532dbfc7a7707188b37f7ff0910beb170c22b7f8493bb0435fdf44676ca7a1570632eefe66083ff47a1f096b70ab0157ad2c4ff08d50a4851118c683a6647495f8c62abd7e3018df929cd3122c1bf18f0828c796108718f5ddf841423a2d44d762a46e67c42208418a5f9f0eb3153095f9b6d0f0dceece6aacfe55b679c6e585b378453ce7138e06434bfed6f82d5c9b9daa266bb772b1907017bc10bb91e5dd872fea2416ddf2f651b70e4bc5804efbab0335c2a0cc570b84ad7b1c4d8c55fa574a903e114d270813cc9ce561d4cf20e80f174884569ebd014e9636db73e765abece4c397d62de98124ecfce6ffa8cc45123c4cfa327f8c7b71dbaa433029670b96fc0a0d664ccaac69279715a802ff2da106bd57f597aa513179df8a750e3d26269274b3411bb429b8b341664a10c42ab4dddf8652cbe5f43b43e609146dc9e1eab9ebc993a64b7118891fcfc363d098d6b75d9f805517de1a9c815e96c0b4d421dafe731cf6f1fedcc066aef239a374855acef0e8994aec7edabc33489fbf45d07aeeec4a3f54e2c2c20f9e54716068d5c963110c18707aba3c6f56f3f9ef85829fbe94f33a3710ee2aa18d48abb7ea6988b0436bd6c806743c80f6b6bbd14bf8e4002139fc18a4fb09583c6ce4e26fee9134148d386f5405ec2d17a4c448bfa2fb246b5264cf302d02283a1e57e038b4cf4b6fb288a9cf0cd704925edc9b82d9db211ec11ceee8e7e286e9dedc49384e91e53881091595ba7fef2084309e6d635088a8a1a05a34dff59e0218dd63cf233dc925a6d0657a7b68c576b91af48d085f5431b0e29794a16fbd67e37038960a7609bc4c85efca2c11f68f61b100230071a6155f1c15d075b90233ded924d7444e55fba82bbc63fb12e2ef3c7cedb187c53d0b9f988ec5299ac508871c01394533c71022e46587350c95091c2c4e62870ccef23a7bd22e158a7c39c14549fd78e54d98e3dc1364ccdaf5b89b40e448e3bf64f5563bf4a4bdbb476d331eac656df3ad88e0d5d3e4ace6342b7147eb65a092f2f3bbacc50bcecde43686669aa04ef942844c3ae8b6fb549a1835a3d9384569e7d7b870fc62d2b674a41ce4b5e1ad3607a0df83b3d04d954f38fbda341baad8f67f8f8453b60f9ff35895b381e45c83c82ce86a2daa0e20b688b112f7696e68f920c72749a87b6eafb17df53d168d5ebde1975a2eb38e038d8b19d48b1041503781f3130ff38c4f41d925afe5e5ae288660690d957b19e33ab5f8edf56bee9f23a5c2cf62367ab18feb5898fa389b91a52947067f63fb3468538f3fb74c51c28f4e21695648753bd204e96ded491397622c76befbe11f767308ca25ee85408fb5063c33a1e8aa434f3a8ac35d20829346cac5396f6874d7bb63301315d6c3f8bb792195cd7880d8a728ffe41abeaaef6097f7f46d7181c22b992102c0b2bd9a1b8b2c2b4cb6b85c1ab24f8839126f164cfa3a9e9560c35978af5ceecac064cd62453846af38a6440202979dfb505ff334549ecc2c22641e4276010a468fdd86fb6cc4b927b22fc3859f0b9fbbcf1b1b04596c4c2abc1f064f5f1645f43563bc3aab893327bb038d5f0bdce8b9c61875bf8347a909742f8f8c8a3375da91e9ae1e4e06f001d5d53c449ae77ea6180aec4b677fedf095064d54fdc7f892bd9e925826961f6372f435f7e200907e1eb6947504ab35abab34604705d7de53b638af0b8fb38e5677f8e44c60325b176e1bd4713c446d85c7fe39589697a1cd25ea15375e32c6b725ebf2dea3e1fa606c237476730c77495621c6a8f714ab4f6e814f11656883e22ce33743f99462f7a703af78710c3c0f2097fce0800e55fc2d545fb238eb476f62998bf18a7aa11f3d24ac298a5b2b26a9bd371a38f8bdc1dda85700f3547e772d9b4e5884085a843f579efedf88b4c76321388621039501befd53cdf3b208e7e08d837bae8d2648b3cf6fd59c82eb977f629f0a0605e6c6e22ea2972748c737672f166771a044cb4c68757f800d26f83827c2aef1653ab189ae2cc04f475c079df6d9ff6582aa2dbc838fbf4a47005cc7aa457f9c06209c0834be0ca630c70bdc819fcba5dba673e4d11beacc65777482e6ec4ff1df0e5a562aa4d49a3f3a053dbaca0511084d7ec3a0ba8a971b4c77e1ab79f12d48baab7d5a6623292d517ff2d538181c49508ad48745d597314e6b2a58201684af7127fc2f27f942b513c0ceebac8bd5b9d112051e0b30b57568406ca09c9eef3cde238a31bb3739e08a29d125de650b1ece83c416b117adf80314b8bf112cd5a4865063ace67ab957709dfa732c4c29e8ecfe62fb7c9778ace238b02a804d77cf22085ad8875edb8ebb43e0523a9dddf60f2b71801a9e87e20d68213d1c07433d14af36fc80206e4c0283040ac0984b01eca775df3a3aa4da7922657a7b0575b15bdb1b72ce2b2f74ce932539b1c553f14e38d4c0ad3e7bbfbfcff4ff6d5f931667edd05fb0b88fa059b580ff30d89e5f3a3af9eafdbb4ba5539bbc939ebe63a76fe21f6acc2eb3dbfe07186f7d6c202629bb0087c2bcba4e75088d266af15b4575dafe4eb9165b951e19b20d13a1a723f208a5106f6e1e9249795a1ab232b3564fb218d0f09ece6cb544f6464b268163655732efbe3463cf192535f426fc36dfea3e5d6e0e61bfca3542eeff06d48195e458c2c46a5fe09a439aff3a2c46bbdf621219cee268f92bb2654a6f4aed2c59766ae1bae302ee505fbc932201b69a5f41133f7a1fcb4d9902322165f05b768a4523684285c451ba7725f9555500575b7ff14479a8cda7810e423a33a6de54a66864e5dff49d2b86ea7eae40399e85cc3ba33453125bbcb7c0bdf41ea6a8991e2e8b740b6549bcc729005a4c47ceb23fe8cd859431e4d426dc1f749dac7ba834a703d250d9f098c5daecb9635bb44958913437b5e2b85f290be6fee784a7d8013b2ea4b2d0cb0109ff911f358d76457a1e6c1eeaa208cde641f68b8837cf3261ef851944fe513b27aed31bffad76c48411428603bf2c32403ca15d48c40d5f6f6578fa9e1f9e019d15a1d26ee7555c8b4ca35fd9232f486de8885e809a4a5c9d09dac3384d4f771bc8a22e5fc6105677193a279862f82e2f756e512a0408426e123e3d75dbf19886bf8c196fb2c612d7481dd3bb1bddba8566adea25c16fc21bd2e724352deaac53ceca5f253562b6d0d42a83ee2d5a3b5def5f27ff57362f366bd3adf5ae4e94dd402b8c67303f6f79221ee7667d65e7cdd24a6c6102c919ed3b0f922a53d72862399d55d4000fcf5a5b17e712c6ae13ed401b9def06fecb6a9ca92cc5122b9a080754d5a96f4edaa29b3b51c2bd93624275cbad1f5621f44969b646490ba9e5fa66cd5b41845448a0a93988aedd3bf09e541eb2a6db6e14c450f68e8325f6bdb6b3695e73fbeb2004be8b1c53b430bbbbd961948dd5202c43afcdb8c0c80d9f73aab33ca968e90c7d0da3e216166b89ed5871669d98c19ae9ccd3a42826a61fae34cc0580c9f3fbfde380f82716bdec8921a560861a886f2e2ba31ea0c188724b5366df1ff05849e5ab31fa130e3f8b9d56ccc7ae071535a2766952014733d02099b8a40abd48f4d22944d645dd360a1ec4a09d4c95d6e45399bdb24b0bbe3a8b2e4029c91bbba4a4209ee9757e83da2aca72fe6c85dd3344a0a4b7db4ed51daf521a4f6903b6b4414ce0c325ba2ae2e5f8c792cb3baaa32a6133e6c085f5ae437f0568639e2b17e1906307eaa9790359c54bd8cd3ad235fef8cfac07bdec8bbcdabe5231634708ade7cabe3023c6ffb4f11d11711e09fb0f38953b10dba89c8bc2b48fda823ca01277be316460508c8bb04bda7d4b12ad6f5d3cfc75172a015a97260f70954fcad30cf71edc65f2eb27be910fa978db3d448170e7ce7eca34052a8f1e6d8ddbef7338110bb831230a44a209ee2a1f5715850631a49f96340074f3c7c80489377bd35247983c12175a6e6825d587e31a2c625f2d2a95fd15759d0444adee49433738fd98d42074862218755d0e745d4f0857b135b92733cd261207944818c20731523ecc0ca8af6ae135f741f477006952aed393d6426aa69c1fc7b8ac7fcf42583ebfc32a97acfa44e30dc25b2bbeb7c60b1881ad281151f31ec2e6cf4bc5fd84fa2edf4787372d3b45e3f3af1a90253166e5dd10d3b6f1b57e43f3115fc027f161ddb31635ff1162deefaa27e2300fdd63d3746e05c74432c4cebfeddffba5b64c4f71ee235f3c1b2f48224325504b709cfb7a0bee1ae7ee70d9e8838a4c4f110f62f09cdd52e2c267aa6d53c207dff6b42e2d625a18b16e0e714cfa0428ba81e6d51373fab0bfa642b0b1daf1f72be46cdcd627745f8369be5358b8760ddab0f33505bc4677aa48d86738b7336eaf8b5ffa6d5841461a9e1668c144544195106eafd890757315e510f96de9d589958be5fe8da72e229bbbda48c04ecb594df590fde60af331258e53cfe37d8a80fa8a4c7e384f49663bb48fd5decd05dbbec842802c67a4e51cc59a69ced83509ce2aa5ed8e855df41d35102ca8447d9fefacac97bdedc976f410a9233437f1f89d0673ce315e842787191a24974cb812000f01b73ad2c6f77525177cc30d337cbc06638eb6f2b3732aee169e861742839f5e2dc71bfe7dbfe3992ab88c1136fd7b82171294c28d35c5f082c12e8a5ff95ecb09eb9af914bd6a3d1fe5ec179418fb680d312d1588d5c9abe5755bdde06c4860934b6ee31c07b45bc6ed8deb3e97b49de66f76d1d67ae4d3a2a84aa93bb72db467db0268c8b0d8d4c78eb039a52e55c7455b58e0e4804e3b9feda28b0fd7571a1a1cc5dafa5bd07cfa814f59178946db45c4d60cf3f227a01c14bb289d830f9700b0c756fe7f2304ba471b61b2fd37e891f978fa8737544add5f267321ff64edfa2ba73fd1c8f06972e641b5150570a061d842f9c2b230668741c8d6819be8630bb6c9b603be4cd618e68252c93009e72ff080c33c384dd294343bf99a39686194284a897568c8b5ac911ea32256030378c461b997d45b47b9d69e2987b7442ee5b479db7cc90529302ced0527079dff7c94e96f392cf158c5d24c1adf499fc8e3aaf4ed00062b8f0b9e9835ed8e17879f8fa529f2d887ec14a5f5d0ac1f676d1a68045704b67ecb4ad3e78ef9b15d3e32e9881ea457979488a44f058481f883f9a1e6e20d3d3c550d660625562e42198cf2c277ad9daafe46e76e4853024603af3ae8fe0a54582c264fd7061613f1d3784ef6c02703efe19bfeb8089bd887959b93de8e6e72daf3ff180b018e1007b28743ce859222147dd56e5d4af62417c4f577c64ad6101782f00f15b746980bcfd075fff4eef5eebaea8f7abf52b276db3f1778e88c9544abba98d86c0ae59074fd2bb7c7b160d6b057ea19f28a24287fb9a4b514c81778ecf7c7aeddc7991912445ad86fa17b2cae0b271d0e3fb77778eaa8117cb15d2561fce1f9194184ede87a584deda813e0c05a9870fb627195ce4025f524ff939b2a57cbc1d0def1db07fc65274983c9b809345445ad9f2849ac8061410c148272e46a3a573860d7b9a7046454979c5a5032f61e7ec3cddce36655c6b8179449668faf2c1f28ce16e9cc84849bf68bc9f147ff0b7de1e5439bc23518fea10041645967346478f86c024bc26d7699610ce72da413f80c69a6c757ea1d4cefd72dc8ab0d480b729e84d5ac65e705019450621c0ee295a9b1b5f75981b9ea8788608f9da2061412d64cfa7b55815e741d6463946ded45812150bca33ad7383be94767cdfe5957b481ceb9fd1d58f31bf83f520d067382a440c43b6ca2e0afb3936682620746193fe44d524271894a65b7bcf6aab1260fb61d0c52a315451e8383f14814b227e1395edc69c0be8532ea39f7ceb502ab7ebd2c74a2dcf7f8d28956d25026db1de39e6d1d0d7ab2ab778f0bb1e728424d53ecb98dda8d1c5dee7f9a4b87710071951634dfaeb787f4e3cf4dfff269d42c2c9f08462a1947641ac165a6e53f02a8ab31cc14db55f297b9658b76e1a3844f84a1bcb3534bf0f53220c205407235db0fa0cd033c4cdb1565b8028e177f2763ecb36a0e3088034ad8572bc9f1556f1750e1e8bf55d4a3455a2db323440f4662f757da82ab334afee289cf64a0f5fe7be260c4eeb882a576f3da78a926bd7d577e2d1bde2e069cd9265370cc57b45e2c548dde0daca2b61d6f14b474c86213fb67beddc8eea2eb4e71e0de1ce9e028fe1e50a38f3d393990105c6d459161f2fe2b4739423a88bbc5e2ebfbc1e8fabcb6bfe38ed3bbeaa691942f74e395dedcc99f216304655d013b96aed05000db1031c19ebdb5555883ec662df41920dd797ec65d85abe8ab2027fd1e6421ab9b49e96157b313f08e617724852e968d01f57df30ad1d06320ae3ee0db2fe2565ae4c72d64c228317b84b44a84e75a4ca01baf0dd80ea45b982d6ad151491b0fb30c0537aa18a1fb5dd0b92820fe57cc0c9a1acb8a46712c0b8706bce251719c34b2891f3fe6b454dd05003acea53df14f7bda18ffcb9592881da40abffd343eac73017ddc09e44e67cb2178f1595a07de4e4806e609c7cb28d7383865f5b61732e6d25ce27df9d6eab8e0216c3864d106d45a4d9555673e6bb962ab0465423eb7ff6692a6d00028b4f2b22752495fc052553e7394db9fd3f4544121d7e3032cf72afae680bf37b4f52a642a28646cead591bd10fbf76e1a84cdd758dd79e632131b43ca32b640504be51cac50e9f901d7fe0475b83a2235553d7b03757debc64ac12175cd97b676f36685673d2906edb19f5eefb1375645b35897cb49df2bde701c8f3a5a8c8e1e1191144432eec470e152cdc60e2c56a8256067f2d63aea58c2514ccdfc0bd66590bad4af7ea2cbdca521187dab74f9d12ffd9eaa987bac3f60cd9ecbde932d7dc946cf7124c6bc3d0bedcaaada538b649ec74335bc0175f7f762f9f48094a4e9215a51ad503bbaaf5be5c82ce3625b66226f7e9737aeaeb1c903306d72f792deaabcec0877fd9674cf2a471d7c2d51598a0d9cf4d3c0a3452a4d2ab12880fbe99bc5fcf5f9419f756d01f6ec598b67ef1751322db84d87005911a121eb074589cc29c993d5c55ac5488adf0771b4209a4f058d9a1c8fb7afd312979fe6fda4ecb3234178aaf3c01d5f2ffb5d65e9a9742971099a965ad20b462cb40c51b4807f184753e196d6ff60a28124be5f08a4f2d0d78ea26e772c5ac9450d992bca2228ece56b0ffc84bc4d8125c2c2916173c970844c6816ec94e8db8aef1a7739732c05764d4ca60846bd49e64756ed252c80433598e7407813f3a51fb737585d31389b49d6316d5221d62f2426aff04d4e09fccee3d13be04af7a532aed015cbe24b5cc431fa165615da5d9b3fb25c33cf7e578fd918f6fa5f65dc1a53d31221741366bfb2bd4df0614185b47195e35ea969b783efb418ba2f4906965a93155bf050fd4d38ac128f5d212a4ede03b5b70f2ed20789ff0df540e9d9bef48f6af0f5330bbb9b421bba1158e5dc51cf253060e450de221bd9e51f123eff4834c834da7c326807d06d8dc312c8240d3519019efa7e1f7b4164bfcbc9a6a3e08313c97fb73148679041d18298cdd4acfd26fc4b0928c16128c268fb397246642472001eb4b84c22dd444cb460dcb99034035bbb8b108ae1f9e640393005b58edd982c6513bd0c9f554b6fe6ae144d3c80dc9d50c307926c44ab71f47ec7e7c9413221c7f30436011e19dc75919e60d130e6c4726aafb8372fa154fcd0df8161c74513c2c7019716de9dbb6617e7c10d9cbe1eaaf6e24352fd181517b0ff3f8358c433380e811c85d51c5fa34eead48ea976981a4be965e74d00d1ee8b039e84971159bd7e12392a885e6f2c5082b4ec0d1fbfd8c500a966438d1339d9ed287f6d56751fa31cd393df85d563a8d85e26e6b74de3f497b13b5b42da66739992b2439813ca8c3da39f0b748b27ef8474a41c6fd101c6bc07acfd12f5f36c7dd81565aae775b659287b923602e392d856ba24a776e4d23ca260acb031590b7b6f80945b6cea1f215666c2ac9773e1721599862fe7fdba8b733d05615ebad6b103b0f5361dd71693379706afe5c617af19c414ea4399245a3cdb95cb433d911d205e708ba12c27730cfcafa53c10fab1a2b28e17cda2eae211872459ffe73c83989fbdb31d95d966c26dde8e454d71b75c692340fc39a81a64d2da767d89a9a3f7b646874751a5ba6bd96a81977b30ae5d0ef94da7db0f94527c36fa6ab65f5bf04f8378b7814d279707fa847febb1c918066090e9a2d814738b4ff520a41363060d4edf4836f0230e281c77308260afe64cdc9a65c68486a66498f38a7b08cb4856c3648daa93740040134e101f359b76c041ee8f2d25f3fe4f4b8157bd7af844790a365cac14b6e01a00b0a2e5bba41b1846e4ca1647c0f3904eaa3d4450d96a6b7b67429dede6c933f965a3b6fe01cc5ac0f08807829b268a8946df59c6b9e1f83dbc0312e2208404599751022fc86baaed25c753a1d40d262da020a065348500c67ccbb8b07d522e7d5d7f11bc252eb111dc09cdcae76bca2572e8d95f931984597a60a3c8fe450e053739a2ea93bff64359d4ddca6f0420fc1df1f0d80f39d492ac8b4cd90c0b9e2ade4ee34b495375197331f16fda52b352cd25e0d1dc467e77e1f1ac1f7c9ee4c7deabe78eab9965843b0f905d8ec17886e43728e790fd1a6514c732dfea24e28e6d982858da545afe2d47b7b69783f25c11f09007a5045079b91193ee793f4f22549df0664dccbc3f33d11ab48b8d36f1bafb8b4935f30f8e19f831c4ee50b6170d45e863900b28bd51861a5081ff5b7f96e576565f80aff51998d5e91e22079e44ed4722a90b474d6b43ea2808fcc7dfb1a48e0a826b3df66ec7d651fe61a9248dd3376739134dd9f26f5678bb1d0cb643bc987d35ec9b683c694bcbb0baf9b15072edb7004b07599f5441904c382b6b00fc82cc3d1bea88b5b17e918f1b587b9c8dd0ed616c25b195d7d51a64b04f912a17ddbd1eb883c2ffdbc577cc2ab84a6853b19c18121e4086ec7988549148c5a84255621238cca2cf697f34e11170ce2a827a3735dc4d949aa68f4685b99602f167ac52a385b8e3a08a21351096b0fc4489b7fcca9a66f262624bcc2f2552beb0052f9352ee78fcd05e9569581a4c0c030d2a48257a4b28f0f41e86eb3b60bd8ab93212912539118cb1fc9fa3de613b6740650fd8016e460b2ad07937c14e08f89c30a43d2b425a164e93be06d4a180b5bc32d3e9ea0722a45b108e29f50ff5b3a22003040718f8e20dcc0b4c9f3e5a473ed148e833a414a37c72b0fce6940b710c0f4364d40105a96f5a5d5083f2fa0bdb5122d2e0f8b02698990ed62edc2bc69301db7cdad1278ab4b24f47cb4ecad976c21cfcf2a20262b5795ab5867ffef49f7b626cd3a2115878c123739c2a730342e66ae28223c00df88f44b0095665d4f66d5cc2f7bf2876dda525391847a50c88ded5006fd526f49e9bf1fdeaa9347308bbf06e3dbd5db934314d1c3a89c9661e5640c0e9b8289b8c53432ee13d7201d56642e805629b33a4da90f185dcae8b2ac18dda6c2566c1271c725d41c52a0d888cef028cc051d42d64a2741e44b6b397a8513b51c422ac20f719d0b4e87eef8684b899657c3d77fc19e23b56fb9062d21da32c7b47d971e293c3924cdc3fcb741a8a5fba2a50a74f4d2c81d72b44883119cf96fcb5cf9c7ce39b63a0e787d9d6370f38363b5460164a2756c4a4866e75789d8d824a50cd7493648c0954a8152a752e65abef54ffe0d5e91b635b683a94236ccf78a6fb60120549bce81d18d193202e0395335f43fd42b7fab05a346c3155cdec02f582d4b283d94328fc7c0edb518b2e4f3cddc61246403bc49fd4e935edee843ffbd02ab4eaf6d1ad18d26e840c1c1b9cebc18cb1c3c8c2f857b0cd254143d4542a0b3493644f7ebb1e094095d56b6a5ab7a5430b00de849ac3aae8760fa79ec8cce21842ed2e1d118e58edcde5189f904a032533c586b20c17b4479c00144aeb9a9f59fe8de9f013cc6e800a1ae448e0dffaf99653bda3424378dab0e10f8aee104a59064ddb1bcb8aef26d4acb3145c96e047d5ff28ad29bbac489853329481e4d1d3c1450d9cb5266da34dad5db2d81a0035d80029c60e554d01f4819f4f3e3695e131b67e8f8038696dc6a00c32756c7a2ce3a2f6ec484364199478666981207fc3d84a7bea584d28a8d0b57b4f103aa597a986430bbf2d1384d867269840f19955a37b7f6037c5aa7bbba1b6a57501b46f1a57cb3a6ebdf7dd524637674a10712f3793c3d27189045ec527a52e0f10d876c1e88bb1ccb6486cdc0fa432f9b35f681638ed0ce7db51fc9c5a5249bec64847bcade3c2abf798655a5e3ca75fa4c2c13e73def8b18461fef3383b7add0e4411a3161103e3941f80a354cebfda8488f157e9d73cc87e4e2002e0d55874d5c0cdb3cd99166ba9001664780c51cb15ee79f5b64434b26cc1e256f6c1b2bc861998893e40c6eff8add500e9ba0ba80996f89490eee63e7e8d8ec657d6897820c86da4cc425a3b8fb9df50ea99f2db6f7ebfd6daa79588b36870a048e2df594b4465ff554e619115717fea68de0ad21976b305166dda5e3203b74b747db88164eb7d08e69b62ea7969636164c446434e928943f9dcb67efc563ad5575f98e758901beeae7e5d24cc49fbe6e649338f1832e20519c7ebd8e3557ab439bec18f8565f8a469d185798639dc8f534c026b44f503e04a3c2164c8f39846ec0f4d38f73a1d43e39d3991e82a9ad3ffbce104c72676e9d2517abd1b266ba71b07e7174ec7e2acfa4004507e675bd46349525539c646cd0e7eeee13df8a5ae31664ddc2cb56de1f2da50195ff6b9301454433b08698e7c845c5252ba95f7283b4e35e4a079e4e998bb7733c8195979b43ca0804c02109d1f583d0840dedfa88eb5d1a6c788db0ec9cfcbb544090d33f9c1d7c88cf47596b4811586190c5ef4ea129dc5d641f8edd141dc315a44bd958c4ae7f1752c94ee5eb24db8be1c49ff268f874ee56f38ee22e65df5f96e205773017e05673d83885436459a62043645da34d1c387ecbc052fa945580fef26621b13c1a35c592c50d8cef4e4769eba0940892dae594b786e00ec3f4b81223a5751e2b0c6a2519a41ac8e9541f110ce8cb97ac3b2434ff3bfe5618c853a93563cf41fd954048df1c5a4eee90ef9d3d91ddf243d4340810b128b4abd936993e8da8ed341b790691937175898f91857cd5f536a880623b6294eca5e931f0ce185d0a1bcb00c4acbc9e16affa68c661756135c9f5ec7167292fc0c2263b9699a8f755108f84b9201622081f6ecbeeb8491596f1ae77a898eee0adb4973419563a5c721af95d277a9478656a7f5594df601010b580eee1f72a70800e2f960553e1d1055042e175fea4c78a1883d5ff041d3fdf2feaa1528635270701982f05530976431b6cfd980d791fcdd97d2fa8b44cba52ca62b24ff998e2e5fffa9887534a6bd906a4332175ea7f1bc257ed62faaa45c95b3b43fea96287e46158fffd46d02030bf09feebe56fcb32de9593ffeed02af11941ab9c6d38fb1f9130541e5a87b64ab486e85270b2fcdad3daafda3a2db07a501751d9a0e9ccf3ba4b6a5c25736bda504ee14066cc82b7fbdc3dd00cc1c62fc517da57670e2ca9f5ba9af2d279839c4de4ada4b2c75791809f125bd91a3e225bcd8c7f06af3da049dd9ac61b39478a2fdefb3bd7af08df9aa732ef49dc14ed2d4c274b5db547f9412eaaad89c56061a60b5220dfe097912c326b2984a87a629f25284a5b36fa4d2ea523576fe1c492f072e7d8e425cc4e062ddb09b389c9d106a7bec2e95f48ebd0cdea89b57a2917f92190bb0b2563b08b87d24d35e862523c7e0d80caf27477d92008e59eb38e1aebda165e2d9dcf50fa6cdc95f96e8c6f2c57ec73b6138fcb506290617f22c8f5e64242796e08e64a9637b3aba8a78cedfe993bd10da111341829228dfb601a657e1951cbf7774e6c01cfce5388f3a94dda12c91b4fecc893f6500fc4540e064bcc95efe8f51402483ace137e33b247a64af44d4217a0afc5601f649515a662cd10735ec2ac8da63967d6873a881d57e168cf3a908992a25b9bcc54995b66bc6da84a58c94beed4126a7d1c50a4806a14dbc45d1844689fc8d4871d21ab99e448dc91cbe0545099f825ea92a433903dbc8bbd8dfed56f60c671ae2150b524b70bbaf343cc0380b0a0cd41483d5c69c157cb6adaffdc77eded95968ab9e3dbc4021532817f1e52bc75107a7c050bb6df9822eb21c117b4e6199a30c2af14e30c97f3477eace46894346143f96d0434e22e473353ce77337d758a0ec1d5010beb464eb7ce1df818254110fc85fa4d0b90fe7d5b932301fe8f744f41e12ddb1775d844d2eb181065f502c1574ea5247a65c5c018556fe798d4915023c14c6a3865d5714aa54a686e376e6d8e03eea29c8a47230beaa88d0e1f1507048b3295bcfdda5772aaa4a780bc3078c3e43ec42df406c8ae2d90beda31a2a09bb471aeba548eba9cf3f30eecb2811f874c0c69e043a193678ff5bf117d5d97143353a55eb18604e87857e852f596ad55c0629305530b7f6e30307bf1ab141c74abff72c725ca7f73e2466187ef0a9476ec81981f2f9a72ac070fc07426364fc90023f3daba988efd2bd1425f319130af4f17151263dc0147a9604148466bb78148c63eca59c644f9191c7db526d19b8e1b94e653a2e32298b94c0657752f35d2eead55a2e47b56b1d59b1a4831c7a982ea499c86c7411c520d1a5a8fb7a7399dd52a7dcf02bbcd4c5a43ee0e0ae90936d9de2a8431f1413733461f21df8efeb376d83116e90ed43e36a753df8a0a370cf7ced8fabca489dceb9aa90a933a7b3ec19e90e9726194d8160dc52170cba0740ad7f03552bd0ffa2dcf5756dbb73a6db761c8cf1a433565dbeff9bee03ffbfc32a6fff957431ca425c89b00c53121636c6d7d83dbcb4e521e7c98534214f43200a59b8de67cc97cd803482028bc0ab5e71f1b6e8a7e9713702aecf49e313e7644fcad9bac198872d66d9dd5699feb7dd0dcf82cb99c9d35ec97d58ee20597937841279e0ed481557cd803b388ce284dd7e8b8072ff84e6e66681290404760be5d2e2e873f70fcbc1f5fa17ca2b97439bfc232a457160d76b4079c81bc29b4c7bee380f379ad631f9c10b98d41d2e308210d4bb4e3bf8f8322b77b5520f2cfb8b133de7a83e3c1eb881727bef521d8576d2c78932b11639d05edf3f0a58c6faf71b74d6bace76c008a9598f9980929faff1c15431a3249c1765de75cc8a3f4d7fe463b0b591b0abf5722c34df2794e1aeca36a68647e03b6ac7dd710215f961d821fa55c2b5e836ab0316962224b9068cd6243f9c959f728cbee8dcab51268471c92e89b56583349cec7a8f59730b57c1d48dbe36412e2d0c13d37a2d4edadb02768671fc4627448ec1b275772c1ba53123a89479be4fca6c9c4b8dd3c64a48116ee9abbfb9da9d3f5744ff922e2490f5e4254994ecff886fd52fa2ca8fa9890f8369aa43ec4ff7ef021e88c7b4245dbdc53c573f561825282a12dda6cd68f83a31664c29fadfa780cb6dd604ff093298c53610ead3d5a6611130897acd6d43b4fc9756260c5570fe0e2cde45c3968864ecfc8c9f1d35ea14db2c7d48aee3f2528107d085ffd06902ca3535cf6d9e1613f5a4fb02d03429a2d06417b0adfc84fe84aeb8d11d620065e4049cd4bea9b4b82291ddf27c7f1ba437a5f7dd4e000a1e970a34de959dfff9d77eca17a09739307c2c98acdc229dd6221d8abbe92a7f2dd6da39bfdcd0aeacc0a433bb9ef20545ffbec39cfc18687120c978666630816b56a745ee4c95c1c256ccee1111d803de1e8efe1afeb141ce5874a79245e955177d1a3dffd20b4996639ead0cf72edbea2342952ad5241dd6d11a99032fcf15b1d3009dcdb90dab9f1a39bafd141e276204beab92dbf2b207478425f677b1136b075a792c9bc67b3c04cf85923bb8b14c8d8af378a07ad48874c0d6aca4883296d18d9658c29e3c1371b32f0e138af625484b2f291111e38174f0eea640003dcde25f6701915fba44f162363321487b80cbce81541f19ab8f802e9c8494e72b812cf7dedb0bc5a1059e348a8026e56cfc6c2d865a1eb0f7d6ea0d7f23e77e8d4f0feef4d6c759932fe675a9f30dd0e0b5fc3bc772d3ad58de34d611a796e70afcc794cde9675276fa8e8ad97404419d45401ca5a5f7b4fa530b9cca968cf3d57e50c8e2ad6b5c410b3e656f5e707546db9a0982051de6e6c595f4187bad66e2e435e8a43097091c71cd909af160c46f512635a2539df3a7ea4f97895c27a4b72c2a1d9629698afe2c5d2d1deb9074987d38a531335ad90f30c7917aa6481037d6ddda50bc6bce82e8b048f5c72d62ea6732eff105e0264dda754dded1bcd29ca9b37c95ed106f09162e53941be8be84922fe8dcc1e89d9b46b727e778b07ce1c73581bf4f817c7a710243c02cb5f47d2b31b646f5a0da1942be71aac63ff59a71e12f0be081b21d202754d867a7aa6d175fda0851d8e84bac9da40c561442d0f20080d63e6e2b2ce7ab81f436ffaf19670e451016598159a88cdb08db5482c00358d4e337dd897bb3c47ff6b961dac0ce8b51f3a3a4b1c9e1603f6dd2c310f3d7023ec8f161e4d1b451e5662a51cafd6765c92357fd9561eb1bb711869cbbf7f4f440b7b28def10487dc191a68c536809f934b199b519c7b7a2accddec5f139121a85acea93303373470b859feb1eda60e1933b5bcc69ce0b82382564691a267ed07db3e50ffb5e7d063faf9090a6abe49d2078e037ff4ca8532f422003ed424beaf2488d2aa01323a94aa9a11a65bb41bc1377c3d060f072fb44fa040b106609af26b2a6f839cf8ee29a34cd3e7a06cb4d88826c1eeb7273f02ce9de93d8e945f92a7531c81e8d7015a217083f8d92953712901a0a6cd3dd7af42a5b5e1e0b9c095e99a0a8ed8dfa4a81a1b80046485d34b054657b8c2260abbd3a89cb30c5fe545d1ec779859a776f6674669fa51a58bc523d1682f94a1ae7b5ef320c9558d1c8c3ade3b8104e04ef3f1d2bc0cb7bdca1433b489f108737d6340c34101095556cbe9ee751acb4c0ea0706097e09dad5ce1f666d34971edd2f2df0edc90036e682f82520d2ea61c2a287efc6aab6f7e3eb322015ff6d0511770a915a6751b654af43a33272d436ab02a3a1ca7b934ca7064908d84d4436af0720e6f81b1ff3dfca46be3372a69924c320469c80bebc8a7c4ce156936fa26b8e9e2af39c21de14cb5337383753ee066c55c1ec6fbe620d0f1dd1e4feff4dad7a45d04dc038bc2bf9c7a5f37b4ace90bb9b31cd42a63fa0503e4dc5b2a9d6988ce4ec7eede3cae922b2e0ac93fa4903e5f1f43dac260c4fc5057b2f7b6b7c8c9a4a0412f8e18dc208555fcc2d763277ee45b453f9c64078527e564bffda607add74c5fede9b7865dbe6af55424c3c69c086b2fcef5a6faa519599b35781839da8c5e1f89a0d2c4869345c7f41eb9faabc37a902f17b46331fe2990dc33cfda0c538198abd390c356a3f2426e3ec17231f312c806fd1abfc838a3c77358d56ac10f01ec2a007792caaa2d4ebf70d29c5f7bdd16c1aa9345358fee93760575d63d2bd5f1d6f9ec2db23dc4831d8be00f1ebf371a1620e765b5aff7539d052a30f81d386933d5330ac11e4ac552a07219a9fa8763601c45a2392e01537e8dd20bf788f7d5d248ccda51f5e2b52d405a5c4c87eb8f4c560b1addd99d985992e08ac6364dc1668f2c9bea19a4ac6d35e2ffedbfe7356bc39f13c1dc2c613b20f4fe8ec4bf10896afe76fa33cc4e94d65e2794ff42185bcde7bed1201eae0bcf6fa3b67ef18fd856e3409a9494350871190795753e25d13cd93b363b115a6a5fb694c414ef096ab8895a28c5e80aa3c0abd8ab6a32a43ec2cb421edf458f038a3f0296b49713e4ec68931dc9e055bf877e042e54dab250912173b520ee33906816d578a6289c400bf02515a35798c4cbc4a8480a663748655fc5b41cd74d9b33a6dde110feb59ff095edc9db5cec51825d9a93c965810fea5c7599a03cf4a2f3db82ed14f0e07d8799dd5ba52650d32e745d212e969f3e2e1e5f7cdc5b37afabab11a568196b292179f268599bf498b020f2c86fdf76b1356db9795460373f9e8e2d9e8a062079f894afe26563288e16d734da67b0864aac010026d10904cc3c0790c6262af186abce0f92567d996c87be75a81503583ef637ae6e5e5545034588996706597ff681b788a27464ffd4a90bea902bf8b9a03f248b8ac863db7cc8a9ea4b8bde1c21a8e15111b4cad9f3810c2231632e1f12de6f312b0f814158728654d0c958f4e887769aeabee1d5d6de35bdbeaca444611bd6c031e427720fa7500d2e5cabd22b4f5e5e04a7ed82a2389c0746b59a4b3fbbfaf29073d2b0cbd3e25c0ffa95cec59d65af31a79a6b6ade0d4daa266ecc9e625ebd52e357dc8a96539e66c966215e9d722720eca12bd613b196420af7520ff09dae0b198a8664484bff4194c8e3e467412a849f2b38247f374a1b3e9fe7a6cfd1e432f2094f88892c0a6b1a372b87df6feeca96b1ab8dbe3c082a91c33e8d8f34d5f4daeff048730252c747ca68824baa165dff5458b2d4b0191bc97bea9e5293288e988e14d6d45733c66e313597105a96f0e0c1fe3a609a56d732d4930f19ac112908398237dac060639186ca880ffc02fc84fd29da30c40d767459228d7783ac55e99c89d6aeb2749e9a607bad606c968e985594febe705737712367c25c1534cb800d046bc915d420e825ade01cee4601e6186d2a1bb028a64ada7c20d649dab6a8708d5b2f69b4a421e3f8950e931c38537abb41f338287e76d1210540ea8b4b255055de7c698ccecb9806fb8f7b931f9510108331913314a9efd0fca74f9f2d2294ddb96abc8a6297a6c743d997214c2b7898eaf52a149c11b7b05c67ac598adbc2ae5f0201d867f7eec593d50e1178f4c61fa3a0c0d8c9f18f51faf2ba158decd4da1257838ebf0ad7e906f3cb0fa4e89c5efb821604ae035bf0600a7dd533bf3471860d323a99bcd7c1322f172de6d71bfabcbd60a0bdece7a1db9c6030e9a80cadc12a7740fd60c83d9337fcd7d6acaeda504a8879147edf683a13f5e82670af09143acdd71b197cb4ce3183b5dfd6f2129ca41e9e74dfa0b10a33e9e8f6c145303a781ac5bf153e5d8af6ebaf0f6b4c17ca3659ae6cee87e6d75d67b6c727bf8dfda2d4599bb9a5e8368cf77aef18110b3bb5b9e73d1dac42c01adb8e78ce179da44d9f45898d1bd7e87bd585aa099d6965a863a7d1ccbe6c30032c65869cb27f3c89b45914c6654020c649e4398b1cd82a3d7f8e261d154ff9470e7504f3914e41934a4cbe5213db1425cdc6fa6fb37ca340c2c699b13147ca1338c795cc5acae90f256c249b3c49952734498efe73fb914985a381d100cea7fa708543adc14377f2ca663d479b6bf94639523a033fe305a82beaf4b80c2507fed6637d2d6df430847679babdc83a09d89936922f56069a41af37b3086f6843d7a013fc88d31663dafbdc29aa9a89f427e6c62d16a1a403b508f24ff08b0eed3536e30a7e32d2adb3a92ef6292391731ca03021103a434c13edb941437e602649734ab9044b727bdf8d335a125b024ecb5e07789edbfbd078a523a7afe53dacd96af9e1b5ee1049f473ecb1553f4b0b2b9e0ab93665171375862bd8e6ae772b3213702ae661935a4a6090654951ea7e379d5ad7232b592ca7d5ae142c86c96521246130aa7373cba33f508ae70eadf48c527912640746902ebb21f7f06efdb361a8e59c3334d03f21e47c302e946af1f20a960ee04507b87ec536e943ea94a00cead86bdb443aa2eac2e9ff37fe69e87b3513b8a9387e07a25940a2e992796e9408945e5b96fb98c7c8f35b204e03ae83e873c7c1cb12d7fc88dd45603f508bbbf00a54f6460bdfb1ccb0f18c415251fbb979e00d1020c6e673278538e47df72b2859e569d306b430390d46d2fd639ffb786d961073494351638a50871c10888ec806c442a2fd07fd43d6266d593f9b43cf674d85b101339331d43a69b56e7ab3d596b9b529f1f67f176ec60a34e6e6906a0f69a01cf07d9ffb84c8e4dbf9813aefa66e09a3e5eeaef18976078edf7d439dc846c00b03664615d4e176be31e404f128fc60dc365cf73720ad6f10781be871781cdcc7adf211282e3d36da80126cb05a3458827c29c1403abae4ae1edbe8ef4d8901229a2cf991ce9b022262cda5da223d772794213782f23c6d5ac591337f6bc016817b00917b624d33a730a2dd2c0b5b1f97cd173903639c7ba107752efa9f1eb0c401470b8ac8b83645d3eeaed21db2961dacbec3a3e7ee911682a4b1c0eeaeba639764a449205d921cd398883b93f21547a2486dca7198ae0654396c25411de243dc85ee2bb2b1ece6f177d192e36ae0350f9010cf8a2a5976fe7feff9cbbe51061caae419c6ef98778d72aa02c6694207b3b532c0fd08617a4c56ab6c8917cc53d3cfb50a1d2d57eb09182840be8601b993b5a13abe627248187198355db86f1e7ae7a72b0b92509f9756c5cc7518b46f19fafded80bbfedd87aeaf5c8bced2a6fe039adfd4e3e543841d8c946acba188b7b5a8f6008fddc337bd8464d129697513a65982e9338e9f01038f1c69ea33541f12f9c90fe17c0930574ffe12bf50cb63aacf08f573e33ebe646ad07c23c1d3dc52a44d40f689ee125f7ebcb5ab0a9b63b1c9c64e532ce7733b2142a01b50dbfd48a48cad8515cf9afba5722753678ca80003550f040709c184ab9383ac899b4da21657b12aebd36a9a14251996c7c79e5a7b394a59240ea87746babbd6846e20b98686a78cb1314bf5468c35bae3ff0437bfd3c1c1fc37d32a99c5e7ad8e5e4e21a23f79f66c3d2a25a35ea8fb5ad6302494f951f03c6982ff112e1fd9790ed9acb91c88510901b83f051060e1096ded946094cd64cce75d7c8049d6e2088968311a4735640ef791533c7105bca63838731ae74da8a34b095ff9c274b71e14baca19d03ca634e93ad1eb0e2b234df7ac2d5198755d739e2d7819ef1ea088fd557e88238614e442be9b51d16c71e3321338fcbe0b33c9243c410f264587a1496c39dc81aa53a52112e17afc47f18262e5fb0bf9c277aca1aa96a8aef8cca9e228ffae7e240fe9d06366e6305c65fa249bfe365308eb403beef2d720462872db3b3d9d15331d380b8644aa399c8b4daa6731758792697a5fc5379643226243add88cdec2f7333f88c45b820b5fb519545a633f6ebd33b9bdf9a142a69ba2d441c64a5cb63b6280b63dbc737d9cc1c24a61f14af860ff07e69c76a9b71e4c76a892392f3c897e165e5be70b7de7dce0ec2886e056b58eef24ad7517a4abb12c4524a88a19da29f9d9701840f2ca2d1a4facadb557782dbe013eb44702338ccbfecfa23db9cefa95b1abc5b055e6b1f8fe2fd3ee399d0a5f24a71d7edc071304756378174e4b21ad1a3a87f6f37686ccdfc9b2c863eedcb9595948df9501919f44dedc82d6b545999200ead00a05e649982577496a928d6da68860f0d9abd3348831f35f1fb788b0cc33c8040e9bcf6a0805726eee465ec622f70914f94eb575b0a30ff3eeda095eef5b790bc6003b60a41a8e9993df93d1b312da151b30bedbf6073dafce352beb6c11272ab58a82b970ecfcc3d2fa2b47f9395533814ca8ed2683c453d60dbd75d0fdaf56c550a41379917b15b599a1ab56c8b96f34e222370492bfef2583f71010e0687b61b9de08438eb45998d5d5b724ffd135bb0776e9ecaaf4fbefe7bd08e86546bc4c68588d521e783712e18a24c157bb06227c832c0b12c9eee985fb20c56a7b9a059308f484f1e3b9db0f30fc4b527556c468af338f25a84fb9f21aae50a48ee768daf50c43b006cdac91b46f3c7d3ece8425a020005524a820971b69a192265f3df0ac6e5efec20c913e5bfa5005bddc8220590eae5c528e5162086ee4fd691c41c9cdb6cef21da0eb704e4621b6c026bb7d3d4604971fef42e987c159123075ee4d87b02d9e18ab58d3806b37b218a9b0e2f6e7a8e3a3c8735fff1af920c9116f5146729f07f0f3844f89e02560e39d68cddb77b0b525458bb142279d7b7dfa67793f4d66eb71a7708200b99abd6844f108e8a73f5ac0c6514f969e4da2891954a94d742e85513f23db58256b7533d96e8cd35aa3187a0b270c731bd23d3e2add0a18f317824219bc6dbc65c471a3d38baf94088fecba977e353cf2c94dd903872e03af3baeac08a92fcc4d88378181db19250dcc00a8a5107c043ad3f6f63c87e634e222d303a11ba7e218fde0e441d6db04a871e85156cebc8522d3ec68a3f5792cab5f4f1c6e9b3951e84488e842985976b9d33384f1dbeef566ac47458569bca911139b498d7f461068652c739b184db4fce20d6f877c2e85aaa5530c55a5282c0bed9315f6916af72d6e78176134915549dbbe563ced825179aa114ae43d9e25254bdee5840d12e7a63abe26490bc3c9ac981e7213777a5e2196acb1974de2329c6719b0d2a40d0bfa76acd6de64c5332f23fb9878cf983db1fa38b88923e73c63f07e657f674c1153ebeb636b5e0474a3680f4c55f8adc5c05fed146d787bde00046a511785193f68d301b351dfd2c81721d0b1bac9fb71c43b9e089b54953a44aeb3fb0147e3144508fc5b433d70622a0a98b2fd02989f598e11ca16c1d5a7259d77833047aee4ecd9ce1217e0c4d7d755c8217361f7a28fe938722a473b940b2553fce6e6f33554626fc1083fb16e886e9b3d40f8fdd3e9a4484fa8d89da465ec475955a9d47a92717f22501eeb662733d1001e4b39cf69939d1c1661faadc40bac15a0aa391ee2732bf56285181ca5693693bab5a6ec454b2d0468c944f5edfc66947c1d1a0b091aa069cf293aadb0dfe849a82eed6b65eedb0a7556019807a3fd56f1acc705c7c807c6e2f78a125e22e4954e83938fdc687fbb784f66e060f00e6725eb3b307cc8c9a29da9f01b8884f74ad89f0b106ccd61614a669abd49e8871104d7515ae16254c2e34e1c15cc489fd91748a2c39aca0bdb5023be3c4e8ea793ed548d5e8139d2f66643bde251dcd82ccd2909604f1e7ad316a0c16ac2320dbd1bcdf25d9de1cf9e96b92a41724e3461c97b21797d73fc272979ff3d9ec4029005c9d2b09ce0d0813647da6a2c414ac5e169aba643d4f11f6dbe1eb60aafbca752292e7ea5f6174de2c6dcb16cfffa314c4edab7c7619d3c8ccb7da9474dd5c61f8b04329fc4dcd885602f8f6c6163a6565e67bf8eef9b80e2bfa082539ee1e80fb5124cac4f04f2a765478ca2342bce78246e8480b754666c564d964d783c7d2d43f36f62ccb911a0d993f316c98588d6609c2efb6fae30f14237e3dc2535c75d7d9b00031613f3d4103b854222f8e9399e6c3397ac607323a7b42d9ae78cbe4801022f6b2d27d2f6b679bea4f1c9d1b58bb2d3578a5842163d1d8d514e941206df51d2903b804d1c4fe8c1200f363ffd42e182a8eab2918cf47cc41b3de6ce4f84de48135bf566cc7e8daa8961ddcc448c7861a03575194cc01f7a4979a06c595404f5f6e68666932178b5098301a1f537ac5e7e36a05a83e43c6920b2571694a3510a0bf6ccd823adbe4858144a98f3ebed385ed04ef4837c070398902c2a9c3d5691533b43b5851362b9e2f6e39c0168019030cd61f9baa9705d5d934bb585936c6d3f06abc7014532db91ebdd2ab74300ae34c65536de205bbd02018ea05df5d7488dacd855d5e7b350ee1c6c246af5597fe8f2cfa2782f38a465bc8190ed0aff22286360a02bb3e17b7467db4307bddec50da99c10b49fa1d62999f54b50ec467f31dcd8262e1c61d37bb7717dab1a8d4c9424ceca2b89074d999431843c79f7e578cdf29f83ba3242484f22fe0a3c917cfe729f897789ef502740a060dfdf1f1a53c48be0ca6013a554bee18e5a8579a3e3cbd555a523acf3b5d39038de29c596c232bf5d2601e88a07e523255037a0af04fc476a56df93bb5f78b379ce9422a5fc0ed910298c1261a12e7b0d6b4767603beabdd044dfd6bc8664385984ec09978082dcba9eb2ccd5d30a4c85de1d5ae4eaffee07db45dd61299705271f7934b5f7285b3db43430ee16ace6e1b4181811d6b1ccc172ad9007a54e8b22688bf3b712b77461a9d3fa6a049172b6778da075590abae44cca1b3b6f0f78c6f84de14311825dd5af9a060dcbecdcd0a545354dcc80f5475290dea725b7794746190f03857bddf22ddce3a379d2acab2b5a6ad0883277ab6f9ce7367b7a0c18b7c7c574ff91f180d633b33dee410a9d4652ea9459aa1ecfd416832c9547d5069666d20a2bccce2958e4c91e012b8198d1744c75cc416eb46a45606f0d652773f32f7c3d899ba95707231be750c9cbdb27ce935d0cc0e6281cfb61b66e38611b6c6f20034b16299347b3c6f74b3833e07b9f058c4cd4aa8cfd8b615d1f5e4bee7706beacd10ae1e5265f832f1da895a98a5e92e13707b495fe267d0a48864032b5541e7ec02781043acdac25f5faf286739b8b4b396a2555c9f19776ce00aafa31b2cee016db66a9218bdf740adfcf00d430b073bf10be04b6778cc6a559d30738e89374d422e523aff9bc3af84b1d37c9a6da714a5f488f21ad7554436a3dfc6a343fab8e77522995c228234bf79109ed2486c11c13137eb68e159a135f6f409966529d42faa256d549a51e018da6bdf6b5f5619148619ed08eea8179f09b2db8aa25350a20b0093a922a9c019c0733ccadea9775fb8aff2e6db6f7582f51cd66a4875cc0ee67a2cb2f4c22548736e1f3521b6aebbafd142311c32393b030530557e6000e86e1faf1a55409be773367647b3c03c68b07776449b180b89072504ad9a7eedf869bd76be9e804d5f7d54a589c2cea2b00f16d0439ffa30fda31dac4c97eb0b4cd37ff8b383c9fa44a68dce2c16c0d49e3295a9a84fb3b2fb0305a47e16992c959e161903b5d88f94382fa625dcc85abd813e13db27f178c6eef989fcca5e3972f4b7aa9d8c7d3a431c65adc74666cc9ef098eab91b2c29990044a224503570bba29b446fba510480a09e0c7e5c526ca4a7a9f378d81f0825a06aa7566d4cbc5daef3ff4594da4a876f825b3fc69181193b01b03d052143b293f4b59a0cf0827a71b46aa89e2df78c802e39b78da3917c87edb98732af57c6c7d9a2549ab762e19d02eb0896cef262523419fae066a1f9e0ddd06b269dc294c27b1225df4946a753bca7c84e1ce6940e211261726fee69a8696251d7f44423fad7900326ded830884a63fd95608b5fde43cc00ec494328d218a9a4b04c47ac0b10cbda5b7448b6c69d10e3c958e6d6421f4b2a3b4d739e2b7a54c325e2e628a3df60b79b5ef556b74c4fc72ac63bc504aa1ac3311d837b217c0468932f6272dee2091a0a83ed9148bb0172dee55523fe1057debbae4d913243e64951999b1cb78c7e59b70a6e24c66336b431000b3cee745660d7127bbade19e6ef6da64fcc58b0e8298f87a551e9b27f6da90dad572e05fba2af2e9161479d6082479e4941d2f1671e41848a4855346362db0c3152cd07eceac00da5784efd93be290214c03d2722c3520ab6a8e87210934053aecf6a412cdb3f9104ad1d30ec370d5e9eb41b7b086704adeb2ebfb03ff37aa741b0458e082da778e840902fe525bc73ceb270507318098f90b044158f4e18b5a11d1d47797f993e7affa91addb9496acb4c6cc89ac54628dea698169d4b1a74fccaea2b1e504f8f5b3ab29f03eca68541a67ca3b72a1922bf01ef96f2829698f456a56b9704c99168fb961d546c671afef63a0e6e8ed1850b1eec65fca54c3b1b1875688d8aed7b4cdf5d1a8914668c176cd834c84648f24ddca415f7a1b5a7d5279aace5ba7f92eb2a3ffbe8634170ece2d36781c00d4ecba3ce9152668fea307e0fa52a6a00bbd902a82cc5abe40c7872409d44d6086394e57c6509be7544a2d19eab329a69da9643515deb60134a8350581e6669c4f8923b65c69b0358aa9493960f76f08d65599293a8386c215c89eafe11cc2e6f374486319b6caaee29d7ddad2c761de42ef13db37c06132adbc8016b0e6484e96ca2e01339b2ca943063b6b5e4b529e6c32262c6bf44937136b787fc255aa079afc685dd7d36749b3bec3dd8369fb24dafc306dcc5d1df1f7f8b97013ddb9dd5ebce395b834de4ba3b166043024a20cdc24b5fe74fdaba0a61e4d203c577657755dd11a62ae271f34c6c1d0d1daf07e2518431e6cf49ebc8d8b555866f3e0f06f84bf1ba95682ab0c3cf0174ab9228bf9a21159026f98c6564f5cd11f7da1a1ef8653369f0491ab6c1e472f5bd972394684ce3e5b2fa229c7f392e448f2b07a290e75a18d05c895d870ba7c8466c880b2cee5a0b0f1dbc6b5ba20205ef5b072a580804615d97cf3e9bfc91c7d3fb8c9baf9900d2c4f6fc59ce6e574d91856665c27444cbed4b9f883430e88005568cdcb57cf0085333c028c93f897c4937a61595e13c9aeebd4d837d497b53e3a7a0058351ed631d51b6cf24b77258c268ca2f7d308e0b7185275480a90372c68b5b2dc3664bf5031c7ac90fd61faf12fc7901d3e6ab751c03525e9de23c350cc80bfa9d8e1c3d099e3153aeffeeec4717b05dc605e67ab521b65eca3e5997efdf8688a30f72f0c8f7653a9c10efd609ce58b5c97ba2a9ce7cbf89d83a63321abe77b4735aec041c03e0f1060f0ea13dc0a377869bf679d5806c5902c5a55b424815737f965b844ae4da10f583ba78aa6e50eb1f21cecd4532b37a96aae84c8f02354f2502193f073fc8dacd6934741444ccd4089cd87a4a27af9b8a8f2ce58e6b86512a7c220efb02ede34545d03d5a29df6b93588a8dabe9dff82175c4ba86f344347591bc16fb1b09d6312e75e7d8ea5c8c715b83dcbb62317f6d322a3055caa6b4637bd67fab1103b3a9c6efa70a5fcb22e9f36284267ae2b3a0fda9f25096f71b925dc92e2914cfc2e5ce722cbd940d375fed67af4d9a361f12c6e677341cb92da5f564e9556dda0e1e1a68fdb7c42042536994c5eafe883904bf3e08943dd18412722e40291039e90e7b2614d7fb43dc3a090106b099d4549de3a90c27abf73e19d75a9899cdf54b651eb72bbe36cac69cee2496369d6bfb4a09971ba6deff5bdbe8e158253452bf9d20732585a111381f254a0c9285d7d8cb683cc5f20d7fb4254c08f2f274e0ee06ca0cea1daa5fe5bf9fa9ad6d5dbb7ab5526f6777486d6b024b417f610b642550a9204b0355801b131ccb7d9cc9ddbf0b4deec9cbf520cd512e99474ca3e2f39ff2587d05fa6bd2c4aea13c1b187d6882340b95594bd54a17f22520dbf8dca53dfc618592a8ab34e965bc2ea0fe93c8cfe219807ce39d5dd764ae87e35b4a3f19d08d1f951998bdf4da8f048105c891eff5e1934669184ac97c30fba64a309bd71d28a96bbb630a3ea41637d4dbeb5dd15ee25660bd11ee8aeafb936d00a6e10cbead8c5ee0f132f2aa40609157915b137a449f3593766ddff4b32435a5d44ec8ec3fad49fa78df0573680c22e99f6f0ad55e364680098a915ae74592405e1833813ea0a71c3b812317de04606ef7e87dd517beb9b45dade828fc7a9da49cda64201c341a02f1b0c625dbee992a4c68f79cf9c33a906d631923cc6b96455fd7260dcf2a358b13fbe2afa126a43ea3831a8b82b0321fa5bb6f245de27a6b42e216ec97148074ad82d45dad52fe3ecc27dbb5d9392becbccb47ec9a7bf90f1c4eb4e14002d0605d7a396f719f9c405136ccc3d05c84591c53e220cca1c621d38aae131dec6d0d46a3016379a7f5459bf32c32821f3e8e5d8e94f17925e81e64cbbfe72cb309849a33fa486081db9ed405af3e11037053805933171984cc658a7a1783651f88859d96ac030d999437ac5fb2af7faeee0f1aad8fb9f715b4e85b3c952d52e6ee9527b6677fa865d3509a8af901dcd431138201dfe720d82fac82c0c059daf83b2258b33065bd5a9f962dd2d89dcd5fcc28d41d7f93dcb5e68435cbbbfbb053aec7f0ed14a75b302534224837f133d8597923794833bf4f9b07c82f577a29d4b290679c231c4a9b3c1aef4853f221d52745e450af50c884a83ada14849ec865c0ce518d25441e7c210a13b740cd820a87592ad203d1daf6917bf5b51155fc176cb6940eed4a9ff6c96c0254802bcc71126f82f051b21f147738f79149bbc9ff4d99d465001c0a8249219292f655d1f6efad84a3d7ae02e28850d8f387789ccc21a6b7e5d5c79c241f9b43f8f4f50fce8ffc01d8ac2c29187fb124d655c6aede1a05eadebf2d7bd6832497afc40b776a68a6da5853dfdf7a4f8ee6ac9e0618c5e0d70b777df6887a9be975431af5eaaad293656aadec1d5a12e9b442bc7e32fe5e372f3dfbfde79ec15270f67b0c233cccd5462fea67f8b0e48f0d61fb502c1d23ca79e21628918fb02bd75864e13a2cf61ea4616460695a225a2e0357789fdcc5478c3eee699e01847a3a72650766cc8a68bd1e3272c17db260aaa4e6bbe30cee0736584550cab6efba0d486f8b30313b1cda5d693dd210e7c625ecc921d34487697950fd2b5b7a9b1d84ccf55203677a9f73b00ffe5f72b1c51c436c99c5784c094678775f94099ca643f51cbcf358b028e4054e829453fdec17b4a39d10504db743bde9c28d92e191e5d49b1ada3e623437d8a895b80a2ad966414f787046f4aa80e2cb36b57af05c61765b95e2f6b9a985fdcc3acd14a1b422770f4156a75b7e535eb0a7f0badbb6e826b4d5bc90f535356ffc5faeb527f4e2849e4b77064ab13941dea01a565bc822e166a39b5ecdab3fa26d46d4c38f7ad780e98f153eb385d5015eddab24f55585dd3c60a02f47fa030b23d410330ea52a372130d88bfeb5a5030d6bb2fbc15a9d2e5ba859dd4f6b5d32cf70899e701bc8db6d82df149171a0f0e3b3fbde0027b0706efb897b5d5f67d816a18f3dc637a939704333d911a0211ce7397f921d8c523c01c26c81b75095b169921939305b6b311946a0ee105c503aa214372e888ab9d88cf52a93239851c1c0301f40673fc2d3de9972b91b82d3d1c6a4a22378da9470623c457a7a405bf8e9e4db2b9d4b75fe81e358159fc8ad875426124a82168d28b378108fe29d7af38f01d8e0446ccf77faa3f3a0bdb08e5e3f1d9329579d821e2e13ca085f6d3c32f1e0fbb75859fe22d54bb9c3231b7a59e971a1c694e3aa31b2717bfb2346946a2e3472039dc5aae0c6be8ae5c31e0eccd3d3b5ab485d5b1980388fc72deff5d0b0eb9ae95b23ddf8aa373a0e2d5d7511c94608c5344daa38e9a871d64df911b478d8e971e4040952b8b0e3fea3bdf7b246b5b6cec206c032855deb285db8f2c88b806b772366454cdb5e3c6ada741c4a15a8f25366a33d2e174fca69fed267d0d341219c66bdf93277f971e86421f781f7864f622520b50c456e6f8d50651db1afeb4ae18e7256a54306a7b603c981c5a4001a3f9ce8857d0bf1a4e8755e826b7b593e7676e08139904ff4d12689513839161a942308bc964293e7e6d17ff1c76542720f0e42829c979cc67875f38e424d842aed817928388a16f981738f7b181411819647f42928e1fe2353d858d722f755b9263780813385eddc60aff3c01bea9251c82d86c6088814d1257009f0f3d3fb0ada4a9b5028b81f48b6ab76dd3c30a143130804434e32a1086afd74bc6b2fbb88a15ba05e395aeb9d343cac44b4d731c6be384334e1951ea4e8082d8644ec30d0f9d9113292524d9e9c25b3141d4be1c74d178905f4e912b766b838a7a038ec10bcfcc4b99c5a32853042ce6d095a9722def51242636d7918fbbb60bedf043c0affb6fa3aed2d49ec5592513521dce9e5480ecf2e341dd2bd1349a79e6cba50f9751e18555eca0d051bb8ddf7941e05b0a50beb8361cd185da6d38c1db11eca352f8bfb426a8546a34dca226147b58a424387918a95a1d55f564e5b0a0a464c60918fc934eb44e7427db1fa1104bc179e1d4d66f4973dcc2acd8846dd5466cfbd67336c2ef47f09b8657d3bf52877e7c1241af36e935269be2f664a7b6aab1bb20669d90c760977e22d2ad0f9762186a8bd377ddf653f34ed2c3d58c51264fbe366ebb4036785311f24e2fbf1eb2c64a329969151f57d0d7ccb6c7d71279b7f307d58c5cf6d38f9237757c4351a03d687743adb637a8e1909df710526b41faf1d4e84b3a4fca072b91ad155a6fc4b95a067782d61efdbf965b5c3b2ca4351f40f5f93fb8146544406f3c7b422417cf1061eaea2daf334726f03725fa943231a3862318fa58cfaa83f18ee02523a9968a20d46f11e97f99a26cfc00b9003b7c44b28d505328f6c9a6bec64c473ddf6cedc7d51828b7667ba787bfdb5bcc46ba84f67b4d412f684a3d4a8876a020f16457e24cffb13a22c7dbc525c73e8e23cd49c4b9bbd2e45aed3789efda3565536e038fb2b59b1ed5bfab255d4e688b09f1ae2f87a2cec116439839e3b10d54af79af346a0f0046621022221332e56b37d651e2c3223c9aacf16dfb70eabc9145ee68704597ad286a3b0453ebd4acbf4226a0ec1f6e41dd45d5e10639312741695c14d3925d13e3d295a721036a986ec657055c2ba3b4b3a5f911606cc9f31107832a107efe15c91b5e89630ca57decac5a6e479d90d1038f55b70eea68133121734106c619c297767554aff8e7a21bc6dbdb20c1d6cb5b84643cad6f98e1ee362d4aa5111f07b7ab902e36cdcda195f22e43152fe97cf1b135620f5a01adaae2b89b38bc907d38c55c05a9f8c5229036e36c73d73e93dab06ccb8430a1d75dd627b91e3ea718a4af4b7a95d8d4c1189a8b3f4894a5f046228da9262f6a3bdb704416f018fdb428a9542cd60314d27f8640c15dc17b533741be0c123c6787e71272f108b29f3f1dd6604854bdb3aba378bd48ba43e7f842b9800947fb098f6a4fff24b0c260683c8aeae60face088632199c38f81feaea4aaf52cc4841e892330e294e898211a5ccecdc1a6e5de77ee4c7ecc99645687639d531f22c326e87fd7656ea7733d29e5d7db92dcfdd3e89c22465869f7b70d169289e1ce556e7a9e97c063f49843a8a93c73da6b5dc1241f9c0d61919966b00c2c0cdad2b9fbe620cd87fa692435e6c921951a0cea415f0ca23c2e1372333a751c59d98c23fd5559abf5c2d0373fdc61912b5ce503ccd0691b10a793dfd68c21d8af122683218ff814170726fd845e84ca370b496d9feedd65efb160444bd714d411599e374043b883714b77386e2e06eac8ae22eb4c7c7bce2edf2a9294b3e02d7ca20b82a025dca504cc3d7a928a7986df34fdffd9602bb86c1ab32760a6fcee9f4934a715f73c9f40b0ce79506fea9410d1e895777f8db85c92c17e6ae7a282e61331a2c4b7f6e47add1a80d9e98a07aa8bd80e45284cedf48087938e74fe46396a214acb07f6b49dca0417fdc5e361c675cea7f4c70de098175c5665b858134427584c62d359e9ff5bfc5cf31240e64ab8f9620f2a9f4ee82fba08acbfafd5bbcdefd9aaf9f82040a7f360ede0fafc85fea2f7ef33227ea81c4b0657da35a2028e6a01d5be95a013e65d6e9b7fbac5599199054220ce423e212cc09d09a76283cc614714a7b13e4b464a45867c9fc0d2e235deb509b0c072aadab67af4851fc42bac09c99348115336287cbdd7530a60935da4af7f5cb88cfa327497c6593696d08b66639d77d0c9ebe820fbeb256eb2ccb5d63652d5655ee68c8c2593a34831e74885c232ad201e200cc523994b592796e131f00b675a11339a4ba37930c49cad5913253a0e13af1a00e8b64d83d123bd03ad0aca032c2602999c8975281deeb163803b4f5770ebc96df8f7f1d7fabd8075132971e632e9ad4843e2f549802518ef7ef2f33d621e012dcf6289dd51a0ba474d7d380128c71a3116f09e4df5b101e9b95ce356c2c4944cf65bfc6c5aa1ecfa020b560e59e01ce241366fca28446305d88f7f7f85112b22e16916fd7700554f3bf9845bf8a01aac76f7b56332ac79cc55456f9cd7a5b0c44d295de491a4f5c8d4e486f08d1921e609d50418822921779c15e6d1568da5f13cd1083aac9fcb298795858273b2b4919fa2be2b36b865e742e8f548d07ffc38b8d16811c71249ece978f8d70d48da0be083f976852ffdfc1b912a2f180df421a5393e8bcf4c26c94deb49033d81fcd0039ed9ba9509b37bb5b6dfec5c0c404c89b4eab024a88562adb85256fcb7b53de2acdbed39deaf33234de19961753aecd5b494c4ebf0641ac4ea1e41014fcf7adb9385b54903821866d2e269c826d659653d71f44293d9d03e8cae65fd582e3a1a64cd343cf42e970c9a0b4b8f5406adc240981e08d896ab9100f9c19430ab5b082b8c66a5ae4adc9efeaeb300dfe47af72114dd8696432f2ecd5fa5936ddb9e0831728f78caf2d1c2cb5e7307903fcc0ac6315a2083c6af2fc8a9ffafeca95256da8d7423d255f8dbe232c4498510db089e3c9f95624fb0b8cf67d73f13519c9c347ec3e69126d3e2507e4593fa61fc783dddfe46cf1f6134c582b5ea598d76ce45021b489c6d8de35a71d09f3d82753cbd1ef0f556bf9d4d5c5d3740d354dad666b668d1b8f46e99095e3d75e9654a3979217a217df8fe42d1516378fb2023b57a9e90b58f866a12d7b4fa9041021434fb8191826f298e72a3082a5822901f3c2639869b0ae97eb6b388a5507295f716357d11a12b7f3a61cbe994f262116e6c728286ca4eb834b3105c4b789f3b3bb47148c9a8d528d0191166af74bc313e0d64d7479f068146d3be5e8072c06ad6824cf1bb91e45248cb8c05ca4467a58b8c5e37816af5db279035a98c8d462a56b754f3fd497c8a419cdc661374c6209cbb5a605915d4ef54a777cb46aeda2bb7325c4a447080e45c46cb568539c19a773dabbdb2ad68db1e195459a5680e94c7c8818efb5955e6f9fab4eb350249edd80fdce3400d7735b67bc309ca2841258b4ba0b2f23717ddd648d4151f3c79030764f3bca0913b7090f7112ddbf774775168266cbf11334d508738b8c228ac7c06f6de6ef898018a55439d9add8a9936bec48b50326af301ec641c21ab0813b77c06ac55817a1738bb7543a3bc909637359c1df88c693bc3a207cb0cd5f9817b9183b3a1b949b513fd2a3c7f23906bc54c188a40a46e67bf39ca2701f48a922888ca1cf87d8c7657a2b8b1c4813146711c33a928fa9f2e6bfb63a30cae23e76a9b035ce13c35507794756bb99cdb9bd15120272c77b9dc27c5b8198f1a2441aa22199da18afb952f2048df97df12ea207f172f7063fb6487e364c13c50fe6ff73988ea40cf1c31a0010bedc6511c05147e947e73a5fe32de45af5ccc4e76a3e3f075d230e9b08829b33b90740a9ef58357ab51c7e6fc8886001a4c0077e1f4c70ff942ebf914d8fe2c9f56be1b74bf3a1273de4489d32a05211e19968cf7afa58fca1344dd93f0e04a7b6e0be08f1eeaea7c4ec060d7cf4a97fd8ac0fbf8c44203e908b89c3de04be5c6177fc6a8c7419ae606379ca849c835fe8b19910ba1f4b06a20bcf0c16f06b98b11addede9099c2a538bb7aaac21740086d81ef101a17b52a6f24d50de5e831b08398ffaa8067a4dad3ebd1351689a3360fe2ffaeab7003df7bb33d198686a35b1f180e1bebb656d993193c35693a884ecfdf9e31ba2027190a9c7f32afae9e219ec1133f4c18d0dfa914df1be0c5f70d4fe910ed472cf87680a2b2fd701037b2a3783e58de13ceb0662050cffd6be21f827f4859c9e3b90b1464014f4052c5ee9f7a902890e34c755875715bea4d62297fdf32b9fe03598511543bef0d1ea98827905c675595e13d3a75e5d4c33c1e793f8b779cbef7bf33f90f8dd8f5c47dec2488ba07e20e80d80ddda233a847c9b3b3f3ed49d1284148a5ed28c9e95d1b7fe64cc4464ea7997461200a430017d99f5d24b0f863c6eedc27646f32fc8c44816c86438346d591a7ae7ce6aeb75350c4ba838cca8f0c4decb5b1893e3a0b9a84e3db14d77f0324062df3ded81976c1e27b6b75aa5f98e031bbd37b7c44a97977a31195f73969c90cb825b771dd89b236438ecb1ea58c4c4a317fea60b62edd0a5b3b9d1c286be31a44fd4a7938927e52b222b971c554352f2d1ba33052b90e63d3740a966e54b24c4132b244cd24b2323eaacd209ced61c4bf53c3d293e503c8f9d9b8e670049a9791a19f0ee5667f818cd7895541881d0cc70adcccbc90798f40e1df2703b28a5a166a8115fccc93a8b5562e2eb907be1efca4604fc326d86f177f18ef5818ee93609397dc09033f53413fd19cd77612e062e9ad70a21986b945213fe1cea9f03e1ff4bf9577e1d687316ac9219bacdc5ab0a399a20d62e45e6909b2b3ef3fee886ca317faa27ceb970c0d7a7631843cee5936dcee01b22901fc961fd4e38e47f8e002ca226e1ac5065c8e94a3949746816e1b0a9e3bf09fe58588ecf91b70b4675529671198d2b33dd9188d05dec5f6252e33c2ae73de2d5e81c7f4ff7ed6f046a56d7abb3784a18b370166033c88881936790e41311c920d3958b238bfe09ecf29f53f2c6fffabda535cfca67f687b86bb700a762c2025f7b37cbb486ab2165317819450e1859bff9dc2c0a893c0a8ff921b8792e91db7c10c98c89b32b83ef18746bd1808739198ba937c2b9c8cee3b35c96b1d368beab6b88e13b1f5f935b82996249a5d89bf5499f907f609166201b309689af8d72270e9a1cefea85b6cbad2a5f7779cc3e720c038d8888f9cd869d89f24fec85e6de04b5e5ebc54ff06f18d884c36bdee3c672b7918fb27eed48eb51e14e30f93ce1e265980c39f101cfe393c2f12ce752f801426a8b9449493fc443e269858d22dcf8d0a8f7391a3ab42d5a6b33e4d91c377fa390e1c6ffba3dbb64d7c03ec7b83d5ea49e6dc43cbaaa4dd4f1a1a11a762db7a5957df8310f1ae7d81f9c8444f62e95e2cbcdaff50120b5ebe538ab2b510f44f3a01140275a06148ba50ff45f5ec0bd3cb585da608b4db5be219b6230ec5e3f7b804003cc651a6615b68af0055f51d447e2e0508bee1c1748bb1bbb728739564dbeb4c7193d0a90eee19eb4a39e086201bf10484fea06ce7832c779247f3acb9c1e45628de5aaea13e5b618c076ba1bdfee3e85fae863320b679fdd51389257fee7cb9ee0c54593a5d8471e6a6eeb672dcee62e1ba1f93d6f26d7df1823ce8eee760f760d88737c83e0213bd090f465880239c6348f75ecfed2e505c01fb91e0a0aa15d7aee1c88e15f25d3e28c1d9d6addb5c0e8eecb753c1180f305c4e718dc603ed768b1e5d7ff046cb42635a16a44f86761d1aa70a46bee341a90310a797ff386e6bc7931b827666ad8ea775a8e8b1de48db1d7d5c402b5bd2526e5693567dc4de60f42ae1f109679b347922aef2d0e5f950d9c075f6546b28f8292bb4efdac6e1464fd485eec22207a037b8baee57bd4443f36ba92bc3439c89f2b5e26b066149ae44527fa75ea36cbfa2ddec42415848ef929f765f100c77be960ae2cbb6530d4f6b080b5bfbe43a3821ea8fe41ee3fe4e3cb6112ca906d52f8c574a9763a39b091afbb6352cd40c2a2d07255c5a631fc6ab9a8a061a40a464ae8cbc33114cd3d8000da2fc212ecbe514db67ebd23a8aafc3f05c77296f71b4dbbecde4ba8b3fadd4fdfda64f3ed2eefc9f14d24c07533a33d0d1c4c447f2b1287a27c2d2df5b1b2f2de520f0b8a50fd168030a34c9f41fbdeff3d2f1edc044154bcd71f852868048bab433b287e4b485dacf81427d9a335d296fb4e98c0e70b3d6b19134e3186b39616230444e48991b923657fa86c418213a3ace9cfc0c0eee685fad7e6ee2275c8bf3b6be5cabd988ea7dabe578a5051f7e8c9babda6ab34567f5c2d512984abc6922b4d7fe2f2dc7b09b6818dd35e320fa29fb36f93860ac5197d5a4893da062f49353b53cd8703550da59a8660d97d3bc8863124a5f0ea564e782f6f7f7b4a2a84891c0a99d07807def00df5708d43f1cade5850182dbf7583619cbac43c4c55d0c811fdea9b7fb59ac5d929720cfadfcc41b787e5c9bea4212cd7656ba01705c199ee31865cce9dbd47286b08381a04b7da223cc8bc64e09337f6018b9411febfa0ac8ff6ea4ce9cbab37ccb3f947072bc6f39bc95f6862b4f670167db07c2520f3ea4c4178932925ce4c4ada729be2ba50d5e7af5ab7e72c65f6a1dea583918f6829df9b9c1566b29195e4f42a912b43d6bd9170252b9ab558431030a84a96c7678a046367a24a89fad8db03936a28dd1686caeb6a6e030623616d294a2de34dac67ec2c26e606e47d1c7f65507e5210b75b5a6143255f63534cc81ed0d3290717e6bf05ff1932d2febb28558093735b48601c4bf85aa1d6e85cbecd32d15f0d7b513e04332284fb9cca593fb72fd4d59ad9f526546d629602e7ece79f7b732bf2f7391450fc18839b7d25c45a8370a82b6ca134f1b152cd5e578e00768385bbb62a69907d13eb76398e2bf3036f0f81e883ba969f37515bcc1eaf63f8a117cbb8fb84860390a4c812200771ff24bfcde194209ce9d6d4d7d98b0e56dc9a507c0532651df43990cf3bb8f7a444f6f851684a80f53dd98d8bfc87b869371ac5a06e4a528c93acfc8bb0af829e3dceeae1643c8cf6819c24518ed62c00e4a683e168580f28a1cf45733b688a958875287036b1bba17f8fbf6c6462f510c230b2448c8ae58e2b78d942b883620433f209205df61a30382e864c647dbb7c17420de5401bde2e2a38583a956fd12f758e914de73b79fdfe533e349da957f0f32f619e143c0bde5b58383385e51a4fef8c02f8efc4f742694991261bc56921be57436d6e8170e8afd3d70bce3babe294fde8eda4de6ea9c7e5ab61d9c3fab325ceefe935eda5ebdc0767f61955fc78139ddefae3c9e978fe6829533382aadbc9f689dc95e0fe8b827afc88e12e3013e0dca42cf8d7cc52472619637f22d7235a13dd65779bd8771ccc17099e7e36d3709a77f0605f5bbd47c724de20811c378359c4d82e36d1305ef5561dfca6b9ed8e674af3f86a164d8dd413669cbb84f058e8174f732baab42989c917742aecbe01e6a89f3e0fdb16aa20dc1ea319ac86f4a93ea94d3bb79126aacdff66cf66b9754cfa0f3e413e5acbd3a00e1448e20871b3cd9f8ef8595e5b76dc194e33573dffcc690a1d42de1e0b0a8ebf7e51929728ce694df229f2a915819643d7d3124fdf29a213df3f74106f3c72e09d1c12ef854dd99063c42e9f880691136e3dd5bb8641d3a82ff15ec31b875274c47c39c5f5c88cf128d5a65488d2506886352ef1e6ec6f07e7209431eb012b49ec89d0d162ce04f0cdb0225ba21846f619edfbf98873cc420690502f684db3b91d814b6338e3eaf6d92db06b44f38e7234c909c48a5b996b7893a3cfa4c8c415c189219a8ef6bb936e8ca5a3d02692b9cf9d218ab301e424363977a354ff36d37e164991d4e3a0ce1f1860ea2b7321baf26c018052b219c98482c2b0700eb93749a36af7e521ad448d846c82172d3fe3f1df56b610401ec049ede1681292664adcceb3c7ea76a3a23369c4e07cb426cd502d999d19c8c48d76a0e332f242276c7ada947d2c3a1c97040267bcd9a6a6e972dbe152e74e4dddc3ec81f2897dcac80da6c6e2862456c558812c15b761151f48b25131383b8683891b58daf0a9b795aaa44a362540007b1ac9b9d0765e045eb2b30ea60f0fcf8368dc486cc789342a83c78644f1ba4a6f31731f9dcb4f780b4a823655607564b157427f143b8472286119fa145a1ab368c8a578d1728dfa33bacfda3daba4e2834c69efd7e43d8c89c00bbc44e7198906046ce6d634afb50a819098e7f4c135c49f08f4ecdc44f3fb22a801691d8fa6f827dbbc1859c7ccd8d563ffd543e8c6fdf8dab6a8cf443029d91c7d1bf77ce72365ca0b64d6b63d503b496a70d2f0703b1562e70130838a00703da461aab6ff10a0152e86817ca697eed3e25d2c0198065b02a9afa1f19bde85900b79beb7627094f19ed9af2542227a1ec6dd7a002a36ee78ff23a752909797a47ce5eece38479e8694df5f66f91695a03b2995cc7c87911b78896bbbfbb2088a1ed8790e9a6b10ba27d1490ce7d275699c9b23955032323d50aafe485c69ad028a1f2b25461da0110df42813c48e210b3beca2f25edcc80fb183d1d8f169e7bc2316372378416303c1a0476eda2dab96c7e8c8617f29c06820a4b551d5780244508a5f96b8c23d69e524d66f76fecbbd807063938ab5dac82b4747872f02d5b3b9d1d3aeba96f2dd34537cf4c4c596ba5cc6ef9d33f7a82c23acb93a5a88dd9e28e310fe4fae7c0e058de15ffa0ddae874520e6acd7b38f017847907720e7135e5549e8fd34a2152721ad4c366bcb7594affc40d3053f7648518e70e08474340e2c1aa8bfd592daf5834d13516aca2fe4d433e33edfcd03b870e4482043be246cb16aa5a31c36f6bf4c7b44ca143eecc03fc9eb5cd1b7af718f223d9ebf6d725463c5e6c7e9df3521809aa9209916e7b1f8389a77d2f6595ec9fa62b1f546e69bb7f708d87492c359cafc4dc324cfe39a7c92fe59049d6e2020e951e51d22c7a3376ccade44b58423bc4815621b059d936a2e40987b41c75d1e6c5cc23b39ddc4f846c28cfd11994b36d3153647e04198fbb26b840d7dd04315ee5c8a1d49f7498a29ed5cdce7d571e355b145f7a0a997f275ef2db6ae01e9f5eebb006c71d638cf1bb6407704ecc9d2d169369de0eea2a780b2749314804bf6637cfeb425b646122f83a7b6ab3bd6fb7dd880ced913228138aa010bdec6d05a294d24ced55b101e055e79bf2d3f13e5557f724186905796d696bb2fc58608501ddad0d21371594892c30f365253c730251c0be798e8b033ed87921240fe6cd20a83b56b68b6d70b51f898c53d33ee03c31b05b348855b0d2b415b321fb9e1f96963de18b0669828abeb29d75f92557e3b1ffaf9eef98b9468855e63beae8c2261c84c831588d2b941e045240ad73dc0b7a1d0e735f570caf4811007679f1ee992a67ed217e96ba3b40ca59817261bd09bbb239b28438ef6772bea9c4302fc9eef3f2284f596572a241a19955897c87cc2fca33bc319efafd73d901871d72cc7da37e0aaab2031e783623b0862f1d158fc9506a2fac1743afbf54af1d40513eb7c0c9542ca90c0edd321df0e71846639258766ea93c6670acbfbcd6056038fec8dfa8214323eb5e9474b7d581bd30a4a4a36677cdd738ec71f75ce576707a3b00567a959889c6742c07648afc0e695e5633bd525ba193ebd49819cbdebb4510ac10f0091d83cf5304562889390c51f734d204fa4345636d9f3ad120b73cedf81e3edc7cd3c08f2a58c0f731faf557c09ddc9bf5257a33e57d565852b666b7b2d6f69bf4701301c9a19c8cb87013e67490d4dfad03c80b22ce964eb353a54228c424807ef3b83f7a175b9f112b27b45f441d7e86dca5cfacd960eae915d6c3001c54206f23af94acd5fdb237a099014e6a7430824cee9f752a041a52b71a07743f55da5b3fdb318754211a17ada183de6233e2e72e224541bdc343b84b68fa744f738ff981516938b2b20164c7702e68cb0577789bc0aa3eba32bbdb8a033c710813f4271f8a324afa5778c0678760e488e56d5ba3a36fc8e8338c018fb50c6114ad14434efae368f892e05c6f95eac165628b2fd2bbce754f72b063481eae8a61fc14d761900079fa454e3564fb15760621bea9f51e39c8e70d778fdfeef66cd3e49898f2318841856b0301dbe57536581dd3290053fc7c57346218399d1b94a72ee9bfa4be16a9616ce32e8a6e311c8b164f554873a3565897f54b5fe6203c3b7082ebd912e07ace4ff0baf31c1b12bb826e73888aeb5992993e20b2ff46bffbb874cb2f9b08339e9a2a051fdfbe1ece5c2955515123ed0d254e5596d551f13d81efc1c5d129e4901f0677a7a9c6ea4186131ceadaea20fc45ba08d59d340c12d0f09ad81142ddbecb0067fc8d183b32271427fbf4d8e80ca639919dc5494a249eb616efe140e32f572b7230e3825e4082b8e78a04c9bdcb73452dd6a0a6bf4b2146a9a817aac2230c879ec09273102441d5386d3cbdf56925a7b7582c7fd0d1962763e760796602aa95bb8b48ef0765945997390b0ca86dc07b9fea69bd50b490c544e0714eda76f25d2791b2791224c585769849f8fe3b16cccfda4759bbed289ef4391cbae70576acac6768783269802e7fe5b3e03e7e0f8bf6ef8a4ed3139ead442e62de560ef030352bb467da48191041245e40f03abbe5abb00483de7b7a6090b1b75b533cb0d7fe1e325ab3bc219f33c843863fc8c6399e59743196591046aa3e73b706f7044dfd6d318c86a0d5c8637533dd5573f3c076919121445b753e1daf95bab9dcc87687fb2ed9457d6d62129cf0044894b5840ea261ba706543f6a12a7699042b7f0236ecdfb61da8511fa035cc7bcf9d0d299ddee2f6bfc7687f3ea2dff15e45ecd49cecbd893db9c30af816d28f25a8a66fa5f0839d1584d0b29ec212d30dcc577503812473e51c15fc03b71f2dd7aa10e3b300e9192c845af32665d0cfdc1817b9c509677db092a84fc5c87df170fcc03ee7b1c45f050bdc780323590f8063a912bbc90580765f8a9e5a539f42aa0b4f9cef0979603f1dc07e0112a2741f6d291f1a2120cc3ef48708ac70ebe8cca9f709cd5db6c20faa75029620c787dc4fec81971130b5a3c114cf7bb166b468b3ebb5a5aac001f75c11e52d27b67ae1bc722fd452db6ab0c9b9250bb7cb8e45df66b005789af594ce171619c767bb7c96b1c7af2b69840fc7a42e938105059aeed3bea54a874533184cea4b0ef467309ab20899239f0cd3cd35589cd1c24d5ee01798fb2059638b1f7778d6ff552914f7d25a644f98770ea799e730985c5c479750584bcc9ae57b3f9f6b2cd08ba5580da34e59d52ddd90cd92aebe509f370510dbeb1af74043d8a674c856532d5566b82a369fe877b80a64bb0f49d8e1dc2938ac91dd71c6ca189ed90fbdf13e7687fadc0357bea7fc150c45de6c9aa20dfb0f0b287577c2000bd412bce93488dc662392ddeec833c71cefc324e6d76b188884d21a774c34f4fd330fc7908545eede2957b3d821a83f67c4c927f1a1f90587f475f70b538be44fac7ab738360030d4d6bc134a416b170525ec7955ed61280ff3ed20cc681dcc5ff734d1ef9fbfac357f6be72a17f78cceb08a2c6b86f22458d0db7e70392b35863fff5d6d313bd8a922fa65b823aa3499c03109bcd48f68cf7022ee9726037d4138f9cc8dedd803b8e0e7b4fc9488fec07ecbf9e9e70997fe232650ad653e779b007e2a35e2e77819dc66451dd7540d01a258c1488a7dfdd22c005d5e63764d06dcb34b9fda47fb2884d060236fb54521c0badde804e7eab5943a51e7b244e2f6ceb100774d683fd576c0832ef3f4567f04d513d92c9984faaa2c6f08c2d05b8b9317db17d4d2c5924e247fe0b0c15b61420a37159064e71030ad4cc40b878ae89ac9a09ee5a7ef628032797a5dfee659805a9b954d42e1c7c7ed6ecaa038fc404d7454ff40ac7cc9342074002cc37e9f88815fe40898dc5c4ef7d2ea12947b9e7791d221f2d931e060554a3983db875a067f656ddfeecf6ca932d1a06a1cff6164446fb4bab835307e1b8e8c56837550a74a25b88bfffc5df21a312c8f4dbf3060936a26a8efbf4d3ed0f6a53dce7e077c184b1ea28f92118acdd133ade4c7623f3ee2d32fce1b0fdd685383d559ef95e9f380d10a3ad2947c80d4203760331abf4aeb0656f352f7d22bed4f37ba2cbbef0dd7cecb6fa8221e2c4152d0d701341b2b3ff92fe45a860b4cf6a8433ddac2d9f598530a98c0aa14f36c86a681335721ef99408e15372211284f08f84f33baef75e53dda8116d50994894f5409cd6aa711429a03a7e1797ac47672d095be155cd24e51fdf1c0b5543acefadd20381f922e9833e4c4c080f205bfd3e0bc093ad76155493cb51fe00b55ccf8216ae2164667612a64312551bf735699c76b385c60f6ac8ad3ac94967df410ebf288e4a9d825379f2cc2c74eaa83ff249ac00e6981e88e78d465414e98a9b50cba2426f092bfc884debe3126f9241a04cda2d10df122380ff3f3938266d72591315eae7efbf40e89a8d81cdf6304f6368b0191f4cef4a3093250a9adc9c8c5a2b1f0b0e43ad8d49f5d8ec007386694a49b4d228cf55b9b6e6ce3c4ccaf82849b915594c21a2ee6e801481547638219c2bc5e8f70b16ff5be5f75708800a3a468b3807f07cc9bcf9677a7261382333d25232a86eaf9f83cdcc4b02922432636c13889dd5530350a6f3bf5e08777be0231b4063784b170a5071f32812383a8e1dc8257d729eb554e8def74821c8fd8cb633230b35bcf4de68301c334552fdfca45a7cb0023e1aea4c368a2ded3eca8f30aa2842479b0f053ad07578bed0d0ab614e2c79f466d410cbda428b31986d8eb23a8b7435fe207441a94a1666a7e408f579e0cf91a89751bd1e229b9d64dd71ad5d3f0b77da1f96ca4799b9357d978f95bc5b75ebb1d2596a1f04c93403fcafaf02f283d410e5bc63a3cd02c5838265c972f7f5b67c726075444a9b4cf162cb2db6c490e0ca610c434ded7878db3863898267205f13743790187e28b5dc69836eed819765119c26df16eaed99133ec92ab2e2c3fba8a150c6165ff59a441de77458332cef43b971662853cbdd929322b403e3396bc0468dcd03729de5293c94588b7be3c98b241e472fe667fb721a218c3120b1b6b98206c96b226c83925239900f17a10c487a379d2b8deda2729e92b539297547c0695e19c0a2059bab970afddc89a5af7d6203034a126f814519377248d9cd66b1d160433095e25f3a96c64e4c14fc3cdab3ea069d171b112c8144becaccf24fbb2ed5a966823c48d911ecde561f448ae017747291f6ad15073652584dcf13298e5cb018eb2c0c485978d6c9370ce52456d25a5a0dc93e5fd943475ad2a75b7e1530054a2f4bfb20d2d1be019d090e9f785b0c3ee6f149248cbd73df4c742d87ec4fe2cfe2adf3d218b37b16f7b5693e207b115d0543bafb261830a4d5a6826e4e2514f16860372d40f0b810fd7aa5e1193e526ed14d5fd1fa0257afc3883743e9cd8b4df52c75fb31ecad79d836ec293ae0d0177206bfa5665c9c44223e3177152d01cdfc7fc3d338c0df2930cec71d3743412226e1196973dd65a8e154b6eb0eaacab6026ed9773f9446fcd85c347c5b55f62558bdf4d6bbf01e24352eb1d38779a8d18eecbc0bcb9b5e861f804ce7ad74e6ba66e14233e18976c763ea3a20d1f6ee4f00d883623c15f822fc311b910528b83fa9f6c7000abc05a20aa05143613d8c5243101386d07432aaf54b5ad37ad658267b5bd992e1e4770e32c8926148ee217bbf4ea886c93e8b60b3a9641ed7854101deb1671c5aaf698497e7a3509b97d2b572967532221a075c8a1ba906bef1153430c59a4d411b11d9ecb969bcd93d81ef2ef33a800a926f8575fe3becc3e6fd3cc4a39ebcff352a0f921e180fc76141945e8d97ea883295e12d9bd4eceaa76d2d11f8468d2ff408959bc9d21b94af242e4e4bf8e03c4b39c0925c92fd0c32d14b1eb32e63a415c6d5d048249742dbe9d41386e8fbe6127502d9345cdbb908958ea67a53967059870b4bda3a8f35f288b453f55896207414679e913bbd48ef4b21af14c25bf2ccf470eb0fab4a76b3b05bd15fab6e3b314a95ad6379eb69c2227a3a6b0df093f90f18aabb01a47c6cf2975f3f819a8c0c3a2002008e86c9c1acde0dd91d23a44a740a4216930c1e9fea1ad141894e7ac2040d4cdca9dadba5c06f6be7ed290a5c7146ef70c7b39897808a572f3b6c202715449ddfbb31f6150b6f018a504249cd39bb073b8c6a1eaa60ad442ce9890b3809af3494a730356fd2a2eb9cf4aff8949b5ed690c5ee7d3aceafd6bbc0b871f715db84b84ad53479ed2f8e9ef13a81762c234ce818d9ee2fa6d82e5ffecb5869e89aebae167bc7e2bce49305190542c75244ac8ad10cbafd2432d9fca3acc991d422bf170cdb7bf3c3e697c2a4ab7445646ff78078c49aa2d32386aeb6760063420ec63095f88dfeafa10975e98c404730e128875a9a199ae1516ced0c6cbb086189dd3d37131c055b9bdc7329ef3f83ebf828244963fd6e91928d159f9b74011f6b0e41afbfb41d0500f070fda6226d821c02ea5f6c623cf5bd89d780c7f1e1c99730a0a2eba5d43f3ac6fb715988d0faaafba1a3da35f711ecd8e60ab788bac42c14d633d6ab068f3c507d2ca044addeeee1f6d3400733caf4bf5fea1da81749095f19146d1d80d2d94c0e6b38e37a1674f46a079dfda3d750883b4d6ecaa2d4c5854d78785d96db09ac754635e31d41fb18793f05434bfade0028036adde401bf3f1e48cdcc5fa4057e4928c3fdc537eb1811bbe980c5cf15c0d56873755c4f187340ca9199969a014d185ee5cf7a7b1404279db9f92d63a59d006460288d0008144681031df76a5b097275d2c10ab6a5979872ece689947a8c5542804fb24ae2559ef5771af2a79776834b898db7814d1706d84c089d0019ae2f5978b0a1369a734639a59a452bfac24c37984ab86acef4170523e35e85a77d5886c56991e606a1701ef387dec3921597add1478e6106f0d2c7c9135a718d0d5b2c8e766827cfdd669cc900026799954a3a8a53b4bdf19a0cfbcae18d0ac1f280edee57f1c3380554cacbe9da57e843f0adb7a6bb69ee23cf30d640c175f03d52ee3e174bfa11199b19cb8a0cfa88041cc945b3feb23ba69b6d0fbf5e0522578c4b9101e60b5260a85263a2e10296ff1676a936fc12145231ed5cff171f30ff3c99cefe2527813c4a2438dd57e1beb7d8b7d22c1599e6a4caad27b9edc4ad1e6675d0446d9955bffa912083b299aa18ba5f9530d0cabadad54cd7bcc742846b2c96af8a6e616e20ccbd40e3acd01fa46b765cc60f94e7f3c5d5d795d8a2e7db654f1d88fce38cf7bb458b5cc8f56462fbcf7603f60b1b2152d16802bc72c479600764a4d491de7062fe8e80e867a8b71ea80ca9f67f4ed87164c384693f3c092e781c53a9d25c9ce608661e43bc61f447a0d49c5387829d3b9e5fb9b6fe2d98e4873983c6228d19a34af8180348a9b503970f1a27a21dd64c32345014fc986106e92f5c2c93f9cfcf9987d7615ca2cf711b6083160afe5b1580806b89c3bd0d61edb458add783f11ec1ff81b936fa995c25670ab035fa24ef9ae29db9ad1dbc283a83c2921f5e5e170b2ee45eb205fff93630dfc7187d55bc0a4b94fdf34041e098438f74e1b61da45ad7247471555adba80a19288e4ff72fd85359a85596eb5cfd3e7b69c809fb55f79d3ff9b0c924682d2b54d3ed89afdac5e5c3275985cc9207c9ab087104c9307b305128407a70a1b68e1f8a759fb45834ac73475f3f72a05ba14ff50a72806f0a1b7ac095fbb82d26a1f847ea87396d35882508fab07ce469b9423970d50684fa69117296759c4471b8deb316a3bee5a91c3563f6d831e9265cc344ced445ddd56606ef93a70d7e1d58fe60384ef684e0880595e5585a2bdafa7f5cdcc871b694add7ba99269d7b829763057eb8a12832e450dffc53528766750da4107f3083c85d059f7ac63628d0a9a8b948ba07504707968fd5f310a2a2f3f01fc38a5d24d1b12c88a2c574e9b810a9fcfd2c312d506749e99ffd13d0d3989b64933e52c09adcb9d84c5d3ca365e9e1f85391e58b998d9df11398a8789934df0d98a5e3d54e4d89f2329ff409d265fed63327f9e8da3f2cfbe97dd507342b4d3e353a158538a2c09fcacf7cd46976e9a13c4e5202339377932e176cfc817ae168e74f146f0e649f8c1223181bf9c974b586ca9687396623b62ceaec492268d7079fd27c4ad09f3c07d7b6ad46105a1f2f4cae6e04527e30d7185a26898d16e562833c0722b99fd0ed1da7f70ff28d8ddade666dad2b411c802e414038341e7fb55ccbec5756fed1ecf1e43a9207767d6439bfd28ce9653760075ffce5fef1941aa14223f59e042acc4c31c8e31ffcb20248cc27c90f5c420778bd0d8a14290fcfa9ffd592f0a3159ce2294f5eec588a4665362836e30e408d92c06fa53ad692cbfe97c47284c8dc88bd5a2cfc3e9314990bdfe49c90c11de824a82d15a3813651a9b394a5fd5e2237541c7dff23a9e55e4e1df9c2941791bb15dbb23abc38acccec20b7f8e5d2878e107b7f1289c5fc9749744775acd59cde8a45549d17695a8cc63de9a06c745d7189ece33505061cfaf08d85d1f9775b5c8b98988e8fd855b47366f857a443fa7bde482c56f05fca7af4786797188105d14767285f50e46cfcf023d4772dfb70b0dbe3b4c69bc85a9090139aba747feddec3f5c33fcdc92aced8c28348d6371bc7ce581fe9f1311004fb72f912a9c476367ca79cdf65396cc097487cddf3f39a7e9138c2846b3018b1bce2f5811ce7857f3d4f18e42b6869d4e9ccefe7778e824b4bd049d008a1fcca75cda9c8200a6dc6baf963bb1ececc3859fe45b4606ef97323be2a7bcdb2f340f1a897aef6d70894db008e9e318c2e26e7d4851183ab3ae816c4bdfa57fee444212cd2931cd456d2895abdff9f59a39a0bb03e23d93f02674efa3303fa82c80098df197a29df181b94fa4f7c59c12f2409093c76bfb1bfb9712cc9db8b199120dbf17a559f451abb8e595fa2dc09d82d779cce5cedd6ad9baa838bdb7bd47e97fbdc1546485960911ee55af81ba964ee1d4a6b955ee26cae6873f89cd93d2ecf0758b95d98ae9ad9d47cc7030cbe70e31ec8849ecf265e4196c0fe1c8c0ec1af67a01271f60f04bd8cfa36853e8f2d09ea62a288e676018f3155c9f69b42d3ef16c1e9c2cd5a64fb6503f57b27f6dafa1d7f89d3c3d255beadf398817d5535910df9e9d8f7fcf0d37e8e4aced044e32d95f6b21aaba65dbed566dad2e6dec6ca1986b9c7d0d5904004860116528c6bbb83cbdecd81d5dded5dcffe123276e1a59f0019bfc2191ac10fe0b822c62f4400d0966aa1e0ce6e23c656f968db6701afd3c23287a64718f14c303130b01b49f130e2ba1a66e5238db67114decb6d2ffbf474f72506ad5d2aae0c9a7ffcf704dd1659cd183ccb7df1b3c65beaf1008e5c5c3fc764ebb752bbfdfbc2d8a05ef2431a19fe5c74890a52e3331a14c8dc167eaeedb85485fa6a60bab32f3d92eba49c9b04182bc96d0e83077584fb5ec6d7bb55ad2ae04be8b00deff2c336175d29a0b86176b1b271623e9f561ef37f2c47587731298c745064e9d6547a9ff9663bd9432dc8ebc20ee8f2c969315f678aad57b088c9a0edc12b250eab5210d77db16692b9dd2844d3f8d4146115df18edc03ea018c7cb3893f5933f9aca997869f1d8ec80543bc3289f1c58a7e006072cb6d7f67f36613166055075e82271d3a477e984dd3bb77d9130d834e36f35e73ebdb24966559a27dd7f7c686bef60183c4f523a40ac057bf8531c9c86a59aa72b59a482c90819f1ebe7356050b50faa02cfd92ade254b8177e0043871647501078b62b8365a693d885ea505885ce7c3865dfdc16a71b47c23d21ea19e28cd399ffcee985b99f83319e876aa67310fc7debbde9615658e7fb52cdc9f58912afdaa62380c39c70a6a5c69f5443040cd569b6b1cffb91ce77176030040e7756b081e5c8a4455018c8d686560e78b341295f530ec9bf16553d7009ce9e3fa4b6b4c823197bb1f8349eb0a75076a17308b1bd91db9a31d910844ba4783b6293abc22f8dc2d14195fa1c4709e95ebfb686662294fe528a2758814331de5fb908312441e890ccc28980872c868ecb5037e9a4f57a929bb22c2e25eabd02a4d9888ec1acb9db6445c97eb8b6d587ba0243441e225f2992385df313310ea565df58b042df85fc1910d561d842be511f6c3625f1a1973867c245aedb5decab2729a0736efc1f93e4b84c4574e307b9ffcb45eac92d0a4af886f0fec42eec2a33731cfd1d50d542601f7568cc52c16d11c4df34e7f65456929ef91d4edb41feb9814e3fbcf1ce901c684f7329ac28dac55a19852f5c84a215245e8caa81d3606de0fdf2792e230a200d5889fdf7ca84a401e0b86c319a68a711cfcdf8e97035271375fbaed462fe5e80977c0829d8d0d1628b806f8d5d64a0aed3ea7f421b525586e4f2eea881aec41a35a7a79fd2e5da6a55422bb73db1ae5fd24dc2ae066ea152c7283c6d81c554b6f4c0203abad2405b0d3e26a0b447d95f65929a0afe17b07b594d26877d502dcf1389151d67b3f1360813cdaae180a03be56bb0314461bbbdebdedc1d6dfc9211a068bcc9f9fed4f596ba24970a6d2ba421dfb824d35278198729889171d218c9bbd59b67f26e0c926054ca02e23ab77f8da4e8ad27a017937e2cab5a6cfbc72158aed08d712bbb0dd81c1d9311d3979923d56a2dadf36d607d6926a0d261baa13fefacfc1e72c7c6140868ce9e82bb9d249763774d2238fa4145a8ea042a57e1fa745c27badc983656a15d7b75dec746baec6b7dbd9e13b1a7d1ff5154c5cc352dad7141f25264970f71f51ba919be2bee1be74cd1c9f0841abb97ddd02bf672000611a276dae80ca1e39bb76d307ac27b8d4a58af6e3d0879142c68380f9f47d12021d786a52f42bebf3fa3cecb6ceff2007478e5f8f6d659e5c2ae5e3b375b68acfb4ee754628e6e67bf2d18b870fe3681e93b5107f5ea0e177735bbeb1e914bbcd8156bfe81d213002bee53dd0e0bfdd27746918f9e2b2da6335593e3f4d227d385a750d32e97bd554d3a9ca54eaac930945918308776e71c2be3c9e2ecac32c56d48b97c12d8b33d49fb87d44de45c101d7b6deeb889a4169f6b81b50319c8a019784990892d3c766ddb3a025cef09017678a9bc61105d1fab4812a4d4c5030fb6cae988f92b5cbb7ed55c2cd7a0383ae6ec4f737d635e266076c42435799c8f05964ad2a935b399498c6e53847a2289dcc4ca09859f6263f75e5f88d4f1200849d32cbf5bde4206b797ddb1074ba9fb456705717e5cea59523037de80c619689b8080a7b2e50986778b32dc4c101425e54b66691abcaad5cbb88703dae7c96c81f7bf909ba1427ace590387b17f4ff2c945ebbf0185ea3b9e7a0d55b6367b94fc01c8dc31a1f1f152c162d891344fc79e5eaf456e25a0e7b7ff7c54ce1b7cd73945aad5c01c3a5d6515431af47a65082c9ccabc4aa5728bd225aa769a0bfa6adb5c77fd36acec4896c5d12f2fe867c4f9b40729e10246f8a9ca40bb44bedd13c8772c1941e3134feb83d3bd38f3ef1f618711a7a13cc0755fc9d51ad1920d0d80e18d432448c3121a74c3e8f437065ba36a234f0d60dd539074b844072a81dff6749e7d47244ddd9e6b4582bae7ef8891a855369c7e3a07ca23314e872d597d38e6c505bf99b98672dadba6a51a9d1fbc9aa15692535b30726ffa876d72cc8673341354eb375f7f33a145d707d83959a6d2be760436d2dcaf16577fd220a6d0cc3ac5f94f1de1806db64f8260de563597d788cac37a98c4ef30317eb80610f26c400c18dc92fe45f76a61ace53f201b5fec8a4f7fac3795e716cb872084983e8d7c21a2657bb0b3734c130e17a36292b84b670e8cf8681388a72cbdcb0ea349e93ed4b69219d2ca63df2602ccca8bd9b75c8a01dec90cec406e65d9549195a95058a6e61861faba5cfe28a7338bd8928da6de1c44818fe4a7217eb582eb709c166f704888c9f9c1edc94af9120d7e8b02a71a67dfa1e5be2957956a26a0bd267f1cb50ab1e71fae27dc9df4999e7be915a4685bcda819b1e4141b49cba9faa0714de44b74ddcbfb8cd1e581bacf405850028b17deb14c73eb385aaf2c8f854017a0cefb702fdff61826876e90177c5af12cdb1b133144a24767589dfb050140a0d2c4b9a86edc9d8f58b873e09982f2a719de48323180027e1087d84842e0fcbb42cbb76f84af9ec4d89f9f7b7bc49a2450a3e28495ad3536ac67b76feaa62b482b25dd20d08ec285df1fa82f5210ba8d6d91558faf55c05b73b777dbb5100a084e76acaa239556ab3f05f844623ec95f54441b70007b9706644fdb4322c4eb7538739a1b40ca53261b2579fd026c112991548050495ab562badd73dc8e599d000a8417900f2f3ec3dd4bf0e8d1e53926aa93d4524969525861a8af779a37c59ebfd1d19e825dce5e30efdd7d8edc6ec08da882336798d2bb9c690d6e2f55bfb3a4a004a20ec18963796077df79e1bc1860ab7a20384143b92384d684414f2c1eee4211d0561a866c43fc20d000ee001f9e5e571af6bfa33fdef2d0d83e0e32c81bcaf8eff5cfdab44709c114dee887bc7c339fbd8af85f4eb0ccaa637e345eb327e193ebcf38ac61789434c509b12a2f8469cdb835b4acece5870a60335cc376120a6586155d119c14611316e0a9f849c939662ce851f5163f5098441f154424d9c961f1423debbdc5a901c1c6233791622884b31b3ceab620ce9aa0e579d0acd01065f3135be06a04248281871d1257640e5f5c14c1cd64bdf07c86f7e104e63c7cdbc917ee8e86862e8256490e46cb929c8abb5cd944de9c0a80f567065ea74af843a3cf519d31a3f2f45968bc8dc7eb902699983f3f079879c4f207e04a0e1f3538260f6e0e55fdde34d6941b2e16764d4b0fe8e4feb35ead91b12e26987b5a4b3d0b689983b106b08bd61d871354d6962ff2d01adbd2868be822645b95df080f5107c51480c655a609d58edcc6b1a9d9bd10e966fa745dd04ee87a6073784db50517c747fe3cbf4d118b9f645a0dad40b5db883eff599472f97c7c7a861c9352573f2332df192d1774d937434de56b7369f4881d0f6f45a80ded1cbaf3ea15031a8876dff6c882782d2ec0f29451c81e32589aaa53d3d1815d626bbba44f63a955c3a7ef67d226773d8fc2095ef1002f8086f4b5628fb346f9075f7e297e35766af2ed7c7b84fece2864b842a25569a9bc4266298a902c7154cbb931471beca1912f10f553607ddd213362ea4b9ca120192dcffae2b8436ad0049f244ddc77e04bd69b93750dc63783fa4b7f43fe6fdc3066b9cf35d53cdc59d21fd748d7316c2d80d2cabfc5264a6e35ea48c7e23880633a2524afd5c58e8c09d0c3ffc1b338a65d90fd30e14a0be246735469ecebf33328f4ba2eb3bd6efbd46dc773b50ba700c0a6078f48ea857a7418fc8eaa01a1f598247f21ae2859cdb03000ae39143eccdc636b3d4abb9c260c68a545d2c90724103e04ead00d27a1d4c7accbf00662d8ad0145be5e563c2aca16b538db52df502f583377d514b483416ea5ac0a8ceba5936531c1741f1b0c621ddf104890ea0e37bd59c3d44fe2fed03e540c5a2bbc45e1f54083778ffea34c7a061758c237e94f567c839d3b8e0a21d2d58febc57a3e40e0595fa9c2c6c5b0b9bb1efb1d8d48142ded67233c65064f6f4a79c435125d744fbc683a3a776590a93904db9bfae6ee991988c7e1c336325a39cfd1bcd6d36c79ad83f313e801c11b61c8ecbf55a159272ddfe07e51bb2e1ebad5787700e74ab5b5534fff9ea6a8f6ea07cf68f379dac82f49264fc70e0c11a82d8aee13a84d53e84999a6fbcbc5b48a20e09f8da5e508ce3ec92c53653f3c6c06e8f8cced5263ccc38844758badb11025ea8a165db9bb7ec5c14012e902237754dd3306759f52322ec8c5ae552ac52d249132ddf9e392a5cd4a4444a61c0880666435840ca24bf33747ab15a000137662dfd253913b874506ff0fc04639f92d4d41b4c6d7cb14b0317ffaa8bb860aab7570001fde71d61c559a187dda748d996e35abc907721afc5072bc54b68198e0d7f28bb3d50d8b44aa40c9dfca079d44673de2bd5ef2bfffb831d20f5ed969c6e883e9d72ad7c796582fcdda2cd30ab44640d99bfcb279c52daf93a495d6fbdb7e7e90f0fab25cace6a022babee006ed37e99b9d532884fbbeb44e4da38762ae9b81c024ce2ca8af83be7fa3297c870983bfe43395ed0574c974e08546184651e58a15d23e4f31cc5652296c2d6fe5da035f3cb602fe761c83ac83550b776e3766c0cf865856b984bfe7409699f2dae865a4340944db46a5639c5e2dac3842a889658a4570051d5a76fdd483950cbfd034eefbb9d718b5ae1a8461c42be90a8eba207c6f8586b7eeec9717c0b78e7c679e26c30e546a2dbce65767b16ff72124eeb5ad92809aa8f375e4ce10b916439716985cbfe28d04a6504ba87f7161d6985069e8b93cca0d24e59733ece160c06a77bc10f9c9820ed1489f3e61cfeb68ea13bef47a9e268b10daac329683d02a562b2a37c06121360dc37edbeafcd84660ae36996c5d6f29c68358e196c4f0187f87532d9ce44826b451e310ad47c85b48aec116ea9c787552d1e8ccb8507f09f942977aac6541aea3710274f412b857b24851b174dd3d69a7ad192bcaedcf864b576c716b3fe408999654c186f12f79f78e05f9b55d0205e8e1c91194d2dff1e9762858bcce0f6d104a8b4186d6e417e4d7146bd4b4b0e1783edc50260cc66d901b3eb881eacb5dc0cc7df303737ec131f6331fd27a3dfa79f79ca4ce7fff6564d16a6186012c7113cd9c99901fe8e6bd24271ba1e87552df6d38d7a40ff0cb216549b2060456b92efe4284d32d26c14688ffa15bb672dc729bb653987086d284ba627833798a8a7c6ab72f018dbd55780b6ae8f9385548fbfd1a6e2416e8c9f51ff3f823f0d3a170fae84c3cbadc12247f5b5b50abb3c2020114c6ed89e1ba39bfeab1432085d3ba50655c1935d76d6a2b8ed71b32e59d601374cab8fddb48326c23af0b2ff98c46870028acc1fc3efff4bc789c7b143e7d3fecc74bd02f8152f28b446ab38c89d2a2b47f4b851470a00e0bfcba392f8850434a378acb17dce6169a9f09811e2269f1e9ee1bcefce17fed4cb4c79eddd8c5b133b3e8bdb68020d585c6644e298188e447caa11a835f3e7ccd6cff5d1431a9597c5233890fa097a87f95adbad7e2939068df185b09f1b9e96bf653580b8025e9fa59e42fbe7bcedf316bba68c4450891cb770b32498f3e96a7b0663409651c9f958875d9fdc9c7b3a1c8a92ebe6b49302ad959b6a89e02e30f83fa8ddbcedbda3906bba4f8ccf50295b3746267e69a84103f37e00d04d04873f296ad8ca57d28b5a64293c7992db0cf508234131e6cba6c006cc0a07b017e4cb04d2fdb9a936768901a5fd6677c7f125fb22cca4a841a56ac58cd7e22d4ed82a59ad510e0ad76c9fd6decd4d82abe27a22a00167c5644f38685d95a28c06c49b18a396a68193c7ce2185bf6afd846f9bfc1933c9f0a1b52aa5a626f467e4b5ec006c74fe92ab8aa3485ae2b07e5e535cc318d61a2aec4461f68bc88b247c5e9ceb0f6b8cde1d28fb1bcae795b6f66c7bde4d34bb5622d024ca620b550d944bf604049912f3564f86353ecd1e2e6cc81c6ae58d840758b82e1abfdb5dd22c3aa9c0e41931c8b98a29b6509ff854b192fba55ec3e2d0557a58250f34f4cc16326c101cbe56bea5bdb75ce618126e1acab5969c429b3f1c18a461f39488136c9c87817dd8491eb5c1b7c4f862b4d576d1d1f7a11de04188ba25a72c927e8e9d2e6bad17770622f8e3258170a12232d9cb7403b9dbe5e18fca4707c36d3df79291bc3508cf5f33c993c263738d0953e5279394455c15070f7237fb973a815eda60759977872fb5101b6b86b11865bb72729c9f8525e0e64342535efb7fb04dab5571707e93ede258ef82798d11a2f4e1cdc510debc414b2327330f03486eec629eeeb56e2606b5987a0d5026bcdc3fa5fe2d412e679c97dfcbad80f11426a1881133ce17147ee3c69279953acc934c2f89a9ea0f0db7cbe9e342e4d8fd7e781575db0d6d2c7f9a10c70ca619f1f7b7f0bb4132c2622dbcd368ff5ca461aa667071aca047a505c4ac2459b8305980b086c7af967cc18dcda6b838d2c91454a4574e9975e6879fef379be9b3a41de118bdbfe0019557e154b11d004bc1fd186623b003f0334cc5c7831e85755a61cafe984c876de2f22b2750a829ff48536ccfa67b5848b8184ca9a2b19569d44c037d3a9a86902e03516147b84b92fff81be1e60b90e35fe39e4700a0b1169e173bcd66aa564c42aec9bbb103dcf17bf476316d5c113440ec66b1a3987121a3fd90c59def3fa632031ae053687ecd13fe50dcc17e527e3865ac389975a53562cb56d77d31d330d62b68b56dac9ae0ded39c10601ac6baa71a25584739fd28badc196918b7d14e3fb92c0729d71345f35aa8af93c4d3d8742881c1f604255b3d49c72a3c40f238f056b11f79b784ca3aaacb1a72785bd2a33cc67d9eb18cb1a0dbfcc3ea421758be6de84c596b793f2d43af0cdb7b7ce74ebebe82e4e8d3ec4edfce6ef88214c7886ef24c90cb1d3f7054e95d6110351452d221cde235b4c6d02d65d0fa1c49ba7697210beaffb5b141e19fdb152352a077f1078f321b9cbd4fb5b75bc0eb1a9f4586cafd44240b62c5d2d26d3025cb4bb0a4d9dbce59b0c692da1ac1583b63768e59d2cd6d22258b65a6b677db218d9930b01daaf63f8396e5e7bf80392c08de4842be9b682e36506474318d81e77eb56643336527371ce68a9ba933469346208923d008d35183f68f5f7d751392a1e2a257f0e35f627bf437115da710136c577942db8302e5697a0337b6065cc1006cf07a61d1101abf29d060ef823b1702e6134ab714953e39bb6e39f1646ddce21fc40e95e0060f32dc0cae90682cc1dd75ea93507e4b17962ca53bd1172901dd376eba5546b23afba2de3126b0508fde4023d425e2f3f66b1e3284affbe34ed44eb3b2322ede73f09eb0103441f92e888ecef9de96ee0fd641ad25645029ded95782f5351c08982bfa8ea31530c65939060945084df6959dff1c7fd75f74cee103b5fe7519fba6b9ef1cf69c444c6bfc7994cceb38003080964c8415fd9649f24d50ffe7a4f8f4b4faddd40ea6102026228ef14cf4492f9afa790ea61f55af0138d9e3a2f04c7c0d8c16d697786017e4ba9a0075d0ed10ec10caf0615820f9c22d41112e4947836b001446ee94ae3b0b35c11a5499d47fa4cb6024d38c785f1689528c37acf1dcf7914d58a6005f6e480bf31d23fd27433a487a963c32d52c9f0c8f0e552d16439c6de21ba3978da8d35fee7d6c832412f4571b7248165195156ac87a1b62e73f855123726bd8d1c6bcae75ed07e176ab9af9ccdbc3b8005de75f5b7bf7457e3a45b9a2c28494e0249c384622c501ac87d55a18354ac876ffe06ddf921ea6fef84198ded8bfdbae402d39c0f3859d9fc7f861fea35a9c916a50972662464f883a8cc4dc24bbc21851372a26f7edcf6d799f34b367be80b9e4ee30ac5bfbf035d64109b679c8876904d360d85831c5f8889d0b55eb519d4f60fb68b45008433b60cba7c2c8ec5e6208dee89f60cd6afe529e2877a0a330d5fa9e97ca4225f6e06769f46d8808c227a1464f09bcd304822a7156d143854e089f5f73c84a68a83a1fb0acb3ac4090facc3425572f577502cee0b3f6d340b9702e37e20d44b306070a74f8d89c86b003d97766c5d9609b7b17f3b3f28db77664862bce7f8377191036b023faaab3e680fdcebce16fc85033da5f6332496d99f0239859e8c39806e85ba0e1981b620072b834a430a8d18160bd9ddab7363f38a9d8f791ca0263624536c480946749d0c616ffce6788d5309e0b6802cdb893775db4a78de6def5294879e49c77c32f47064f2a424642728d601604ec02c3f486b8fc3db832db1ccc326eb9aa9c3f07d9cbab9066509e2db105268355ef74ae2fccc1640f16ef8791365edd515fa4a522d7fc28b37db95c5cb207bd98d6f775b46c72ecbd0f4614b680f636f7ed788a8c0e8b0239acb7fc2a039f8eac34b74a31726861a92a0522dd8c0bbb754cd5d7f62818cbbb3a98486e2253e831aac19fa92bd9a6d6aa836fcd36dc20dc9e330aa9060a65506c3fe42b67b71ad5b3eb173d10d3855ebdfec5e61f489eff74fb585582ebbfbb1e8c1d2bea1ca0d0814f49b7b52ba7b94cca13a60239500e2e06a066d4040c957f6fc932e8180b9e1020f52845fd23ec93fe2ec5f2ef920c6e0fe2473497eb8b269bab9f2371b88ea39b735bfc92eb7ca9f869d57ab689c218429be969f9b736fda79f2467dc755c76ed5079c637761372e87eca4d3ba61fbf917cc948ebaead6536b862a2d84c96d1a96adcacb8e00ea90be74642f71c91df55ae44bb49dee39cdc2c912c4137d7ad1402521792b9f63182cebb3f1485bebd405bc19445b4f3f27013ef539ee546ef316b5b56d6d74e34db231d2b7f02bfa22036476b59278a75a7d30cdf8257e14bc8f225f81ebd171f1ad0b51ffdde9acf366997afd185ce0acee2c7b78b3b8761c35913193fb65892442ed5cdb4d4150e14a5aac08ec8bd907b552b0da0da620b84226b5563320f2b752eee15151b5567042759e04f44576cabd9d1617e41f33837d92dbb5dd380a43648c57197c525a0d1695b58f2fae59d8de38d749133095976f96d26d07ef6e2176e5933a801b653cce847ce2cb5d352ea7356e0fce5432123eb58adc886b15d1a53407bf1cd7442681bb4fdf41a9fec1ec1ddc552a06bdf52f552f15d775775916414e83c27338abe0dec325bb536e2334a97fad778675c701fbe5e1730eb8f509d52ac718b1841e21ff1d34e633e2475026107edc46e2add8539d5664eed79ca7db2d58b1d58d0310a64972dc2bba0f9e02862e78e06f5797c1c9d5daa8aad0d2ee5a39cf407ee2a5e03c8d3a26532ec501e81afc2d95f342d94b8fb594bbb73359227f55e96a0dbe59f3d7d892c0ff3f94bbd21588d69791c21aa18b2535dbe04255f9fe98edebb1757835df075f398f5d5059684fd425a5be8a83e1396e3b2006334da727360075a7fd3f3ff45faa02808953c1f62220ee5a38d3bef4315ee93272b7ef55c7b769cb00098925a2ea7a5167fbef7c0d25b4ceeb93fe478878a0d2178c97f5ddc1993110e97faf1540410c1b8a708718dd36e987e3c748834ad84639f4abd59306fb3fe39ed4b6e94d42bab36cdde189080404c663a5fdcd368934c60377679fb33f4631db19b52cae49196c4f13758ead5926c75552239c3c1de16cd9733b1fd3493d27e688832211daba3a2b56a81054c6dd630729326a1fd89c1637ae7909cc01c5bb6eeb3122f60d9f929748508986ef2f2270bbfc92ef1789ffe85be29b5c7da2641a91dfa2f89002baa23111585f0f892acc25ed12a88bd3cc020e7a3e64c570b541e34c16dff331e195210eae5f4d015d5f6ca425a7bf9e3df8678713064145a92dc1ad0ed26004a972bb7f216da67727352b26c747444e7eff33f73102fb8ee7a8635a5d656572d75e1eedfa569d72e39560882c1bb91247be5f09610a4af90067461d53fd9aef4e9102e16cc75ae9244fb8d589169279bfa5f7d82634eaadf2228e9f6e35080ee0a801fc144158d0f4c2c201743332320668c3c2881a474cc456f9a34b07b4a4c5e53ff5b94e667ba65cff7f42c042b9ac591496d261b5a2fe6b666262981d9e534af616137e5f4ce01725e0d4b27a7d544bb57e41d316698dd1b493d50299700e0fcb33050a3ec3d467e42a5b02955788325fdc3a5c01573be852fa01e10a49db77fd3e8cbea7e41b02d50f02b271caf9dfad2e6f7fa71ad3b22975ebf94f5439a6dff6b45ba1be3d41072f76793b4b29dcb1b0e1e956a971879bd687ca6c0f775b41c1d0e21a4fc35ce64edc8d1698c69a17668fc63e3f502433ca7cc03fafa41cfab07db476326b8b84544f94fcb71b6429d9c1c9ccd233fd790e6454708a22f35c8a15bea56b726c4aa87473e0a8aebcc9b91c67cc8c508ab5fede2b4913337f075ec0392c38742df884c474ee640a7e231e1baa8e50d206d4f01b930b2d118bd89288c764c83df29819abebbff447d93130148e7602cd7ee0ccb4431a1ace91dc9c67506c8cb4b3b5b2fdf21e4778d01316dbca15e4fbb8500f4fd66115a88f65d94bace50fd3d3f4e1a5330c936f11e2c6b7114923a2285b8b52ea4acdea9f6be19f66bfa69fd7b265d97c097109ddfed29f9fa72cad62c9ccccaad1836a45bad9bdf450b9d135fe1cc82eff5907bce948a39baf1dc6a527331d77641dcb89bc8f07d8835ded7f410989a14c75873f32b14ba047f28f7cc21a1ebce6556f1bf989f6b247e2f8168b04b9079bda6abf16f31bde0815a593723b01f16e369f1bcdc68fe54b40343397888e86b30420adad508efa222aff1dacb16bab78e4227fb32217db959dcf8bc98680ab1bbccb5a565f436e32c3d25d86c71cb15ac1e7fcce1498023ef412729091cd418d9a7b482167775649cccdc17a465d39053f88369f61a1cd6cf46d935bf08ee6594e843600f064795497a9f40f85752c5dbcd8dcb7c558763a9563e6eea9f283fb458d017828377a92cc7417e1d6640655f129516d889c3b067bad1a93c473da7972960161f018104cc1b846b266fc451b7a9f53bace5d2d8a4a28aa957b917b3e9f751dfd9788e6d6ae67da38d341d9953f96b07656ba559b9f4bc5a2fcb3d9118b2bdc8449e27645576b2d393f618ca3ec6bcc270b4179e566a7134741b489b166f4ade7f78687e5b98845c5992ee6484d865c5bff1b718a926115deeafc00e9f913dffda1291d47ced0ebfcb7dbb33d6bea3e063340527e432f39d550259258d58677fed3a091ee59bb7a8ab75faa51b8257ab0ab43ce09de589047e650900d67c6ce35a0b19771060b9d3c7fc83ad08e3ccaa09ca933d7e2256a04bb44554b8e8a88eab408e70a5bc7ac2d19dbf38473817d1d7b21e65e7d53dfa76629b7bbc69304e1b6778c259d6f50e84db2dbeec3e31dbe5941b58d0fd0771c70d1e48223c56cf7e95895f13f8253b731017901e21042418fab34d65ce2b55d8bb951c30c73dd37b404315036613b93894f837eb61671e0b88054eff84ad8a9ef80f072f32413fc2a063e43931ce3b8e330d4dbb20e684a693348d3829b9e445a6775f292a0d50b6bb9dd2adb129ea21e586ee90290d5b37c90f5d8f51e3e43fc367309d0f1b3f4ed1c11c68bc944f1ca87071189e3535fd0be5dd8ae0abeb7a8beb6b195b0c85009280e2bbdf6e98e44e9a21358641da9e8b6ca4a4a7bdd0b883bad6ef9d387f51771eed1c9c597adb364640022ce5884a6540c31330dd3ecd4ad6b655bd62871d517c45913e94ca8fe128ea18eeee84d4bc59a94607a79b024e12372568c005cc907194938e5f96e0e0a82c50944e22af9f54134cd3a425ba77906b7bca9ed8ff2bd20ba3d8e953145477461d1d0cf8a848b8587b06188cdede0ca0b7b18b3c6a0b0e8e60f2d44385191f228d9175fa58c2ed436749b140d9aeda3a4a08191f6c5d9b286b6d254fe63305df1fc3e9ba114cbf1f78e96c33523e630938b19a1cd701a6f05a6686919a31ec52034f45f4f48b38e8ee63e22cd6d15c10a91ef11db459de3da31814105c5cbd0f4dc7ed8e9b3afa57797f4aa211fb4d903304ed9cd592fef0a131a29c7ac0c04a1ab3bf1d2b6856baa88d3fc8674b64363415fbb7d73caabd3ec4e98fe01adc9261e1e89710f5baba0054fa6a259dc0dca1b9d221585ecfbe3115a8fe4b2febcedd39f7315adf216cabdb6e2d9034adcf50ecd0f68a59f8cf934d9109163b18ff1723cbf09f7d6afa1512ecd0ae94ca5563c8f3b335edd98cf035f40b8de7ae1fa15ff6120bb47f4d4508dac6cabaa0812dfbd7e31884009145058b7bfe10d5bde0e6711da89ba3cc02e14a59ad053094872a9c9749c46a90e0fcbc997e84f3473292fc921e134e0927c09afa8b29508bde7587c77f903036409004c347643cf3fbc399eff4b5cf1cf546bd03510cb64fd88726c6a32b7de2480596096e65db999a968e56915e41e60251531cf8c4276b7374bf7e07bebbecf0392bf8c5145ded647afc6c40035f4a20e01993695627c544812abb5f48fa884392dd3e81e1d29a0dc6e991bb03b7ea4a90ef1d3ae1f06413ef54158ba83d328e9b1a892a1fd9f5dd07e2dbde38d4e4cb33e9f67b287cdbc979cfbb33fa927a74c068c973633953800a3edd4d6483915979fe1d1d0392f5f734b7952aaee3dc5a9f90b987243efec47c75ac34b391bf1f8dd684c6bcf47c6695ee9b53b764155a5d13515568549f74aefd61528a53f157b66672ab1685bd3084d55271bf6ad23964fa535f90fdde8ddf5c19f5d454fdefaa037d8b339c96586f3bbdc854c7b1f8470279ddc51d81c9896b6b39139c5fb5d2260053be1d5cea6a483255d41f15f1238493c91041b6f7f8bc6c77cd1e6f38c5090dee3e88e4526fd916f3dfa97a40e5a07b657baef2a24f92d324ac1648c53684d4e226fcb9c8265eec87e4313279fed0488c0b25410857da407420c9e51a482106f47012fe43a27b01f2fa1795f9ffc5dc4ab75c4fd008730812b3f52f2f66d3169c173dc7f2578fefd68ab31451ae61e59900132f343eeb32a756fe9b8b6b5e26eefce928ba877d2d03e6d8734aa6d5bbba0b078e8252168e80beb80ad0dc5afb3c8ee34eca0e37011b8d646fcc11d103501c04d94e7dd6789da98dbe09ff2defaf531be95ef6584f0ec750ce527cec95dc94731740f4fe4c1a3b26e16d08a9706cec3ccf12594cdb49c6cb89a0b33e649b051e88477dcd7f90dcca41f0a4e40975d07c3dc175c1ffcb3a8e86ef5d4929d78fda11aa7f75389181c7603e3d1ba616db2880046edb250120dbba66e9ddd59a27e30a2d728ad7eaa8ac9b08b0904755a9a8f4642cc3fc393d0826ddd74a79b3fdf726d99699c0c3ca9219dd665a7ae3b3734dc58ce3bd33d3e04c5606d031bff663e7fe433c75130bf351a3cba931b4f1843cd38fcfd934d16cb3e12759c788134cccc582933eee2e33fc1c56c798bb779c0e1ce0ced8047838a6c5002e51efd81ca22adcaf8d10bfc8e7f267302d5842dba6a8cca969026c57afc1b65128d8d9c02469d0407a5915ba4e3d8a6cb65101b2c1a41849320482c5e0e2b525a7b0a52e1fe630f0a5bbe12a24fed25ebc73cf3f2893239f400a0616b83fafe3215fc7c19a8d1fa2be5a26d732bb9d431d830cbf793f4f2601467b1542b4c99bca68474d22149be0a3050256488a29f38de9a6fcdda9c57636568be1a06176416176ddb60468f71f98ac20b8467ee5e77246df244f9b508abb0331d2ac4cce9a2bcec1dff451c008611731b581ae2214924c0e6504b40f6c2b3831811a51279b61c3b0026ec1ad60666e98a99e21da239a5cc5cc3a7e1cebcc21c7eaed482e7f38f7693c49d541a64bac4ea87937ea4fba3a37fa812af22499adffc0ea646c037427569df62b630148b2a114c8e4481ce13aa5e09e743882eea61fc1cd3eecda1a16efd73bec190c148b535c3a4e517e127f17df19ff5864d7f85ba71a4b06c0279a846f44fdc7ff0f03b05b075fd90118d052ae48c313364406bf07bd102830a1712b6e60f2efe5873949c59fcfc7a01521fb820ef951cce6d710a82d4d030ba6e0511ce9804b400916976f82b025b3a577d0708c0b690c95250e946ae3a032edf7d69d9ba62d12cb55c8a6f846422c4bd89126d5fc5ee7a688f932342844fc127f6d6d798a58e7c173d384ed07a7ef87ff5104bbfa63f6db703a9fc10ad8418cfdc90a2b1d0ca98f48a3e1f864b9d4001116f280ce75e1ff2ebb78597dfe3d7c89fb1d2a83606e9757927bd3755fb2ab5c56e71d485d1210bd27c26119002903289430b6ce3daad1b22437a850e2c592db14c32459d001b29b908014c866d7a95f229f125cdd39e382f59febf0d8adff4650ef17366a26d1e6b1e0f78b3c210804c942f6be863e0437c1b00d1571c941fab576db8b4a94e4e31bdff42797e5a66b61149ee58b6dc85291b32361d8101922bc7fd3daec3d55a7db8e59da1c63dd9fbd7983347b284a1c6814120cccdfefe44b6b5ad3b957eab3e638bc0da863fd227a64e4071b3f4ce594f7b52c6e8f166dfa96775d2327d8bdab0594822e3b2396892b70e2d43d9ab5caac0534dc3c86a80b12389ed07c7d00a2b4f74d1ea873da5363af04ffd986a96434f306a5602ee40b05783bca8b3fb8ba974d5584c4f5d7043b2a752e9ceb6e3bc8f57cb4e22744d6169bfbbaa5bfb7d838586ccbe5c8a8883aba6b72dcd54d5155ff7f13eef55244373b315f4b905232732c208a27dc01adae25b634a71031fe5fa38b18148b79978a81f739a3f19a23c0d1252dde9d32be01483ab62d98789617dd640d6cba237e373e15ce3415d1c8ded904d8f1b0fc9584189bbdb5556f5146da464a4337987061cfe2176e14b8752fb3db2dead298fbcf070caf4312c83d6f042de7885b362dbb7ec9943c9003fb211b55dc4eab54abc7efd8d2ecca99c0af4f4425dd0114e07376d86a1cf7d390e69d59fcfa622b4aaa1b42d45407f8577f91606f39b505be48a56dc8febb4354ba8ab727f44788c9cf6f4b5e3ed97d91b08d6d5b995ccb443bbc3be04289d1ddc8b21ec256dc6f32666330a91a88e7b327f957a929ff0c341dfd5e33385fe943ee064e56200c1a98bf54263f36563296e5a60eace8d82052297c991896e076e9c298f11fd5d809f098a05d3e953aadc9ed8bbe7003f81b8f26aa1607b84a4ac6988fec397cf5cc44a16784a17f50ca00f4a7173170f6b7cdd636ba3d77da684d082cf0c2b864d02845c5cb3e58ff62666dae9c06c1e392fdf2b3bc934d09c3bf92d377573c63d8d3086b18c34b87f852ab8ce5f338d4c8ea3b812413ee66e2d8c0a896e893dcda4ef8d6b55484c38e9ba278c7fb91a55fe0892779cc4b5a874fa044c0a0d0701fcaa490d3e6187c67761561bb991efedbd48cd431f32cf72f279600810584a8e64f4278f979516d29013b95784826cdc4cb304b5413b8826a351a3093b15a832e91050254e55d44cb31a02fb259d21131c316af2bc9889e11d45b45899994a3aff99224cd7885771ea42ebbd06cf5cc33d15ebd55781a2d4e918a5a4cd6022685d77aab191a42aa13b18c17ec72f10052c808eb6ea89e7b716e558dc6b66a4da6e86cb94fb4e5d68e6e43726aee25206da5143a2f85815da780b7ab83bc8f66d9a90b2d297f74670f9aab6959de82a7bd365dd5c1991fc0edd736f5ee4871117a413ea1483421e3333aa051ce32af9d417f8c6268360a738fb0bcfd881e661ea152af0521370c1eb102ab3674bde8d6192e91ad6f85fbaf391772f1bbae40ac76c0eefbeaa004d3ec96a2dad6f507e5d1af340c3ff197f77abdc9024dc11a01c63128dd513d0b2175b2399923e89adbc50fedad2cdabf48863124cfc12e78aaea592b8bf283e913cecc1d275323e51f5f9cd442fa072277b014078167042157d8bb1bfe691f462d4a4f974a6b8705fd67545133279787a41c7c0ccd065eac7cbbffd4cdccfdda51b689545a1b1ad54ab7f6241f405c480bbb2bd2e8c828d14d4c7db5909952d2b641a97d152d8585bd23f1e6084d4bd024589eb1e0a02f29b563eb8112174a89e789bcef530a5937a2a6d2f9d5ff688a451179ecb877d24a909dd2d2cb0a5ded58913ec77c2a9097928e2685a8dded441b03501981016a23a8f7ab753c1a85ea67ca8c1ba9c6c7b28a5dfcd4a7341539442f312454db688da78590cebaf9a8617af7bd7928dfef734fa70d7b29e5781fa49ccd696089a156521b2240df677e16b2d529fc00334c9afd9de82e12b0e6c2a78a4b1b9575e022e1c85795600e7dd9b55887a302d9a18b0ea3e212d1d46eacb6f41259d04835b298aad928e497cb2069d888662cf9a244812f26ec35cfd99ee553075915117f10cf4209b59a40ff55c2ca1a87398577db04737db973ff42f89925e4d9e9692fa05aaf953bab34b8cc176742d31a93d6e3fb970c30509909b3ef5f55a14a498097d582e88459de801cec0994ad7fc86832d9c6f0db0941ee57255463a812b50715cc653cdf0f8d93e1f1f2e090c101ce5c7610947b787f0a9771e08a1a59a4d9cb5c0512ec1fd88b1aa31e8d171bce88d55c543b42065cb6b8001a94b416e41fcbf7755855dd19db2f6f16be678acfea95719b297d8de06ac30875068303f458ae6cba358418bfa24fde133cfd95287f9d09d68200d6a63ffc5fa3079cd13d279ac10841c6edf52503c9bf666fb34285835bf6a07ecfbb3b1fe48069fd611abac9c7ac8596db93e4f1097ce8bceba832c1dac8d2fee19ec91c0756ed86ada971142b9482a73469da6bab661f1155835d92dd7f41678e960ebee6a1447caa336e367217c207f80f526bc1e264e1c30648b962e4a54e4e837258644c1b3f687ccee9110cf24807678415a0d4a3c8182025d0e09f1398e8d75ed529e37a91cfa20c00e7731cb82a762beef467b5b2e83049df37df33c7f93c1e51fb7552a6803ef5a3294912a2cc24f9dc52edc95bd890b04f221f54e3e76a49f4879dc755005444012811a0dc89eeb4ab7ded3cbaeb146dc0016b9c9dade1c0c6e914d55e2fdd9b2caa601687f40467b762799cbcffbaef1ae095c477ca79fc38f4d1f29926780b3a74822cbc90515f62fd831f1c7dc24e6eb62c8ca8ced9d4401c9d58fba3ad6486a83cdeb1df0620c74b59ec8bfa8c26c6209056bbbb479281c044eb0f6ddea5e42b16a5dfd817f0328393109e81cc1287897130954d7b786cdf993536aaa4ff608765552914a6b3b679202ef8514f7b78fc1d6e1020d137ce25edb39c3f8b352ebe73fc308f737d95c20a0662849ea76530803c45e1e8d33824422ca9fe1eb53e55bc285ce13135ae4adaf40b2e510b3f1c7737dc30b71551898f27610386988700e9821d7527f795974b85b1252645d2b36260a8fcdd77a3e95e976e702127719d88bce28b911ba6445c60471eb1b30ea9e76f91d4f697b8ef85d6f38d307b5475ce1dd7297ab8e48faafe20f35f315bcf7138081fa6b65fec53eefacc34e3917d5409bcb7317b0675b49b36064249ba4af62ba9bef08f323fc441ec70e2b8e00e1480dd5ff20a5331c04c0c209942806dde91479bdd4dc889842bf8b5d6adfef6055aa3e8cbbf8666dc6dd46b976f5c40e3cf34cdbdc7f10043e7dc0a529e79e7bce066a7927cf1f23e792d4620cb1309903a57a34026471a72d4672bfa8a232868ae104faf5f1719076cacc1fa73b8268b181543616c4b84f78e1a50edcb1dc7a19f5bb4a8e14485efc0c24aa03d07754c52b3cc788551d4ee1608654fa17843a7ee8b6f9348ea73cc541767568a7b141830352f9126d3d7ec69d95bae45ea701b94876ec479c46edfd4264790ba18bfa6ab3fd9b43ad47bbccbbe2bb10f82903673734c8cead2f65a863129461a915d9db50b0c5916919612bad607fa6c9271168fda3de47b23fd1aceffa8eb5c272588f66b7d85b5b7a10d79686fdb9d6d704d1d9072d2c45229285565c8aea8dbd70332ab6a00970bc32e7de6007c2745f370917f24a2174686c3fafe22c6cb4a9e7e1a19b58da847694c3c1b4b4b06cb24d7fbb23a7b9c75661f6796eb060fb69d5fb0affdbd7a55e79c3740b6cec5fcf994eacad838d543a8a71822560fa0293f2c7d1ab3dbc2d13ee3e1a06942ffdd88cb352ba296ed301905018f503c791e75578c2dfcfb3e28aa44f1d14d01ec6f34db049d6e666a29f2595a51479776c904d8de86afab47fb05796c03e7558e1fa44504af75ca41ee65098ad0d14647e0e841f24cde36091dbb0ba7ebd651c0065dc4e88f6cfc005f1bf3123a05b1f7e5dac31bf7de88adb661f38c050061ad653f0a127957ecac7c2d3e4007f36cf264bbb9ef7f1952bd7e6820df95f6570e7258b4b1ae3036dce586ea9ec1e578981c3cf4233eb93679920ac48e872ea7b5bc9236549109eb140bb8709f929c089aea2ed54262d5eeb0c900842ce803ab88d266bd158ba3d2964231ec6c55065a3f089ac91322ce3bde146922f706267e13860e3241b49f2e4a03f3b1f075f190bbafc659c8cf6b22827d18c50e19fba624d42431c27a0e8e9beb82d6011a1598a814a392eccd941d8c546ebdb82969689bc68ccdbfcef7296708b9dab5596c0238ee9198d9f540268e1e820d8afd08b2cdd6c19914a0ecbb083b01b5c13dce6215deaa5a33049eec08eeaadd9c3a082057dbc2d915427c97dcae0482cb1b3f6c6ae65acdd0baa0a7fac9b06e320bb020f5bd4e1a328157e2a11380d85357fdde4e3243f7fcbbcfe3948d686f62086db6f853b2dc9fbf5862fae660d1b997def456c84b5487e9a85099cd396a381c1c501848e6c1575223a907bec52cdbb39e51660a7549570a5e2f1f13720127700f86c09cee483bcfb77b6613726ecfb778a4dbd8843a33da57da5c080bac5fb364d4313fda6ab7a6967d8c904f180e8143e3afe39e7182594a25059da51780686ece1373aeba75608981b1acae4d99f384065da061f3288da804a0dc31e3736d359ea6ed732cdf7a2679f84950256dd3374b327ddef65926f74c6673fd1518f0ad62554af4c1566d5e8d6be721738f033b24b1b42d479ac4bed229feb5487dfe12ea96ae7fa9697c5ea7d5f088c3141be0c7d52e1fd8a6bd7e6629cd6901e4b19ec426e7af68e7987f32f0ffbaee8f9cb47c8cd52dbc49c4933515157c583341cc7ca3237dadcef4e11e93fcb906a505467f0b8d294d63daf4f5b750b675b4c9f334728e9883d1f9e23b787c74abfc46effbe5b69a274c17d6b124fb811cbc39fa9be459c8a42d6aca38b4f07ead865077640de4bcc713b925d4994d3d510c4e723edcc02f7e8b83ba5295de9a831e99f48b890615fc84287f3babf8f5b2403f9872f4bf4ffe79eb850ac9f9c640c36d381cb31be3c55949bf5b11cfee8188f782323cba5120681ad39234bf41ac61ea84b7a15ed124e14576d354605ab4a4862d58c69b538269f0ddefe378e43c3b8ea88e4e98d06264f69c9ad21c2e38600a9b0faa4ae2c64d28078b8331208e056a860445457866cd8abb50a1923e3f7dda011c41185b5c31d3d4cd9f665388761061b873356bf7e2a45cbbc76c68d0f6c32b156b79b31c6b40846ba1132595cbb3ab18a338451050e9471b02933f118d0a2867b4492219ce0253de1f18e5b49a48c42d69d5d944f02269c3fe8f5bb8a062a1915c3f14dcd9ee7513fc503acd4f718af9fa183e87cd4ae45b28fdb1490385750f7768c5d2141bcfe7bf853900a9639fb4c8fbdc52c8be90d8f5916ca0555a6da3925304528afd5df455947a6425a9b6a5f6d73819073d8ed7d9479ea81b5a389a014b98745ae89d1116baf088fbaaaa58fe49596ef1735ae5ca3396c1cc553d4607002552ef4145579a93dd4d9bc5cf5e1c600e2a1a56eaa7e23398a4f60a4d828e7c7ebc73078d0aa3d31fc1b50982b023124c8d51e34a5eaa698ce3c8948fe57ddcb7b6298a74119b41f5f5a2a4065457c87abec2d2982ed5bfb4a67585a8abd194eefc8c9801c1c5681c52bcb9a9e4118b9aee8e2ba5d91adc28c4add33085d4ce1bafde840af8599170d3adce600c81d948d5eb1b50096ffdf661e8b926042c76454cc600887c3982637aa343ff559a28efa8ccd86ea81f46cf23081ed780892455d9bb99d93347afd01a37d6685ab8c7aab2859d51617b1187038dfe51fb0746bb3c0eb9ecb1efaa9ae9e162d1583ffe38a7c4076c4ed278d2a0fa4ba82b83f777dcda4943b6d0af9513d7a1b0c2876f4199c1bf0e2d350c034d03be882fe3a89b404bb9f4115c3e9a72176b35af7019d6c6e61f04134d035b0f52435ca22ed82c8369410d56ccd92cd738e2adfb729397ec39759d3bf37b53146b3b90a34b74736eab1ad2247380970ef14db02047dc5290b9d158b5d5d197c7547144b6fc5b43af7d606f1362d18fb1b6ea42e8358a2a8fa107b9c7a5274cb1937dfc5a7e7348e1d49f7a18abd7e2ec051fdb24ad64ddab19b5f6a9fbf322207d1d5aaffb2bad617f2e9ad3fcc5d5498bd5edd5b7825b679af20b9f6cb086a8d834e27eff7710eb1cbc5a0f7a19ba3eeb343ef08b41dfeb8510fa937eb7d50d287bad93b5f318efbfae63e5f15fa3eecb4791e5c3ed6f9488ea92ffb13700438b4d3e7f57613bf1c8278fa2d4566b61c482058b4d34af955fe4d1e8a2901595532067f92e5673e4472a735de7afceed7e5efcdb53716fd6054d8cbcebe9286b11dc6d47b8b88ef694d8ae278c2ccfb5abfef781dd6a221916eb38e483e772733849a8ea775ab4472d0e3f63ac1358ec713d60720548c0525a4ca280327fba6427dfe96e3f4321e88b849b02bfbf56387e0ff78f4df18106ee0fd0bf193816c53953d6e7b55c32479ab9a1702df8c1c1e4f92af11682ef1f536a4b4625d458720bda271333fca1823bfc1dbc3bb7ab6993dca31c9d3419f2ac0dea8b8f04b293170006e76d1736f56e36e9ca3bfd09d74530a08f5f8d571c68bd5cf1f6d676ecbca125fed92ba744374946cb1a13801ed73b03c456702aa19aa4ec408dd200f5b3e0b504f3861473d18486fab29bf04ca7e9ba943140dcb89fd59dbab25ee74cd85cf0e15275589f6a1c3d5cf52293642cb7e58ac4d709d673237ddb9573fc19874589a574a8cf907e561d6ebe8e06bd43d444c8551b4cf38e4446694f0b16165541feb8d13da880dbcf324115003a84e4d2d3c1ed7de43f4c144174b724ee3893a9abbdc4b0795f426b5111403d6df73a3fa1236ec51053f2886ea8368b6ef4a853d61bba48f723eee2bbc0ee74f618f478c2b9b07e2e900a826b0cd18fe4b5ddf6fc98e165d683293b018e35a1926b51467cf4b56f09de897aa5acce360eb1ef0e25d953ac92058ac2268fa537ad292480874683a99aab6dc95d424300214f79440117d01e55acb5676d34ba8aa63782dbdf8105f91b0023a8bda70c4b810ace0467581b3d4c9bf10ef100c56c0b55d0a04abf144da65cb59feeb898dc81945558947d42465c63dbaac91155c7552f9d44f897be819607292c1ecf74a27193aea39b08a9d3850fa84349b70c2ac653b7bcac50223a3d387050a846b1511d41897677e59e8722ca48220a8dc39a64c21f0ebe8f4dd0c84629f0e65692462cb23238d79eb37a3876d489c831747e696e56565910f7716e231cb0543673fe3c46b6f08450e18f677d4d5b867f606431814997802bb96586cd74e7569e53496b2767ca0f7e2eb1fa09d32052ea1d8d3990a183e15d09e98b915db35302a339bdfa2cdb4cab9a36a9c5d5d87821bbd4d7ba2bc6203a2ddc10718ee727ea0c673c03564aed72a6e9891dcb70e66b8f2895460d232e4a601bef853ff477f5d4e2cf532b78c14e84984790775f9e673a47b1942d248bf2dd4ce964807a55ddd92bd0404e6b4718798fa47d9fab3b397ad8c8cc1706849601b0fd05a08dc5ba88f41247dbe45e6448c11c37cecd0f16c78d4b15d8e2f2e4b28920b69ed6352539c6eedf1f7afb106c4e32894801a1d7c7ad03bc2728b027a7a6abeed57334c46675af6fb2cd91b488425cf26d3730c50b06403d4963df4c9e6f026971d77d4e40a66732c555e7d66c211c8ed31ed85d0948423b381f29c6a0127d22583bd7a231e6036d3ad4c013ab4b1a179cad4d3e4bdffad41d025e8ca8c7e9cd27ffa9c22d48bcdc91b4ea03a5c3af7983b484406ab3bff34fe0b72dfb9241c0c44b4cea164671c5698327e751e0300dd75a899fb93c8472d9f7db50f333a9071ffc79a6c29df88bda790a705f6e6a22d563a7b6368678e12440986a3fb35cf3d836a8de970c2d7932484f4bede42f48bfb9908a4af7eafc581c5c2027013e116742584069f6951fec96e1a75da7e1dd3ec009ca955ca007ab345b1afb72856ebf0096c888b7fa0ad4b93c68501e1b37069981b4e73d92adefba5f36896963a8f5eaf5391ae507910146645b66b8923103ae6985acc0c6c05a208ae4baa9de33dbdbee207aac17701047c5e1226a2b931b51534e22772f1921ed592070ee4df83fbd82c2b117e60efebfcdcdabaa2f8902bc707a75f1541983e66a6158e38f037c5f565982cb00e19509a3599e2ed6ca89c438c938e92905b1a1a75e1656fda768a94376b1cf6d23c45e57ed808017c4c9724789a0e9c19730260344a7e27ec6a6b86de727af42a5d92491a0d601ffa8321d01a241563c2e7a686515def8040703ec190c895355a45b3838828d22c9ae329aa69cbb5c4d667d4a3da5d1960ebf5c7fdaafb49c788f38a91c99eefa1a2fb6e443f64e9a6aaec76d9d3fc3e463f12e11bd24abd835d7871d410ed7f1e8db2f7505728d7e34a59f09f8ef269f82b26347dc8049733d7bf09c9f5d6bfd9e5f6edb9982622450d0de19601a8801cc455128476c10ee190a41d57439e1ecfdc385b6349b6fe702caad4d4def8b980820ac797a4f8a84fd5251092cbe8045146922a5c731d275caf032e720ff7122531b85a2ca9eee18ea77c885faa5de9bae401ffda860f7b2f74146c8ea89e9da1899b7d6952f268a39689ec73c8ae973313429036b55396ac76d8f5e98852c5b91d3e804b22c90dafcec1633bb1a7567233c7a5522a645e716e4b0a6ad2311e014cc458bca32b8a939336ce8351e661a64feec93fee3e34bb1e2f16d6d08ba092b047f93631855c238587570cf1c33a7a963ccb0bc1ad2eb8c81e262a1d058efddeccd6d15d5481f205d9004a450061bd5c80cf7539da962c2aed85e0e018142f968b99461409750de7f1a01559006f1ab945517d7eabf1e505f71b12f992553816d1b44283f57aba21e85c44318ecdd753995a4ca272ae5c2946323ecf4a397d08f73a120a30f6af15923c75f23942624779b86f56c968834ed38258d5bd5c461beb093b577163bfd9db94687a7b76a2004a0087e9fac6e7e6c733d3b85f884487032a2a3d54b6110bc4e6a41fdbb456db9372c49c4506e3abd163f39bca2b030178858ca9e18f68285573886e5a1a137671fec0c199d47838737c5689e50c2381428afa79ad146339c716675c865249da1d843c10c050f5c7e7282a9f0b9c13cc94062f25acb4940e01edf65208596970f801d28472f68ea7a462b3fb65dba58f1693f40e5e7b66bb610c7e7593b194296567eaaf074b8494bec34893a98e33eeadb126c524a5c12942e1da3733087c2d04eef23b1852a118036efde4df6d504e4e6815d9c1241dfe291b2f8270a64a9e5b23f93e6fdae831af5c66687160a6e3b6d8ad3749d72d8b0739bd8e08e3c5bed77ab6e21a4e7d1371580b43b94dac2962d9b9b7c785888d7c21e9ba72997fe07616e0f172f4b70eb8e61740a21ecc21c04d28deee158ba91f32989b1c089a36462fd0d6833b0dfe5b2cde7dc3a931709a1fea4ab43e2c149c78e1239d4e2eabc2245c0ea1fa3b2c086395a1dce148fd9485e5c8e4eb6d2acec8bee4a22a6041d0deea8cb2cfa242d16ac8f1dd303ce78ddc4c4de1b6f6f10e3634327316e16f1bf15193732c75c5ba348626f218151749e38ef371c6ef927720317717bb39fbfdad1387dda8bd92d6e3124c2dcfa59a9a0ff7b9d4a8a68014ebb9dd7de14dffbc2d18024acc50fd8cc18c8526afa113b0022cb52e141919aa3e8d72b94410cf9f7ca90178b50fd76b6562f73621ddfe60c0735414cc3546b969ab017a0fbe7ca32b480556249786a16a3422f30305d20afa428563d8fede0b6ae5dad95ee3c2ba75c52bcd0d4f363bfce574232ad3a4a0e23822d852ebdde6fb3c182bb8794107d3d9470aa1e0e2ffedeac46d36ad580ffc7e2dfc5b857742f8d1532c0ed69c8016d1806255ec1ef9e221de5a16304be933ae6d30cade1c8168188ba360ef1a901e2833c78c9cfcdd2ccaebc4f14ff058b72bafaeecc19ff31fb55f5bbc76d8754ee2128ce5db751ab3d42646c88afae2e352bb54ad16d753d9ece882e5b054dc606fea89a65cc403b6b6516d187b053f81243c5c054f0fd091f56e527e1cbf6aa53bf8160e4de6b6ec81e6640c2f3dd01750331ab8e4085c9b4e147b536a52b1a28934be22ce5bad942f5d9cd5c747dec1a6f135b561d810a8fa3da69545d3bd3706305a6b5dc11437540ce6b4820548d1f1509f042e35dd7985a2e3a34513d951b0ed97b470095991837208479275f3a4acf5fca56c6655b0a84cd45550762322ef8c155f442842f6a9b3eb780af5b96e87540e2c409fa5072b351a51fcacbd087d10f69a6cff993be139682991c8289bf3a627f7ea94711cd9c31f88bc7de8bd6ba3c021981506eaae514b1f3cbf475c259937bed2343f8888af5fa160368737393b5c731688983a7a6ac40bebbd5b5447ad7b978ce28f0fa7d0a362f78c6b5921df2e9ec64fac298c4f8e8fb9bc7185cb537c9fabbb7e8e3587df0da40106f75fbd26e32663f1e8a1550950fbc923db67f73a38e6381e3efb19728137639c0dcabfc78a5e786d401b30f97185c52fd98edde2b67891f92c516e5e211c18fbc61f70005fcd6c3c27d2cf4c6fa1bdeca4f211e53b80aa688c4fcfa219792b0cda9b4e977bbb6944edda829b10e25964f782de060f785d6ad43638bd2b9bd53c9b8605da2781f34fcdd27e35f38603631b2bf1b99d28bf6d98797553f64c5c18faa4e6bf475870b7f83b15ce6ed6e5ed54da1aedac2cd69f505fe1e54e3f97b94257ca4dbca74a5fbadf1fb15373576195c4196093c707fea868000e39716618c3822a7e894f22264e7e34a77ac9c4d73d7e8ff7d7ffcbfca1aa808d6813d263113eaed1e1add265522d0250e733cb12b45e3fb63392c5700d20b43acf33b3707f85dde362166a3ff1747759f8d83e904c4bb7a62db2e76fc8a78f6a171cc00a5e75a4d1d69e1ee5a347bb0a54ca50fc9746dfba5aa10eb282dc9aa701289fa7a5606f81c1b6499e7a0d7dc9992d786ed339690cb6f5be559ef3849a06a1644e6824f78313c867ed1ac22b797eb9ebf9feda3245611b085d2119684f317cf872bfebaef790476919a7a52ba63596b7c24be6fcd099c148295686a8de728a5dfa602f044da250327e335ff68d0a9cba12a837fa60133e8730fe47debe5c4cca2b97dfe2b02be6be892145a9b42abd3738b2bfa8a6e2387879ed1d74e5ea5e6f7ba4eafc463627a4014fae00a8106b7e2334707d3717d1d32ef1fbd177417e3117860b8ca4db3949c8a98b2156d3adc38f7d7eb90f9d4dd40a3ee8248cf484cf117705bdc327a6ee63443d0d0b2bc5d7ad796f8dcaac562bf4481d75fac008a1a45805988236d9bacd544aabf35f4cb03354b1128136eedd3502ce32d2c664b4d05c873bd10025168cfc25cba077b522743562d17ecec4ad3fa62a35e43e6b6ae43cddb9efda197133e6db7d9229c14ac21ca06d0d8a5c6be6c698823e8dacff111bac56804490ba903fcec7a8fa495159c888a5b12272661e80c4573703e166fe79898104f1e6e4e32d0bd05b40abcbfbcdcb48b7624de5c4fbbc56ede791ed8e3cc943632118f1763faa0b37ae64703420c2252fa2d153de9a53e19b1d5578e3b6bef302dd5cd90e094b1d860a5f89eeb81add506cb5e4447505bccc261276f99c94035ccf0cab95d7a7207b0426c48300374fa26f21881688a55bf17bfa5f51231cfe66270af2ffa1b693d223efb94f6bcd859d592511070e3a64c11f3a7dba26d45596c25f292186e56bf9654b12996c59ea179a4425e97454bde830998a28ba5498466aa87dc803042fa192f52cdb2975c905ff584e6850cc79528c9adc76284044ff1a1cc3f38906a0e4542099e6bf0fd2b70b87b0945a03700952435bf3a4c3353e565471614c28fdeb10bdb1d670853d201424d68e6f63517c23f364ac5d82b9bd3071ce8bb3f5ea9440184de698a99d34ceb6842bda306be2147d1739df0e388dba13147778394c0a7b5cf9c1581a20c08e107b01d02739c407dcc34acb39d8c6b84d0758231f2b87623c4895e4723eb7f4ac0f753654ba9124ffd515ae2954b204b22a5a9ac5e333912595560598cc60fb589f735a7e69e228287593c9cc6f2f68f41d3998141e0c23552586439daa0657f029604137fa61608355bd8d7f2e8901559fc4d000523d9cfee72b25bb11197ba5c17962c958de65e1a812ae9e23b260239a6f127571f72dc974ea71d441bf3ea80e96f19e85c0d11a5ba6ad8a1daec4d26925b15b98aa1f14e1ce37d5a57088641a90a342d1b033e22555410ec2e4ba0cacafd09323a88cc88c0724c6b896b9362b806162e7a9d9393ec6a473b1e32de196a7a01d8ed4e55793347c2775aeee7cbae25f91babae2c6e41bde82ccf056b45f11f9e5ca58502d913157f12cc7d3065e61b0f51afd19159c52e71fec6e2d7b7c34d8a2188d3c86d4144c7aded026fe85ee0ad52b4dd40554e47545b236fdf07c1e59fc9b05b68112888cbe3d7fb051bfb9cd99b873d72a083ece87a8db03a5394bf850aa08fd6efcaba7c6a098107ccc3727e4c0ecc7a4d9c9e18fd05f2b76b284463cfc2e58d1d0fac8ab7573b8df6a56585342cbd2ce0583649e13039850be97d9bb11f5db6f097dddc33e48f1dfad10b2503ade562c806db9967c444e27e7fe1879d7541e06278cfb262a0764eda2971278e33ca5b165a335cf2bab2b414bdafd1f2e5e4d6c813fc6d3c0c49dae6c5e5fda8a8e28be3866a8ee06a75bd6ccc6dae69cac5868c6066db9576b0b38ab81a1032f9cec65fdaf65145eb0011720c2926ecd69439733a0aa09e674122f16e5bf9e7a9c5b6d07b22acc0abb3ee5ba19631fa1957289fdb802a992f93ecaef2deca998747e78ad8aceed73649ff04cfa5152aaa866d8627f0d01aa894266753e8357a4f1c8c3bb271c65bd739413a6bd942966ff3f7d5bcde4894b0e7c728d7a3498be206378dc592b7aed0dc91bc51a0fc24714dddd4e92fe441eb648952bdc8cf9b13b6c506ffaf5ed5b2d5f0c531356b308ddedabc0571bdc21d840d74861cc3dbc1db5fd754d49f46b309b2f2233b14c6f8287bc6630cfd36a6128b27703e6f7bca43f4f5033afbfb227d0b19b0a36ac7fb16d1c1ae9a922a2c789a290c9c241da112fc1f7367fec948f3607f9ac281d4320974d829f211bf61ca24ebe829b90b028bebf94efe286303dfccf278598e6a3cc4b0b4b61c433e18c11aa1b4fa8fef65beb78c05c28fcea83a15c75a60a93abef692ec0a7c1b47aca2f61802b163da340c6207fd532865fa75c614df415415a062c4bed0b40dd9c60a509b45a35d711c94a86f758486dffa4d0eb13521b58858e6543e143b0212aae74ae885cfa881d03ce914d7cff363aee4a86ea17ee7d8f49c8b373891955bd1b7a67b2c6865fef9bcbc247aaf3fbfcb757dde02190f3dcddcfae41f993f194cae3ba36a843d5952f236724d2b9c02bea859916a0a9db427fbd69dcbc5d264611b5c02dcc462901388c4b746e802c281a8dd4a11052968fb04196326833784019901623b6f43775632d6b45977695a062a0ff7fb70141eb13be02b0d5accae46ac26ee4b7ea36694b9c541f84b5940443bc738535e889bf85fbf3c06473ab24a68c3ef64425279f7796081da011593b92826c4ca5bb8723bb6643715605d03fc43c141400f3d7da3ace80a0715a24942155943a205e297b0f5d7829c2d15e31195b73ff906b1d6c9464b93172de9f176a5d63862921321efa5c15de5ad7a301ddbc75586dd6241e291d761cc3e79cc23b3397feef85e7d62ce0d7b7e9561e2fdff61b6166d79ec2354d879500fb8b85f34d46a0f10fe5a452ceb67b89cf01c69efdaa1a85305c20ead75b54603d9c4a48917b3e88e6ac261f344743af9cb923af0708d7c90d65910e194a1ef81a084157ae0b89e5e6d9794c4dba2781001ecfa21cfd08ca467753439e36e4ef3ba87cecdb97d48be8089642ba82fd323afbabc7f217f59f5a222e3ed62ec3103db920db941dc295911551fe605136e37c8341db96cfccc81001291fbbb97e4c5935caed62a7e4bd1942530b177629bc665ddc8bda948102e686cdfbcc391dffb58890bc77ca890ac0521713436aef91aa5e82fe5ddcaf0de540ad94f0a9f7488d178d872a13556b0e28c9c429febc1f292ab719ff81dd0d7d5a165096118a40f701f4252b1f7fa86d5e068211009bafb7be7527e75cd9f33c5ed1bf0debc5d2cc34be0ba23c1fd465dc60cf01917f73ebba6acb053b7abb3955db81200707eb3dadd1ac2abf905acc0950f3c461b062e347412340a19ffa1085db4f925108aa7f2b62c9cf61e5f1e072bbecfbcf4c23898cdc7ed807d9d458329cf9c0d8fa68be1a31f9ae3870ccaf930d04a2bece2c5b9690e3f53e4439d56b59c90b52be58292aa0c667de599ca4d510182e16c9c6c8b3df9be7c5d60079d663e5633928772112d410538ff20be803f7b403d42493b366c9af14e4b5fad5abfde57fe67e69ff82684c81ddcd54337d17980e2b683683a52dce969ac885aac6f40eec05ae17d1509987f90eda510dd94e67f7ffbfcea793662484c86f1ee8ff19da1a5073d12318094accd9935e0efc92803be6216a8c3208c856064fdb5c859fc5ec3a4bc4f6e412d6ce8a95b67183767ee978e72e9ddcd253eb0af8a8f491f2034ad0c3ec15ebd958b179c11e3430aa3f7b01f3cb7d25064a0b9ef79fa56bb3d5e910633098e120c4162c041dc9a87a3205a01da2c4344cec1d6b7a07bbb139b056bbd2b075e6ea026acbb529b113947d3f8aa86c92c62206254a28bf169220b9d89da5ae3cabb6982596b37470a99277a64c1da9916280f2f1a8c8dc5831c194b5871bc8f0ebf30f49b17f24e6bf18c3f04d28b085c79211e6cdcc73ef2465a6ea3a8298c437a713d21ef1365b69baaa3b757fc4c95fea6b008348e192919835e4bea8a580dc788cd28e01d959968779cb822f32e812cc7f8a4b9370629838b370d6c11b5f14640bf567ac420c082fb860804a72cac92bd15f003d29cf3d1e8a8b26acb8fc6b496aba24dad957186ed62fc7fbd6eb18e5437487618caa64425eb90e24f62979edd98e4e85c478d1c6c5b39ad88329176a2b4f43563dbd84c173206a6fafcb05c8bbadd9628a20805df365933ccf24ddf2b0126b748b379313aa5f2564d6838d3ee2a2c56cafe0d1bec908bbfa286cafe84e7acc4266ac89960abb3a4f6fca042c2491ad35c2f9c804797d1e6f3c7157b07bf62bed70fc7993914b07340f131d93e1e84aa94a529dd2652d1c80a61cd2abebbd8c3f826f9be0d1339e76b2023038dde961318d83dc0e8c434a82764d8a3b5a962c539dec3d704790c9123b2a07ac856a85e8a56496810a68de2a312b314fded967524c57dc9035f9e9903d77b9aee9163585eb0877bcc639a303be15e34ecd8be769c776f8eaa0a5f5ece6199ce52e2b5d3aa681f734df4f714175d064b2a65b82204ff320428bc60ca81aa7975bcfc55ed89c09b26639b0fa14b30503e1e9ab2706925a89131e116e7a352f28f4ad7108df36972092e2d7d8796e014b7c90c124a654d52460028669b96628bc0a98b844dabce53567e2eaf508362daa5b6fe6adbcee3d77d04f3b9f3b58bc1d004bdf218fc41dc77f24aee798980a8ede0c34eabda6d30d15e4cd2c97ce5f5673c10595cacd559c47ec87875606a572d9c7c1178958744e63605f7fc57ac14354be38f824f037512970d8b54bf3cdf9ce4c6d896fae79357caf5a38b069b40b40ebdff0c9fe5b2beb593fcee40ba96af5cd39bb87ee9d77f46145a31345db789d68fc6cae99d5ad8afc3d234d0412ef41f2bf298b430df0c63e9c4aa4ab496d6195e8059d6cebb935941f726edac75d3ddaddb15ca0946f133c959a3b81b3e345b3fb190620327b2f9ae2ebcaf4a57d33f4e67792719212be341f763c997929b3ab5def5b353c6c4a6d2bad4407b11dcc15de2119c3ef4cb33ceb490cd3cc0a83a8bf6f11b61f97907a49d88ed690487f20f1050067533d36223f4444447c8bf97436ad8f5dd23c9c815bfe3e386cc404c373011cceab62dbdd30cf97e85a67e5d7fdf0bf1e198d0a5c16b026c66b65f16595ce60538f4701a9c6edeac936ace9199ed42340985d0799de78d3bf4005cfe68f292bda31ddea6a03e58ed8af9e869c82d10f0ae89988d0c82234164bed6ead9a15ab5d29092804fe87a7ed197ce56d409571b915a614279c8831301c915358f46474749db4002a45c01c78d742f6a67b82da6b693708fc867706eb2362b91485202e97b0c2d626daa842bf2201704863f5ea2a34da14ae58307c3f33c327e37fdd0808f222bd21f11b3c24c713cdf8848f186ee0fb6f5822f7a537cabc6f05909b939cb50eb628c7ba0e2440d123b85a94539e09a66b8c6b9c1fa02bf8bd0b3117ec4c4636f2b0e9e7ccd11f671953bc720c384a1229fc0d00e4b5d0b184892d65a98b559c00352b12374108217d703af88458ccdef908897d3d5a0318e29ba5bd63e6349eed692d1623dba091f52eef3ae79352fd6e0a6aac06f2ba4f8f31a237d56cd06fe52e207fee7e24aff633d20fa9059356be791ef0a0285da6fcff04cd7b2fc49e1652f41829a2d24be835fbf327a774c6f4ad6d174a32bbbc8eae0d66625f2bf3ec2dafeff980c69e4623550e5cbe0ab5389fd0a2363ee5c25c358440c4bc7858fd993585ae9aabb9b1d1dd48ecb1f2def1d5028acd61b1398a2985bf488aae62155bf6ae11650299d92ba94861b6ece945fb4f723f295bcc88ae105abf794cd6fd8cbee0afb2e56bc4ffab454ddd1270a586c1c6636c5b2735066c31834cb7ccb61f8f19b455c6016e8d65f11b00970f6a760c0e0db27d86ee78edd350bb2a01150ff27ab56155356942e2a1a4737b61d3a8c1c7804c633f77f4af8097ae8c6f50b98595fe828da344c351825673f9f1bf5adb46ee047deb503ab1a3c5fc9320dc259348162dffbdc44e8802be10b062b0c078e8eb841a9f6275e4d629968782ec01292cff17f3ec06cbf9cbdd5998c175f35ae3e42197784a65b35a0caa6f767928254a10b3abdae3fa881d7f718388abfe9fb55e30444e9cea3e696e2d1547b9220b8bc3e99168a471a03a999373ac0d7976f930416abc5f148842e6e57893fe90dab8d95d249b3b9c063094ce35eb1ea81d3e5dbd86e1519760b8be07679ff949f51551d12e05babacfb7d82964d49d2c4389965feb70602b87a561923e090c68dd60b8b5f6b331fb61c7d253a51e58105400ec4ff985a6c50178714addcd093a11c64f1fc25b32203c7ec231b796527e6bb97b6e90fc7cf79aefcc72ee4875c6605e9864846daf71d67dac596312e5b60fc3edf61eedc72cda840c8e39d4630f150f3c72d862fe7197e6069097473167efd70c2090da6b5fb3a36815456f05fc7e015944ac257c4cf2966d7be6361fd2c4307b6392d3d3e7f9072ce222944af706625b0a9f96f961ee8d3c68644ea64ac4c910f2d0a14dddd8abbdeb25a6808ecb49a90de019fcc6d4e0828aa4b243f4c2277e379d7855f01d78b7e2a698d3ff3c1ec4b14eee6a725cbaf1edfec298d80ca82eafc7519129e5349b2eaa7c38cf0685dd47db9db038569fb19b4c2f25dfa1bf9171e34fcf390dc51351ae3bf9ac6970ada478dcc260abcbc1d2bc60e80be8f596a755e80c44eb7ea467519edd976cf0ee3a77092418a32fb95bff4cd8d3ed5e12146141f336b9ed6e25f889da3156e5ad9f9f9a636ec8c95a33d112293a04176c331ea2a72c6f542f75e40c6eef8455553c30527eeb885196e7889f691eb45f13b615658efc80594115d1b7340f95f4b349d8e7e893792179d915e555bfcbe0cbb36177fdb51df47609e667a2373f7e87457cf7066c94ddbc76a02d11f9b97b1b48be5d7347f9c158c248c71e42e6c53e1badb14c54de686023007ec1ca23897d48fe6b99000bfedd5e711b8c2ac04f5ad45b199d9210cfc400bac1a3e972fee0bbebab68a05cf5086dacf8cec393f2b6aa8db39c953f56f38a091a6c0529ac4dad6f0f0eb745185193a3db6a4d927aa1c7fd9ca529806dcc1350f1ff10d3c935773d110a142f88c4b117313df67c1eea847827a4b22a7f91f5aabca9a07b8c7b2925f3d0c6c56f567526394b811ac7d65ea2ae0dbb6546257ddf5ba12ab6997d5d4304e4f72919eaeab6666030e287288178337e48e1e9949ec8fe501c48e95859cea92abac4803b033ce74af19f30d3525b53f0bc1463436f871238b76e0bf2b833d6ffdf4c7f35ceddbd224cc811c9cba47191539da9d0635556ce8576acb4f35dce096e1aaaa3b9ae4714be2fe5cb7c8bcdea96a84b4e13c5734e390cf7b1841dea9f54d3b51b6cfe63b2a9c02a635b0bdcb18a38be45676137f11156fcce994b61c188b058c2d710b8008e9d19e188bfdf957137cc0bb4f2afa418b676439ea61efe858a42ec84d3b0387f3164c04ee74765e0db97e49b74a1fb091d3c25cc294a8def19dd1fbc59a38d2bb2423218c99c30002dd00c61ed82ace84bfe54ac778fa8c5a61f6650f8ceb5a921f69fd806ab7b4eba15ab2cfd16f9556d438f898faa993f2e45171f70c21e4ad298de79f31be448510b8a7d0c6b46177ade46c383ae2d9a11794dfc877c93da168c70717fe73a85f402d13edc886db113043352080e938ffd3c8cb35d0f31f53990f59fbe8a41f5d363d419a3d522747a1b71531e3de628e0cc17970a8ec0abd59c735cfe0b42bef167492dc7c7e67424c7a875b1dae52ac40136060d37b7cb5809ce423ee01a1a000e6ba7e5e3516fb329c901e1515b75a6d33dd96e32caefa28605bfd86f5cfdc94f1f876dbc945621de42c3146e62ffa20ef1038422f83d7153a8f953cfbe085b7fecdcc93792de29ef7771b45e08c22dfa1991233b1f1e3df9e8cc1a280ec89aa120b63504ab0bbb797841092d9408293024fdc8a63ca2adb31808ead7842b278f4268571eaeeeac4684e65023d70219582cf80a54927a8185a7cdf9e2fb212e5500304532c3a23c2d452e93887282b3f9997ccc4edec385db4db07a0241843e22bb57df4fd230b41d68371300428c8b734ec163fe04f761c98097698918f30e5b7916c9e7669c2f66ee66a998c78eaf05e51f65b42dc2dce126ed3614dffcbc6431864c443eb874f3842793d6234e196c3304ecc4fb9f6af1c494e8a4b66f4c407fb0b6dcd3ba6613861b9a0be18f7dde14ffed2e0ca91f8457cd092b5c933281b03c48382a9e34760e704082528607f515deec1d0582faa10bde005142d89f26708477431983ce027571e80efd3c685f31d9071d9e8c532d33eab0f8923345aa18879dd2844effdf3ee46e2a51d7bb09a8b2cf1347829990f7d37c2abf7476f2e4932acd4de2e13cf9d1be9da38566e78c15a7231fd44acd5692f96966191e8f5232ddf08ea135292734dc27f800c10e1de2fd092efbce2f3d042522985934a2cd059c5ac3c289b166e2672a0b5dd55489e63996727cf3d1616ca6ff19a9d4ceba65efe473afdef6d7d6bb8fa0aac693734e3773e91a48f86f0f8e6fc070c40905ef60419fcbc23a3eb0b60e868e9dcaae32fa1436db6d8a4e6968ef468cc4fcad27d0e330b2e77dc0252f711a804bde9676d17b9b1c748f148eee0d1ae982a80f6ea04e3f0ad18166cac08f0c1728c20a8e705745d39f7ab03fe48b2df023a03409bd8b811bce4ca983dbb59a040ccdad447603160eff3c970dd794d641d4961c056947c0f59f80968aa4a5d7c0e4506ba4130670adec6c81505b73d04760247e507f3a242ad60fcac16a05f7b45fe1b65480f37ec5ab9408b5115cc0ed67a9ebab1122cb640f040f89d3a5bffbde2aafb698710380023946dc2f53f1ef1f8f81eb7e79bcc052396d2c750cd0cfb0dc8c8e18224b0f7b6474ca548c1154d4f6a9b8b8d6c81491cfb7f16c5259d4c23b699758caadf5d6961dac44e88763cbd5e803bf2e1f4284c4ec38966ade052b908fb863b55daa6c672f875c4d5dda9fc45f3193b730f6a22ff32792a0518a1bc4422dd1532990881af19da13810039c65a35ca2e6ac5fb96a6088bf401034a446194dd13d9d6b5b1b95e2637f8363cbd66ff0ae02c9284ba27e75cd0b037e4759e3d7dfecc2afaf315671a7c93d5721a21d9c58adf5652260567116eec3aa915cf6ac21d7eb7d0661da7ab57276044dc38f5f635c0a4069963cbaf6299fe091675db12a5879f3d87554a59bac14d156758f12899d3446d2bd2f5dfc73b7e28851b8700f7007517b71d89e52443a320465aadea7756534755401bb9eedcc0ad3fba1e3e888e954258f66d8e1fab6f1714d3bc05993733b77f71181d115a30896fafc97b0d9f7c479036e6a6f2477b8d5bf5edcace7c55586f029ca5089cd6d0d839edcf17a9c887efd4efbc06acece2e21c9302af8c3df257b306c67cf7a0818cea6ff9c411d669217dd29abbf9b4cd9ac79514e7a6ddd38a59fa5126debfb6bb26692995d6d97356bde01c9707b229d894f09919816cd4329799ffd648ef53313edce46a84bdf837e6a023d38ec1a1d4d36bab4fd76809fa4988f651e65663510aa80e435ca25148e7c136f04d28855bd454e1fbd045dbc531131d182460cc4d82bcae427d4745e47127f9307a0a9f3b641d3421ccdb854192bad21ce883915472960809a3720c62797f6a44a38a289a258a0510c8231abc640faae4ed3fc4ac7247c40f55fa24b55d297f9f1e27b3db0c6699df94b7a8b0c113d90c69af1ad5fb032e86cc455ec9935ec4d7a916a535f0c7c67cc61314f878a35a8fd7fc8b03389e037ea34954876357d51e3943dd8a35e8256f75c9daa97b0bd13260e60d319e39d2214c555fc1047082184421a8e1f315c83e882ac738b76dac542d51d61488d8122bde294ac77304af587fe31e116d8fefe761ef618be17794d4f511b581099ba93f632c66f7fa7d9ead5491a8ab48af3aff0d51c42f64b7f4465374a7034fed1d40a26abc8a9ba4dc70973efe8892b4e2efb930f4a33ab65a1968507b9ebf4f3daf456a290b158febe43c5b4b85359fb3a496dee3809bf2ef7192b4e846a9262bb2885d9c9eb1cdf1745c24341613002fdb1edcca2d5c5d62a8160bc8bb19fb899bd6595513ad1b8990256cb0c482e69095fed0b8821f074e8d971f226e8df4bf36ff30d1ef8bb73fe6dae2d0225aa5dec4752b592efc489ef42028fdef56485a19349e6f272b51a17169e985832b8ff57a31f1bda97e5244821b98b45c2e86b652e3fa7dab73e419658375f5b3c6541cb34fdb0198f91b625047a6287980c990f03158e79e1d2d41ce0c624bd2cadd86d435eadae526ecc46076a7c42646e2a41c12ba9790905b55b507e5884a13bf344097626358b0808bda9987030c0d016c7255d5a9d3163a7f9e976c0d0a8d01ef2c5d06b1fe7b3871dc8975f558de43b5ddebc0933ae0ad56943842eeb7edbcdce38a577f7a6799a9712abc86b34da1f9ce67b28b72ce5d778f5c465e6220b3787fe5f3c98ae99af83cd0a95f1c0b64ae019f73cb80033536f8efc3b02791946ecffc4c5e70ab5b84565629da45b37222c59ab8da066c10e49f4be29d6089d1a12dc09b5961a5feca900ff354d0f0849e7edb96febac12de5136fcfea7d097a78e8dc9ad0b17fcb8e1145c54b2e021bc1080d50b6c36ab496462d8bc206cc8d3a27630d816c29dea0e3e8746df60db1fb7dced47360f6380187121c590dad8ee69baa8c29a68c08e22ab130f2762f3b5f04248e0a1110f2d6c2f31171b18cf8008ac2ca53f319451082e8fa77c1834f3ddc850bc08a83270d3afd6bcac489e1865d6e540bc2f8e84359c132914405f4fb0b4425aa2ef7e907c5fc9a988c8bcee7904c6c81f3943970f52ce86c681021da63588e1c7b6b6aae97fdc1d48cca8b94c871ca8cd53c150f827a3bcc972884db3f30ecef7f6234aac32ca2b78be3d0215580ad0ee3e3ce13ccefdf3721ca8d91ea8d7329562747ebe0e3ac7637a553da32e18da0474532627f9fdad8ed90b3024f9249b4f30a7c6605a5226305b18ae1dbdcde62696d0b4d0dbf29bbeec6ca5cad24ede95e14716aaa7c89085de338e5a5375c5a8af6bf98f89bec8a523359b02804a85b82c3da7f1c85ce89dc4d4b1a5e14607d8a46730ad5af8b0719e733d8eb3bfb66172d93e15233d8ad5b51240e3f15506ec15956d651a7a107ba6c9f7b290be43b2fe8f93604ddb9cf43aee325339b77334fd79d19343d3089598b62750dceedb1689bb2121f7324e670bf258dfb64ca2e3335cedc350c66c4ca1251640cab386090f6ab6adc0bbba21627e89ceb2bb7ec7cba47e7761c5e93740be644d9c29bc09522ac8033d8d32733c71c8869862879cb936824c101c248e67244b3f9d8199a2a7d6ad7ceb3f71c79737eddd4a22cb5d534a7721f99d92c15f739ce4612a3fa36eb475b9df5017915a71d90e5ef6b0eef0dee647bc42e4ef94218dc3f9d51ee421b8048901810803e1f584d22a669b238dc1be1e865db9b6c5171d80e37a9711a98e63d88a61a90a8520bc80a3466ccd357a0d3f564ceb41df020820504100bb742b3d81c8736ca3cee0989ff3cd77d0bcc51f2e82b68e85376072ca0762f4d97e4e571a847ff1f51573df779be8373ce758aa647e08846cd9eea861585a6faa33305b427f1349c484f59fd3d937b78a36950d61b20bd0e74101bddcacea1e54d87b38130fed4375b46559089ce33314cf8553d0d5e446fd4756e75d715dc7b75ada62116b466b2b947dd6be23cd54cc8ccafd3a82fd2c5d7bf78c478f221b89ef57f56942febe53bbc521e738678dd7d79ffd074a0694a7c6b946073e53928c559efd1f5d224dbcdcde77c566178cc536cb9425a76a09a78cc76314411d1898b4cca16f21246b4fad06cf32a8c3fe0680b58cdd52662b70c02c8326a72eab7ee6df3ccbb3f0091231e0508a361f0b2602e6b6e5bc5349a5d6739caf8bf7ac30be8c60ba03c0d3094218b2e155d1bac1ac45a7543dfe9b4cc6163091bbca3caf4ad8e84b75979ed8002ab5217b92e0c4317a763b1ea3f498cabc0f1478e8ec1d0d12b9949765dc47ef8d3de8db674bdf91576ccae2d7dc616f358f7750b899d705fd9eab6ef89e0e39b527b3757e37e7251b9613e5d295f27f5fdc1c6cbf6a2597fa8a7ec3871202a07c2da6bec2e1075863767252a3074b831f8392ba14b219a51f299969e180e08fd783edb4e24b195167cee4a636e131a5c504b10e4f38ebe1a1e5e92fb432dd39e079debf1be88defe121628874cdb52484fc7ef4810294090c16ba9507a70609be64a3266702633167595c3023f39076c0d3806131226b5e98c8b07857cbfe8dc53e7dd942b04605a7b01a8552484ad28b98e1b8b4174e6e5b7c87eb97a808e13f21d8fbd4e41d6a4822cf19faf05f55522aae87a9fcb9a638bc1fd669f063be15e5ab4983919dc9d78e1486c7a994a1ffbf98c083732ac19069cd78e3cd9a3dc8626b485b784701e899f2159e4316a4d858306a1cf925112c0c196bb57f501511ff58d0a1730693164d4ce80fade11cb7e57c5702f8e9c3d58248388f29efd1bc9e715da9b23aa385a81788ca468c6ceca143d745841c19516b954aac4b520c5e676dbd8fd5ed1b7eb8e4315263f30fedcac8c7623030e9efd6b3cf5cc10b8a23588f93c0eea0f8918263026c56e749631f771067360b93207664238bf1dfd6ec7dd572ef7e27183cf3ab6bdd2279dbea8c68ebeb201bb9b410e0843ff0c9177a15a4a7a3293e253b734d2075f20f498128fc503c64c0770b0983c156283ec7522d2e0389687a1eebf1e7b6c40f8740dcef147cae03c05513a8b6edcfe12032edf7a50db461a627b3d1f5af620277747305a274b5ab39c71b7e59f7b118f45100c4927fa90d4e3f7a1cbfd2adb993e705d87741ba8b1f73e2e7fdb31d690187fdabf75fb85a086e37fc7eca16091e7135d3cd07e8de3c26b76a9657b1427b6e258f77bc13268eabe91bff2f4cb31c119b12d908f62da926697cf813344078e9ca1c10c5243c1419f9bbe8af3df6189bb5d92bbdd7d7de2550c1444224386af69b07fbff02d45bb7c3d34afa4983b630eaacbb191803cacdf8c784d365ae117b9ab2795e12832e621940668663e0ecde6235edd948b16e4f45a5e38ea46f44541ec7faf645f0015c4b778efcf775e7f2cc841d08df0776544cb84d3cc7dddadb582170ab00df4cc648fe49b8ebe2e714b61d3ec6fc95ef111a2e714817c53da4da71ee63757f3ad40649fa435cb8086c3fae73c1d240fe8f1274d1f857aefcd37ae1936c1e2d4cdb344d593a560ee735c0f0db0744b4d2566fd6a8ccfa820564b255f194fd5f4f918af52f741ff12aaeeb3f68b2ab38ee07246ebe699be6582e86482200467431c3889c68920d0d81a769a64cab55a6729da6dd850f34760eebb96c3e4cc6f6fbc44bb9c6e1e0fa6451f66d5f98a8ad1048a8c1c53a6c48a6f6e1042f2e56598feae8c4bf0e91e3d4c3c144c7deb2c1e1367739f167b21334dbfee3d35352d325806e044121b77da6c0f3c75c2bc3510cea035e3beb3016dfe59022b3882e2cf8fa111694b921ffec022445978252bdd891e6caa9a6257ebfe41230579f3330d788d7a3a38e8cf84ff273a514a81189e3011ddb29c7c43ae6955829461fd9cf651824387357157a85f57f6d4de3f8dea3857d6ac6f2a075f037b23444b11424c4e35fb5f32341bfd722669ece627d4da79c28af6b3a21fef795ee0fe9396ffbcdeceb4d95e2ec87808216667399c7b4c1c59aece51375f57c484ecf8ab4e0cf35084f0f387c0715ae226b0424ac02761108f1ef5098b43188cc764d1651b7ee30ba0a7546ff9ad1b5613242fece573c3ce2340c93c25275b63d473b8f622b92514bba2998045f9c918e45f61ee37aa8f5569ffc6ff3b5854cc559ce4814d5ab0eeb95f61e1a2900eedf8564d8b50d2f30cb2fae7756c80f17d4f7a16e27da6171b7ae909ac2a586ba64edea0855224f307f37e7f5cec606bb5ea24a7c8fb517a0cba8252f3c473359dcb88cabab96307ed323970bf37c063f16e5fba51fcfeb14ebdfb3c33da0ba793b3a53581f108435ac1c920bc00d13a2ee8381bbc85765a18106ba5e8582dc21d80ad8ad950a8b295cfd1f2efc9460d3e9dd97722e73fddd48d0cb040bb5f1c430f883cb666d08943ff40a9ad257dcd1895b8d8b97cc4b31f1adbc3c410e21881b7cafd4cf414f22ee5cffad7be284edfca3e5864acaacf8e5d367761c4fb81dece8eb259aab1ab4c38dc3adec865a610378f5c0dbad72a0f51fd155fcbda7cbc6e81c2a4073536efd01df564d1d60fd13afdfadb6be8a74a49d62242cb0bf9aa9f00358df83648292571dd8a5b5035ac87c8d66d1a7d98616c68001d9e83f89f3557e651aa9d88dc1aa0da6c273250407a6c4611a4352578050860fcc9ec03e25b63391cf0295c25bb1e0888d3b1f6da760855edbd57535249cc621bc5198442ac78c188f43e67ab38581ef75f32ad38925ed660278d59b09943371de08b1109c23d8d80e070f5dfdac955b32fbef77fd7b8996731978c332404f7bc9ea3df6303e5471342e1d2194a384ba1827b5fc7be7ef04d7a1d9f21996dd5c140206958f229cacc33dc0cb81bec9332c447df4f0eb9c4d87937fc61fdad769acbcfc55111542854c3cb43179afebec1b531731168bf9cf8408f8654fa19c2b4a7e280cac39da6d371502ff3f6c1065a2ce6a01fe386f4ecf7ff14f9fdf40e191fd6402b8d15e3ba0b3e5c1453df4401f435e3f08985e3a1a2f494abc4acbd93830e5bfa200467e005e84c9996eb9ba249e95aaf9ea74ac69bae142b803236f578fbee603c92ab538f18511f22c68e92cd2a22825aa5ff84bd31a37fb639deca03728a756bde1b1d21486a0e1d52ddcee37cb89dd9b062b550db6343c6846d49b35eed2afe3a235754a60c76f757b29b8fb1416706ff7255dff4f67ee8c77895be9a3e083a67c767e1f21366dd2d6588557e6448453b9eb094c56ad8ecb414fb61bbe840fba4b8055e9e880b9fbbc407ab17af9ebbfaaf1e3b038ed40962974fbf8c9cc1f62dabc13b70ea95d7a540bd85c15eece9cfbdc3565f87a3d7d5dcda6b970f0fb71210d739c0d611fbf245c413e493c6790c9d13fa72174c6b82031b3412a735a6f0796b9e32cdd878859f7b1598c3324de8341c7a7a7a1803aec718a52b4e142bca8e295ae76647849084ba3e05b5ada18eb56285d8f7e39449a185a0b54872afef08343988bf8fc80c8619658b3d001e259dbf908ec7b977b9da1eadee2733b21c5f6813b9806ddcd2ca9ec0e9a0dd245fb2964e9c371b1499a5ef0594f27548abc15a7b1a84c054e9855e5dd7d9fe6e29affd0babf0f15f6564d5ab88a5a8cdcf13f8a57c4736218fe63bacd1fa1ce50f012321d48d07d9becfb8b38c896baddb3db05a5a7e7ebfd010855ef8516c4e9eb62f6cef00c2bb9ab1edde02e8a5156aa049c4e4c250ede27142edc7ec9d2adf13ba6371f5c258865036d51d6ec3de7af690af53a60f2b244b33c800bb2a90adb9bd51dac47275adb06a82147cbc67ca2a0c6672de6dd40abc3779ead25960301ac1662bcd2799fbde73ebcce5c0aacb4c3824a2c2e5129a9318d752502bcc6b2bd85d951f3b8d456b8744414c66148cb6c92ba0fc9086ad396d361c29779c2900ce3f614f2af59d4ff694f698d34f7a85d1873469bbe0427106a0de04d2d6eae4739cf88befdbe430c90002da84032b27bb7117c2c9efee28fcc81055e93ce7cdc47194a2c7e17c8abcf3997ed599501cf482773b63f4203828d9fa9e8bb02d3c0c2fa9fd68699482e2a0dba564653cb5bd494087c5ca9084db39ee08e8f2e7b65300e0d9498a23a0e55be7ed53e3f430d58f16dd27eb440d42bd424ced73b9e07f05505dbfff50f246b8993e276c520589072e0d848a341f5d9e7703a0cd31360ae4905335a322370f4604efe42358dec8524ed6571b648dbf49d0ff9bfe861672195b0c23773cc15dad43f55930838601ed860c3ff543dab47bec5db12a80b732e124ee42135b0ee0b3688ce18ae6631e7abfcad2c00a0c10184c94c0a5d292cb1a3cc111b7cf89e0f78f381c2aee99f73fd0b726ee7341db5f709ebde25594fa38db9c1870ea2d5c43a3d32f7fcc88c105786ff34b46592d9d20d761562a13e80a1255f53b8f914e72918b102c767b6959965ce9d4c638ddbdca5d15f338de87e5921e337387c456c5b7fc3c90de320fba0ae76f7e92b223adae0faf7a597048b581110109183e3dffc0cf9d431211dab5b4d83fb195403642633413d6a0ebaa93c7bb76203bf739aeb55b3e53699504455e94a5ed0c58fe1115848064b445a1c85ebcc5301859fe99dbe475c987d49fc17ec7cd54daa122b0bfb1b1688feae6fcccb7aeb579864a90ef1530ffaedacd86e4a9abed2296c13a447658c1197500b5330ec2c60b1282bc5c0eac641b34c346cf4437526e77386a5f09626194099bf9f78399e447434849dfdc701b9b3600bf833bd3f67c3e92680b771e47f865b540d8995ae74a04e6ced59a9a218ea64842dd70d588364267690be6ff9c5e7bb7db6e8c3b960b0c322e083e3cb72649c5647c3aff9818f09406421d78106c04faee1d822d3ae31c31a9a4197592cbc9cfcecced01bfa3539bddf487b3b1aaa9bc5d80c87ee04f4cd5f15795dbc6aa86f9d73272324f521e24fd1d56d34dcb9ad9489cc41ed1726d5e366160b3c08b0e1249bb13092d2410bf3677b528c14f6133ad18efca9d5225beab6f205b812f930f6e9ea9e8e2132e1648ae7bdcfbe537c3e65bbdaf751f3c4365baf7199cbfeb05387445663023912ee075e8c7357ed60f60db62afeb73539344351a6e1ec11bc9b3720510e7a96e4ace795c1fcb5a693cd2bca05ad4ea1817724366db9f2f93fb74802d5a5700c888e20addb980f223a94bcc57b64e9c5d6c55039b4cc60fc69e81706d94349a660f5eaa89e5a090bb2b15cb640c3aa3471172874dd0a25f2d41181606108d1f7b851c5301d9bea746d153b98d50d297b9aeb6928248d3b8dbb7c8d583675a852975669aee9bbe342c981e5a33b99f55f6d19c1d4515d1ced19fc781ddc2ac78cfdaf9f54828bf11602d9dcaa4f2fd479ad018a5912937af01da54084d7bcf9ff24ebffae543b09439efb6697bdb1f29bac3f90c265d34975136946eed73d428ba6f08c55b1362309e65644772fe4a37b2bc62d3d6439a7c010ff05acc6b7c00ba1f23b9f611dc235c1200fbe0f6a6dd54d53f3658d6a13065a9c3124ab5e3533f7bf6604f3bf46e96da8714b02de82c788f0385298c00165ca693252bb051708c1530bf29a84a15eb571239408baa5a8870c64ca37c481b05c80ac5386b782be66e768f09ffbcddec9ec355f78c146a681a98a5da36db38433fdfafe693663498f2af275e15b2dfd1c8419c61fd8f2af0d1a516f55fce35f52301aa38eecd7b1b7cbd7ac9fc84bae99164743b902a6f19b84768f86529ecf383da058a61fdd36439160152f1f6002530f30e8771382786e8296b3a95add9a6bad1f2f0dfa740611ad786627edf5e3b8f4ac5ca5f2880f6873fc9b8288765361648c0303e3451205c5977af11b8cd2403ae62b6251de66c4a1febc2104fa8a74b503dee72cc90d30e43e9212c05300818985b571c5a26214bdd1e5faf2f048620c589602bc6bea7929aa7e8587f9a1203e963022371c508006e99ff9af8b05d145831d61d928230df914dde3013babce12f7b75caa23bb7470c80314824277a5accbabdab2948d4c16db8e2aeaa040282a50c816ee525bb902144cb9de7841b6a39ba598e118c6250ff34a980d9fe021a7f9ba78d68f6f4d26e44df875d36c64c142a61a923d72f82621b3b59ef3e5d289b86763693af98f4475937f883e1b4902c1275c40a792aae41995deca61a0a564e35e53c635281da65e33876ff3875e471378fb231c68f7a9acd43c06ca4a0b1073bed7ada5b2b522d75e3258497285c097d12be989e5ebd12969b24612b6840260ac1edcc99119e58501df2374f7ddcac1f7a10a0a0ee67d07df43d7ae0375df2da6055a0b2fc360847d72337d3d00d443d84e891cd73241a1d30472fb0ced877805edd5a27584db46867e7fe5e7557620daab1bbb07c7c35b1f745479226eaec4d59692c7adbfc58a9eb3d0ba617a73adda8b03637102063aae32d0ac4a417f52cdfef28153dcd6f9385bb642216e14f03d7d0dbc725f32bb45526e915db2338c816cf8d2dde96e681f5ff938b1e293bbea1fcca3ea79966723f4dff42b4d54a5ad385dd33927f19bfe2e0840c17632ecf765fcc8b758d5c39afeb5c8844e0aef8e071052d2ca55922a50f9b5edef44d84a3d864bdb0b2b194d7523150f89f2a9d4106cb10fcca0c0c0d0417f70f17d55ee0cb9ab2fc6b8643a2750f06f1123d1c1465e2714d537e0c22c7fe95f5d74119ce30d6a630f49d228d57e38b0234531f68ae2ba6ce011a043bc6adc9c2b067ea5b189a7a06ea0ef90984c0da386119ddc674cfbe00e0354a4319c1197a8f75e13f7d2c7deacbd64d0844b2348a99f654c8a7337cd1fd2af73a618a7f433f4b474eeba78522c76d4ddb1f6e2031f061e7a49ba76e230695e3efa3776e988e48909e28e447d70250a96b17e54b5124d2ccabb86aaecc3dfcc76bcf47fff73c21bce62c45ee8e74dc99c2daec58ac03be35152c0bdb97f7b391bf88a48805d8d258bfe40c08df138dc2efac1e32fb7c7c9db74ce10986bd49da33fec62cacee16da0f4650ec7f6fcf84246b081ab210aee1c5fa668cdd788598b0716f75b231f7550b2eed1a1023c71810f08856d3968472097ffd24ed500da18197a262337ae3203014421f17b0f9ebb9c276160456dd16f0a97b74e2615285364b37466bdd4120b598f77f5be29289e05837369649e314a6523e71f08307f4916565beda8e0e9939123dfdbfc4fd05deee3cd06d393d80a1ae8d7e09489f467dbb77248708604d419ab8649710b11d19e0eb5ec46ef5e768a529181f3430710933f4f1ea24addabdacd107b74e5e0e09ed601e1f42966e472068bc304185023e8415489470aa39f47602d8bed75530c99ba71a2a1a35e18b0f32b609ab873648ecb3642702da722e93fd246b37d1737f66f3ebba8248633e8f117989c13dc2ab274ca256f483b8919b47f95de13f82b1f97e906ae4433337ab830d6d68d77a097154c6743009665a8c5e2106778163095e0f713b248b8d566e631bf8023db3e7d633eaec65d9818446c74dbfa2b90214cf1bdf5690f7f2d34224bb6683a1a01ee5af5e053af0abf00a599d7b10fe8ddb4674df4357ccbbe5d4d6c71a3a33c7cee494002074c3b326ce48e76f2ef2887a92d6074f49e6a5ddf14c5fd5c844f82ad7080054eab392f0423c04cb010a5760073d340cac01ead05227c23e486a976791f9e83cbd308b14d6abb3c947acd651e1aec503b13a1e093f68ad8bc48253e98c4e2a481d9cc1a846ce2f84032296d02c519bebc0b80b7a0c0c669a7d25858022c1ee09f152e579817ee2309fec654ebf3bf7622f21c82bf1c4921085defd4b908da0809d96bff7071f0023175b0f4503325287d2585ebf9c4898ba0f8090e5bcb6f85e6957c98f76befb10a9ef8a8775ed6304aa670d7c932e70647f7226ac1fca523bcf70ad1e0be4e30e3ba775f315a86b54d39b1d67b5cf5bc4dd0e13964a25d5bfc79eebae9098a03452b1dea732de3c1d1b49b46d5c70152e18020b4a542b23bdc6ac128138712f151de880e6971fe8f18808278389ada12d494a12ac5c5ae069429ec2dbd0739a3d8b130f60d3609898c3afe2512b6eb71162aec08025d6eddb44f55b908fcc2073d40c4df220e1dfb720ef893d09f7ec7222ea2d0bee8d875a665f100d3eef84ba989ed8221892476fa38694996421a74ac5d7da5428a04b96d8c1961af175a1eb5ce0f8af329220ba94fe6fce592f85cff783c24a41deed10c967a3c8edadb00c4e457e01f70096820545a4ecbe982d95d5b6c9172469c39ad6d5318afff6d8c655a82ef440ae8ef518b1190c08a9488ee850fe71250a66e292636ca8b4046e73dc72128f1b9dff5c47d3692d58c9c257721168d97e3bd184d4159b9292fcf758ed67bce37ab5fb1a137636f73e0c2fe01257b230512e95077cb50574ab7b35bc40c017f767370651ad685e4e5b3e5fc4664e26e4f28b86e7638800b523d47d57a18cfc15aa391318a11beb3b8b9896e4449bdac7673e07e172b125c5715d8f25e99eb27a5d247c28eea058161483197fd0cc46e7a8c557e95be1d92489ebbaed198edf5c3bc1b69bc6c4d90151cd539a8346a2bef0fe525a6157d5ff7617deedd43402577dbe5efd0f9c526aa38b13a3e63a8fe61e9f578192801aab6a6351d7b04e7675c19887eb22e83db6c2f8e17018342694aee3405264deb7c80be0165dc3bfdb03260fbcc09fa08b5f5548e3c8ac8c49e61b654d13aec985daa7230df98187cc9ae309e8920b80ad53c24ff325ae899fc87e934dd90bfaad8d35a137992d1abcac3c91a3f79607b9853cf3986285008ca5245d3f05588be8352ca0d2b8dc9103754e4c6e493c7d5a52f10b9775268e20c06f6e60de2defa9e18583d56943f1d0fe83d30e3208f22aec1cfe4c546b97320d47327eda9de05693377e5883427250ac49fca33d7115429c129459742168550fe15e73e58da46b8963477bc1336835e374a1676f53cfd3c364abed71aed376481f15d84d23935a1d50a414d001f28cf1477b2c26fb33594db13c2e56d837b0c8604dc655759279a14e6ae9e2933267df9ed747246862f53fec18438f893f52b6fbb29ad3f80504ef158b6dadd18450ea7f0955ed11e56441ac863a11b0db1e811848aba94268d44f3c51cd1cfbf94fe37d59ad8916128bb4e683a000d4497de6f57aae736f610ccfc18bba8693eac4845f125b6c060a058385217d726d03b753b8316e02da60a554b994af2ca54944c8bf9c33753e99ec55d7f55ab78e95cea7aeb49970542e4c4540d4d9f281ba19117b53df966a054360a039319740d46a323bbe075b194f167c6d73106f71f822d21b0b8a5e655d0adc2158a4b8d26e1777e3fe9fc00be9ae9997a4622b24ba00ee270f99b6655fe117e9c7fa54d2ba6b1a4e700ca038a4330d9226dd0d28aaaf5994310fd89c825f6fdb630c22daa6cf9923b2415812f7bdf0cd6f8761cffccf4caf4c51a8eae62f3db0e0632d1434a60c0e77a96409472aeb6268622e57ac7e4062e23a3afe28351723667e6eea1c68603ccaa90137b9fe02b07593db6c3269b1097903f5f53a29fb5026988a961033e016e5e6546c96578f457c488a7ce8001def79ae796c57d36b70d68378c43076876442129c432e8ffa0ece7e7b8a67579e566a6bd86304d1bed3c1b4581889a9f5eb65a1758a30639924a482b22cb52005fde69f5699c1566784fcdb7bfc449d9d86af45f82c6b6e5f97012589209a74e821cb3cf4e5f8f19c65ab257a25b1479cba17b0e46ffc7331352de3a049ff8ccbe376e1a9e35d7180e8c97b647d3f4f8330014c52dd6e9ee2c6dd5e1a0ce70518c4b3de50cedb27192b1fae0741c2a3ee3b30df5adf143cc64e853c5ce498f144c3d1b991dfe80c6db06276bc2023161b6da9467f7242f3d36096f2353039e7c2102bcc4a3b5b4b88a495379cd140278732ab56d948bc9d0d481165374a82be7a54a033cbdb42bd538b41687c612b352a364c6cbcb7eb280953541c88a6c035290280646171503cb7199ca3ea3d4005628e2915e54884594273c8076bd3af79b4e62b2ea23cbd0329ef3baa5ce4b6bcb8f77119d66cb7aea5dfad7264fdd810f0336e0a86c9a24506e0845aa91cf59ab64486436fd325361b6cceef197824553959ccdae0d23e887d415b603488391cfccdabfb7aef12054132214a63ddc60b10542bb14b1f6e340537dcf3384d0de87865872eda229dce05e16bfb721de8fbcd424beeb59d4023db7ae1abf1ac94f78bdedfb4a84705871c4a3129c7006eba747884c5540bb89da37815559aeddbf825b6bca35cf3c6a9a0bf84143c66be62027469e1d6db27882de3e143953e6692f3627aa9370a0be63d360f276209c29decc2a4b761177388b4f571dfd52236d013725f0d4ebb34a65921452bf6a0f358e6b1cd884e280c7f34e8d52ccee978122375baa650492c132cf5f0b106a1fe91cf2e53e7b2af149c72a3c6a9fe8f1c2918bf907b16444c11f42981ce38a17a9b4852898f31ecf4be988ac0aa04fe7da985e93cc657b0821c833ed3b0288042b1f70086b521fa7cc01635c954aa73cc87d122d67087743c899f35fe34de9a414f6c234aa0b66240c3619bdf72a9c97b2b87401d95b0a76c4c32489ee13c184bf4eee912bd9b5cd9ca0df8e85880ba0c85c46cf164dfac0fcea07fa9ae5dc241ffd3012078c6e0c98fb1e0277b2c1240be88fa155526e6a2a68f4e151a6fb5bd3bbcf23ff42057b4075604535215d8ec5a51ed4f1d62ff46966dfb67c4d7da5f116f7276468edf7735597d358341d5696091b9ec9cb5f24868de902144fb620f37000863191823d2727dcc3c92af531d751c8d9a776d6ccf284695837b2149183fa0acbaffa6c30ed507b013d4002caddd7ece2ea9c76239d9f91b31764eeb2821539703ef193bcb6e74e2abe7f1e634dc6ac678b0bc5eed310071ba00e3790d4751bebca85a406b0f3a1995dcd2205fcf3a9c29edb088de7c03f32cf38acba3e9b422545947255e676012de6b33c9c5685b1d56326543bee59ad336d94e8438b0c7c51caa7f54a29b99de3cf8a62a071ae336c81b84935391cfc874290baa779f35c23c01d31b49fbbff8cf571fad0dc7bc6eabae026d0cc739d1f66939e97350adb81dd2db4d6bf5c4fc83f43477af014e0f36dcd2001cd2280cae9fc324dc840872631db71c2b01832bc5d80efb08ba1db246356d1971263e915b9b9490c7ec4105192e4abf9f2ffe82a38d80841ee8c7a32419e6cfacbf2bd4592cbc3a3a756ff6a4cd5195fec97348bc5e99d0c3aa100620df7c7553f9ef5845cad27c4209cb09d705c3c7cc2bcbfb1191888ab20045fb99fbec1e6a21d5a8f2790e24cb12cd3910f976448b01ea4554290355e7ea8f25311e2bf66265c10cdcda9d126aa90a4cbe01e842e1c49427dfee69fc8eddfb0f8d49fdd8545b34e5ad47d92402502d66277dc919593b746f0df1682bd7965ca4c7e301ebfcf46f573c5117374fd13e662019a2fe525e43dde646fd2f76403950a05a2fd0cead1de1d89ec5c8f06e665c8a246b74376319aad8511bf12bf0e2a425b07e3b862ff25dcd84f0ce355513b6c93dd421bcd1dcf0b09f25d88c6606042a1d8115d2f734e8b77cdf67c213e30a22cc599ffec9300015801f0bc41ebeaeb9258bd298b8fd3441bfba885b8467ab963dfb1131b71f4763448c17e89543097c8001dd5d7e8868918a126952b4639236f73c63a53ff05f4413ed7219d66fa71c8e7fa3fe0af60e0268d4424dd9d43213c296615b51cdfe467958597ec4f7ff2eb5baf25fd20b7b86ea62a9b0247a6065f73c3d1016a5a5e65ae0927ca6be29ec4621eb45f33cedd7a63ac770fc5a86ec7b998018997c1a2ecd152c7c10cecb5a9ccd2c12e2b64b3a7ff4bbbf05ebf80f939987c476023b3ea35c5abba446c0cfc95a86649e095af8f037a5dc3447df21f7db8579c27e1444d842eb3280c467e430b7b774e277152a03b37212a29ccecb15e0e420ac456d3168a3251253d7465f98889b5098129ff39c395f6c584530b6c0d81c877364d662a9e4230f7e2d68282a429aac77dd1c0f1c30247c9f30efbe73d415cae0191028adac64d1959c9dbe216f20bd31ade032bc4f2a3a3515415012711426aab039fe1d79706db52b20e123268600fb87c091f2c36cafb23db04f29f26713c7dc9dc18f12c07fdcf1a5fdf7de0ca7788153fdd1dca401fdf6fa83073008a16f20250ceb53f6db9550f5060e9164331f1d2758f5f5f7817ed61145351599a45a949f6264ee5278dd5d242089ab92690751d3710717ba31fc5cd70f43471cd523652f7d462649f0b012475a732985108658d99c9250eee49032fa524066af2aa662de94a5e10915760495974a62d397117fcc676f33631817a4205ef104c3a1c674d1e3ff1cd8e5ad819eb035444096a9428d1fcded69dca672b7c955602c8677d8ad54348bfd619b5e84bb08e82f9dea2d8ff650e2b10d0c6def0dafe22b84a64fc2c36376894f518a70650f8b61c5fb44d808a5536f5e9d53b6b28ba4007f00b001450c4b11f525801cd982b93a7b59ede60bf41c297b957a416a31965c65eab4286b6ec5c24d19d73050d509dcbb451488365b8a483a1d014a02537075354729275d4b8489b15e1064f68c6895dd122ad48c502cc235f87cebc8d9f19d7a0277ecc0f581aef8f635654d0cc3615ecc2028070fba518cf481eea0314e89a94d0fbba45dc1d66434547574d09e160d0d558425d89f2bc4b3e95eba54d9776be93ace938c0570bff425abc1a1abf843c84a3b040674be49ffa5996c1e4914b38ae9a32e76bcf9fd9bf366bee69ccf3b2344f06d00b2b9446748a67c51142b32a900c7bb4012b4b5f3a5b7634ba78a6e6c1b6c29b41637f009a4a35692760c93d065a16ffea153a7c9b7dfd1a8b766c41fb1a9c47a7aeba6036f57706751a1a9c0349509b5d6a2470d15fd512c984705560334af254a55a6137729a4af831aad73fede84c34a1725211a66532ff888c3152326373bdada0933fcc06de7e9f36b9773c9fc4a009eafc9b583c99b3b07d1fdad609f3d0a6ee163892f7f6f97d203a09459ce8b22b5aa47b821bed5f215c3b0536af7670fbe219b81b62ccdb8b06e6d25f4bfd419ab52f2cb2f7d8df7b2371bc54fa33284eb1923c02309f1e73ba0fbf78f2cf051d02a0dbafa6501c15087cb7deb7fb371ba9d91e02b9db0f91b5e3a9f48496f48a33a4c0663fbe2111185dbcfd20b6dbcb7bcee2a891ea08a35cd3e1569226870e173e46e074ce7c67fcdd7e58797e97c2c5a9ba0e5b6f50a63808c7c56a7909e89b6ff23674ff3913a48227fae53b4e1aaedfe7fc464fd3640071b2e88f1465adb7e7f33220c37dc4ec953f0d9eccea2f44615591797e2abc0fc0758ab2c0214fc685e904b0555d2f3fc107775f462f48ca6da26ce4ab43ca516caa80db8eb64d79f7b375e3f068dd9f1f04099230a96bb12e5aece23500244a9cb49978c63304927ca457794ea42a1e93f07b2179b5b9018e32af3fca44d96c83fe632701f95c258a2442503495a9dba75357488b4919b9819c7813c8bf06e4733d31a2fbb417baa1c4d324d653c211ee728b23348603bc3df1b854c2e296e9f1bbaac3098e4ef9628b90f6b0ebf0a3e80edf12fca6deb3a4ce0994bf8de56cd9a98194b111587c874a5826219f9f1e9557ea7afd4b9901b35b32208326ac76e63c55c558f1db859451c44b0967b495eed1168a9e2e41dd6919f392a75affb8364e208c8f8bb916ace78c387fd14240b278cd7850cd2e3078f3e374534977f949a2ad69ffcbbf8087c32dff2d8cda22f56ce2c9eb209408cb9b9ac94800b88abef271abbf697bcbab099c5cbbf46faf6fba30856ef323e72b4f94783c4adcbb8a5c245eeba34d9d7ca75f424088a0e745d29c0677ab9d18d5f5c9a4fedc041f5839f6797992bed4339406f79ded2e652626c1a02b0c100e728d9220de5f4c6a261d50f412701e58173ea8c724aacee145f2f9b986a761c3b907754a81f49c296e2850e1d7c005ff9410219f8b594d9c95621179a73b741599247984bfd045cce7a5cbba36b325d9a6aa5481bb2d4928a89497bddffdba4351ea9ce212182dfa6832182276ede1441ad78529b131ee3a53665be5d72244d5d76a72bc96a0c4be50b8c12516541c7cb035d3af2dbf389e9dfea344092d2668399ee07a516663a85177fb5adfea90d49eb5355471c0cdb8138845afb8e44cfa3541816867b4a715401d132d721ca93d7c402d0ecfd6afb715696c85b528b91c4dc302ac3d07ac8cbc64c0db350539df1803d6625e9ef4cb66f6fbbf0180f88a83d74753ece5a3190ecaa31e304ae423347f4efccbbe1a20f4ca3da9dc327cf1265135bcdaf7d5353d336fcf09835d4ea14e79bd2e89a0ff76969780de91ac2b16cc334e01f3759cbf2a7ac5bef0826de797cbbb2c1461958ec30d447051eed03216c25a180b7fbd8c3077558eabfacd8fc266d6dbbed244641c80b8b81f660fa05950ded6aaed1dd98acedece5db9b7e1bbba260b5b74bf7222b7bd7bce651443a6ae11c503ffa5e71714b614582327704a0f80bbdb98e9d5a3046e302c3a035a14e0fbfa7495c5b91babf36f9727d02688c88120d5de0563fab076ca7ac6cf602476ba6b4e77b412ca60f3c0342007d632e93d417ff49c62736134ae7f0a55e2446cd6503fca806e4194505f218256025613a6cfb2f2c689530f0869845de1b997b3eb2db8c52cafb25ceea6056c67fd477363c0865216ec9744f42d04925c1cf4f1519809d37e3aaa1130dc75e675f7e38c11a69a9c3b951947cf315533c54ae129dfe3b55490762c416c124716792de89387789dce6f65e5b38c0c11f09588763c1fac3c43778339e999578859f0db3aa1b90b0ea9bbe0ba645f3c042041402ba6c28c78d7e9f90b73bfad300744da832979937a712035061260a95dc4152d9c2c41f843751eea2a2918c697940c925fce26f14c1e1bfbd6a593783fa38a16d364b71ecc43a24f6d6609b6ef5cf76f5ec4c82ec5a6e802510bf6d35330826bf89e03e4df534208defc262850a6db220c21b926a73f20f20bc3b1e99893efe18a7810c50b8a486690c09685c26d458e392be0c7f8dfd6d76de35d61de370cf1a9cdcb865a1d3124e1e400659aeeeadfe255fdb6446ad2e14955cd9b29ff526ab23d1469bf48e97553cf50e991aa8630b791d8b61b3d6cef6eacc08961244959d653f61e1be040c7890eebc9627e8154a1233bf6ab7122d4935a842383b4a3d90ca2e23dd2a01dd18178792783df248da1fba844f5dc60cf776d1c0771059b05e0740532798216ebf16afc4329e43d839ae24704fb11f2a7c3da475acc7674d1235956d2843b6cd1a7d8d76c8ecf27ef3a54b65b54c529a6c30a01e308de2b211620d73be4ef7ee0f4a11c6624b73112fcb7a68a9ca9024e5e5666e5629400c4b2c9fc50b65b4c3cab8ed3ae755f29b99e1f0e1ffb6ad68af5053d60fb156ff090b6728d76494a4d4688279fa3ff7d59f689d6bd8dafb0a5b486b777e23537c6817237680ae1af5e769427f2b389de41624547c7637721f39c963802d9e47354d1994678d3e41265f47794de3c7b1ecd64efd2aecdcdd79acf4c402a583f1589b593076d9f098a9ef3153fe4ca16b5e1050c4cfce3a6186f73e0b5b8f3a7f4a311b912a0f9d14bb49273fae6f9f86a75cd8b2b18905087b6fa06a9cccc9edc2a46ef9c66d2e69a74673ea7b7843cadd8a7d379cd2a308c485913bc084e14c79dcb1ab2c36d04686834275420cf98bbe6cb5b1b8370ba079947149f64a60fd8b8f9d4b80a5250cb6a776afcf7121eb8736f79f509c52681b0793e232342caf2b79be8b35ae92e880c6f93e1e05dfc6992bde45934ae8ff86796db0449df748de085d824794e646ee7a6ef35df3342046145dea207f7a7c61af6a883ea0b53e6bcdcae6634d3a63d46c102902370cfd35b2148faf7a99816348c740923ed5717c3e950c24c8b2f16de59895d19a8c17d9f9cbf8bd59327ed5b68e4fb4151cb8d45d409e1242a470e5bc540b2fdbee7a225c80546f6751d1761bb396a23c88d9df772217bb2b6030efcf9c2cf0f4a4ebf673a4a429be285c5f4f27198baa7ab85a3f61db5061bf2de9760aa8246cbc3cf056f56d29d8dbfb4605784e0f3dac9ae55c194cb6825c296de9e2c2b230e2b7afbf5631e760cee9e4f2c8b09ecda07222113905f03ac6981112634a652013697081b0ce8c2772f0cc2446ab925a8b6ad98ff8101669beea4c4e7edf999c5b1c53414d7cf91731633bb78a876b7fe9ea75865c9c31a5ab7770059e0d0d0c5662c4d9726993c7a9ac9d0ee51b396d720908474aec64d919ffaa345030e8c20b8d68443ffe407e806b562b0969aa76d8d0409235d58d813c4f92d172f6e64e7dca93f7018d5a2e4e46ae9d8f6d9a94bb1842537e561c99ecdf28285f006160527318e0412ac546711ccd165fe0d14affaab9b79becfa3f7fb620650d7b4cf6ad3470a01fa1afe1b1bfc4ad7af2342dd666194602f00afd7542c8c8e4901bcd52ffbc9ef2c60df834b1fff43da988d667c4dfa9b2018dc44d86479ddeb55e9310784f1df3c6dc662ec556f6e8e861611f1b2994e9c271f534028c1c515a2444e55856e3668621164f1d54b511494960ddccc41c906f270a3837e579a858391e76588861e4d54797a4dcf0d9d340f5084166be75034927e49dad465d91966bece3a914615cf2e7c9ebc00485ac53e66f5baa9a3c0b99c69d57c809faf4ce63669490afceeb8ded2c1d2c81e9970126ce1b2b212acfa942de515c7c6db78dff15a1bfbf8ba48869f2e3d65c832f030030118ea12fadb32304328e8d4f50933b5f3979d471686e64a2464d84511683ff6eae55adcc5f7cb909f5c6e5d420424c343ec78259000a73a54a8b837fd37616e36c4a8e2414203e86ae5fd41edbc7da323b4dedee43c78f5e5ae1bde7c6b57a84a55ff8db6e22af4b5d7617629bba4f7373d85944d5949512c8d9d3498621b0b3ba7ee2bbc8958013509ba8b1e17e1e23e08a82e3e95edfb673c3d2bce6d7e318ac3d96999dc320941c19eff4fccceac29b0919adb1feef1d7645fae571b4fd5ff4ce797d8470f2bb7caf67252652d17ab0c01b75e367556186ec83ee313b78e8263b289fdd05cd646b9b3209cc08636debc072390b6dd9ba85b7730e8336b7114816783e82e57677827236f879ba20adceaf2ff2016397fe7929938278dbb2d7fd4629e42280a3db4ddeda165dbe5f4a31e2ecd1951e18cdec9b6ac46ed8974b32a28d757a89d3ed59452e5c148939474e0e1f41424f1c13c45d9be15924a166b0e64af81191dba6ed6a45469bc4a69f639728b71e2da31aa1bbf549d437dfa7778076083ced27c18ceaaa96c21fa54acfcc37b59b3c319ac5b2a978f732185230a4cd37a3e55c4cff04d274637bb279b3a591be1232a8001cfef28fa4cdca740a02b0fa59bba0ae93a76ce75b63cc14719d8fd45fe1de7d35e8f4d7d4d641114b87b54d24d5164865a977bd5fb7f31f07d43f91003f088ec4305e1f6210316be434e9e46dc6a5f263dcc1c7ff1292952261c3aafecaa7a35756796cac73b12e8570f84fa4aea4d01c0b67a31ae496e0bea51bb4a37d2bf4fc6cc64dc275e701ce8e916daf882a2609dbe4056ddd1dfd2ab983be9981f25514470cce52b2c4ad5f677b711c18773373e1dc553153e7c44499f690d42f0d4b052fef3384050ecf8425da1b0c7eefd2091c83b43d79a15ec41e9c3ff54ef86b9a74a136a0df132197c739f226a02a7223b3da5d968b16225e551feea31a51cca5e9b3381f3318ee5ee860513490a9df7b3d5ed5fa50088db9dbbfd7861553fc43d9dec5ba8ac97bf10d9cac8e8dcfd714a0b1e906926b4beb584e4d462df406c70be00472767f60c4c3fc6a6138e8e5a433c81f1e3b5dc91547d09cecaebd778779010ecf4b302665194acf6d6fa8d647afb653e73e41b2110c2218c33d454e901518be5f2c2390e10f9cbabd057c94484564ae502b42423504bccadf715d63bea257b222af7e3d3f266bb2c5ba0a7ec6f6b13af0703a5f8253f30e66607cb33fc56f053235418817bd3eb84a2189980eac7653540ff17bb8c6f9ed915c838beb024285149e871d9a9c88c3c3a0967346b504d0bd497be80ed8037320c32da1a443a209fdee2882a83c65df7fea0dcb70ec6f2621c106759a6b544dd2dda3fe41bc053f399dfd7c9ee8ca6d4df65aaf9e256e11bc7414c211d1bb0b3d946e99dc93eaf768f98991bdf1dc4dff0cdda26786f2aca8b84c0e1204987183c32a71f873edab0dee54e9496653f8c8d613af1ef0044aa9f42bfad7488998e647424070a2fdb90143341a9330a53e94583fbefff2726d5195fcbc9120440c7b37dfbeeab9279248679668a8296601e0a887ff41b6555154fd5cb783e5eb8837026832649457fa4b37e271e3cc578378b83c8258113528d51753cec1f8a7bbc2b90f13dc4a914e8ac9825658d1ed19a59cab0a616aa41e632462ec2a523ca073234cb4dbb454ea0f89a161b5891d88388798041ab38cb61dc7ef705ab13b57b7bb828236c03ab3f02002fa515cff63a8f4da95c62b424c810ec1e51034de810fe799a2ad7f651a0fa25a754f0f787f1e04abdf0492bb21476cd9c8b12b5cb81faa1efaee68ffbd8de64bbeef7fcfb02558344c51df799e9a22cc9e8ad091a5d3823dc5d0fa6fae64388058818c294c032dc6f35ec1944d9cf82f6196da49d3ed86b7304890dccba75fbc742088ecf7c2efa858073ea0e054045353a3eb2f51255fb133aef427a3198ae44dd2f2c9e1df600d338adf5bce99b350174f5bb9f265e1eed4aec6d3167561c3100ae6252381089d0e5d18358a9a36dbd09ef50b4ed7a18c420d7383f9e86b8f0bfcf13ba064166a98ad91f3cf1aa954745e65c7910765171d34b293d66f6c3c443b159f3c4a7ad224748bb91e4fbf0899055a439b1eb743567c4140cecdfdd41ff9327df9f248e8e69a8c961a0d20c080a5b17f63ede697dec33d5bb183dd7fcd22877396b996bb8373829712f7b05cd8bf7274be354184c1a15d8955cfeffb9d5cd465c3c3f0ba23601eaf849ccf27f1ae771aee50ccbfd259f999fefa09cb9e7a2cea906e724eebe6c5b6ae715310164350ce2a40ecc977919433d6c1df98150a31b2c7c5b891b7d1cd2b9034032bafb2bb7c5e0ab7a39e0dc7ff7ab0041d1b2e9e1d5c697412c7c7d66de82703821e1bb6f0d13a7492edc9ce1559660e6a6d85fda43176a7f1a2ff37989e40b365aae78b95e005fc9f5296feb18c2ba5b382b3695c8b3b3c99bfb52d613b9953e7e11ab1cd9d17d5ead34bad5a1ea2ef9b0517bc5fcd91ba860ed9d8a1485642d979645e3a46073590dbb8ce1ec188dbc471446d1b3cdfff0bf0d2aa35e3fbfabbb2c36d29c870ada97518fd4906def8f6037d31e90808055fc026d85bf5f156cb45db8eebc43b3330487744092201746cb124736e16894119100e075ccc8d01d8730a4321910b4e6c505502aad8dba6eb49554c1202ee85cd63e4b7ca2e694f215c37af6279346a07823b5b71e5aad9b08b6d99baf642af54b601123e6e0d1f0e4bfad1a5264f96ea616b48ec7a4a0d2d9a861e6468baa19d337beb39f12268328d98a53bc0e038b343d991d855edbc7ba69fe050d3afa2dabcb91cbfa3c5b04a1f513ba302aba1634d8b00cdc40c81ca7f6444891c9f248f8375c423c63d079a648977c2e5f4f42e978b17af1eaa1a9900a4fd0d564f7ea764b9cdd61697e646522bd4b5facdcb83b6f684ce40f7c3b19e78993d48a3e3fa9740d340828cb589add5c7d4ebdc077d13d6ba86f7f779785e2201358a84e8c4d5dcad8b7ab0f88fe8c8abce65ee36a9fb44bb547b8aaf52f1113e390f71cefec232e5d9fb8d13beaf0946fbfb6d5eae41e78571293c9be34e8c610446e98c403b869bf9daf5d127599be28fb89daf28c32c2c7fa36b4c920dd6f3736ab5fc06ffbb676dabafd6c6fbd4aabbcf750b11655283ea594d7df50644f079664c65be5d73c9977f811d13144e81f216b640855b014871189f91daf497957b1d7fdf4a250aef5f48cd80d5a53849457e041ea3fb3c11a996ea3b458852edd70a6e331b7c7d479557302af43aa672f3ab87c14f582ff570bb2c182d84d66aa855b296e2ef4bd349d516655b94274381d38c7efc28d6a03265e2c88b89100285f8d1494f9b3d14d2262693b49ee01dcf357daaacbf68cf64214bdadb874523c8dbf71f1c853f6114551c87d1756b2555328002a3f2b7dc3564eb6c563ec2ca67ed1bf8c889c7713c2bddca569746e5acaed23b1e69017a618cb2c61bc845ce360e375f563f7a945a3164c6b7a3e1137bfee82384d9fc3888f6a5e34fae77fb1312e8afdd72930e5ee2b1ea512e81483cca0abac64fe59c3817fb585b2a90308d323eae080461d05c63806596b4c82719163df6722910afa0885a397b1d76ebe93544f0f9cc5706a59ec00930191f2090e36a80891fac31f639456d5fd656414506ecd1b6aa2b2b2e3a963e5db4519ae7eb51effcb1e32d2d90792569fa703395fbdc3425ab286c9ca4c22fb8a31930319194b789c77a368f60cc644437f88539cccc7020fab5ae329cb000d4a2cea2a9790ee45c69a7c2312c60e6fd3791fb7bd05c39f059893123f4abc55c83c94533e82bed14b856e471f4c4b2a375d208d47d615c08a8a3bb59b60c0742367b461b465f7b82ea576628ed009bfb5264e3fd49919466a4abff5176c7e8f38b1ef83b67b617158370734729d35007af9248cf765554b8a52f25d23b0458212fee826431448dcaaae4e108f9700caff76a99fbc13dd84b8a26860c944658e5c1323f90dd224a0738e344b8c1278e0a8e2edc71387b255facc900478380b6aa23fa9d3e68a50a0d9963a576d1b186891f98d7af9dba2e0aaa57120eb8dd9aa83166be4c320f030a9c38afa8820586d78eef56b752dec1cf13ae960c3d6db16a6acb58d574a935d62836e3d1256b4d87a7ef1662a0c12dd8e9cab912c45194d9090146edf7812e315fba5613779f54c37d88b47f432e3bd59551437d8377fa67bab388484bb701b755b44e4b5a0b2d26d2aa00d64e5f502fb472f7e436313df69114324ecc0fc50f816a0705a93a94de9431f1ae0e89b8a59d5a364a89caff9240817104a255cc1b190514c4f4d5c272210bc45312e7fc363b126d8dd4d9f3ae8d0559863bfd9e2f8f9ba455b354ba6433b553635bc62e71db4f2b232d52b6c82585ef5577f220684d82a8c443eedeea1744b8a4d48e05a43fa4b2b8d382ac88615992e27bbb8d821e2ad3ad1bad9df2381ac8a0374451e533e00061243d8a7ec7bc65343c1ec56d5e7ff4cd82bfca6d940418df96adb93d1520a12c15527941dac1c8a0d0c3cc231822786df670ae3cf07ea65ff3df56fb8841a6bef4588ef63d044f771a3efc2cde43a9beef543a96741f3aa3600561620a1eb25e033e2c8bcbfee860f035a8d4dd299441c6a228e69b9d74e1160a451104c1f57b55301b38103fdb5255b63295f862edb0b02f4c2acd1c33969f65f90cd228320d98337d4eb1f973ef07844cad8cb6b186f0fde25fa4457fe828bf7f5c690eabdaa5aef1855b95199b96026690504737932a4e4774ce35188222a16c018370b4bec01bc6e33394e496e5c03f79de9504189d6f64f13c83155b1f4ad3ae3904ebfa1c6fbd48bc9af52a917f4d7d8d590d9c286cda93b7dfb115cc07625cd3f6493a3da6a82da288901696dff3ca1de7a095120ef4e1d3778e58e399a36a673b3907a32d7b8bd79874529d39bc466c6a9687ed45719ded224eb3893161f6dcbffcbddd305b99ffc39bd5a9f2c029520261ab54e624ab7eb3ef00a6dd1972a7abfbe56aea702776dc945971c0b1ee194e15fa0e18ab48361b01802e601396d27542f0368a8649bcfb99953fd5aeba990f9a359617346b4916a58711fe6b56fb0816e415b0c0a62a5c1e0bb74f05925709a24e3c480e7b8688ac3ecf53a23c4d951b9b5f1a2b1ab3db18536c4374123f44d9237ce1b0bdb6f7cfaaf96e694b2643587a5b5a18a529d6ef68bd6ecc39ceac9cddb23217c0a142ed6843b157c10bdafe7e9910f06adefda2e6d3632605554c3236b5e74725d3ae8aa8de256c00259798122d7f69dedc53e4f00ef3781a1081516c490dbbde28d8c4e6c68f3580f2ec56dd3f8bf461dee36eaedd1a90fcc54b195773f0fb39bcb2a9a60e66c95a24f707df0178e650f7bc64a94f6161f264a7b2cc770e0d6418e256897ba12a92dab012daf32286bd132b49a1eaec98d7a5bd74a4dc4323d0ff3c2e18297305b161ba83641564e2e7bc04c225d21275139ba3903bd2ee0f6ec3258f336e7742e06763ebec821b8df50fae8309e08f9c04cc8f54718e7eb372a3d46b38d28d057cb5f841210528d028bd868d910ccdedcf792a7781f9528752802a645945d714c772d7f7bbc9f007ceb08ffe77fd27fb1629cbd7bffc624b7fad8c6543ff0ad469372b46ed9716dc44902a862c72c0b179fe7e4c6aa042ea1b84c85fc497e23800881bccf21ff4ad0988bacf06cc8c2be9f0fb3c7827b21457eb1f4f944123d444f1bcaef062c4c2fe682f99fa8624ff29025365f2479d1f05dde5d07556a6d1f63da7949ef38ab3e99560891588d4eca5d3ca5f66de9bc7e252ba6a71364c2c5446e872435a38b7157b40ecd47dcf33466eab44a08e27b6a0a981a2b42058bf96e97179f948c9fe866d86045c1beec1f584310a3950a631a6c8bbf5d9b53746457b7f1ad9232e50484063b9a81dbd773b5e04e7dcaaf287ad2651b41e0d188d04cc0b69052274331da69439590b478b96ded90322d3e22e85d6e170142c5de60376b6353413df1f8d6150584af0001e3975039ebbf4b733622daaf978304748a9aacc7c076e16488cabbb9ca933057760d1096e0d60b1a475f353e04532a07933623402e523b5979618f47382ebd0a8b3e0fe7074712ab8bf2fb99f1a848187f89f97ef1f3608551497b11ef94a4b18905d5eb54409f30df0592a593f595e350144564d7661e3331da9c2c3665e9a5e8b699288ef1e6cf5d4c61fd0f0a9553259f57b8cd0b9b872e22692ef113cab692353a7b8a95cb8f3d22707ccd28ac876671d2af35b05d84fcba34585852eaeee563674e762884e8f3b67e71f1f5e8a224910b096b67dda2d6c36b27581ab888f1b850b5f40cad9c71ee40e4d87061f39fa5a927e2d86b96eda1126315e0acda5c686ada04aeebb3718a0e327ee1503c2ab31e25b9336fecd9fa3505e11e57af43a43cac0ee491c1bc029a1f80ffe3afbef9b37c2ee82a03a047c0beab9e8e8eb083ce239462e8623e29a5743b1cf8169f9539e642c6bc9cb2e6d592696e56fda0ecc18fb3e03fa7420c665450f78a57a7b15ba525c713427928eb40e3e3fd6388c28bb3a97e58971fbeb3f062347633cf763e0913f5ca1865dd67d577f55d4ff131f48c64b90162d4159365a6541389dfbb91c2a71f7d4b293a3f629005c4150869d42d6e51c6ccf1345095dc13160b4d7c7d9a6d616b2dd21c57780b4bdd184a7f2417f4ecbdb75b64cdf6cc163cf2862d68d349a4eae7fb053d51f3d285d7c2a592112dfe77e42160b3336ea6e950021215faa6fe25d8b92413bb57dc6159fd161a365d673c195fc83930c35fbb4a769bc3e1d1da19010ef1da19df5d1b5f3f8b775f03a11723852b160280118a1611230e101a84122d20c6616271a81aa07adbd40b86a6320df73d001f722a7730e4bcf89cca90252936d9ca70124fb8213f6e5520f8542a8a417b27e251640d2d20b611f61c05a47a7f2f358d34b8d0a76e271db7dee652ba46c6956d23e7b0129b14328cb78daab8054d4a4a12a079256f159309978ed1234bb33b4e2cd28ab08e0876bcbeb9e0715f53df6f6813c4c69d5fa8493cad8ceaa61f09cf7579682927408ae16e5e7f0c82949b135ab428cd3c1c29cb9b7fbc4208f463ccb09fa84a688a8f4a577efe95e8f974bec4c011f57817825b2b5d386f161bd73a4059237f967df9314f2894920153c717e7d2aaff15f0a77d1af6b5400360c0aa72e0a92b5593d73362c9df345d47debb0cec9242322060e10cb34ae97bfebbaffc9df298398c942be1511b009e62fc9457cf9d722d70d269560b36b7c26e7969e4c3e71272360c6949f2bce231054aa3a2c4f2ae09d2a0a32138d6aecd616f04a2efb0b543c223b6313651bb26bba38d31712815dceece8e49d2506487c73fcfbac805d6c57308607b52ddc74bcbef138ce18967b504020606f825efbef59c3f1b7fa75090f90a40a7b1abd647dd972af8694eea3293ff7b5967154b9b58a8c29efc8f3af0df133920d311c4372562c307b1ad4081086d426db9d08fb56e2396d44024824b95afdbbedbe1c221904fedb9952f36ddf319f2f5230250843bf39d284856662f633ea9ae747fa7d7b62e7f1f56396651e674d2e51e0b2f708ec75a65ef00627b447ae3e4d004566ed80ed3333f9998b9e5b015b9485eb4fbd67e019aa59a7b3e3db7b8ef1e585658efad3e23fccf3e1510c1e6ef92f8ddd57a26201529debb61d612691f5df131458889328564a96784e08b9979245f231a5c8113c7b1f58f7b78d1b8209ef9171fd159edcfab337a1f90e46d13a90c4d0b59a432a1d816f4e8e4d09d2ace017e0b3c814dd2a41f3978fd618c1bb12344793d7e86627d45e0df57a2f623ab33477ea2459df915cf33c61b341b745bbd5449e26a2842204701dc558ac2559e342b161751fe101745fa7b1e5f60bbcbe909a7a513e397003b31e1d94eadcf471ae9f77ebde14c68b5486e3ebc3ef294fe72f1415489d8e219e2c02789ff812334aec93241f7f390927607124d8a602556c0ecf93e6cc9dc5c9dd38d08d2ca8ac9cb47f8b5fca8116b3e6b1436b97ad37748876ed17d2c8a8033aad06d8eaf2992c899adcd72b118e1129b4d22ea4d9ecec2158bdd0a654ccf5e62ae6924dff2ad44391c9117765cc037c25e67698efdfb9b74f0cb048c1f5e28c11118aec70efbd741de745d0c028181d1c566992b567728363c29e8df0a6ac28c0088d452ac77467c330b7eb4749d28ed706a5b2f94c692179f96fb2e2638fbaab4f1c0acaf07a9105080f66d21b5dcdeb50c5321ea1a46495cee518a84940621bf86d0271476804a71903079384e4250f45a4ebaf83f7d035ba3dd2082dd02ea15eca4d517e8f3cae4870de3af2b3eba105119be013ba7c709950bde6929f139d62fd0216ee272cf4c2f9805f4499fdd590ec08d855cd75345684168bf37cb2c7b3f389bced69f6b2ed7221816a430b070c6761645167ceaf98bab6a7a80dd1df2debda87a02fb8c643de08158814ee29eac3cb7aa05c50bc81edfb9a007858cce81504a10d38642590d41e67d0a0ae5221a9b4a58873c70e9bdd8c6931fb1e5fd052eb457fe6042400decd0a5cb1b20ec4f0d37c9a919399819c0e6a3eae982952d72df239ef88bae77a2460677e37a76ecb3db5f933755d58c556d2053e0fa2293d3c8e062f67863e5fee74d2442f04f1816f8b69279a1647395c317bc6cb58a135ce572b47e28d133b6ed731abdaab8569dd1f1fb477b645ef06702cb94416090aa9d575d8ff26dcaa72374c0fa3f599d81acc1dc6f1f91307c457678783b00179d483de65dee4b75f0b2d5d400701ab2b19d6b18c209177b363064d60741572b17d3b837c4d6b0fc5d4ff02ee8c170882e95023810334cbc1ea1715e8cff3b53d42bcb76c519ec9730ab7555b354f8da7ead11ddca534c6648bd2eac9b957c04a3b8f998f7e8672a47142dfb4a454cb7b565a9d252279fae7837987fb4ae32a566339b12742cd9da62b98b51418b2c14cde87f25ba89f475c047cf830e3221d42af53a3923710e92351d74d393c2a8ab68e04a600cc053129772cb464b4675cd746a6522d942a0bcedbbd2a02569c7163de18802103b87a44fa688da6c0f4a0cfb633b3145795eb1bdab2a921d7022397442573da3a026c375762b15d0a948148627fd203b55267bdeefe56b134f5f44fc3b382d7bcf0fd402ac9474574389a7ebbce658ec45de962ff6010f4658ec6e501487e36cd1399701080dbefff1a1ce3174c50f87d4bf673f5a552d403ccdc554cd8392d9c35a8e46190ca3dd8b9b0752cc821e331daab8dc6c2ddb6dcacc0cfec6a76ee3a4321ee16c9fcecd4127221a9a9603aef47d1eac98e8b0273c9afb7694b28d5d827502205b01c53fb9d2918bb88b088477408d95b0263bed0271a23ac775eb4810809a1350e991843f1cedb798018f7f7d7c2b5256317e69a4e7fcca57ef185dc6aed010e5fc55b9db8872d2c6ad9bea462a65f7a8937ab0ec80bebaefee3e60a512944f1ba7b148fa0f95b587680452fe0b11a6ed1fbf5f507008814313d053c445a0e3dae11d5e439561a57f15c62805a87d7133ec4725b02eb6923c7f35c23e216d84c1ae6887d2c582de7a44971f5fd5fb341e36ead7813a57f051dcc6bead00390e14a2470fe2886fde60457750f1284d089cb3f398a456c3866a518e4cfb5e6b8b730e1c0e0c84847cd55e8ec760f9e9e66b7225169eddc37e9523bc6514dda9e8cb88e6130aef23d145d90a8a385225263840f81905c2f5a37acbb63d4942a378f3f151824d424405e03d38b80bdf5bd524c902554e765dc5622d936ff9be98d230284a4c503d0e188273ecf8781d1c3cf338f950212a3d976d49a0649738090b2937021f5a9c4ad9c61de89335f8c534044cdd7a7954724658962fe6ca6a6413986e34b35069af211485512fed16d098b96e7e20082447a188cdea94a286b013f49b183b8915ef96c0f02eacac521064802989a5582cde96fc00e5ba749a8ce0f2c2da1885f92bd2ce7e97edb4d3da6dc6fac64cffa5664e8f08a011aaed6bbadf94300701672adc7c6e683d7fed71787acc9046b64dddd26a9918905e8d38a12ed5eaac3748654f12660d77462c10e82445be4c4aa6e05a3c2559fd2aba30f06ecdde5711117c415af6a2b0de8a2b3e683a1a92188187193636177c89c9dfaa272a969f16815157ca84d9f39a76595368ecefb8ada3dc46da655396fe70b167207680d97ed17c043a75883757af0b33ac598fc3474395ffce4c0ca47b1e8c176cbd951547fd3cd9200e518e54910b80d30b6377e8f4ccfa21d59d044de237a68a91775e4f16c9650ad5903f202ddf2e01586be76e114660a2f6e4214a57866bcb8114a4d829c9b818e5f3148fa4b828f2cc868fedb748f2bc6e8360daea170517589ed599f9f9c65d7ee34632c96455eb14e22d383a102e1de2e22e795991c3db946f7ed27a8a42c213b7de46c60887ebae5c5c1ba48292e50de9138156c417fc2aaa66097ff59c3f6334e217e6ceeda8d7b40aebb4c1666d73844660f6966ac03bf62481aa5e4ffb036d2ab61a0bec9d9e48a4e9e213ee2f6c4744e04a6d8f4ecf96d3decca9835e5b126f5fd8ae36bd5eee36d4d43b4a65f29e77e8c1eb1636a887b785d9874fd8024c3c7fd9b77ae04f35e32f0c259552db7e2eb48a52c7c0abc99eab0697fd2024845f8ac8024fa0cdfdfcbfc7ca156f89ff93b1ae15f0e4e6d50ab202451ac0d29d2089f602838ca07bdc143c269da7d35d595cd910b962518c66eb7b830e9a3bacf02742fce8296a349ede6d891dabbe3c46c5773b578c4ebeb16812c645ca657ea0ab97a41f19e1425bf95af271d9b5b0a72bf82f3b4d1a1458d27b0794e3104c9a7b2937e1b1b87596952220cff4d3a8017b6340a33616fcbf5bb44659fc41839ee3a1747f1debae408c19c3128b86e0a184f97626f41bff9ce4a0027a9596101e61edfa6654b96be2198c3297873233b432ddebcd27191e15817b190bf342b9c692d6cd5900b94cf28b95e4dab758c7a0979b388eeb0814c286f74d2571235d184bdf85539eb8ceb733c9e093c55786d27c5bba2258c4e566b44c479a4a9b0900a23403b68e27fc45fec81b264bfe77cdf5685e1065b641bbde35ddb87366f80e5f53ba6af16bd905d6cc8d716a646d7b627071aeb900c2e67df33b29bc988b90a2da23676cf5fe576c5a94a35caa43e0b4b552a2d7045b2f8d67fbef0c9b47b4e73010fa641b6dd7c5708e30ebf56c47489087cecef8d1725489b5278534a1f22ad7e64b3ac59aeb7be487ef6cbc10752283c0be807becf616168d95a34de605ddf3342f3790904c2b35e5d66107f209f67c394f654de9210d258544a8dc7bf44730efb27c578449443e0b05baf312387e15b7897e16a3301498ba52fbea39e62e0726faeaa78b13600d7b901af144e3413c54913b783235a23e731a744243859638aef50ae05968faec213a3cc6cdbd20f4ffe9eafbe30d4d97750deb31b034ad05e47c315a9ce541758d76de0bda0455bb69abaf83e3bd65d31890c4a101688fbd6d9b66a1577d4b670587146b9f2eb931ca5d9fb7a8910576b4ba305cc970456c92672106806d677080e800b900dfb3cb83727596035ffda47cb8ab258f2ee43ded28aff8d7a8dc00b0f2f4583da4b7fe819b44902cda2769077c0e00b849c48166874dc72d407c1cbc68be2fa092a3e9000c30d4387cdc1b10af78a8fd099b4798385bff822018560a2cec4b46aa56706a17f0eb388ce83a2d0124466852755d3e5fe69aa8cae78c8613000609fbbf5a5bfc4762773f7015f900bc03f178c9d66fd15b201dd21e4aa66d14fa135c7d32e76c7441fd10cca46e183eaf8d77de3aabe1d8daf27ecc6dd5f70da67f9df60fcd0c881e90c348a1569fceef05079321cc7aad560007058cb2d20f97f798aa302b790cea3fad58804b541b974aad59991a8f3fbf88d81f71ef125ee9e9872181843070a510431720938199d2bd2df6f7f877fbcb8d65df90f3ec40e3318d8e91728d9d980e8a2e5c7c758a1c52168d77339d8367c04d3fee3e2c8f00ba24bb32a74c22dc8b46e6a0ddcc7268a8d5628515803696ce88fdfd80c2db885d2f9e81f2db57bfcd370bf1ab5a80038a44ee0f1d79ff65676668ea63c47e1e53df4ba44dd58290cd0fa51362ea2044a00514a3c9e9908b9a9465bccf6c8ea2193f398f45ed4753a4cc8d05d936af5766b770f6a1026ca001438526c5a216f4dd1fabcf33e59c7b80482869842e3a7178920a74bfb8dcc5c4f0e51eb328fc379e136d884b86f45cd363246cb649899a6095ada63480c4129b9c925a19e4c0fd9591247110060f32f03183affa130522ee60b976ebe1cfd57946d502ae4eeb506c613cd0096cb9d618552f7c7eaea656091386235a6f2e05881351b8b4ea9c424278128591faf8f0245358056fb2c5bd3494203ca4bf82b2439d2875a4c895bac2720ad786433829e23a33fe59292dcaf0975f3f3cb8b342b687757814ed2808acd04d21583e93d9ba09a70d868d53c4e22bdbfb76a3196b51303b7e728aed8013cca38ea3464e091167ac5aaeafae8a26af5c427828b4ff9f8438adbcc9e5b387d9f9f83c33999af430f774735def766ef23884208e40192b9733d4f5ac265c00a02b748a755370e231e925a10e0d97ccf16a922e29cfdfb983fd206d89ab9f34dc2fad35b79a4d919430e55b000a2d99cf6954cf2275e54bb5b5a669ff96d0e14075c4182b747d6cef8b318864c6cb97720164b09110a3d8df84bb55a9354b13d1c412cb6a6aa8eb35bcf6468ce676dd70e9efb771ab9a5516a25231109a13dd90f50c95180ff5388035ff95eb89fc8a18b55d8b639c805c1a3b2a72d32c691d4c419d50dbbc71a2b64a43cb0348d2bd7601b4741405ec6314fb346301bfe3090b8122eaef1999c14b9adde545eb073c8b20340496f7cdc71dadfe79c3a3a16e65d3983f777d35b5a0fa8b870e15cce1b8cf1e7c508bfa29a0a94e73599506a3ed8ab9c66f2ec3d026711bdc1a8c818aad942c70649c3077c8181dc2c0d02d5fe415871247c8e8f698f4364d8a518788aa8bf664a8cf7340638a894103180381e1f3652a980956584fe3e4c9fd1d3f47873244ed1f3c2bdcbfb5987e4ae4036b2ba8d14a84d2635851b9172d1b34e9ee4db6e46a72d79d912d0fbf7e0b49d6d023ed7ecacb0f72d0d14ba76eb19a0aed631f04a728e455be6bc426f1b3fa90fa52ff39fb3ef847574e7d4c027cd84025be48ef180ff799e16e6112dfe881754974d5acba803aaf5a6081ef5566b160c2a857d9ff7af5af574405d22f0b3aba70db03120ec0e56b4cf13421e8ddb28cf73285f2e0b1d23afcebfb2d8f2d817078f28be7f56c95359e4893505ca7aadb0ba8dbea91a73e61c4abba60c750e69d76a308b4ad40ca76f84b1b5fc6b88c1f78940270894297026c4bae936d2e55b674717c8cef4149a09ffbd6020172d949c88787ea39e06c25211fb591aaa575898a06d97e159716f42eb59ae5db6cc7fb2e7a7cfe50a4bf57d53b8e288465f427dfbc2d3ceaa28b0fb67a457714606073801115ce658330b8ebbffd917b6b6aad1e5a78a784f6e1fc06fda817fed695578b5f8736510ff1e169d96ea76c2e318a62c11abcf6ee2d4b51516bd0f52febce13be175ce84d7870a4f507dbb01843c312eb991098d85a27b5108935539bd4906f52cf5cae4136c366a6f4b6041ae357fd8b795cdcd96ea79329e5dc04df105b5d638215ee1706f2dbac9933e1b806773c8446da4de61732969d6635d7834c5eb46dc668ffc2e4cf3dc7f8d46d6d3db088ed7c705fd00ab90a15dbf98df92efbde78351b80f93d800d077caf26eb53ccac50ab6f9f9578b5bb0705eb5425cf72991852591c915b83b5ba390fd1960f554f504f2e8214fd23dde6724e2ce10d1f021421d7db116fee7632c9b16b30cd88d4586c9d42a19b0f01055adf4d896c921b802840dd1380b28f668acb7cd7b59fbe80d96599fd1eebfe35aeb852784a7050eadb32c80a1dab7aa291cb622d7c8bbe2fc7389356eef458fdbb92275e6ee27d69b9b7d2ea98aff021d4e25ec998610d2a986c13cbf00b672f2b102d7db8287c0caae8b481495e85e367feeb55a97683b10b47ba504cf1706c0eac67e550dde38df8924a24fa0ae7a879b99113bd27b77a66fe9362e4737b39d29c7eec7cb8a4ff500dd77bf213289f3e1b8144ad76eb86d0127e6926aad6acd1b1363f094a213299acace6d15654edae8985f4644d2b42e1f5c62afece8888974056018590b00e4a019bde1fd6c4952ab37853fa70c5be1db8c661358b0736f90b1ffe20c75de0bc1a874be81e747647f8bce50487e3f8bbb92216a915ab867eececbc8879a5dfc8f2a353e3d1f2b9db6380e148dac39d5f271a3287ce8ca0c4b252555e03ca1316ad09a9f66b8c62c7e088e91bcc84177eb3dcde1a4d4d5fdec2d1106aa10da2d58f616d1025c98d5881806b38251b0503d219c4ee5ad53f9a6e2ac07f69f1449fcc3c27aff53d1266a357c3f551b6aa9efd86a61f7da713b20e155c812ffcfad91d38119ae7d5a849952568c28842e9cf25d3eda001039a6f23c636c5fc5bd0f9a79062b1b93ad511a44f32158e55be53229f94cd3a090d17917138550f3fc16261d6be276958b4b356087d84c093d04487f22e7688d5a4e6a4f03d100aa77d3c12070fd17a358e45460f39aebfd7af6f0ccf36b9914bdfd58bbc31062590d7c341fa3a3ebc4db19a28ec5e72ff7e59a2f6722391fbedcd7e0a1014706b1c1bd51c387b4c762f3fd72ac3d7a531f46701764cd8c848d11fe3e64867b604872c2085c399c030e2a8bb3a3f7dfd2393d2583543c5126a6e7172748ebc5809bf2802b28ba037c1b643ba1baa474192001ee910dd326f24adf7a7a4bc5cdbb67f928e53d69373c08c0a52d72bbcea79541d5d10077e550ad70e901c54f6fc13336587635c93e19b63fe961382d8191097bec4594d8cbcbb5625fad07c07b4601575630fdeb8e14fb89c943e0dbbb5f1873f702564d5d75d554e7640fbeedfa3b7b0ffc4f4a80c2f6348f8869b0ef4360212ea46e724bbc08de2a427c2bc2960bcce4f781ad86bca50055dc12f0c45cbb9e186a9add3e73c359c75e692b166e09434a85e56bd0f9d9646570fb9700f09bd6784c0744e3e14af8fac82637533c983208e8679adce1c8bb430014fd2b43075802d91979d71106555fb550f5bff2d4776d7f3d3dd86b28fe9a370e298c9116b46c3441ee96718ff3ec54fa01f86502468c765f2c5d1beb6813fff00517345dc833a80c984ed7255d97ff8881670b10b90310927a28f8c007c0672e23f789c4a5eb24a2c79f9f314daa90ed437bc7018f98d700af5c8fb198bb1912162f494291d8ca71ce6975d52c931173522563e08cbf3588ec93832eaa35d035b2c912f26e7660fa3b03702d3b3029072adc7738f433a08771149fe4fac9c8d8079276d02263775f8ea6141c82d9b5774923f7bb004e718e7f4b18f0e4680b44dd082f227e1025853d966d2daeaa2a5d2bf982060d07614de47fa57b21424709e5862f43d8788ddca3ac15be691bda40faf70e1a44ea293583048f48202f30450bcd78156e8820686dbd39760d2a188398f0e8e5707e4819a219a95edb8b6eb14d1af79ae8bf1b774d62698a8090814139c300d6ae912300152949089838974685411015784f6e35ff5d0eac016c03a10c8e5e081674474d21a0ff559a5623aa3846ea4afb9f41f2aeb0c3164d09e7bb8f5df2f3d883edc3633e5e7ed9048405af2b5779c6cf295ba0a9dba1122e854017fc4209f8afe695c01d7154fab17cf69d48b1f180a5c0c45481cc7cc25e342ec4e5b11051dc78eca9fe3fcc147972da8a3d2d0ff56f71c909c9455abd9860cf5a7d176a33e9b0403f3801b29a7679cf28a7b0cfcc22fafd56cd945ae9f7bb7e1495cd4d34a671b91be72953c0c3b30239aefae4a721cb3eafd965c694229c16cd434d3b8de268277886a50a42ee973b52ce187e9bb31f3b4ceded239b653ef287330e5b1c447ac5f200255462b9e90ee5ebf160af6a1f62be8373e38118fa7b143be90f2972c88dbd2e3ae279bc60c8a59bf4c026128403c06d62788af6e6a521724ef02fda147f7beb7844a00c5e3f7ca7874a0a54c9f7805be78d99158a704479c798fd36125b781c6d2ec35f55984a006a7e81fc06e08695b9b4cb1fb91aa9280fa4aeaef4adc5c221b659b2602341722f504a058f08a09a8932efd8fe666be2939b5c6c985786d35ed52e5c571c606a1f2de7e03840f1a44fae368e848f382a84b653d405283f84705d3bf2e73a423b28394a456bd057503b93cdefb5947191410077f9ced763e41ecbbba1d7ce9d6b677f29fa5a06c4da8c4ff5dd17f859b7ff370bc33cfbf6d9371397c1dcfae99d7d9f94356087f244e2984587bb7078a366f5353a68b92c433f0692dae69cb36d12594553019ccac6b64ceab084b1a383b8b6c8b4b8b96c36a70f3587a4c4269c9ff87966a6f5ac3e1506392a0739fec2309496cc9a2753dffa069791816a6fecf9519af20f8091ca266d97a3deaf945fddc90ae4ad06e2150c3f036b16b2e89afd5993c3a75f36a91e4af9b2b5483af0bbec610790981f56e70104d0ae0099842b768ca80d43b6294e1b1bd05c263499dff38939a884649c855e9adb18aaa8d16300943adbc08da755e53222cb9d90b7b4a256385040ef93216126dc980cfa436b0c110e21884ecf534d798d01b042b8d54e91d9a9bfa072e2f44d32c9cb66c5c1cc5743267e19af012b9a5da023384b1d2d5397774271b40f07da935c54f857e129efc0118809d070508a88cc59c4e52c6b39bcfd4da1f09028a9fd987307bc5de6dbd047aea4e34a21336a1cfa71da8434de6877b47867ada6eb13a27530a635913acc7ff0da525860fb31d32426b28a7a453382f54df0d728280d5860021cc90419e5c926fa2f35bd01d1e1731afe2f66614a312f00bf0e909d24a2842f36f36702c5c5b81171e5b6dabe03994be47b7c94aa78b57e9296fc04f350749eb4640a14ed2a8354f956e36f376d2359df689cbf271678379797094edafe2aa11cfa337431cda9e342de62c3d3ed19a9634eb063aba2d944b13d2f146bc833a1bbdac2c4d26a99ab5cf5e31b608c480f7fd9fc248391e018402e04d8073c7380c987fccede109a17a61869a492ab0b538d9dd4703ac0bad2904e8ac95a5b09f2d51ae5db30a31a142120f74127df1322c7970e1ef7ffe842550358b0fe238157d7e8897529d5608163588d1a89467d4017f46463cb5ae2815b06a17bc90cec9de1f0858e52161755d47120395273feb66b27fa34d336ba4f936c9b9804005a153c2c9314bc244e6f0ee91eff2f6c403dc801c91187ce7f0736b742188e1d8616ec9f8a234a0f4f6a28c259aa002993f592599f2b8cf2200cfc9736f0356704cdb314f87293b058d419bca22db09ee30507cc508ca5d8115f8c39683f70e096c779d9e235cfd81afde131f70c4c6e99ec71bd468613d4cdde1cfabdb99cb6ecc3896efe0d3c3297dde7375b87b15e50673e3f61c4207afc7342d619d752be2fa6ae25072279bf9cd58b7c5081f33a98e9e4d7461dd498a6692089a0121c4ba161a80fca1724b15e9b7ed3d3a3aa2ad9c94c96ae7b7cca03ff16b529ca03cd53e12ec45be27f29b28ef060337f0ea6da4257a3ddd87f64a22bfc222a4279728ac989b161936702e0b5ce53fcb630b0f67e52a16c094b68c724bfbfe0f3544739c297eb49275cc161f3b27fd67371867955f73378b5d99a194678ac4767aa766aaceb5a1869105006555e86afe1e065e4e8f03db74ad19d859c1eec3b37ed7204d42c911a8815e8daa1478560ab999e6c2776acce1208dae1e5513821318b20f9efe7aaa835271e9dacd91aaedc0e201dc09d82a9f234efdb6e438daff1b1d3eda8edee924ea8c19c26d66428daa1ae18d04b174ddfd22883b38d2255ec00277a71785bbeb37a9dd22557cbcaefb877894f1d5db867bc3dd4e17b04d556f561fa4bfeca4b9c454015247820f803eb3230123fb816f7a36501d7bddf5e758603e39de67c06622d7120e49966867c379ae29f593a17de466e3aadaf51faa8005d3bd94068eabe0993302fbdc1fb7241a4f576d83273d4917b070afd58f0096da98e2c904ec6d943150c852e005a602950ca1103ae2871cd959cc26013175e0df33d53442fedeb6f961c030557e137ae915dfc1deaaf00074645f8b60ec8998c905c6d9633507e1813af1fc8e79e6dd28a14b499c41b14fb8ffd3ce265f0c1be529cd683a98c3cd7cb91abb534c2bcbd15ada950cfc055aa68c7556e88a9ae78493394d6dae41cd1baeb840dcf297b3bfce2b57a392efea1e5b157645f3a3ba3d70764de411eb220dfa7b510550f0fba382e09a920d75218db0bcbd89fbe96e1f51c8ef6e18083aae07cad6b1e887dcf93498782570cb310a710fc8165b781f9c35c72601abca45a0b4d1d73b4a95c8ad481a23d209b74edaa2d77d696670a9f0ef189ada4a1954ff65b262d0058fe3016b8873bafa8534102282237071e6f8347e03c3417a9188b9eb2b198fd183390c97299dc5fe6d68fd54d4917350aa50ac490bb113707db9616a93a47a22d6df12e37ef46e7c2f6c9babb01d268ab055b72bcee2cc2ca493b605c2acf4ccf32e872090d42e9417b4d199deac2e0c6451f2280553430e3803a2415d0fa55bd9698247f2d1e0a1b4cff6b9cc3addd02c061f88010f7af1c4b1c4a2ae2c7cb4cdaac32c1adadc1c5326f39b63e14c649ee73c86f20b22b718bff999d6679b294c8be8e97772a48e4c1a56ce2b08c0f8d518757565ef2d09c7e9d3c18ad625f8f35bf867cdbef5f5597bb7d3bfd987f1f69ad7f7b7d4f7a0d9dea7105481f2f66bb64704f4bcda5e8544f9893f409180a95e270c3a781d28d731aaa2f4e28128110914eae63f8e79ca93c626617207239a2464e6c11e3e3d63e9fbd9c104a0b061e10d56c151e740742bfe33b80f89d6c397a348a8f23b2874441739991eb61156dab5d7ddbf971511f7441fb6a7a9b2d11f7b0ad327e39d7d15bb225236b2f3e3e26a929545e50f98598c677c76c870b650416e6c4dc237143a27abe5ef10fb5f2690b5653033e468642fc83d9a0351e82916ae56c652e78a7720c75417e1e076d332cb8b850592e06220fd1e30807fe41810c62e949319f39669e0070b034168a3eb91b9467b45f287eaf7f34cc89c45778d5d4cca55650b4561834fb5c814e75ad42cb5a1dfab5da34b2ac45949f454289fd40a4d098178bb8d3099613db39d32d076e2f9581f14a1bfc8c7b436ae7ff8ed52df7af0e210c0e89228926fdb1ed9cdf31f634620ec135a36e5fe92c8c403ef74936f8b7f0139b49bd2608a802d831399b67b3a712bba7c93bfcefb2bf15e3c3017314c0dd2dc856de0d8f7ff62d95ddc44f36a80c298af02f3b2567719bdd13f4b9dbc79a09df687e111ed3b05182290037dcf4a020f56276568700e31b5e6e6a546b2a47a87099fee262b41dfd8999730d9dd6af39f4806db7d19019be1b8553710d670df45554e486a56b2f6a6ddb1a5e7a1b1e024d77bd5668c0f9fc3813ce2c2de6956676ed8248eae41e7122d3443141460d94f3abe2f7813fe8df1f2ad507213e4b01e6ace837f33ec824a3408d3b721a22bb981a4ce8f9f3d092a2696c1066e30f4401e039ff738f470bbee10ca6f21065105dcfe9e7e443913a26063f1f299c6e895f0f2252f9c6c07e407250fe13aa2cb284aaf9ac0bd9332f6849039ef9050d6ec5b8891548797ccc055adcb491cbae7218500427269b2dfafb9f7ac21254ed94be6a8bce082e34adbbee85c80934ab58ee00fbf3eb95d5f7c2b0cc73f8dc64c2a082f7d36921f4a249a62603b35554b4ee63e70d0bfd0272e2f5add2ef5e0fcbb877e8313822995bf8fb42e177af75e6c53ab3e0d23e558d850d251b75654e4528475d303ca50fa4aa76df3c0187bd3bbc0ebdd6bd534936a2665a9fbae7887f27e179f8dfb348d8955e8203699d538a540ce6860edc57aef8696a70add0e3dfb2d515b7a795e339def52509810d72cb8f6b6caf4b740efa5f6b66742252ed63b291fe9b597d21eb169fa91a4e81f6386a11f058b5dcb076de6864da1ad3fe1824111f1e11ece6c3c87d290e92ac87dc301f2a560fa9708722d29af5fa31a6aea409e33426356324e11d17a1f0906f0374c7c03bf064f1e70be1978721ecac012c116bf52bee0a6939e43a525c1c6498027a31806b27d6506d7eb89aa97fe4c7ff0be502c71411b40e8e1827a417ca3f52a0732e1801b2df7d881a09cd7f04a1b3878dcca4cf7aec21b0a00e877fef265cc3b61e650e417f207ee19c64c724da1efa1938e17b7df5494e49d6a081424e25097910ee9777bde5d09d6b91d9035ac358aa482fc15aca43f21653a82c52ec879a7bd3f8a072ed0c17c564d59f64e68743215ad8822799031699092a756b1b834471e689465fb7f642fcd4bb4231845fa8267e51dd304d84887622bbba60c2dc59b1797a1a65a107629f2d9c7fc91632eacf44965200ede1286bc8b9a3e23a6f1cb884567322683ba4bfa082a17c04d1be3dce64c23b8a72e0fd3ceaf154276ad4036c73fd47c85bac46ca487f9f81e9326745dd4cca4108474e9c656509de747cfb712f803742e6ff85fb8eb72c36bab98c14db7c378e41ddeb12505d2ffd752698799b741f5df8d5650f25cdcae3eccb2f49af4dd710a059a8e5c99ae075402f21be4949935ec23448301eb2654ac1d70980c1048bca4e2c1bf984578a8caa37a0b73cbfa0f93c66b1b1d5a898cc735a64b7baa8a240c8963a33434985f670052e347eab554b7f082833fb36bbdb46612c65e388348a386622d603db29fa02b290e3392f90664d5791e3b2005dfd78b0051722653b4f04d90526745189f68572a10e102bfd09544e05794086d69f3b093e5aa106b8d8786e0dc358fa52d4a303edca32faca72d481ac61df3842db38aa939c8efe2e8c2b9aad66f5803d6841f8f22add258f09001dd19331e9bcb4dbd13056ec8d9e49a5f52f7f6f245c87ac38732ace97c585fd71a8be3d1fd288321b2162c12c94dcb22eff121670f4e26b18e7f50be70ad55b12156faec775e9721d26c4e90b8ecc5db0bbe7103348c69b29a6e0130a17f71b4d1a9cc545bfcd44b2c0c794c970f96865219723f31f1fc4fff9c463907a66f01e5ea098d7918235908ac7742f464851266b8b74657f3339c53708d1f3b0dca9ba3a36a399121c2b71156b6c144c3f86a15f78d9ba7f17354cd27f3856097cc86157993810b3bc89de107aa24966cc7602fd1b48b24b4c81083fbddd68e3315785e2716599fd66e9c4eb1e14ec9c1255642b7b274e797aa4bc4b11d78fa9311cfe44409725f65163fed07602aac3a2127bb4ed04602a8a38121aacd519cdfe00c4aa25da919e4fcccfc9a25ccf17a2e0d8ad3806cf54df1f45ba30aba031ab75e0b02390354b8d41989c8eb87fdcf6d7e704c693421dc2a59884dffd3d4f814a4dea1db6a495d99177004dfab1859cfe530c13362dbf786cf9c0d7312e6246cbc158b09f92b7fd1b478fe81eded3f3faa4b45bd82bb37e006767333022da07c51e536af8f9156f9afbc83d95a5c62a1c7b188135ed10173b0845ee372c319c7de22aca3a333ee6ac0435022e7f30f3d30ae770297e414c3464b00ed7a1e8d8ea75537f210939dc47248d385b1af4ca674c2304b7f01f12f94a02f9d07607226c45f6f8fb9695a78c35b10c89ed70eb855bb77099324ffe8d127d4edd79d7f14c3b6294b9d7158908018add32b23a20b24fe951038a778417b10be91825dd511e869c231dcddb965af0bb0ba58d5b9f3f1c8527a4a8e6fdc09c70ed4b7190cdc0293b8955f48f022188ceb430de62278771bb076828228fdc1816a22df73dafc91a91e2bd8caf0c16c2cf5e8e8fb388bafe8dec405065b21c283ee530d93795bde5ab6869b523d2651a87cd76dddbfd4ef8305093a3c5f072d0fe3222d0c075300c8bb879b7bc1b16278e46c83ecdb58d39badce3092f39dddaa3635be5b5de3d63dede77d4b6b49f9435e6139704ed1be05bf1b5d61b6ce72a2ed02d78dc0828b00f5c79390234bd627ad4882ef5be4a577a0c607b069357ce99e6f0f22b75ed6a2795ba2af553539ffa52037a8a571afb20d52efd1f51c0002af59f46708136cce3bc328fc53d9aaabf9ce117827613b7b3153d099ce2b5b27fdc6eb9c45383340caf3cdb89c101e0b5ba6b437ef43a0f7659c5a43341f2ab2811f84c67a3b03ea8dd09b2d16cae6d3e08c02214e27b77795418cab338fb5500393214aca602ae243b343335af52bb945ac7652abd9b780b060b41d606970a050dd80a031c2d357a61db4fc8910519253156b7d2d9ba70ceab5e979254fa0e86670aa758050dda4297921042297dc41729771eba47283691350a798753e6af313a0dd8702f33413f115af5d23894418daf90f228606516a0c5687d6f97d4dd2cb0f80418cd164e02d54e92171612360ba74dfb9196027c7de838878116cfa00ff13fb379747b13122e5a992351ccb74d9bb22fe8b33ffb36a8911d7e6d7f4353dbe4e0eda55f35c9fdebe6d3ac3b152e64131d372a48070cf7d41d5d7f9c51aeeec25626b7e2584bab5aeec6e6974ed2a83c2f583675dcff531b1d6c588c0211820ea42d3a681a48c5b56cd52056516db5a89d73c75d4e22a6647d61341fe154da20b4e28793d3db4044b095d03c8856ac53c69c4c4391d26eae7455e18ab150ffab709b6da1d0908bbd18a78af01eef25f7c3b6b23cd6169dcba02c9a743a61f6b0241a001df78339b7320ade4f9b0d5fbb387b53cb821e890af5f482cfe7dda02a875fc4bbcf7b6e9a85807fd898b5761b46f9092518811e6731700ca0400463b73cce41f6eda40c0355a58791ec6c4441d1a845c363290f1b20220b596402049123e2b261bbc0345fbd8bdedf50b80d5fcafd4af2a99c657fd020fa3309c73ba68dc43b4b3db5e6f22fecf3461bbc7957eed87e727c33465ba54f768f860c69fac5c5312fcd1b1f1ca361da48d6774179b0cda473bd9c4739acef56aceea86e96e4adbc003142a6abb522a815716b0fee96d74e9bfca05640c10ccd197ac61c0735c31cfd5eabb0d4b0cd18848bc9fe0383e0497ad43c1416511c66317fdd5ec50efc0202e8812556084d057d77ef0ddcd54218667122c9e3f9994f74813a2450b6df9c6e618ec0e5b3397210dc6983d5e46b688bee869602edaa3c5bf63e3373b033438fa7e3faa86181b72624404d9a3d432fd3d22301012115f3868a84c223199ca183ccca90c75d7402ad28cfab63b005f046d33573828a1ab0dd83bc1ae748c18456e7b575e98395f142f21417b46ca9df21d40015971ac6b38027fa835c958b857803f554b0e50197c66f24b7116c25f087c02e53e1720ef39ae6855eaf455ecd2694713b1ee0a6faac78e9fb8acab31745b3d3c93c03a0a61c7be0a4240ae148055be50f9628710aa2c417eae127530d34c4867ca3d8d22b74e2c0db640c1fc84917bf8f5ba744847a0160c1d1983890969d68977ddb8cc9b551f2fc2482dea6bdef361a83d2119ce5f04eed13055a9338476c2579f57480285295fc299c6d62abe052e79168e856170bce0d3be8fa509fb5f89bc22529f52758057735cbe1c20e17ccfddf788ee7fb2358e03873a5a5d542176cf1ec68a4efaed060f281d1a97c3c0d17c8bed77111101d8f6cd5926247d2abf433badbcbfa87978a0777ec60dae3aa3bd2b2dbaa3553483e5e533e9c84dbcba5ecc56e3465978aead6c6674660fb4710355825df89780c5337bc01a9614e3d908dbc15321c4a2c7e1f290e5736ec990bfc8e86e4920f39b91dfa6aff5f97f0bcb5679df85fca6c51dbb8975a547bba28142e86247230d7fdc45fdba045a281cbd5efa34f3229a9d46d3aa968df54dc017e3617c716194a6f2c1d1a293b0e61e5e1c91eb7e9bc0d47306e69569ad30b67b4db35dcd3f405c5f4ee6443431d35146887d4e1d72706aa85028c5c6db6409e7aa170b81ccdadeacf1f2d87ed219ae0b51493f5bf2f0cc32bf8e193e36d71b748b3bd4725c0142a42aa5f4220be1118e4011bfdbe66b7a87659166a11127842f6003c2706fb4efb03e03c83b369fe9d70e4d5c7df46b63cb220ef2989b680032bb6b7728a8db1bf346cc120b7b2eb587a6ec3d398e6abae4369f98e91ac6f94223e3729c02d37118c8a67fe430c227b96e417d49db5e702744ac77f86cda642f53979a7f127c255b197ef91d1c7f11b94ba8046a8c0d9d8c3caea6ff5dc9a34a5adb40618a15e17938451c0f4b5161b1b0080258cdf40acfd2341ed72d23a9a53b88eabb3ac47ff771b70b49c85ce24af11b57c0fb4c2f632de5dec0242acfad0d62795f75a285de626070f1ea0032d00f2abbf25988ca2531e5122f929fc9be6dedf8e37dc5f4f1e7a72b771631a3efe08483d6b93d5a9d07812a324a68a2b61ad4b911fde44016faf31469cfaa7e0247e1f09b40c4bf93a176e8583f77527c17c6d69a80ce63dd35687c060f71149e2688af5f2be9cb1fe3a919eb63644977d581f18a3ad15cdff36e906de535f77fdb749a6b4511184910edc06ce11803feb5d38e3f669604cc77b08d2dcc1fc0be1557b723618996223ddbee769011640c112208486803d136a054a4c638ba7fbeec8701780b253156324ee6f27e961efdce27902dfad6ce9286fc868515bf0f67e220b06d89981abceffe7c51e9cb00a95a98efc7857fefcc61ee44df0bbd381f18bbbe21a21a8846a5fe113ea6d88baca37d1e25d5ef1848d1e28fd64251aadc9e62b74df92e929b242d9b337d93020f0093f17917729314e9af9db16b1ba58d6472b127b29ca42537046ecd48d6597ec58ea2c5c8be80170370a2f9a5da9eb96a88589fcd1f36960feb38e3517898b323b19163aba328cbcbb3325bb9727bbc051524ce092da70cc349cd74ebb1b6ca658aa58327e9886c5a77393e2fc00d89c85a76cdb7b509ee8b7346d04862bafa407b6a728ea22648dbdfe19572a669b1db84f313f8b18ce8cae4ac57dc1c93772494adfc0e4647f5d668ccb2a215d7e0cdd8523047eb39775e0546c20eb53995e8b7ff41e876cab85ff56b0d6768c644a0bae839efb6c52b43099addfe600b5283cdf38373e4f8b5d647351b10429abf5fd72349246eb2c1be0af794637474556b1e6f6576481033f6f0fe1efe8f6d81e31474c8fe0a1fd9df527bc3a4d53104a92ab77265ac03ac460a4a2605fe8afdfa18a5b248fb5a060286d3cc37fef956e93e07f506d8103a6e625ceae65cefc8c5403cbe41c8636d07a9aac4184783eb667e38324953a7e238cf07bea49d6696675666ccfdac6e27aaf44f12de320f0e9ded804e846cdb089174be63b0e1be2bbdf8722afac27b4eddadd68a61f6fa6788f1e4c051112994a0d68b99c1199d0825bde4bf0f631bad5e7343b3f6a914bda707392f80c0af31f15b0fa6cabb2b69d81ce781eb14452fc9433e94192c4cf67e17700a31e81b7a2d76defc7e06e3a7e3899c8ef5460311067b719ebb5691bf893b862fc6ae59f5c30d70931ec2b5ea595a603f24e8f40f6098eacc102212db8b5fc96695ef5d486bffcab6aada222035b22c8f87d3e36dff36a45276dbc2fc3911efb05e2bf3074d9a25cb706bcc6f5aa41c073b4b50d74807bb4d534a1e0427f91810bb1e643466e22110b8d02e927da954da1dd28d20f9f7767a268acb743d8b6cbf911d34641bca39352bd56596786fcc2261e46a9a848013f31a8323b9f5bd82080ed41eeb9dc6668db6ba9f86b7e7d0b3c83ba65acecaf7f77fd141e5fa3b547151689a8325773c48474fea6828d45596b5e6ead1aab650b8353d8d780f2775eabcc3598a4e3c42af9cb471c69c6860a2f07582f6547630c66e3bcc9e832ff5b55bc2cc2430d55853c5e2a0a3db2bdc87f00050d0f3b2ad8bb647b1802d08b775d4913b53ada1bf5db9cf1773e3fe46884de805dba3db93b8f92079b89edeba9cbabbb42954cae829118b68368b14091ebc4191ffa3966d8e8982f8b7a4f12e0e201b51634fdb35f66d2a1e20922f3904d8b9b8987255b698a26b21c2a98612e41cd0c81bfdda1fb5e4f8f54191c7109cb79f2cac16c86c5f791a2e4f1b4f2aa06fefe6f1a884c1d4e5e1789a7254d3c3d57a7a70a6b132723f499fff83f1f9c7c88cbc7df2e00de286247faaa3b3de7f680a69e87b602a5843f09575b213805eb2c9c505f38443c56557fc0a0f9a19eacf35e0437e0435dc527bc919fee26306e68eab41a5c3e5b0aacb5d7308aa08cd0076a1c36fa971d01092c423365b1c13c99a7c35642858a0c796ef64e561da2818e0392dbc5d2c06bdcb6117a26cf03a64f9ff41c4444149900a7aaad16fd6024180066665c7704d41db797b2dab3be186bd021a0d59029cb1efb1ec84e60d0a660ab1b443abc93a2af31a2b6aba6a0b3579f31f3065d58b5156af52472bdf06c20bbeca90c8197636e4755f3a127482341921df7f34db3d5a4676535cf1f10f1ba7ca1998ecf21a61d028a41780498f8f3f5bf07ac37aa43c80058622899c9712d2bfb275414dd8ab6ddc06cd565b7fffa221234e43a958a7e6dd4b76caa43e05bed947e1fbdfc4d6c45eb82943a438ff2155a311dbe46ae3ecd46f2c6a21aeb5b29186acc7c525b7004f84b6121d95a1379038a17912dd78b336dc810024836574ca0e3f02385309ebf8276a037643a3f6afb38042d720ab6d299ecb19298353d1475c4e11cc6c787c26902376d3dc247124e9737e9f653e869d1cff8d043c1fc62140d4f029701467fd6fb5d21bd8d03e38dfa40e70c581d70bbc045cc13cec269bdcfe341250499353ce641d15bb6a461ca262ca0fbffaa6c4a3a902a94867e004af6862fdc3d7e8bdd560c9a10311ea52e3bee8ba0180675d6a281fc733ceb328aae221a57037cfa825634d5e5aa343c957f41c30fc1d0474ef088f70874a8fc09105e55cec813acb544f78af88c78d86e7b11d18c43b77fd674415c68c3898ebf3afe9ec67bef28452d54ffee087acc9396d4686eab2095a97bdaf3c5e8018ed8f55d0511c9f614f53edc61497e3ed6b109045b4a5405ef8cb297121b50302e357149413269f0256cd3cc32158ffc849b5a49b312f774efeae93e01b715f3776a2f0c9f77541b294946d59585cfa5d67fb2a2b143d5314e8209b7b326e80297a49310c3815cb486aa7791c897ca80585435bb37686579fd0337c3adbe7aa4960e2a5ee5cc1baf86fec619ff69cdce75b40487432083e84bf20f43ad9f5766804f4ee663b9a709ddef3c71165789843eb88804391c2516d5a0585439a65e91d5b38243786dc9b5381c0b1def3de042a5fc6e81841cb0a5dc093d80a2ea9995c6ec35d8e5128c681fffb69ece8f3c460f39caeb1d167b150aa9c0d0de57a0d2a903ee4bbdbfb1dee1a04efa1f7be2585494f7a5b2d91a245a77a6c040c65853de3af84915489ec3862c7bec3cc0ae9cc9d99c83f4c1607fa8495da52eaaf82e707cd9f17d78b7c23ff2bb2bc06ae1eb704f261f636057b9351a7fffe6918857c94f5f2aab9500db13113d9452252af700b946b5a50f3c2e657c4c4dfdc722268dbe41f5a915447c6c1347a886f5dc6bd08135e527e1bf7c9d2b79fccb889687e9171c4d52db194326bf4351cf9be5dc92894210e8351c72523dc1404ee3cc6b0bca443f0bda168ef0e5751b3b6b0665c44793130cc7e0cb147139d4a15e2f5780bb91760768b6698ec2d334327412d3dddf3e5dd4a13e4d3844452ea71e0c57034528dc191a3fd1ad5c9056a07472e86a7bea3bad7508feb207edf76d1096b890de48fa1fc4c7e2816f352cb46f020a8a0fbbb6ad22b7f3de31d30e1271f4111aae9029b2cf576bc4c057442dafc2378ea29c33d1a17a16930cf7ebe48bbf40faca436c70c6d350acf7c6914c700813b44bd76a72b6526659149f3819c16dcbb56f9d4868296db1604c6d6e6af5e0c81bce4bf4d7ed5e65b9bb356848ca6827481f0a21e1fdd348fee19c49bce4dfc3642d5aaa634d124724cb748b5c9bcbfd336b93307d9739e95fa56cddc2fb13ce577a78e095ddb9bd3f6dbca0ac52d63b1157157b0a76596877acb5fdabf7dac382d616d2c209b1f35be915073e9e5439d670fa122c4a6d585aa74c51425663af816858fd7b78b8a5dbe1e4cd17e25e3fea8a52df8a86f8eeef65baa2e4b7b334adcbc8e192b36dd74e45ecc94012ea581ec1ab8fa41cb4468e02174bc439e6856d8b22dc65e62e34679e5fd829bea4887f9c56eec8f48828d90ea23323d0ecde6de46ce550d04f801ee8a744925a878b1f29eb90e92909f1ad01e0c9e39cbe1f834c619636fee5cef8c4b56c04e2f3c05c70763b42428d99cb0589cd3ee654b80e3b20fe789ee804a50e15f9a010811574a7d99134bb9f945b672ddab7a4878f29b02ad58d2c71de3e21a23d2280c8893caf6a01024354848a4a6f08346ef7f589ba435d5f47481273c260d446cf74fae310f1b8755ef21e24e90738cb3d488f1ab09d91375b0ea51976a4ac187ea4be708c6a6df1f06c1f6ebb47e0f93173176bff0286cbeafe62d403948f86c04a0d3afe453a6c62628132f302b17924a1bea79befee4b57fca1eefaac8e7b2523c5b2c210816e58084ec1ad32b851b1219f26ece286aa064e8bd01a4ec52c4f1af52b0a4c9cf8066ba4a13aef30e2ddf95c747eb85f9c1f1d47f92719a1508c1d20bc7b1d722d6f96d0dc556b195299e4e6ebdf44cd9150e8b5e3d751a617e68b472d3f6d0468341bc10b53d26caa7d08d12aacab8642a7100dddbda7634c59f71c078688e29c815bf84b8bdf1d1477d2a1aa26f86e0714f549fd324a8ecdfc1f40e96f38909211c1ba31c60ac5680c42c93ff2a9c834ca1a2bf972307cac56abff3643a0750bec0900591bf4842f902b9103bde913c53083e60eae3f8faafcc87f92222e9b31a2c5de4f65a9b11cff989fc96dfca3e9c930725e65a427c2b4ec93d6fe1a96c52fffb5c4fcce41594a37b4e054e2a7e39c6e8b651eef6b2af6d74a1c9cbd1900130011ae9110d02455c766b29591e78ceb4e32f91951a0d04442e61e9aa71caa3b7e3b8ab4b44af3412723cd2466c2c495cdcac94b832ff17890c2d6abc1a7f67a2bf3a200bb6f9ea412ac88218a9ba4e2e67d6fa721a95c1f2838220082fdeb3140b8c77ffcd93547a4eea2db65cdc965eafcbb1033f0d63847a1a9a89d977766809ed0441efe6583023dc673f01622451e0cf07195766b9d71cb70f0dc5328e1f76caf4b027794d9e4de5abacb48d5bd8ae8218a763c488700ccf975277585e9d79fe7d54f545518054b0d71cf1be0edeab6e0c8a03c114e882081d240f02a064b2ba7a5e509a47dd7f467018466047070c0f3f21f18e73afeedce62db790ed4bd1b19e385bee0841fc238f6a367da52316f0f139fcaeceb9ec2a0317d1c2e84a4e49d9631c904c1510d2940b28784889a3375a96ab69702da8b9688f4bb56530defcb378aec9dbab7e0d0760dce7321317a98512d3d691a9660f7c7bdad647295a2bc5df2d223489e7243059b2ca6fb1ea845eb9da6436c29ac92b879afebd5cc463952f48fee252730b455b708d70e7ad2dd96a97f700fa42c73cb2aa1db48c2524440948fa149972dae22339327b3cdcddd1f7f0c7a9d39c8bdf44136b2462351aff4a32328340502aa1a3a38cb6e7ef2df762d85769aa12ec8e30d876802d2ba08898c1968e77734c8abef3178808093ad2ef28e5d8e1d7af0885d1ad6fc75cf7b29b7fec4ccf951c9a0d55034e3906c5c37abae30f540c36c10c5346d71d68bcd237d528a9915281b10e7032309fcf80176f2f7b4441c512b95580d2bbfafed381ec2b3b86426ba9d5caba4eed44d9f982e090dc071d8a85781c981d5724af7036884818c820d8846dc6e26269ba46cada2b4eabf08187fe20ffe66f3d2c5d6450d1f5ac1ec2ba5b67b7c2cacdd514bbdf87fae5df88d862966c06c14214cf107a69f1b59406797fb35f956ffceb8311ffbba06a6cb391588ae7aad15aca958619a563272322657ce66b882b43fcfd754728ddaf97abfb97a7702e76fa90c6f262ad11d8eaadf75224bdf4d64680720960a28a2de661989987c895a69645eb98fa5c644eee850ca0cdc960ce2bcc87a5e31ee23de04381ac81fd731bb1e656a90eba33cc44a0f81b94c96c7f6f080aa8589a0e03c97067336799092f4edcebdb8bbcf69a0385ec5ce75d30bc3904c169eeb56272056b31900276fc3c60d19b79d2720759c4d2d3d7a6838df17437162950cffffaaf2ef29f6185e824a251f024faa64417b847861ba0b7eeeb3dd0e54037519eda9ad5b042806b8b07ead49efcd4ad2ddc0ec3d9f2467e41976421d26c77158d53a75fed267a18b55c8bfb3db209666736e0406738fca990c473866cd61d127591fd93600cf3850767122a66f2bd1695e6040edb496d4bb8278cdf3fc41f7c86d686471f46ab90bfb71c4cd338c78a8d732050712d83060c57518f13e1d52393f722a75d9f8129ebfd80b1f896ad424631516e70380897f17dddd742ece4d80e085061527cebb386d64fd7b7afd706a15026d3a2fdd78927bc1b94ca5faa8f1b707cb55181cb5058c64015d94abb3aeb97aef23b617826157ba5eb7f6c522e6106ddc7f8deea1b3598a1e66e3c0bde8017447a317d8db325a8122aa9e4d7bbe9ca3f7243ee5470e280e1ce7df0ca8109437a59faec9c5f72ac43ec81d09df6769b88a2bfa3ced5c149a7359824012d883159f5e445d85a30fbd74ce9c76ad74faa01c85447c2db2ea875fa481c9bb6f24b11cdd45092f7e7662ecc886f1953780a15983c0c39a57280437afdd24d5e56330f3c5dcd20cccaf4caf34ebe13fee29059ace7b495e86df260041aa21edab829a2a2ca2fafc59a9c0b705d522cf2c09dfbd76937b937fea3a902cd4215b73f84705caface1721ec53fe341a2ca8994e2bee15c4d0d3a40562aa358dcc0e628166e606d98ebbed6458a3b19c842fb8b22e3032f947136bfa13b2c885fab21a80f8b62d702cfd24b1244bed5dbf83e9ae290185376033bebd0fc925da363ab6b0338904650cf6197bf8b5747a0c8ca2763b637e8099058f2c542ce0855cf83f60b3000a0babf8a988ea4fd1c9b4bf83b51d1b05a11f1b3f924cf458d62abadc63b38f56a975bd68a965bb2ecaf628160ee0ca2a1e9be1e17eddaaaa30ec26af506ed9bace2461310c15f08284eac020a7f7ed594c9fbacc4086e68645ee9af7db3de885f53d7aff3fcc035d578a855bc1ae7fac1f6aa228ac2c5c06ae1e097af1e23ebdc43f89e95dca7ad559c9febd9d647db4013b72ec118d91bf8a2b2e2a5007732a09ab55683c40624b6bcbb2cd3fe3c7ab9ed03ac19d1a57424f32faa0f1c6a427d587a3e59df0f1b5119c898ff42929479a5a7867c4b70ea541f47df26f3c50cfb1c0db8ef0abc5735e9f3f591574d8843222228608bb6c7972b90a64b9c34639bfeebc29c286d55fe233f9a13009de412e75ac53557af51b23994fee31668a55bae16f5d760ee79aaf6277feecfd166682c2ce93ab55c2c5dfae9fa0ecb8b4625916f52fa4daa245a4a46050bf7deba43b442672854830756392c8cbf6a528c5fd80235e47eb08a0d18b0dff07d6d960019e3f9e48c9707f376472b7c0337d01dcb2f4d47615c72d162220322cc12a325f367c8642da575b8f96985022f65b3bc3ac817ba61ec94fe35c1c84dcab3be205f50007aed5e474b6e9672ef39673be8376a6b4a5512819a9109a8c6b929715c36a9916554109fec624645f0b56c03553c73b7c497a6f9cff5fdceb25f73730ca9b15ae1887ac080c745ded1ca8c24cd5ff3f722e032adf8f9c593453dcd5585ca4906b3faba26d00cd3ead4f18849950f6a1dd89a8d09e52c5f121b21a2373f74544e2c03b74b5d6efe67998747bad2dfa7a6e93313897039934d99ac952faf05e39e88ec4c47e637a3b1f7a93b9a1ca31c3a7ca1610c08135401f603df01f863799c29f10c658d9b22e96643165d906339b3b4452fc88fabc3ca46214c8b3c57d07d8e1e40b9db1ef13f4a13186ed973c1e06bc6b22258612ef17a78576334f9d3b95505e2971d0257413e5f772e674151781f465b5adc7101a1e66365f6e98f46eec43be17c47ad6c4d102c77a3320e1f550e8912626ad7aa285ceab246847a37d311c36d34388eab5fdda8e6843e3bbb3ff38d2ccc569d76084a5e8ff612092dfbc089ce7b76f133a81d88f06381e91fbebda2dc7e5726cde8e98b663bfaee2b6ab941f374d4a3206d3486ee9a210c582c7dfc54f73c9a49d8b03285ccd94e3b2845f4d66179137da162869423027d13c4bfba2020aadb4d475cc051986ff562e9ed5fbac2510ab508c2169973bf8cedd66eb919a2ec00d666c50eb00726e17874be12be34b22dd358214eced132aab2e3c152b032596f38f7086c935247eb1b287f323b63364619cf5ead4e228262887cd929396b7e79afafa70b78f259d125d2aab9e4c2a854a9a4a58651f9d75b1583c06e637180bf2f43ecc8a15640f405431f15c2d563831a11364ed8cc7828fb18f289d07262440227c00e526bc4f79453383e5783033cc43d1fc242b36fd66f044bd6e395255a28d3f79a85e5a71ebde725cb4aa0fd8384101d4324f31ae4cff8d6222551686b9b504d8ebf51d07da608ea5b4db8a66faf54cef9d047c89b2410d5ab67b722262c5df1406a3a6a6ea46ea51d0690b4cd44f03c4ea46b07c6ff5945c714ac0e06ec29d49d8d3a63de7734b83b8d3567216909e4b9c7f1b6fb9e8f6be399d27ff1fba612f6276c4ea1c7373749aa7095db4553903b74d288912fc2506f576de1ed7657584fbecd710ee6a6933813f0fab5a3adde390b2f0c28914c4b6ea1a54c5ee9a0db097641fd1d02e0ef96a1e59e1047ac8f1c3046cdf0a23e7fac0c2c3143e0a2fa9bb0f4debe9af8e8414ba7275e2b12d363dc3819ed13690a37a35e0764a3e337c3b3b8923aaa7ad6eb3ee6641cf9ee6ed92261c3d65be251f6cebd51a2308afec5e6e75d65714ba32fae706701ba43dee4d15b3a2a44211f3b49a6aec51c2ea622e1a9a0f647acecea3877a66dc566e5130e066f4e0015acd421e2ef02d5752dde89ca89523a76baa968705ea0f9da5eb1854a4c76ab5511dac2d96590d1dfd24a7f710d8fd7e6ab0013c941633757837b3d337cbc9a5731ceae7706ce9892822fde74dcf3588978fabf97ab717f243ce4ed3e43f54a4d0af37a04b05adcd549f2a00fe49acf95e8c1d386a63a024a2e723e1293588d319e139f1923666de590081278d8f45fbe8e366e25ac3af6fb34b1816dea2607505ea8f878e77759775ec55b72abc2f2989f888c2c337379b7b921c21651bf3ac0f0246b3a7f165e5f9615d1789b314d8c606d5ce427b484cf3217505471aadf491599c194cbdc83e931db02ee61a14aac1eb275688a779af65ac7be7253b09ae83ef12df5769747bc97fd68ffbc37ce9f29cc2d1b9112cfd87f32a01d7112f227d3c7de93ba21035964703b8d7bda6cd73edcd44600c386ce2becab474e2de16f493b0fdf8526b01134ee457350f21e72c414148cd2504d7ee60eedd9cbb6ec2c34a081129dec9463e47a7ea3daf9820e11fc9c38eddcc85e44510d85ebb1acf834a4f7068851787e58ce3bcc4200a4fe914e7bae078e96d2cbae6812f7744189f7bd3fe7b3a7709faf7fac0cf0a496c0f3057776d675e6d5cd440df064e5107844141e1d4d994322a1ac3f2877c4fb1dc062bd7ad0e13cf2dbf29c022c94a8dad2bccdab634663ed3586f6a42c789c8443b10d0654c271b7ac81e7e9c9ad8904690bd7486e46df3deac157f783e38eab8a6bc3d824db85440c5560badc73e11e9b30c7c12fe339d81c8592d323276ec8d2a1bcdfd822a956b0f1bec4114a3e21b2ac8c3565b93ea2e06797a8581d531886f9fc4335980adc8a70db678f5789e5217972d8d79a2c0c3cd1897cc9dc6464aff0075ac7c8ea5ac7eebc5561a2fa2f25d734c381a7a3535d3738ef9c992bf7f19955ed1f939402e45f8b7e5e41002a40db09cfe3eea25b5e68e156717460591c8e3f072ab4f937a479c6f6d8f9e950d3d4266e3777bf467bb77b42b0f88291384753418ebf4b9c842c2e824782f00088b17f708232842a89b51636aac3aad78eb351fcb64a6b2e6ceae6925f2d274cb9ae1baf68c2c1ba3083171db0a7035a4f4867674d7124434f9185ab91da9e0ba6db6ef1d9a4e4e7b1a88ebd1b0b5f514bf753f5d3332fd249c5cde0bd52c7b83baf361ccc0f21c141fbb6d7216fbbf964e9876e650f47917d6eac162fe4ecc69a61f625d873c340c16152801db4dc8fb7f9cfa264b152e9d7f85ca21a3da1bff0fc510c95d294dfe6b0afaad04ff0ecc474591c7f68325146673debe5c39d37fbc2af4efb9f151944459ad0a0e6b8bc9b1c67f64eeb6e55d1774c415d31960ee4b01faa69ea11f56f2a3893a1c14853e4e51eab578dd7756e55e8294250e58ad4a4692bce5ca46cabbd4e54e5756ac5ae79b10e280a5e48400d114a4d73eb8cf998f69c9800917c9b8dd3c073b5a828dc7d83f98b36f152d1daa2feebfe8e885543699be55983683f7dbb5374a9fb0635d87f5a5e86a896cec591ed398766524b223e36f13c2dbaf2cbbd9d6ffcf0fb06a1662e20af1f0aa6b8c76d48723b6682360c926ae7fbe57f286c4adc03339870c96be2cab8359d7c8891fe87560045dd04908ce68e76fb6bb1adb13416251add3f181c5a3826ccb84e512d3312715dcea47984555c2e60a402a9717c09008a2515194e9cb457537c37f6c394b6b0aec8be0b1d1e6c1cc639a2dff664ceede48077331e001429e3651fde97666a9a469ae75e38a58d2b7849309f9fa6ab8576531dc64539c973fdfc34176a5f56bf239c349bf28eb630a9a0dd41ebeb93fa2c3d7d84018f0df828297655f9a81d34bfdff355e3bc045e22a4a67410ff569e1080abd8d7fa3cdb115cbb4e540098d44c565f4b03c2452c68c3625495b128e513a40e68e5ee98edcc76f30a61813d42c376d728b35b09c99b18d55cef8f9f79d0a8e048e4d17e0590a12bd49bdb224ecf4746f09db08fe6962a90f4a93105e3a9a717d6ed1c511dcada2dbe16f9c8d7b44e18da9aa6ecd40506619e2035acff8588919c1ef978aa59135682dccf9e933877a1baac60e09558f608af3e632f31b8866f05f01dda6d265569314abf4c428fccd369da75f1043cddc1d6967a0d120cf0cc833092250dd5b950e03050d107ca451439e0a562ef410f466dbb5a65c3a5f0b611fecec373c12a6b6e12c5e3e1878d7d7fbe62e7deb826ce4e942e6cd99b0410e163ce286be6cb48f2bd15065b3653cb49817356a6e3cfc7fc9641bd7784fec29d8a4fca7e4069c608528540109feba9097a358b2beff0f9c4af34541a5ff0563e7670c940f9e36153dbc682217562604f8edf5e18bd68d3aa4f9c46a86f2130850ee87f9815e9bd2b85d61387437190992cd56ac3c4049f92e8e3970c360b96c5cf0ab2f0389a2980c3489e437c89909c4706773e488fafa0d29e985767f706c0ee5470a7752117fdbfb4ac499f109fdfe177f9986de1b5522a87131b1dc9e17b2cdfe6327047f87b3afadbce29b1fe36350259f091d3900034f74f1aaa2f3e8cb81b00c0e383ac00ca3b0ecc5c4d82f89accc4dde3f34f8ebe6c8fdc401735eb52d09266689d3a73637d3d735be5dc17ec872405b22bf52a1c84552688f65c81aa81f7e3cb30ca1e3cf0169f752737afbab2b8906c129b2be7ef4593bc6b2de71b450423f1c9140c9097b0feabd9ae1c5e45317a1e728ea2eb51499b98a53b31c56af867b69d0737c4540a6eef695b0465390409d5578f995ffbf66577cf12619670055ef81fef92a38f422d327196545cc783770f3c1f70d18027926887a69891648995c23004dd2aaa43aa9321bd01d76ba57e762e468b10fcc16fab7504442f8091597df18676b19b95bcc81a0038b0a6881818757705bf21f406cc4861a258967fa100ff928a18463c3a06afb94426990bf1ab3a9990cea81800d90507da3bf35e1f4417b90294f2c7cc6055c1fdbd10fd4068022c11120b0482290befc90b1bfc0722e87ffa3ff6c0bdd4e78ac6569343984252a050147493a9be263c6c96b6951833bb0ffe4156189e98b8de19f9609477355ef35cccfe47e9d275f9c1cb7f994636bd68f29349507782485e132a028e48c23b834dbd5f372271e24cda3d8155ebb6fd7c6a87feb5a6857fac561e4ec0694ab5c93c1a53579fd659b04bf6c40f6f5530def18b6ac5acd7f48ea69f67cc1245752375c8a093f500f53752abdec504750ebbbe03ca0964f76280f914150e33842bd74e99dcf1156c158e3e05bbdc30d81aec17f1ee778f47227e68af7250ffbcbb979333d9fdbcfe6972e7094c5c3e0d0876c88dcfda89f4e9f3088ec8e350305b8388ecb560a11609703602c92662ca0036c4c92cffa8bf3148452d6c0031b7c76a92c9f3d988dbf3be584eafc2ae2363f70a40c80539eef26834309ed9f01d1ac899218cc50d0bc365cee32da6b069570977106ce47f85c6b265a66549ed88600e269dfe9d70c8b6fbe3adc87eb99efbcc473125afc61fd400438da02abc388e6ec79cd6933e0684593e932a704eef7f0bda802d72595e048caea32f8c8b6a703953cb53b8c203503ca6d30de2de34f92dac07d4c63a303d13a8e678ebc554422c324135722a6d1e659dd29fcc4630a0fcba6a2d4a264e864ff7e3866e919c4a63bc0f2355857e16c85b1fa177458584cf187fd9a5871b47177091eb8346afbdbe4e256b1ebd8bb189655806e2d29b530217daee40de0eb2ded4c36d0ebcad4cc4f9dada962e2dd9555f4db4e1b4f376043dbab015b9f871b1a1003654652baf3ec18192bb3c5c41644bf609e170b91e10386ced8bfa97501c5b4a5a6abd6f73cba628e722bdd31f28bca8b8d5b1c34923fb24e7571d9ee67087730609ca4532dc018d74095bce7696033e93a5c1c883e5e8c738da1aafa6f0a787666044f5fa0bf7294b7ebbc26e67af844af1799a580d5ce97419df3e62ec8e3361e984cfd0008010caa86b0afe174e9895a96e8d1f3716550624a314b5dfb857319572243206e4dcbbe9bab1fc5b5d7d930edc1a4a68b4c59aceec3c5abed40da2ebd36827043e908fee4676a9808a67087e537e2316f26f74107e25e88021a48f64afecee81219e7e03382184174a58d58c9aefe3eed2fb4f8d58bbbb26252a47b3c0213b3ede0c73f324b0458749eb4538c5c0babf3f26683f6ae725c39ff4dbbf45e7a9d1502ae2346145c59b573bcceabb647ab85ae4790ac6b3fc19b8d1129455d63233ee6cfd0659e4df9393385cb4efab6b39ee7e6168123fcb454f10110959d85ae461647900460bea1dce3962c5bd45c002e2ebc51b7e38f9be49184bf5316fe9123271fd980aad4dcbd794f2e103f2dbf34dd11a61b14cd7c9f4667233f42ee5e3f5ba94d2578cb4bd4c414ea8101801e72fd4d1be09e28ba634fa7b546e85254131b4ced56d0db463adb12e89de1212a5e62b7d19650a99e72bc25b57c61b8d526d8ec6b32cf645bf5679be27c13aa719062e51053a99e0e0755b5d89f4204b1154e95fe8882a96c9302f042b23969a75bfc851b62aa0c4c93ed28d841b24ee6bdfbf716b8c31c28bcaa667967d266870676c0b202c6158b57e4f6d088b46be22475a7c3776c36072bae6274507fe016849f0449e39b14abe36ffa055ba7c4e887bb451957261ead8314c03668381307704b00868a67122421d97f93403e0cbf3057a8bda8ca369ca438fbc3ecaf7a4930a97c941865ed5e631b9e65a9033c5bf68d5ef8bd1cb478fd680dce551eee286f6123a0864db573e6a7d4238c5586d37ef463697e582ddf45576b3db89767b9b58208d63ffb79a24c71f9f0af98f122bd8e9eb796a3c2e1f4f4b8eb432490acd39e33b8c4471def1fd69d4b8ad9280c9a2b640f1405a842be45bf3cd56e0010cb582fd3c260bd109d60c5b685061a597a100381f49511a58062980852f0cf8161ce6f8af8ebe2de6ffd34d70e803c5ba53b4ebdb9ace74b1394a3d39d23c71bfdeeba9e73ec40f4ede2bbbe9933ad60246f2b6ada4f868f0f09194266cd376adee08c11bdbe0d12de51f2b5ce804ce41ae322e454041f365d5a29511eb65ad77ec173d1a90c5e4eeab6d36a8063d064e79df4b0cbdc9e82048ba6824b5bc3900b2287504db4680d8d0322231775d374cad1cf57b19e3e96c023158b5cdff471b4e0d66bc771e5ebb34cf528446108787720f4408740e3a0f5d8783dfa914f0812714217cc618f37a0d24335997d7c97bda0db59c7e403f82ba0761995e3ea6e3e88f2a2bbadbfbdd83ce80c3f5386a6313b5570f70b99d691c33b3dc7007b987e5e92372c12376cc0e12b4e71e05dbc7a6a7e4b8dc06d317c5bb2bfe59d6403617f19b3049ae51ab5d39998bccd83bbc8dd84f44b7574846e692893bd2ebcc534ed52bb85df5d38aea853eb76e1273d1516e4d1b2aa79fb9b7a58b6a412fcc549926426e19d0a29b2b7afd90f77b79c0e4395a6ad4ba636cc076ba2f372be4b21848da5f3ce3a4773318879f4b0986b3d86823d1596eeb7d07c9d8297a54d07f89083367a67d44f696359259ecf0e673b3ab4226a2ba9815a9ae6bf162fefaa81889322583bc8d2f8e83866c3815a6f7797c157fb5474cdce2362e7869b3cfc87d37660b0daabd390c89a1848c3ea984fd31fb44b7c8df656231b98dc4ec971082bf13d74980ea6cbb9839093b5c687ca9c4683ec6ee9407c943f710ee37c84094b2463b10963be59f0f70d37b70d1bec206b521ecfa0d629b04a3c32ea6ff3496fb9e48dfa766617328b168b6201b40f6dfd650291f3bf2d3f5b8c5798b953b053ddc16cd66e3668603f80b33a89d15455872ed0e346c84732bc64e53f86903417f323ee38409ec5a4867bdc87a7c95f44e24bdb90c4686fe87665faf287968337aeb8b22555a59b7f5b8c62fab2479ca05a91fc97704087bb282a171da26e9cf4982bcdb52c32dfa0cb5cd12c9e6377c5d9b85eeb976fbccb4337175e0e617aa815764248a1d60408ca9f242c60505762427380c8368a312547f8ab913f8959a9b5c51dddcdadf47cc75894fda228dc7e12593cac15b5fc852ffc920d07ba321450b49d087f6513c41717ba8e02b0524b82c9b1dc8ceff201c3a009425ffdd582eb673007ad670265f97760c9e7acde74a62712b36f3f28952fd6cb1c4a341d3ee18d15e0fc20fc5b4409af9ce62a25d819900f51f5e5b225fd4ccf9a2476c87a7697dc862423f14ba30ed6dd655c7847fd809b6e386c24957c498763797297cf9bd4337ba1fbfd11c6037ded82d8fd587e97c12cad3ee398523cbd22652ace103e7e2854ec06dae96b7efc4fe5dfe170453c1bf008556ebcaf6968748d0f4ba370875a6c743479247ab747daeaaf75a5e9758440c452423c53085edbb866528d1175b53e424320b6106f9ca6612ce499936fb64198f801db7595aa1ff39f9aa63cfc6978a74ed107c9ea22a7f399bd1a6d69fb825edc480a205873eb73c87328029860e22aad405e12842bf9e24990ed4875a35bb24bd5673a3f6f75400b598de84b357e95e52e8f3bcf63039ff4e91af1ad3b03f2ddf49ce956f43847c935a5eaac50425fcd39f3493be20cfe887dfd0fe0cb2e5b98e0119bcad1a87c6bdb6558707cef38e26a036f2c5a8a2b12540a6c1aaeab735d1911f66073e1279439cc34ae9babe6f1be67dd951f2f1bb9ba295fde63511d7c23031a5d30a20f7081dee7fa37ce37256b9e31bd3d167dde75e0a5e42e0757d39c0d49480f2c8c838b67f27177b955972f86dd8010c8e9a1707f9ae0e7736360281c00090ad1801b341aa30028945ee06260ccfe06ea3344e12e86fd49aeae1277524af5632b00fef3049e61ee0a6fb7478842207d21b2b46eecc4aae057e46bfc372cf33875a287628f4d70a8984d70f6df3f5d0ba39723875e276ad46dda68c779f0504dd6190d3da03e140d75a6df641295b80f12cd3532ad76cbc00114495d52b2fe7b0317d119ac1c8e16832e829a506aab1fe7f1ec6c4faf5704bea867c24a525969d48ab1129fd71d031588c8213733b0536a000d6c701798ccabff9b283ff907272cbf519a437e037181c63c22cfa983f471cdae80815a7ce970ad2aef0b9a605985511af17cd5e41c0f26b4e7e00b167db63f90c714be4371ca771e6794b2cda56ff774846c898df74cae811b77d692285c5a764fb11ebb4836d85971a53e216b42a0bde96aab324a3df9f1140387acb905be69d56e3a71340a3501884b5a48916c2e7b0dba547b82d4708ab87c2bd1fdd3e8af255b58c591bfcad6f5c1c47b7e12bfef84a3cf2523be3dc164ccac2935db4ccd4e75b2c91e43c9678b4142f7a51eed974dcd08f9a4043fb50bd60a5bc155236006c48fbf957f296d9e8ca4c1d6048344b13f942960b1336500baad0073246091e5f65f902ebc9fb9d58081b26e5d22ca69d69f4acf66160e93164604e9b5ea923db606e18eccb74789e0a2ddc99f1084ba164feb61e788c52a786b55db4e9f081abd7bb7bc4b1272f18d7cbb20729caed49a62c79bba575b9491eb5604b6e930ddb5fb44e91da8761e0f90ce4d3a9ef38363af900c56deaa7486d44cfb5b3a42c6ff13d2a435b43e4f54a99f6a3f1b30fdd21e6a8dcc5bb970ad8964613ee024900f15ba360eb16a6785e3801636d763a0145e0edd711b20abcc8b4dbcdf1da2532fbfa1f1114b98f2782f14b3e7c93afa3146c6900e05a800dc7e2f653a14971c8b5fc0f5493f4991122defcaf65cbdff67d63890f2ab15072a014b7e472ef67d236a9edf616d70f8c2772d5f8592aa15acaad84d6ec34c285b1f0d94557727e14043ec07d71343d34623a27380da36cd21a8e6e79c47cf5a2f647272c9c63ef97eb5bda663aa9e7f57e7915f742baed37a01e3b57b5134ad9dd564b3fb9aaf6e4389f4255783b28543c77d35278212a9b9aa97a299366bdbc0b5d7a6aba0fc41434b9ebfa844651ff6baad46cb3dae65648177cf94a2ef68ff7a88ea6d1069c780ebd97e26ac5cd483557a76fda6dd3f779ebbd35dc0e14ef296e2ae52dee9f3883e034e5d08948e6b9672c1fd7fb6e7b205c60d76074aa9605ec0b1bcc33101c20d14fda164adc047a36fc074d95d9b9b6e1654369561b45ef279b08f1707ffb533c92519e6d2d1249af6b4d5b15ba6f83cc9b5d497745834199cd9b275e355837e6b2a4e6d95e4cbefb84845dd4c0f164c5137b58db36d97a12661bd5bd3d759b26581a9dbef83bfcde931dde008d2ca5403033864e5b11942081627cc8e53f225190d22ca2efe595ae5dbf197ea209869b3269de4d6a9f9fddf50d15dd1ea615ec25e3fa778af4a9a091917d746e187c603a57adcb5b53d2249d167d95c28b01cfe72b1ed978052687c0970d33e2e2c55e77d5b617d3cb8f89282d6bc6cf5530b85ee11ea3b396a21386308464548b4815b21c7a8ab5e381712af86b2e448a37c24e64180bdd5a2c154492d291b3b88bc6b6e558f158d92a4468caf3102426879b15c0f3cbe4508e05226f03294dc62463ed7bf8a99e6a06c60d59f2bbccf5cc83530287b26efd8a731e852380b3753ae48416596a7c49fff4f5f0667c81ecf9bd46e1a04de3e9523b41e71ced999de0e8a9674ad530b48aa37fc8b5a6900a0c8caed8ed58d402e04f54a68a37492e7a8752a245f1bff820b0da116afa0cea0234bd40705f6554fae71a6203f06c7d6ffb8f32e94c9dffdc12608e54ef63de1cbe9d54b59c21937463a8a2dcf4cebdb024f557d45aebce2a97dbda9100fa12695b752b2c66283073191a486c3aaed67e84e2d34a1690a9630c28d74a9a3858a0b9c81112d4aab5af6d7a449720b6bff546f0bbf2f9b8721bba3b139a8190ad7b3a0c699405637d67ea1c5be3d51ce8ab7d2ebf976b24e74a28a0ae38371748d58e28e28048d87e0f2fbb2862af241cade4da3cc85b6f0988db51afd7017cbc41d440b6738e0e0bfecffe81e98416cfeb43f09128e61258ce172df448fa9b0b319d1fea80e42b8f130e64dd45e34b8699f009fc2cc4608ad25b27832e4ea4ef37ec068bf83bca1efa5e390d6e637a90dc2dcd9e3e232c8c619dc9f19309b7a3ced3916c85899f3a8020effb05355e794b2af23364e1c75581ac5c39695ff3d68ceeaaec1bf19c5e41cc5a305e0ea81a780d4e37a2f92c75aac58609e102e92489937ac3397fecad6981d39542ada0e5f2f83968db0d5d5e28187ff4dbde659425c290650768ea5d4aeff1f40ba70b45a66b77748bda0181e959abdc4ebf71183439192b19c236b94931b1811431d0a5f3e2f53e49bd439b695c0c6eb508b9b17f98d309c80f9ba7add2f0879a307011417c3461d8b14944c74e2f7d9b0cbaab4da4b88eb496bac0ac1804fa3c82fa26e842a2e44b11bd489a452c024e7c6cd5f54b05422e76786c039bd200894681e49f72af1929245108a79b8f5a6bad8e5ad8c3aa3d7ca24b986d29e8b8ff42eb8fa06a67fea981bfe8586df491399baade0d9da3c5640232d20616cb917bcdf702635a13dd2bc81c0906eb43d1bf4ed52091262e65f56970c5e2e5529a10f75285b5033dbbe4233ab9f0edde6b073d86a07581ad9d2ed9413129c0d76faaabe2f93668abee1c71c74259cbf4b4bdf6fdd44fc83b72d2dd01e8c75f5ef3baeaa4902368f17d3721f7101f18b20f8a70375f547e54ae487a3330eb9bfb2c7ef7331c962ce5a19a75311deb50ac104dce6b47dd11338b5826e91909575f296ca7329d6c84d3eb9428a1f0adf45f81fcca2cc79349993847020deb8d73654c554be1794672ae760ffc1c41f0c85cbdf80f53b703cf7e46e030fdf1f5ce202813a57a450c0fa7233ad05894266167ef2a21eb726807c2c653b064914ea843b89415575bfd2c7e57e5ca2ab6ba6e4cc6710fc3e4e0ccb5820f3426289b0719c5a48747606974877c43d7a86674ddbf98ad24fc26e8a3c32317396382a8a847daa226f7ec0dba5c427e8679e8fd84fa76d64ad79107f09e215ee70b91e8c463e59c79adf645ca5ac72b1b3af8853d3d375772f8d1f82d9d5e4929d97d01cbc46329f6c1a88a581d35ceba75e81881002bd6ae897886135b9cdbba8acc82fc7ba614f681c0d2833deae533e8474558ca65831fa646f93fd6c5c2cfef949e7a570aff205615b580438c9507d9fe6bf714ab987c1df05e2ae30389040d18e2c56f2d9ac7ed82523391d4ce9d755feddae9e50e351d3e87c7b7da33555087ae3bb5140f15d7626db7f4b553e60318f5301f803d2f8118f6ff320cc95f8d0db412063c8bd9ce66a61dbc5b95186fc3f8e779c650a7799f418937d20beb66a67ce3f8564dada6bb290efe2a9e1a3064facc5a62b506e958f1f1b677023cfb1b5dff402934190d3c34ca65fdeb58b00005ef768193258dbb09ce336544ed696a7b29062c1c89422fc6d5d750c3b19737129fe412da004a0d879fa833f154725593321a51c157a5b3ef070e753bded422981e967ec7856c8c6f1df78d87fbf9f18eaf686168e036e1f565dbfda5abb52b1b8c467cd8b6f92dc283ca51bb32cfc5bd2952162a55d7ec0689154024917eecfb077533d36aeb738ec9f532a6d1d0ff6c37991492508ca7c5e5b6ae8c8a9942f43af3c615c4738dbf66867068debb10b2f63efe9c12d1bd0ebcc5a2fcf770044a088173f899fd7e4122b8e6928fed288df3a433c960c96784d5136528edf4e8f02e1964b26a7bbfadd36029ff9943dbead18d13c2265556f12591143871ee42a5dc8261e4216ce61192c8a7eb929b8f88baafaa0d0788f8c9ea809732f5fa0b4172fea455695ead57574ef699037428a9975a0c566b61136daae8da4eec00697169eb94b9460d57c99e4ae848be304d2d2bffd7aaedb9690476eb5883ab57bcac5d8c6668c17450ccef4ff8bebc3d7a3996acf42d749bc56715320b82c19783aae92b6e36298fb6720250358408c18c7e0a840d4d6f01a48242fcdb87c4f4038dfcbb3666c575b7291037f7595877e6d04030b9d03435476f48a76af58b612ea9a1cd7b04c78765b599fe65142541347eaa3bb9945f88e07926ab3713357ab698ec6ffc2c592a3b81f49e1c1823b01d750d24d67d73e2d392cddc5e5271ebfa58cbafe02460ee086fb9a2533f5e1a70d01dfa1388b5057207ffd356f9d8430b845d5a83048255c4c756c0114449fc97f039e0dbfb75dcd52e9ba08f03f3acd2e4af29881e58d2d0feeb4fe2286052c83a95a8c6e507f2169125cb6f6772ed062421b4b6aa0c72d8ef80488d2f8174bb0ce47504bd79f49fb13368cee9da2ca40e9c381d416121036958e408f96a8e4e9a9e390dba09919332425c35be42faaee31c1f621be11aeb183b4cb3f6bb01589e56b9bea8e55854b71ce424b40cbde1e0aa8c6994c3e17957fdf3f1640daacbeaf65327a6520a3b67646825c702aef4f1da0cfe2c5d385c18a462086a472799329b1b9c1cf0940e6f3b06761075e10ffbdf533757555faae325c3e46d4d3d87e4a81aa614869810175b6195ec883cb7d950c0a5b39ce5b436a7f40e4c4a77d1bd58a28cb58293d56c6a3523cb84355f8bddb8d246c41b31f8256bb5266d0377b6fceafd8c36daf3c831756d872593c6a345cd46beadb2eb2c27115347e89d56a095101ed592025763dab69c85f2a75869bd78abcb5b6dadedc1c455cfa8e66c90f120bcb30e9a009af0923f6c9f00377bccd2ab25d5095bd4cd05a9c3529fc6f2d6fd3d84ea46020ef08c50b129b0d65efa39fac78c95573cc84d9b8b9f62aa662570bc5cbaf64ec8e405b809684f63bba9d38b68d8073e6b4cb738c0d942c5cf17ea8098e807aadc94d2da5de873401cafa025873625a24610d630b4f3bc01b20c5cd307b9fc86732d67c2d5da8f7858140f70f3b7e8821c11a6909df8c165bfbdd4465e81a7b57633226bc166aa6d8e8e44e0605fbf2c1e904e7e4cd36fdac31ef1eee897f25cda8ac59eb5178c04b45d9ba180a0f576dd646f5465b3f9f08bd769bc84abad8d4548605515d01a91b0fef8efb4007ae081b59a46ce13ac6568b8305f6ca0632357d32ff876d490d088cd9c4a0896574df460fa82d4494d0eb29f9cf59659f9c7e050edddc1f6fe546621db46c9c9d9337f9817e84d3dfa322722fe8ca2de4098319a1b15313111360e9f4cd73be89578eaa1c02c81eab8c093b1808f5b57038cc76ba68922f52d8d18ef1ea0e56407f4f4a5cea4432024ce5653102627f34ed4d962eeacd35ee8b5cd5aa9506034e09a4168ae276d3a92c16bfe05da9f69f8ba6dca927521e11e000dbeededf7a715ff6cb82efac9828b27771f67e17d190d088fa82b468a3f07ebe40d72dd75cefa9455052ca9f48f31646c44751d0eca17095e8abe439b684b74a0e38754173a7e026f72de01655b892c67299b9cf7cca4db26f3c6da688cece109368ff34864a53718f5c8ea453ea8183388091c8fcae8cacc3db6d5f03e571a686bc5bb78561c63345bff61635dc869a977d241e281aa8c9d9713c7471cd4273575403e9ec9d05b5ba8c76f77f2a13f22bfac1b68e0d0d57d5bfb22f51648a0a39ba9bcbde8bbe802681f0faced19733314258a7ff2bdc3747e74d7288d83621d252e51279f77ec3d4b4a28b7a0a37e7c0f77a4754e09f039928c5f34223c9674ac58171bc6328c371518eedbadd261bcfb6ecc7399c9aa1f9b65846e59bdc7dc9e73204611f257b382e929020c5852c4ddf395d59ad6e69db34d536e98c8f0ac8fb8754f6d648d899467777687c0a8c59efc49cd23c4c37d19a44e942dea3dfd8b7d5e47fc7d6d3058e2430e53eb09c293cbca0e0d0030b68365851bddf0085099c47b3df6980bcda902ac36e043369d8a31b3e6cfb527907481232eff8eebf3049a67d15973e24e3006a3a3c19f73409b810b3b080297697857c28bb9dd16d381e57859efed4adf65e83ab2a03ec6b1e33b7ea2305f04b8b42a6931067f35fb0efccc103589d7b79975031d06c9c8a64bc3c21c2a41cb632c5d65b2637702cab800d53533cc7bcb74289981f44eb8c22efd70e3b521bb6423777ae30358c73c8054dfcd7837171cd43eb9a584ba6872a8569ca0add337e452d36c2d43dc14eb1324a0f6035ddc17a144fd4b3e9c5677bda4c021cd1f7a35e5ed12fac7f978777030963ae93b2edecebd5e6ebd202d5849e1531e6c7cf9b8ed96ead6efe7b9c69e39c89f3c0f762e4956ee4d28c94ad2555bd4b7194b312185bc26d82bce3e07dfad4cac87341bc008362857756925de610075feb1b6f555d658bc35824ef4d3f5910a5a8a0bdeed3872bcb5b4c4f9a0963cf14ec47f343102421fa4887e0b9f842fdf65ff793182f5f1bb62dd3b808db1c50c6f7039ce188584f5069bf3c3112397a8c32aab77b5cadb707baf14c8e99c69dacaa89645344d25fd45ac5c3a6eb81d4464581bbda3848123cf401a3d1f518f125dee7bfb2281f0b1f65841c81fab83205aadb40417533bed9e0d95426cf1216cfeb8656783c25fab61d19e4377a350367d9b80f5276bba0129eb615c7f7bd0ba802630ce94452c68ad9cb7c516fdfc1d86f83451f0d634894215623f5fb10521c13e1fa8d724443323d89a95eda7efa3ef882919295f8973cbe0cce1f1ed354aa60eef341a5784643415b8f6e122fcba047d03ffbd9f7d7069a7ec250d5cf73217ece7cbfa5b088ab4d91a8d276f1c61eb5abdcbfcfca8c9ba5f354b887d44353e70a80cd7fd7116a2fa6a07700b1e090e2ffd0f4b3074ee17ba920056b303d1d242f36b9f9705c312e5018ae434ea185fe303d020adbeee922d3695687216c818678e67410bb4ab8e4fedac13a3dff8eb1f7f92e43c6f51c03f0418e6a8136f3f4cb4a6748483f75ee1a02b498d020f020f858cb0423b1f927e75c46f23212e5b8430885aa1cbe882d2e64c819d7178017b60a824abd169222e4d72a8e022047c66d1a8d20b207e658e8fa5b18b94a41d25c9ab7663a0f218c20ca1b2e5e6c59bc44b7795c29341263e3e0b48f9505f52fcdd2d82e7a4dcade0770f337efbddcb2446cf8dac6bcf03f9947ad13f0c0215de8408c657d80bd7a1c70dcdcb949e979d4ad3e3c51a4fbf134ae496b8a1940f97d157bb9083fe1cc2f286fe70e6df139f9fb8ba514da25ea9ae78991f0422c6624420fde80073dcbcecf3db18b5e81f7170a046ad208cef7ace74d3e10ac934cd569e9d05d4351fda4ab6c9f66131ca887c8b6802d2931567f0a5487e6842b21255b05089d0e528b31b79431334727483678bb8d020f394dd4127ac65b99c834bc6f6ea462cc2875b2c211817a3119fdef99366722f0df3280959d43867f042eb5f0729a64d869ce80378f4e94a4226eea79e4d2376b511102e5dae14559b0a5f2a8e07052a28c3081c22f5c24651752884f68aed52c9b4e865a36e9524da84ace05f52b540523fa4f5c232b02eb6bacbb03fe1155a4101a6766b81e77b1e6f759d2e5302f4004fa2a42ef6c7bf4560c959b73a3b1dafe72b952b1c346180ed2a7dedd8da4e9cf167c79e54505d6728ea60ebbec4093a2062d3173d1ba0ad21374f1f12218c7967d392e1d2c1a8de194550594c0453ee43f7a0cb4f10593e950f9f07a4294e8da26fe50351f4d4fd5f5f176adea6498587edcbc7c81d864d398a374febf3c228c255738c52478c6f7e73c21aba53b4568f512706d49e9f349cb317e8ccf24dade7077a42336433e1d62832f6855d7c515d01935f32fa91348963409b19e036f289004ec4219030b3c06f1cc9508bfb35e64cbab5118e2f0044d69e70a7df2d4f634da9f0dcc47951983d6355da94d183b0f718857bcd9eeb7c360408be11e507c849a8f132a824a0137a6e09dea03ac0e1c238b0086add1b83a4061b958a201605afe5f85ccb11d01987cb4d186e4bf448defd2ac57042ec63920f16c654ad43c93235fb054dd52f71142b0356ed9c19d99f6636921dcf3c5c66ad4f7611e37de2774da4c71881b3a2fee68150f641f2a198cdde1c1c51c9a090e83243fe9e9e7a01b714ad5bf1c9a821b1608de0ecdfccf11a48612b62e554975da0ada7d17c0d7f470cb110b335591565c6824c337141c2ef7a7eb7ee9d7024f3c27dcbf55f822b13af1af2020b14a6d7dbf401511e710098a033a8e9f0d03a06fc7e0018979d21867a69b5e10f4e4857c3594c8b100bb482252eeee4a536151b51730ecf25e44143f0f18db1bb9c1c50ef146ec4ab801778a178d7fd2e4fa65445109c79d4420d9f8e42b3e95b70783a98847526568171ed97cc589b51643eb8942b3191f7c5cfed3bedf329767caacc13ae49a01756886f4690e9446030aa1fbf025f693963c1d5b6b9f4907ed96c999198e111d4feb8d8900a62f0bd967e265f4b3df8f573fdb775795e74bd233f295057d43ae23e9b50dcf5c9c5d212d42b1ca652e66698b7871e2307517204c703a9fe39276342cca2daf4626cc996003cb5b1fac82c68681d208c2ef9e07f5bfa7b1f428f858b9cdf54352766dbeff7dc6343af1898f3b04e05671a9d6f35f90ab7cf2ce4d3c3d7f696e20350aa98bc56dca5024d4793443c1cdc145ec52eded296991b65b2dbf7a54663ba58aec5770379769906d97d837509359acdf9b365370f5dd2bbd0ce28947482ed35f5adc8af59008a7a0a231159455bcaf38ba523baaab08f69f8f21c828646cbbae7175f446b195dac437545844be0526e9a0dcabf20f07589b1a0af2dc44b94884296e5d3bfe0c9a77cd4d3ead16e8381991ec74e061fbc53514d427a09c18ab5bbcef86ebcf4b0f0660e2ebd92328a1ec3e3dbcb1fac670b23f9d1f8389780c9c06314f769fab74c8af23009411b55715a74c45de30940724d802419ecdf3535616e78724cc48688face0c3b17365ad8ed10a0919ea4a4897593b232d7a88efb4855245632fe3c275bd71c5b198c9877484d80203b03f5dacadc449e5d2d00b901ca36550e415b31773f5d2fa069a846065d3c437d5b41bf7935aec13680242fd79bdfc4b15ea0b17c2153118fe86025990f5cf47f41b72d1309e8662f1f8f0cf26a7d587215a3b0281e667418ef575163532585f6ce1e214b4897e094a52d4c6eb1e53f0bbfb025e3340e5de857ded3a91862333a6bf02d30719d099b75b67be0832ab0178091074a2aea659de9c50a2033036cdf066e8557348b9c5e3f484c6818476d67672d17b681c620d896f6cb29462ab01ca04124921019ed266abc3e3739685d4a6ff0f58b99d1a765827c363b0d28c92994aa65ede253dde89929e5cae21298f7aa2146e2f77d1cbf5d1fd46a80957d9563684af6e19afaa1c2cfd83e9986e2df4dd1cdb4e88deaeda07903b43fd887e8505b1554814c290397d940139a90b3a8966d0e1de36241b1a23374c55e8361618a3fceb8854508dde197783a979dd156d1581a36b87b9a6e07a8d70f442f982c8d3929078f324e1f507ba3944dcff838b4304a270e169b160480457ba96d864c20c72f417c76ee6da3ed2463635119107d0982da67ec14cf9918aba73ebc6bc649983ea0d51d0e07b88a8b8e22e3279fa38e3fae01ae869292d05dfdd1bfaf29b90afa4c7556f2e5e5dd075e811a339587221143d7437c4c4ecd72235ec75ee68fd1a863e99d3ce3102027cf9032d6cc5b7e2f3278993230c09164431e06e24d1e94be979421a92765f69c384c272f6b09bc618722bb82bd77aa6043cc7460caa6245f5a073ba28e0a9940dffd5620aec936f45a23eb4b273adffac953b4f7abcb90cf7b516c27b8191beb0144a64e8839f14da7f98286b236683547e95cbb645526e09f8dd2d1a422a4416be147dbb225b3d3e0b681d8757c21e5389bd9cc2bbd5428bd55441d6f618184897de582db7e9cb4a5b7f82bc973fef37ef3aa45cbd0b273bee87f98aba0c819fa23894deb72c7ef2e22e899e1338cba12be0c46f652885c84d7679e7587c3e483d50f3c1041b020af5230d1e1beb7b8e034c93c27c6cf921abeb845735f7ce9b04ebaa022402a39c48d399d64af2bef5a608cd6be61c17470e983a88c52b2b5631a811bf0ad33ac8f155c6eb8b13cbe0782add54ebbde779d342e7a4662586755e7e9f659be6f081707c00c02abdbddedf0d4357336d0d55df7ff7f61e11a0d8c43fd54cbe539238ad616b8dd3d06d7c6fe170d18be52f25a92e52e09e7163d2730a5645f6093db5a78acfdb0fb4ee1503e174aeaf5ee6708a69076a21a83cc07f0523dc7ebb469bf94066df4bd9cfd7ac21831364494b4d4f16f1858d63ffafb6a439dc49cc55738230927bc8839ca02da0f9529d0b983ce55df421d764d8f92744598b2790fd7e1540e826be33c7fa294203be07ffc43501400db1bf1c249ca698448d3c4fff8809bcec23024e98dd6348d4bad09b37d3889c5f50e3661be746eea45b64ba73dae3c6ee7a5317ca2edd5b85b49923363c8e88c5dd6b96d895556523796b7c7c538f0516ab7f7019ae648670fb70c1d2130978fd430837211d433e25734a576d5de237cacc6c15b9145e431fb19dc236350ac17bd9d64d45c6712fceeea3a33374b4ebba92d9a1f83b5a1ffedbbccf0779aa5d0bf62666807c2757e67d0fbb8f383f268cbec7e5ec4dfedd9c6b296519bb94e073160718d156bfa5bff4bebfac27c71aaaa613d7ce51fb756b1d5d55e802dbd7bcc7b3fdfe2366e772d0db988bf1b60d7a02d232e4d301bd499e7ad9bd46b5ae4efbb2f1dad08d1ccf8facae034357cf3c5b490ffe9877f0aaeb73a17ff4fdb5f8e03ac0d040c896b9494e6b1f3fd45959768411be6eeb66f590d0d12e0d2e680dc5fbddd74f82dba4980f4b3d7f8218b29b6df761e17450ad3ec1b06accbab71d0c59f0fc009173129b375bbb1058e8317a96c5dc11f0356dc97d224bd8ba603b0299773987df4dedfe472d7924062925fe541a70d8b111784e1dd8c138e15181b80901c749cb9842a5fef8210f0118637ed82040043c6f18cc5a5f2559a5b88a31306a5d867716873868efeed1b0b59c82820094b08eb77929a496111dc3f4b3fb2bfcb6bc44a05040db3c8fcc9456f8be568e904cebbb343c505e4ac39080c05eec963fcd772abf7aa8336a6b3e2da4bdc2b09f63f5691a6c0b690e60406ee81cd7d46612e274a97a73e8938c704f8e30043d24f74a87257672ede2f12e0ca4d16fd9b9926912ece5a4d9eca044df71121373313dc5f8e5906cd4d0df27983436fec6e2f8fac1185a3c44635dbfbe6b777da4c523356a9f2a632f82422898fd13bbe0c0eb523840ab4f9f05dcff3b4b54cb318d66a704eb156455d7ab94207ec4a4304c94949dfbe24b0042a23b9711afef82715a04bafa0cc231f1cddb64f53a2e6cb57fe82c9bbc283f4f524b12d03b5fc86412d218e8d3ea1d41e9290f302588c69b50034552ccadf81e4d80b4ecb39582c66e9a7e353666658aae61e7552f63d9b011a396d080f67664a298c9ad9b99482575a5a540e212107d3f024650523407237727b46c0ab9411eeb37d221f32e67e6586aed66e9df39c8d5eec55c8d1f0b0b073a9d943df5567a73cbb3cc43022fab4c7b31f4c04d3533d6f9b4a532267df1ab8979e30479c786e80211eed19eec62cdf68b410a7ec54cc0bad8bfbab9021423eae22031e8b59f6624d2a8bbf63e9630d3b7f8af833533da84e0aadabf1e2653d4d699fed4db8255881bc070589118110e4ef566d0d3b4e132e37233c428f05f48a54ed6d798294104c9180b821a0cef744081bff301b21153d7109118609708f2c869cc68a5eb62e1d803a7a9c869b364bb3c9a28e2c5edc2e777cfe06ce35dadecc39a9769255ec9725bbdfd41bf055df6204242d47c5ec94006c41a7e3d71c3fa848266648d30adb9d07d534f2e951188c8b2eda7092f3cf92a366f919fd6348c59a1236adcd8e32a3ba6226c4fd315a7c050c87bb9571eac4067832c09ad469d161f1a8fefb2bd004cc16acd553a349a9de7dee83b8a2b455b9f775977411f3f75b7f9eef18f55124e90649292aa195d9867448d5cbf322166d20daed416094198684e7b4ace2ee3efa4d76a602bd5bb1bc8f123f41a7ae95dabcdf4c099aaca0fb8bdcd6cf7299840e1fae3c93f8fc2c6cd3d705b194cb71326439886e5dff44f7d7a3287bf38efc9a480b70cbd959ba5118051588bc1ef26ab54d35a0ffefb5121d99e1d214430d548c3a52a4befe1541609b35c7590750bf776b2f5a7ea536666f789acd26d13d4ffe549a9aaa488f3b34d19801eb4563eac83ea0009cdafa385187e2951fa4f91c3d170ebad5706ba8a723d94f103ff7c4b0a7a6745eada94e96a0312a121da88d20997c50723ca54b7688ab6ce4dd8eb414671a712afaffbb4d461a6ca154b746d9b6463061e37fda7add5cefa801edd6730f29504164e8bbae56e8a3eadc062278e87a5a9936dbee93c52ceb6e77a310fa47deba0de750e760e7ab2f6dd311bb0dbc6d2bede87f1fc748f2bb1ef8ced428d3ed285a3ca9b4eeb75ca53e3a9b5b97b2a52b18a5f2a861c63ef37c403ee13e7808ff4e90977d052e53f70effc210a8bcfb9f6bf46c345baa0fc8017da0f03d27ff93519d8d0f34e1850941c4b0973f66c2cd74fc2c25761b4346891fa22484f7a99e877c54dee3603bc9ad8f27a681a489d2c8e579690696c1fadbf96ce40a5cc4ca6a181ac5742373a8f81f41e53cefff6330255df01d2dc10fc14afd79b6cb0f61c922e56aa6b1f0977c1be49fc211fd9e91b15f52f3be6f91533b3e5ca6bbfab6786061e58dfc4c550b3b8b8e8e8511c73914515ab6f5d8e4d244da978e38a9a350d1c40d0f70370fe7545dc91a5e4099ff29160a29534164507818796c1517e84280359cfbd8b7af7a88358e649d078a599d6c7a8ee2b15a2d666dc097d6e3fa9f59b16762dc353aec783c37003417be0b2dccd2abb6526e6cd31d68b28d388ad42bd94733560c576790567416992727221d624b226bc376d6c21928e17ffe5c91a2ced4c3f85cd1d999cac7ef5fa91fb1f111b2727bc0c3d3d9b535cb5d3dbc607214fe9ab8054f532ec6d72276dda2a019d028dd8704e7361f63c6d884ee8f5301292c76a3dd2ee098613566e14308c24de2bd76f1516cc6781e3c6506d270b17290f916126c456e3a0d6b2d1b01ce21e2ac337c9ce8363f6afbbe2c71d89925e2de9ac763269e8376f8e11abdea1b1882c9da396b33474d13a400d45d3a25f4224560bc399ba259aa8a54a5027d09a8ac0ee03272f460c43215f67dba35b1e52c23c28bc26a938c1d70fa9c3f7c6324d1f0bc545e238316fb2c14d46733e2d371bf922fdbb418b1beca22c4072fc065d3d25849b2e47db7c43e1544d350b81a03870d4e4b39e762136fdd457f69b643d561f24ef2c900e75f4013d0c9335547d677ddf01ffcefc1396413672830dfb0617e4e74f4de5591ea919d9a1463ecc321c14f46b5d39da3be86c838f5fd877ae467f845d93d7441330a9bd3a1dbbb9d3e71c2db314ba9b3e4f35e654503501396eb51b4899136d98a75949882eba26f0d6a0f7671f5b0fdf83c5f3140f5fa551fbaec807a3e77f85e99a8cb98584ddb43a10c95f470c82581c14fefb0b52c8858c20a49f7730c52157baa4e62429af5bfb3f53775830bdbeb8c50f3771d4da566cad2f899e89b85c22906bd32ddf30003770a40649e2f3018d600d944db55322028d75c7c63701781e142a57b0d326b096cf37bc7390beb0a4fb2d9a8ac17baf6703e196de2235a288662580a553c4cf41ef7425c6a5474bf6b26be43f346eff5ec8fa6886f1b770b09ab8ec907128707fda68a1c8123b23c37e028ee5e01daa92dd32a21de5d555ea96d115e56e6ba7b500c1926468f8696faa36045b7cd48e7089baf871e73a35e4dd01e2f8f5575fbc31f781695b76b1717fbdaf87999a794a79630006973354eafaa55d71e88b9bfc22429e04418ad83926b85f24fa83e763d7fb2e547adc2a78b255a93e1fc72847e0497e4dec23db0009c73184144cade417becb018f88809945328ec1872111340f34da3aa003ab396ea3b1936b4cb099d826385897154a5da14888106caffe4fb4c1b214bce115eb7c7d4553e57e2ed563fe939441c04c92a2eb5fa0fc112ea5b1eba7e9ec581601c845ac9793c66509935fabbaf9558a9658304f2eedd95b5c2e35c97443875469c17b2ab4d3462b1188aa25599165614265fd8de3adba4ba767690933a822f2056b09f9a7995f7feaaddfd2e9e2f8e3958ebaed8d415751f09cc5bba09e6fcd2eadbfc073e10500960f37a1262df77570919c147703db694837f3e84c598f5a7c4bdca5d3857860ecc966787d59f10580f3a71662f7e107901f50c8d1eb28820060b6961f5996c61ee322d9a462592604de24eaa8e18b2788743b9cc1776c0dff3238c964f11eae189cdfc9a534c25b55967a3ef340e99b71c3ff224f1ca59d172f55a2d2c27a13a86bca45c8cc50c2fa17b0e00c9bd324b17d869b05bc3bf6e6f8e38bb9940b8da53dd60341d3efe45bcdfe6ef30ed065d88a2e2f423e47a4b77e0431572477490500961c67103088d26e0c8440ac8a627c4cb95460d7be1fab3def3257524a626c858e6cc0be85922e63cdc4afcd72a68aa8fd38f22e72f1340dfadcdb43ead6850511f17fdc5f4102eac5c6e21516f58df0d1d35162f86a72c43a81d779a58e93af7e98bc1dc39ec2eff82620666fb0c932863e450d3fffb0cd8da6809849a3af4da359f46a7917e2ac7d0b725c28fb908bc5a904469e684b0a4f2389f409777eaa25ab1d2aae9c02ef6921de229e5cbc43be66e4b81648af687eb25917cbf81a140fb8e6911fce7cb6b6502b4f5a1fb680c7f1c46191031305fd09e21b282a59a232b7fffc6296a0751a4025fa839c3d998d82ad5ea63b6f1a6a7e8956b43531069b2ac4d5b915fddf003a9d8dac54afd79818d0c56a01d54d1aece090650936257040336feb1711f02e6f522dd2a428c9354a689874f6f71dcaa11ef86d187bc0ddac1d32ee77a54d62e769636c6f2f1bb4a024b78460938176a58025bdee734a506ecee4c3b4be2d79d76943158502a93f82d8b8873ec0ee1a492f3c42996594cbba02f4c6212045269d554acb69194c03bf07c226c0a8ab282690cd5fa25696063a5c9877b34b4a130fddfce04fb85fe676fd383dd224a9222b243fbe9d75bbdca82135b1ca604949a0d2163a27c97f561c0903d757dc69b27fb35ffd20180628e28943c79192ab1429093a6d14dc745c297fec09c48349c22e1d60884c1d9f805446698e6a49ea7bb7e53826e03bff27ffc6c794c9f2d4be7f60637bfd17e0e4cc86d1c3d666eeee07eacfba9a763c1072df8cf650fac85f012197f865d170165fd434b4c7a41e4f5f2df3da2103669b3dce76f4fa8af8645c9cd577d40487346e1392d11329ca91145ae2b5ff5bc0721d2dea43df2f8c5f0b86e77c981a04db34c6aa49bf01b96b2267844019c2c07fffbb8f1a84a5f9baa689df9ffea0ee91fa049ff603b6071b6e46af17378c10b7939d961bc21bbc4dea033be83a0beeeb2c1fb4e3a5c741979196fa4825c145a2058df1c526a281aef0c2d8cb7e22f668d0c997d323ca2940ece6c1742f486476aefe69f34eccc41968b17ccdd9f5097c88492529e11a4b1fddda7eed40425e1fe066909406e9af6a3e57dc7beb6b18eed7abf83e10384f54758cd63543588517af78e9e79e16e4f17d94d4c04e30d700da15f40447afd74d5da6549c6044279ec7e8a1b1351a76100fd4aa29511e3bad4c0b32b8ee5e3c4526589c414c3c60cff42f5b89c07102062d60aa3ab91c2dd66cd6ea5db8367f964f402e770884694c634e66df8ad09932940b025f49f8858c68c2466d07e0e0ded21ff31d2fe1fbd19c93eb599d90f3e72dc58db816b1f157b9f9a4e9a90ecebb5961bc05c4f2bf03bda7355a30863fa5489cb010b9e1b504cbe725fff08f331ffbfa681114aeab621860a641008ce59669163884d63a4cdc58e02b658ba29be43cc36b9a3dc9a240cab7892df09bd084acd6a272908325cbe13f75740a99652b8ae9bbcbe82bc88d9509ed96a6e4060ad614a18fb34fb78884b3ea379fd428ff20fec6243db16b66454fddf03aee7b265da1c1cb18fdf46bc42a111c3029a6f79889f3d14469ff52e272cdad75b1e8230b4eff2e643bf2a16356a43fa1740d20d3b41a6ba0b7bdccb837db6a24d7db7d23e243742479e6d6d205835746541b4b2b19495c6e07d2d047313d264f0e9184939a15097c649a3512a24d8ce8021fc4d1e9958ffc838e8cc8b3fb9c08306d95242b428dccaaa3a79f38870dada3d5c7512c19ea1e0af5e0b0d61ae24c80d1fae978c85a87d790a89ba88b060941f8932f2d7e11eb83b668413eb31c37a358dee524d08f2a5baba5c036ecfd600c136e46dd3e9fdaa16ba7245a303eccd5b901f05fd0cd2e2bfce44be7bc397effc675e8ed77a00c0b00bdc0f841c2d039aa8f8a33d45d1d5d978cd4dde845cd96d752e68c2bc2c955eee06783cc4fced9530f4c9dc377b636ab9eb422eac943ebb39a4b44a76ddc233421216cf5b9e35170572a28bb5bdeb8cbb7de84a1cdd124edcb85c8559cc8dfc2203d2b160620a732133bde2bcb55d88cd25d0ee53803f45f6efd244bd93785412b46d6af397cc13b3a895bfced9f554da1e5a13e38ee7c6a0f56d8a2d9af31f3ddb01c4f141760c97f3255f60ffc6fc363b449e50607884786f7ed5c8bd705aaeb64f43820f07f75c1f49fe9d44d4e3973ff216cb85c57694dd166167e3e893eb62e71e473a06a79af9b75ad2a8d61d18b38320db45fc71348ab61b498629ab3dbb2cc4b5de0b1be354817e22dda11c44ea1f3725ebfadcbd01d1d672f47fcc677591e0ed1457eed0614467cb2e0b40fbc8a0152002eda5e01a4b2bd8c1e0b465c8ce40abf347566e53fecc8b0a074e55c721e8a19513680d507aa94a13003d75e86fddb7dff8959bce694648a280d02f6f32d9d48049fcdce55823a66d51272fc8e0129201d1c2bab47fe716820145924585c3f534894a46644b2974fc14c836de08f5a199e452b58a023fbe69e086a978ef151a0e0723b3cd56d2cd041233de9669457852af2dcb88cd48035c570abb29aa92e3f21b7be08404c69beb7770b12769fad8b55f75534cf403ba69a89859bd14316cf59bc8dffd7c4d08da1cbc2be1e5f26d897230383e1cb17220de93a75679da49b739aaf8719df8980e311d75f1ef5052f25f039c3e978a4c4e951001456aadfc476326a630ebeac50548411288a272ced0eae934fd0441f283b9e255ae77eaf0faa3916e50030b357836400961ca84558629c58f823312e9e54d76f90786250538d784460e2aa8b5d75e2edbe73efb2b5ca2c4567922a883161c283b3cccf0f4b0359abbdff2ddf78034fd0a704a6a62a1fd7da94b362a4c1c8534044cb7972a7a981e26514af8dc89b793502767a74ba7d218a2056d70c4e1bbd8855234a27daa4530b16b0d2b14073f0a7a3f206e152581c042ffdee4a43e3897e34cc0fcf5d1923a4a030f75f484ee3076650deb3614c8288729ea546fce5fc8c548842893526d566c93117c9b5c815b38376f2b0d022667d845f972a2dd667b6f20096fca7dbb14f6fcc5310654153a211c12ad3bd3bfafd5556429aa1ade20961096a6ef054e9ef1cb862a5aa5050a83a7fa6e4620eb10ff0c80bf92b816d1d4ae5eb0f444cc9c1f159942de05eaaeebf1f927dfd8eb899a55c040ac527062927a363a86eb7b195d8921069b85ff5a596c9db92df58659844c3fdc984a9efb3f16ceb2a022ee949aef64884e962c626cad4e954a99563b6bc58d85e611b2919c4e1885f60d8a784fb574f0c102d6dc0f482a4641aa7d073f30019738aadf5d2520a807cc2a51432bd76108822051c8d8bf53a481fd9c9c599da5778ee886de03e4279303added316fda2e03d27b52697525b9f9c287cb4adf4fff742b26a1d872c5e4390323014687d4ab6273badb26f926c42515f974731b619260ba7a43f1259ba6e6ff470eba399cdd826698d19c30cd00540d20049caa899b77d100b24980af0809c9ab6925f88e1d0b98059285aaa7927e801fee6c0814dd929c5881ae98e1f0617343699e7a0c2c080cdec13b923a33996546cdc17095e0e8c34e9e4fc6ccee9673b03885958fc3ed9e01890b77d66b33654bcf61d736f947b0ebbf4ab137845c7d3bb48293422b49047c4424eb534a9115a0005ff1413537a49a76bade2160f63567ec35d59fabd5113d8999608aa7cf6bbbffc68ab9b5acf7b92ee6fceee1c91f60e86e5cfa57624879832f3d1e056a7e8557a84d635da1241923b2205f3cf5fdfe70b49a5e7e1fdffa38985a4a0bd54aa42ddb98f241ae70f221f6c0f2fc851ddc904feb15f1d7d59d18ac3c909bab2f69747b109ce98c318e88558010621b6219ffa3545a5bd0cce6cb3400f2642c762e68d9f979a58830ea31e379bbaf56e56b99a9766e4ec364b6488357556770b081a9682a8d41e5c97ae5cd50115301def6899ab935a206f9166f00e7f553ad884ba785c3bb6982d1483f159bed36e1d670dd634c254d57caef75eadd648d7a86c2fb5c4b62fa5a20765b5f5e4d2e15af22372313d6a6cc42b3be9a12c011058cb6e2e2c8b0cbc815c75a044d47ec36092860f9fc3200ebb3ed030cf8128be7d2ae2e05f76cc2e3a42363602b64e135364611adb9fe46d41828a1e4f98a30e688feb51e02772f735d0d7a62818cf12cc6be97ca90ea68e1fbdfc0daf24fd549316fe6cbaaa0f7f44982a40e2e98b4b664b8cf8c62f4adb0991f99bee76278db7299c80696485fa4e1b69380842f1e3b2198ef55e63a96c8f9fe43111f649859ceb8b7e4dc81e6e1f960f92d43ae6b419c7c7829a69ecd1c97cb4b2602e5353fb56b5d80fe79245c624cb41dce71850bce507c8bad8f2842f3f09b4bc0c3b707c8ed6c105f7d13be82d7593341654629b2bd675d42d0407a8eb8c55bdaf73f7f098ce21120c2050f4a982e8d2ced5b1f5a129f14ec5cf7648b6a14bd33cd4d5e6da311083de2c012597a861e82280acf9fc7b1231deb1dafac001293a485a4631edf9b9a45ab240135a6909f22ea91c4a15dbee234c0a8bdacac2b509c10ba37d7587dd51e2053837cf1227cb1d0af7dc95c8a8c7b817ec60f9983b5dff1ac6e32e025bb639109b125fa7059e2bedea86918e3fb2d1519b74dfbfeb3affb9a45c28db9c4a850caecab12b40c71002836af28b772018f762f121096005f2afd8c02f5457c12f72fe14609f7bd008148b86a9f24035f669f2c584f918bd4a35b6912cd16d260e80e5c496ecadf5c739ae66cb47f0f79471c380fd0e5315f94f5f7814d1323f744b749ee4ccdf805e9baed29e2fe1901e010820eb6f03f68203631f6d9f4ec679a1f3c08b6dee43349873db2bba340f892c0dd1fe312fb0cd602322f4c83ed57e4d0791a4c0963505d7ffbc82ada0fbdc87d6a4abf3ed6a471c9cbfd9ed12fb57a903669bf2f5036046473f9319406d7d22555a6f601532572d1765146ab0b4dd9897ab32ecaf774c26e2afd64bb1adbc914bf6ab8a62923d6c11866f4b697261dd7d1a14ae3565c7e824401c99e1c1624624e0d3e7d6b02258092ceb00bfebfd3162740f94feebda084252e4fb6c978ab59d48346cf6dbc6144075a387affe6a8cea873f4aa4d2573e16c05f91520b4dfe3690ce8d3a79612ade17464127bf072efb68dade65d218a1dbbdec80a999e5a894bec9d9d48687dac51775c7ce05c3d15851e7ff3030d9b4ad4fbf7cfc5ff77e5f4a7b575a237f9d101b2317a710968395c0c4daf5813c4b07633fce06436a994ce548df72ad50369f9aab578de263f38b6d53382fd0cc4a5122919a8f2677da91a157d9be99df770b9a5367210544778fc21d86126ce97f248469a6de50cf2ef29cd75c7d4167dfb42c07959202712d29d72879115ef7ea903ee646f5b9b8d55bb809c08fb7a227959c4b9d3a9c92392721cf6281d6865d6472cd171532c08f4bddda5e415f357bbf637d624d654bd779c63c303961f483c3aa8b23c3551260c61de178fec80e7544bde78c7bb442c818f3acf305ca2eae7afd1213e8250786ccb571584b51689467a4ba72740d8ac139d21e885391c79114515940c51a86a2225db6bff4a73dcad4593271a7a931917fd99738955c98bb1445acf0cd40d67042fa33dc3e988024088ac91d05ae33d2f51b2e6305492365073ae2dae95a32cc42106edf5db5af03a8e93f2663a0f0c31fad86a90e0600c16396c253ed3317ff9ccea9882dc7669a125d3737379be0b2c6dd3a14e6c8dfb1f832584142e5acfaac1e41bf6986dd815060be9a0f3cef22a47fad2c1ef0d9f62b199efc047788922680c7d856c95a7159147484b01e4038d9ac8af07397c3b7bec970c6339f3b652df26eb1b13e43654d50675356982d5ab700531f665a5d50e47688cd173dd5ca3e27a3f008d5b823c47be9a615c54c5bea6d6f0696a474f2565e438fdb3a4ef7659f5bd6aa4513e5c184b2224a230a271b8c3ba09f3ee124a4efff0330950ef5c55f67163197a306d021a32b0a9ea28e512502f4646e9e4a3697b808d71cbf187b6c72595eefaadd64f540596e1fd90b25f928bef3c515c5f11cdfaec7d3e621ab2ffbbb730da17dcb3e7fe5e299aa81a64fbc5268a567c42135960d133ada72736d45a7142c97c90dc8316ca78ba1839075a63dbe1a7f5389ab51650de16c5093ff579c686e93d3ae81f8180f44df59cac13a9a0494f79aef2e117c1d774f074af0b1e9cc5643c70d1e13b3e1603a0a98dce0648404d247c0e4b04399657b4e2a991bc92fde734dd9b08d13751af157320dbd486b210bd4ce28b3879e942212c760b9d1ecc0cca30a55f2e18bcdac8863a8da18dd91a6b07471bfa5f4a55a0fb1aa0b1860efda8f28a9cbc6397e63f62a3b1f566aa0a7a8e228a3503c8858f00800f3a7cbdb6eece03490331efaa64d4f3c4d13a7d8d115795c0ff9d2019d293d800fdb2405226d2ad04d1330a3a6d47232efa33c4a316e0c6023714e4344c025ed17c878b85393941fb9077bdb0c19bed453b7595bdd151476b1ac95f456952040c58f25ca1b05deca17621487325fa4d06dcdae3d541e2ca4e33a966a035f14ed15a6e541e9061299d21d4aed52358f8621db04e7c438a09a4a184cb542dbf6a03c6da219723fde4a948d957ad1660763c8a087a226e2a389b045eb8143430ee02ae24a54537ac4761c901d75af4763883141d044be0d1901775c3626fbd2275a83a26c08ca707812997afc0977bc3a2ed1c216a244e2acc31b4d601b5de88cec4e5d935978cfc3f073650641691d4f993d82f49bda78ccdc0fad7873582bfa1b5e83e951aa5e33d549e02edcaab9760eaa093c1cc75a54078f6e7b9bc834049bf38f3987cab49fc582f90521a10bc8cdc6a2b5c188402d598d870e94235650b7176cd8ce6586493368ead572be68ed3513836aa265fa3bce642ac164020204624d2bc9d4b6f490b51fb199b877842b65775c127ff943674d29797950cd197229cf85e5acf86d7cbc16653a9bad71a376a43ada6570346955ffa4706f22bc823ac169240ef3517e53c5e3734201571c54c7b930b4bc29472419f14008c644154c40e513c9394f4d0ff433913cb351a79a99a1661ef305eeb43bf7ed3119eae3d00d40e11a859389bb5fd32f34d9716770967f49e6405ec14171e4f1c628106d9eda08bfece9c2f72a00b27ace23b97a5abdcd841bec2e96f329c6e6cfc1cdcdb885b67c4791b8cf7c3a2cac599c3bba50b801e79b3a6957aeb312bb847d572484b94cd7bbb94b57493a2ed9f8781a105764ac8cb2cddb489fd84fc34216c1ed4fcf193b6c94c57dbd11552b0dadc329818595dea0d6671798d38216a93986f064154ac21d193ea72e7483c6cd385c01a7c332d1d9114501c8ee6739e4d20bf3a2baf22348be4deeaa0a345d8a5ff44f66c70743a197d31ac700f88de290a594f6d64f7e3734c66241295d0c71b0f24c0e13fb11d3c504a41e0e2449816973dba416b89fbe28844934b1bb37768f888a40dca58faab9ed9aac3302872ea35b461f301bc87e89f590c1d94f4e8ef899542788dc60fa0412d71a3a7ea85ad4000c74ddfec7a34d97569b2ef99f634978c70cafe64d3e6051c34d644901c2ee8f3bcf5c982293a464b61b25e8b7991431bd32b3173bc9ab42331497241a1a4137e2ff662d4afc5f1c31278dbe7a04866921fc1379d2ed3a6eec39369fbc14e8641e6a7cfa9d5f5aed5abf8c1b55adb24061e8c37f6413f5be9955facaa6dce1d4b4427cbfbe41f740e335e76df37c2bb83b3025e1eb74295230f18d7f1dcc183fc3c846489948816d3dcc3befef1536023f0dc3404996873b4797e352ddccef2b8804c5ac4e95fad250272edb08ede5cb8f4b9a0096b955f9918dfc28bba296cff80debee71c3ffcecf342dc157e72ff9976c2af1d067ae0116c00e78c09ffa8ddd657b061984fe12d23abc2b9cfe2cec1ee909d155e70fcef766fb3b9019aeed30eee8df1e09f357c2cfd56d0393c8755025b3a9148185a97df49ae0d0e48cc5b844b81f1a08ac235ddbffc7cc18352f383b90af5c9b52e440085a6473fd13b4366da378303926186f2ed6b03c82a6dd4c3b3c119034c1cc5246337d885bb448bd22002a22b59e488feabed7f450e2f4c4e37cebad6a1ccc2e42d8ef4f6482b5f8dacdc1ff0e9a88310151f7939dbfd6e0901e0bc3b8041373d89c792f79bef6d17c64505375eac5cebc68cf2f340529771f5c0f1b7230a5d8cb6b79a43e2f760a81fa970803930ed1253ff2841fa823678e8da520294bbc7ab0d4d9fd6a8079a884f49ed0e2da2f11ed19f8bd36bceeaefaadfcce68c57c02e7fdef85e4e731780d7ef9f926fc774a79531a8afb50bb84a004c08b761169ea1cb5295b392b627eef02e36d1bb312959909dcd249edd9a505d5cf7064bdd1a1af9f8e07716a725eb86d15c9a3d6f3ae41b831af10294700ab75c5f7c687210c795bcfdd085b5e2bb9148a6de09050db2d5b58db0af00811c3c1ae5a4ff21c562492bbee06f0d3fd2de7f2e2e625510d0a133539ea3d9523429dcac24d6fec3a147a0d17d69f2b5bb60dcc06556dd415ae9801a740956435291338de89d509a7f85f92eff268b73816be0c8a25588b0eb4f4d6b1c2c9b59c7a9483e03273431e1cf598550e0605cc5968888f9f419c4cdfcc2cd2bdcc6591c35c7f4f3e0fdce08eac820f2a722d3b1630a555d71361dcd0ad66421cdaffe2751c884631be92f0802499b16fbba6a57feb980cd0e2de71cfdd0bc9bb1409a027e927a63fe42a1f237cb867c85b8f760533eca32817c6cc2899850d528190b0f4c43833025bcaf856615913430addb87d68a704f391db38975d5c38865fb73370ca628d1bbef73210281eb43f793765b35894d935e0d237b7359804e7a412464d11ff47fc21ba029fce3b5a3c73f049da4bed5a5a1d3fa886bf41d8a8b95a23cb0ae03868fb1caccba31c4d946ae86a1d217287f670fa5077743f73b514019dbadb473d9b28aee15ad5e745d139c593f03be3c2d794e5592af0ee7feb267fea92d3985032f055c52a96f404fe8ce73dc744f0f9df4a9132aa4279bf97e40c5b19f5eee8aae7418cb9ce05e1bfa7ee2aaf0efbc9f0232bf29f9c73c9c4fc8f3ea7b5ddded41f63d83bb802afd66fdba4ed6ce7a39a6f74402899fd4c0c4e92d34339b8301590b4c38c45ed7e22c76196ec38a36037eb323d738bf423f9531ab1450a1392500e1e2e41bba89295b88e17eec4e59908deb7e509a4abff39b9ff19488654c1ddf57fb4260257eddbc0a083bf21755d14f61f3c1fd3afecbd4ce640f4d73a1c30b6dc2f6861a8e43683d34025bac9a2010e2750bee2cd9dc9324d1dea6ccc8d8540278bb95a342f76781a025e95613ec6a1170a7ebc1162d4cb770a589a1e3392e9fa69c82a66fe92e5d9f7e43d4f5631f1b6a8bd592ef2d2c7d661eeaff76e32172a32fbcc8bce509b164b9a60c0a7fb4f753ab67ccca7d90f6492c218dd406733b5305e203b45d60ee6d826db9df80a88333dab6930eb2a33f6e789e08b2db5c9ae592756b9b698384cb77d88792098df47c76811b4b7cef088a004ab0985e1d56ce907021b804324fac16458e590ff1d2f388d31dbfff08081bb7d442a2eb55c9d3fcf36b23996b316ab353d1ec8d7e22fd2c6aa63c7869152065faa56ced1deab56d7ef8d5eef5eee4fc86aec64266dc74943e9b83fc4c34ff1ff1c9ec1205ca13d884a5853b54f95229dc07ca055d905e979525fee19b7113c203d4a1db28b2c6dda5a7876c0ed6bfd23d52f0c720904d059d842e84df2e0a5d9cccbf0b04dca8d81dc9f3ff14d6eaf5d822bf47e3eaedb301064ba03cb65b6f2f566f5a8edb9d66e263b79f0d16771daa7af9b55cc8839d9ca5456f5627447848e4b7be050c231c010b1881e16166de9adf142bb8d894cb05203d34ca7edae11f5bc26235f9bfcd563c2a496fa7e9aa9c45132af82b43b01f14f65faf00b31a7746ccc79efa2e0db8320a4eb75ea881d43c60458e3304d811861b5d0a58ba4828f9ac65a5a920a1ed684d93fc87fd60155325857a2fb412686a2d53ee274c84a538a26aef133302bbb039f043181075261614e9cbd631aba2a9c4054e50f4694f327a77aef03c42b57e7eb3c217bc9c89bb569c4d449bc003020eb95e0f6cdb46b501ac66302e9e5950d5da3595a68f26a5e49f26a9ad060379ebf9a1976bac6b6b27981e98548c75fc9ea8ba2a5b289b936cdd7ef530c3f219a0071daf0175b18cba1787958cf99baa57a32265a538cf2dbeeeab5b47fabd7e5b39282e7aacd2494be5c38a283de195b3d7849ee897ef4d6906b506fe5d5083c795a0fc89b50f167e5a2161b6b4d3c704b66663d72313e1b83a057f456beb83036e997a72f6c710826e91beb270c0c01455f0b7f5bfa84753a20a5fd7c4c0509a20659d5269aeb7d2a457b34256e3ae14db3b9a8eacd7b5dcd8b93db3490302470f0ab99d96a967b1810c3fde60365ae21e8a3a890412ad2f0e6512230a943759737ba9e354fcd1423d9835c70b5210e96db9ab1603399365dba3de5dd1999a083870276925a240fc82497843f1256140e986c7d2d7c92c705c619cf411372485335725dc5917c72615849040742f2805de8d81aad15af68f7d8eea3785ebdb0d54c4caf81d1aae73096c01e0e2caa2059519e03fc98ffc13cf5b2afe4d8256fca5ca9dfff37f3569cbeb12b5e80fcddb3fd083665fe1f2ee46ef6163516a1878b4c7a0778e13d8e48ead817799e3019a8ec360c06a71a8f89367f919ba7b060492c907219ac5c5debb326ec9cfa53b7bc448cb27c9beebf48693557febe547b1b288aea62fb3f187a2bab9223c795affa55201f8c8ee6d95c518b7ba24e0827c77ab347af550f138c25be7b9001614d3f3053a29551c392d3bf9437bf4c5f1105048d57d1bde91636a6491da3445643da144e7d5aa696f4e393e8172f0324615b3d0b88c32e1f8230f61069e1a355cea9bef558ee2ee64871a9b11aacfcba6c09b12410d1a60ee27098563e1ec7141b62c796d559fe6d0efb548545404b2b055ad79c0f55496395b4b6c28d8bb874f44c12cbf00ff871ae35d8f4ed30ede8fab9b02de6b5d7c968a6ef74d7e27e363fb0b2fe7940c2ed3091e2f0a6736953a0d04bec7df87af926871a9fd34af4c39312e122f892a92f15d842231239968fbb6d522910b65f7dc74b92854638278acd31bcd3eb9cc3f76418adefb033e5e1dae5146373c6f71478b649b05964f949e94d1a184e8ef16e76e06b10a1a1e4c429e0fd4deec9688c3f0982e96cebf081ff424781f39d01aa1cd32973bfea4c99ec80d2581baad893368eebbbc56ba13960f0e3a8d2183a0a3eaa3260dc6c458c46bc1288bdaa00974dd0e80979c4cf7d4e080528c761964251e7f7b55246150f1801897af035e70fdae079cf0b054f9cab3e635dd879769337fb9706091e22128bd35ec4be1fcc05b0db4b0d998fc553a820f246758aa13f437a769f2ed22e16735a024b9f55382c849e8de112bb15bccefb3101775aec4c8e0152961bb558d54fc11a47aaa87a2e7ccec422a7047ec098ca5c3ea91cb5c6e39b459e1a4cbc8e411c58fe68d1002e703475dc2b75e77946f36e80b89cec6aa3cefb5b698d5ce7538c059eabf0606a52ddad74222412f1ab846d093bb10092102f7958c547496c79ad252cd080f4fdbc0c2a36558007178bae76003b1648c3cb24d008dd15715a5af0fa154400729f0ea93797c16c6dd218570b1452bc0db4726e80ef78605368bca55ce3ff1619377f73d1dec9a9da69988aedb4c5ac9584d1c37ab6ebf31080f87c0d0aa57593fa1f104b6129daa8a8a77c9fbd415811c8a8d2eb44f1595ffc010a3dfc7ced4a75e09d9a0f50aa8834046b6b281adac954152acffb8e8dec74422c8ba90ca56f33ce132975a6cd52943ae1a368d963da01d54873192746b72a6d956672bb79729eb2fa3adeffaa5559ed59bb4a5a196e61e719a8d08adca217db5b513678a9e037d83e4bcf59895643639ad7b244044efcd85051c156ddb41246432ad5319d5f32f1085bd45c5efd7f84bcdf8ef7b2005c72ffc62b4ba709b0cac1ed8a0a086d266c365a4e499b55852643b48d79620112da9250ba911e8c74016e156e365ab0e0ddb9dad7230a0c8f57931877e5a9ccdea86c97478e56afb5b4fd093d14d2da5f2cf15ba5ebccfa4efa04ab7bde2cf800249655f605987e106264a97cd5fc4ef537b695718ba6ef10ef62bf981810d504933df616d0856b1c9dba004c057834e0cc84fdbb1ce983c0405e77a66d62685b37388bba6c84ecd0b392418b12f180d86ff1fc05014c18b1f00d2c8c16062b6245e313a09053254123a0adfcd5388690cd37b7bf5dd47b2fd97313e33f3381e9d944774d9e41996886369dbd228f91c085045bbd6f9b4f14c09d88f435ea216b5d39cceb19d6d93bde5e13f033ec2e2d052f57936535ce9623798c2118624a5a687a1223d979fc0d3cd127b79e7e26784f00d24981fc1663eb5943937908a9d1cd08cb3d3d4067a6a73c1df1868fb3d84fae38e79405d38d0d0679952dd9215c43a36dc78a8957d83722673bdbf9381251fba29474dda46af717a82985a1ed867de98a00e636a346a7cd152a785be8921c5e5aad34e93ffc3a4c217ebcf9e0a6d6775c9eea7ce3dec7370fed5026dbd93e339e5d5bb77ab53f45496ea5c839a2253b2d00dcd4ef0d7eb8bf71a1dc166d747a8552812b9f747104218d82c870caa87b63753c31bf2c689543ab81949212133e6c41add33a471595e365d137e819052520dac9def8c1b53e6e5ffbc2209f20a5d9a3a9463e0c780da1c50842dfeec3e41bb55099bd1cd899b2cfd5011000cbffa022525276f348e72d437520f9a18aba242983e20ae1c04235d860b90828109886156157ef6b92d7dbeb98b53abf25eded8938e2a40e2a5aea45769d8046e50be59e4d68ed89f0d53aba933ae79619ef53eec0c26cab601048c08d54b3e61d64d9576a0a99e1426d49daf93a88422c279096435d678063439b670b506850930af62089a3da92b699cbf9f55acc319ff6cbc7e139ac5b92822c88943e04f5571e07623df7131e008c61753b7c96986dd738c80f57d167c83d9a881c747d5a501db9cd60db5a19beb9f2b4c3b1aa27639835980e906c73dfed90e9a2b63e530ff053eed082f1721842979140324bd88a65417a4d8ebe73e1252ddb25295d8630c0af2cf5cfb2c67e5d02693e01f33f633ad8c99d4aaee694e3dff4c568759188b71feb25e7644cde2f42f035fb1460564645a9a9c520b5d12d13be6a1a81e6282001bc439365e42221a8dc45069f63ab9374b751c1a13985985cd2a26208dccf3878d92ac37655979b610824a533024c6bcab5414388789ccaf03dd62b3c35da6f708528293e88dfe5132188279160516d1994d525ea489a7be21d45579a7365f6a0bb7982e41719ca8b7f90a744651bea9981af7d808f58a8e1f05e9fdfb24bfb14c69f066f8f2017f6df983fecb0dceb44f29b6b2deec686e91619a7a0940f0a654e9a7b5575c04e8c7f66073ecdbd0e8b049af59a54b0ef369ec71c8d28d623a57b8d75978378275b3433904661f9ecff73a9cb381ef8b9e9094e1b121b956e20dcf97d1a895bdc40ddeb89c79158b3913364cd7dde5a78828fea522b8ee726af86d66ded337a5b7fcef4194c322a733aa31d42356d668c20f9bb229b6fc9f28a71925eb9549668f809bbcc58cc7e214377a7759eb2b3d849051837fb00774cb35ea9e4a6a015130754ab1dca7141a293f4ca4244b026d7555c417d0fc5fc0388de70de60d76fd26b24233883783be958ab99780be458577ab1104c0a71eb217289e69233f562617475d15ffdbfce35a8bb72b4b54a881186ae9a46f5b2dc6912149abaf0c55a2e8e79f42d922a04ba48b82d49f2e93b1bf0e1f6ada4052db112b5719e2c40f5970af14523e26a77e739f9c30699e2e009d40da6c4f4264c6b3e191ca2eac605c233e0c66c59732a337c44823eeff4a39fd638006c0b7ce7efbf5d15651b710037078de776ad18f80de828387f7faa93c79b93cf591a26bbad5880885dad5ce062f79abb70a432c894d000f74430c134c742c23099f6ca8152a17d5e58c07eede7aff220805ee8a0afe3a01171daee33f509210606b938b2e98840a4021ee669031635d5d6cd189b9146598c641bf16f3d15a643cb4a04713c8657c897a37f8df2090de0812df4698c1ab2b9b5fdab32ec3f24e2dccdba0d7ec1acc8dc1a8904afa7681fcede5662d9c78fb9015a018f6950c83eff32b841c3617999894abf0ad0743de7425d1ca0e314caf39841c690c764b4b71d482999a30752a8468dc4b1f39c15696e3030146f231a0eaee07656362bbc5ddefcce07499b711fe887d2efbd9165ec207189b00cf1a8c343440ef8f7defaecea4a25d9ada4ff6d8de95c4d84bef1b2f86935c29996a3ae4419dc5c802924f8e4455ce527a128187513a36310bc788d515214e08e9d347d94fd7b56008aa9f29151058fdf2290eaa86e8463c28bb7ceb1101f4528c97b469e477d7eec76df864eab10256d16e9d6bbcc75e9a72b5ae249e5e9e99f7e4e93757e69ebc8191746dd10bc470a299bfe6a897a7ef852ecf17c6fadfbd74ff6a83247fca14f00abb58a32ad8e4c9194be2641c245123ecf88f9404715f57d7e0930c6f75ab9bb7ff3da5e93d5ba20e1d7dd7f2fbd5f644bac3fa78728be242258f04108f45d055106a269ea8f93a9432fedaa2d8a371beb678038460d6abec58eea0e984910a3f3d2ecb5fcd8f2b86973070d39b10f8428b4857d70c3016f4d874c1be61c346b282af072387a2a9ad7a4c47a5aca8240595f2523f271fe2c60447bbd723947ff283cd00e76b743eecf1e56715fbfb62cd12b4fdc33245b3137d250db8ef422b2e217ff576308d4533d3fda5036faefbd1bd2e05cfea1885b8371e48b394652505f484573b1e7e66e841c3fe883411263c918815f4d64b68076218589c122806395ab9694048eebc0bd71f862331123646475702b413db0e3b8c2b0f614be3bfc87a4483befb2eca24776066fd7beff1f939943bd4cc8ba949c3d60549b0299319bff6639331240d2b2f55ae33d046f7fd76e3add48de6f2d0873f51e3d4faa22416d37783551110f4fc9b6d9f0ee5cf15754b0bfc055cb62dc23d63534b8c78b164c52fa2d874aeffa5b7f47a678924b2e6f8ba3b69de5992e9e15b3ba9b99cbfad4290a23b69e48275b9cba06bfaaa55c128ff2abf4a835c80346367d24339ad695b34d902699630c3bb2771d47ce18019e2f1addedad9b1b8fd9600f01d23985101613ff7bbc756639f4dd2455e09a03012c1f31dc39a8172d52bfcb3c8aa339536b36c190b4487e6336760cc1c3a85b24d48763e164c024289d2c77cc4cac1f98c9c2da9e89f9fb3d0bec61acc56e3daa2da37cf27c3f5c7d2502a6be535b11741a54a769c79ae2ee594ab74dde5ec36fab08ad9176893150704be0379b7712cd7c48194951fc4ee4bfd9d97da7ce811c94e029af34bcc743f6f9edea3a09167e74c16a8bbf2b765f05c76b232efa53eb244c293dea23a6d0e8b17b5901b7298b3abf76476f6d9a335cd80825a10996dd78bfd2497ecd6d9e2d2a5f0044d3b53daec1512c591e3329d9bb9bd03a7e2e9e670a86e2562df68e5cbe40c1138de37f1a0d6fa4c9f03b262b6e36f9585e23abe5fc75ac3551d918c2b53809c3b19f25f7ddf8508381703978022e306afefc2b97be8c8b8ef5dc826e245be241e9491c3d136ccf3473ad16edbc2a0480628efdae310da4589f5c4671b8ecf1e11153e1af2b183554d30ff5744fa02c0259e8b0af341986f4ba2332e20e69857e1f819d10183afa8b700a8c49596cf6d43a750c228f0be10bd3ab564bd255614f981a295787e4548522f8a39ddc73b503a7a394f2e776a33322cd2f6be95b1f7b8cf46c02d73e0dc1cf4e4338b5e987e0289bf0b167ff380f931825b300b2e4bfcec2e7a8fc09069bad895a7c39c549702f7c1cf87bcf21ec8c8bd646488ae9721fd52cb62392688c11797cbcdabd4be5f45aa18d330a6b6756ee078db4ef785050d1845c5aedd9cbe45ae52d3f654fe374e9e7b077476c10aa098d2849e275e05ab9ba4d1ede1fa74bba4360d1583091e14fe4d4f47883c58587f4202ef022a40885dbae057e7d3e60aefe105a4f78ff379e5127affb42bd010fa2b8ad243b0b35c047bc9aca72d0ead7e137685d280cdfce2c7c94a3d563f213e973f507a094be3a148d3dc02882c8f0165da8464002dd6bd1f9e38ea4147fde1ad94278d7ccd23185a473c4aee1f652073cdbc5ee5729f218148367b75cfbaa2a9516a36e41a7a793de262419d5514f147152f9e139b483b24821789cb20e3ae8c86d7dc8f8886d77c92820cce827c8f1c7c1bd7316940e26a4299ac6923198b98d03ffe9ef838b2fcc5fabffba2bff9ac1c4b516b14ce6d0a096bf86a630832bee2a97975c5a840fb200d0195074bdc08c67f7ef7671991cafa4a562ea0e9d0807f027c0d4a1aa72030c2659f2070c28964d1cd2e09d36c61509767765506bb5588d79ebd53d97044f3cf91dec42851a72de3f2068fa945bdb8065094e566ff0ecba43d33d815971581ae8494962bc79c3170cd99a74f64ea406cd912a72198d1b17c4c287224cd2890064d69b6543362f3f613bf0193d7b4fb0dffcacd52ff8ae0fb744f156b9d189634e663d148b153744a65e78c5768ec0a215576e7a9d2d84edbc7d80537655fbd68206546e967350e227ec1267bac22ce1a6b3896bb34377a70d8862b7c2c494f9d1277018e744e94bcd84e11384ea7f8c08737db3c99f82a69b055dd5b9555f683b6e4f0772d2933a170fb42b4a55e9f796ca6e60095a80b628752cb824c31fef6bd4dbd83d0e1fb23a34c99f0c840cc385a3fefa74a6c7855eca19d50874919a2e52ef024e16adad255e7b03d3a540478df6696100b9a2c39f7456cbefdbe2c2d5bb18b9bddb025532dd2045b0cb79bdaeb9ee0fd83a33f75be3ca1e2cc7559a98ded398371d316da04c1aafc76820eeac81f5da1ff24d188c8858413ac0527e709c81acc903e1f49f5d4c4cccf39574506ea4bfff22f0e0fccc2d36430ebcacd1454c6171fd2231524276ca8dc4a15ee2faf8c1d3be70fba37863808b272275cf3e3a68e069d1292997a96425294c3b2530ff5e5171af733429cfb45ab2318d3e1ac560f9a9c3a4640472f1e18a03a11f95b6e917555a7aba2f5fee2e1c337f84893178ed7a2e756f39ef8eeb503cd69883a0eaa99c1826746bed75f7c44b1762f6f79a8410cea811984c4528876f999f4d7b0a5f144be2b4852c31c6741832ae306a145509c551f11247c2a4f2ffb58b42286f9c1628cccb78e29b7578969e22f9b14fc69c8ecea975a8332612cb06e64a3b3f0e530012e824e8ac22ac7b661a9054e2127c5ed59a37b44f5f061c916f809acd4faf0ba903abff25b81f05fac0a51846d8acf66a586fe888edda7bcce039cc9e95b795a0f42b71bb12f0c96cddaa347a9b246a139972c608763bce15d2eb6f3dca35113fe3373095509fa700947ca2b80d57cc8c7e781232c5d04eff86c6fd5f333be7155e3ddd2eb562d6b29405d10c35d713e6c1009f54577abdbd94cc88bf55a2eb7d4771c16e96bdf0b9c3d8d599f00ba11bd29dff68eadb21bf36e58cb5a6bba1612cd4b4688accc4304f8529c980a8835df7ea4e66e7b9a39f05c145ee2bd4a3f1a4e8cfaf13e6b0f50cc758d3d98ee424447dbfdba5dec74e0f7fd61d6916beb4e9ff8fef18f1ed67eecf6babf2471879a8f112840bdfd54a4a92e6c7fbb9273dfb0ad2fa2155381f6eb1e19c42eaf92dfa9a918550cd0e2f6d40aad2fdef934ecd1f6fa1611c45e833ec0a80ac47b232bbcdd93c48c8ebe607c22082cd4ccb34ac788ef850d762132511336bf5968969dcdc81b11aedd386d4045325a95cced33d95cd68970c168c91b29f8a669bba1790be927f405dc2c0356737f5948ae334210c0920b8d6228a11b2453cb12cf0af2f8c04526859673b9f0e209a3f31c39e4438c81791f9c73419abfc0144dfe0c4524d0228e6fdadfdd5429f28ea9b41e2ba3fdf84f2a1887e1f53a1e08e31f51e88cf70cca7ca7d906807d07b555e8f74e8f8847dfccb5e1f29b0c011891e76cfdca16dfb0a0dd31ff0bbf2453b4f37b314d2bc2ed860998394f3894ee239abdc197889a61eed129c010f5105218e603726fcd6915852137b3486a0b1a86b90ec355b5ddd1ced09ef20c19a9592c410344443365113ae60881d9cf493f78d915131cf17d6777aa4ea8b4384c88bca01f9a3e1dc3f6eacc375b40e2bfd8a8ba67356515ef17af425a8978769e5ddd30a66bcc93e94586dcff3ad44da3369556e1546f26d8a01d402d6212866eddac60ed4c81226221465193faddd10bd6062059a1b50847a3287e54134bd4e0433800e7f888b6a1ff97732e125c97d69ca9f3cf5becb6c9a7af3c547be6b303857b43dbdd1bb94d3595451c05d27c8519cd528360d6b44061be1d55dbfca01222d67501374f109c38e5e084b2e41bf53d76ee2d53d6b680773519e01ce8173189b1f989a391921d2e00328813d1321a246c8069e053045da87ac0ec9aaeb967a3c985d5a318d6e671cdcee983ca7a70fe1ff4e122b052a3dcbf16eeba86a10f7fcdc8557915a23d5c0e9eb56eb80ad81f0f42377893f04c95254214a8ba9c42b3d280bdb9114c94c0c8337e20af1168bc75918d1bb54f5d5f610d01e5b639e4b2deeb5e61ea6d5ed646f153dbc8734510e25753f3c9a03f6a111aab10a3fa26fee2d16acf4cad493e7dead98bb029dd4ba4555cffa36b45c448990a7dc201e0be706d2a83e001b2906f9f944ff3f1520c023319746782802fd0134edd65fbb34ca7f548eb9772c32288e1204d39ac47a419af34177940a62c0408842a00b917ad1d2d79ff2ddaf795ab114d594fbabe37ea929c627819a29671dcd63ca64297a6795341762c3d96bbdcce071dcb468e5f96b8713245d1892785b24607b871d83fdbb95041847e52bdc2c12de02353e1b3868728f99b5b9019ddcf0e2f11846a39e4a102774bcf494109c795d039c0ad24be5bb913d918574d26bc228111061bef8ef0961206c99017ccc49511d2d64cbe1e1e468f28714655f527ea4520202cdab8d6c2b53ad1d2bb4a38356ea4763ef1ac86303f4fa5871411929d0c76be77e0330775825250d5c7faef475bed2e877b4439d4ae24f0663d0ab877d9f6cc4170a6a9ce26f82ec761316b5843f88c58a568fea7a723c5d85fbde737ec466cc615f65ff26987f2bc02eae35ebdd403dee7f966291d03717d51d39239d75bbd5090bdf77daf9442c782f016b29a15b2d8e999e697fe4441007eab5de80ebf23d243cf791d6142c1aa25d3830eb8382fc55c903b284a7cff78c218aaf7bd07ab07c1b8e5e91332df9f1804a60261be1998922f7162a12ff7bd04ebe09d316efa2b52ad4a6ac1c7fff1c031665d3489dd0982142719d3b7a68a992d3350a2517a8536720f91258b3f1700ce0bddbe755d9bf801a63832bae2985685948e1e2ea79be2862d2aa98f6db28ed79f67ded48dc050ebab2e9dcd2011766004d61ed2f99160672c26abd72d5122d5fa3a2db12d2a9ce41d95fd5a7be40fbd61ecac83a6ec92f5d6ec31061e3104b41e1b909358fdb86b13cb2507a1248a740893f825de64f3df791784fb6c1471615288a3d86204234809e1c12e98743780a49f9938cf8c255fd92e59229bcb52bf38ca812dbcaf57f755862ab3849cd1d53a2930f64f82c0f61d6f607215e7ecb055c1c53df6181a9405f55b128e61c2cd52d454111ed97dc8b3d9d3f520807d3c4cb7a5a395a17816ddabf73713de937e0274ebf55725b6067f9a8d73a6f94b944ea0779de0d82eb4dcdfde3c7c9ef76f5fd31bd654f4a4c11e095c97046f1608d16553ab45b8d8fe441deb0e5dfaf966eb62e415388cec07b7849b6e1b21210c59b7f69c4d6bb668730e571f4afd8118c0ad8d80838b602471c545ac3af4cb6bb0631726c1202e2f69fe4771946b6b4656a942635955bc75feb4bb968829b3631277a070d957414b2fd9846d791b147b46d84eb2ca2401963525e5570c681b5be00701fe9b864649dd83a6f1d126abbc18348195230b9c1e3c9138dea34693de70461d863638d8ae91fc3a7aa7ced3a865728bcc8f3f8830d7be747b7839a70ec32a2fb6463b446946a9623be4cf71bed871595e433de2511bf4063b7109309b7c62ea30098e293604fb256e8b317eed85413daa037e572518d5aeec0a2b020bf201265a1afa277ee5d956b7cc4d88d1d1162196f41fc135f779c7ee9d20ee828368b1d609ec78809594db55cb5123df2b4f2201618e4abd3c5459a5b506f16ca368119c249b0952440e81169648809e2f33837739d5bdcb013f249919433709332b275a3eb4c051654d49c031f314890be9228134c3b71afabfbb5dac9e95fb02f7b30c8b7faa18d80b2a23aa2c1ca193f7e5e16f5959d3d31311eafc741099ee6d3631f07be18277ae2aec82b0234c05ba7a3408bf3afa18077de709289cd6d8973407bc97a36b5e1cd31c8c2dd8890ee0f7603fd637292bd31a7c4910cdf3469d735978be7094a44fa7cb16605370226379da311bdadf95c32ba01941cbd718c0c8d4c44d83cc8546179692cb8c28945972ec48f76d0429fd07ee602f6626ccf5b880d36afe268d6a50d2ed3ed7034d6b5de79c1e85da9662811c3aeb3c6da6cc6956daefab9b3aae761c72b885762c90f5d28b383d48b2dda5216e966d55a1852163dd41015cc5a3abece0ca2ad8001deea2d855d017547ba6e64682ee623678313d230e8654fd39f871400f9bea78a5b2c4a9dbf0ce7bb7ca9b26f9f72e1b89fcac4bba121c736e42e3892222fe3ff9c5323107dab0aa408f0783b81e60610e908f731c2161d15263a7bede5abc0786d521e3201d41b5030ad1a96ddda5a24092a527071a03201af377560ea7186080f2684f890f2002c861e8bcc337268f2797bdf283c21e5fb2e2f3d2c5e79c1d0c949408d2833a9dbc3bb9411d1312aa191b8696325d3e02b09d3f2b40a744d9b71229cc872b137676b103ee748a7d7e7fe85ac957f459509b5edfa24f0e46a74547034db9935043b7cf66ad3f584192505005c59a01666bd254494836357dae4bfe78072017abe71ea63a4b8a71b22441fca364760b0d6f4c549ecd42971e585aa0b370d8ebe5b16e4595aceb6e863394ac899d38eedd3ad68574b49ada05346c6985f0bdbc9ca96b6e19ab628228e9ea43858b9d02e9bef6e944977436bb49364a9e74f694f0e4e3da93f74885330b169b05311f8f68777486a720a352d028b56625810f5d0fa81fc907b2c71da4cf83a16f5971d54a2239b714a2d2af174d473272beb38f0bd1df464ecfda5e71d1d54f578addaf20f2fc81036349f3b906fd623325c1d8b1f14b6b0323e93c52cfeea6e137edbaac3483fa8a8eeb1b135400954e9d3d15b5a598369ed060821d9836ef70bc3dc24902456feac110d30b26bb9867d6b932ff552dfd90ee16a1127a3212d16554fd080d6dcfda68ac1ee74484c5d6afb96cc3eaee18a4678b29015f8f782259d70fc41624811384b1c52070999302c2e37b3be59a77d8210db0d28ae829c5054d719247b312b14f79a2fcb3a3aec3bd7afa7a963069ba17002ff54b2641d9d4f3f9fb54be1863e702a4865625c965888a0f9e4f3739dd2be00401a002709ff99a7c7dcce920a0cec6317df5a8bb2dda1eb53f250dfa7cea21c0e7fb8a80375514cac37c34c5f040148085024fcd4d69d87d1c4c7179f571205ce45059de40c108f85817e7029873811602130030f9ec8f28dcbd014d2eddff94176311ada97f4b898658860659444769b111eb18e557fcb89d24544e51c2aec0e913381a47586a0db1c30d76c7790ca96a4d0099433833be4a1f2181b85381f5382963a2b5ea133da31c561c49ab29c1670962219234af1adefe9e025afe529e0a92949350ec04fd3b9b718245ff348196ea8d12127acbb69ffcef29a1ac894bf761491189445efacb3700668083f49520e3b1fd75614146c9394ae19d116e7d5061135e75bf81afdf2f9ad3c09e9878ea4acbb988bfd7d9f46238d6e13edefc20e7907e8285c0789d6d7704d7ddbcf002618f79ac36dd72aa200bd8159a252b91d0d0109f52cc8a957dbd4db2c094f3568e95a5fc6941bbd14f767d435c5e05320dc8de238e38b0fc454051ddaee4579578d41222f8db37bf8065d709ddc7c2f10fd265506c01d838774bdc8efeb93c00e901429804eceffb2d45f7f4754a9629e53729fb892471b7ecbb574c9980e38a7487d26452a536e6e55c48ab4755d494bcb041b69933b022d7eae1596de66c829fbc62bb9c34622b019aa4f3009125dabf2d225ce97baa554d36a7036e54d0a0bf720742f0873451154aadf465386d90dbf5418a92f04b43d1ae696b360bc2a9b904de39cdc95b5e2064ecfd27df4d5fa8fc0d4caad17f1130e6b8d7f7f7cb06ecb5d82b1901e64cd9d8cff8be71c53dd67556aee0986f3d53ecdc9448ea4b18825512f1d2f4561dc24ed263432f9b705c03c4d4b3ba0f08875436b3e2dabad06a5fa64ac6d166de2a7edc23bcb7abadba6a4c5b8fe785801f4e0792f4bb56d0b2fbcc1e7a1b2c19be73dfb6c28c89789abc8719931e3b8c8ca3e0314ff7d59a68b4b7b4e2920f9734a384988eb2ba27dfdc42cad69c1ac346b03e571e7569501bcb83ca476466d17828ce85bd4bce3d03ce5b02dd3fc290b9f037b35768cdc784a516c4b5b636fb1fb83f6f553881fc006cd10632fc5af307b1a2ad45549d309c20f7d518274914de929ed4ce0214f4b900e229e5eaee67339d491399fba09d80f81afd68918412a7660c3e91e9ef347010639898a53b40f56af87a5a4e575191bea506638b9fe70aadec41bc0bbd7d165f1e82a1d3ecde5a949bb507327ecd26b94cd8d2f9324461948c910c446b5fc6d428bc2a60bc30f02e9dceeda1d19915eeeb0d6dbeabf528fb2a35f79197a035372c75f6b90079bfd05e511b7aeaac1ea06365e3e27620513619ce049dea9ac287dc201a39f9d960ced504714871411f16ba2958d008f1b706f98316cd389ec34988cbe1ce73edea556e7d4c75ca71df2ea56c5072cbd297d7cf0ba394462727bdcdaa99096ca9d7be8035a4e6fa64f44d15d1991c176c853e5722ef2fade7ef1ed8aee03d4324c3e71ef9ae920b054e4c97e95482cc19b6c90779554df2a311d68ae5274e68c7ff3a45f283b1259714aaae5ccd5b4f973a482c7b84cf960cc61437e99048227847a199d7ef7245af48063f0b06fc19ad522752aad47244e76ec4e59adada07b1c17aa42fed8bb42a06a13b7270c22999aebd0f0208294cb1bdee05ddc75cffadffdf86215ac73a2f3f683345c8abd412c6feb9e847b3437848f92210cbcc6aefb0785052d64533cadd461518a68c2b21a09df8f07fd745b0abf14ddfa8adea1a5ed10a34cc842fa47d5d30f25aa4b572d8f6090981b8255a93d2231849f88f8dcd84da3837c44d7c17f8c464adeaf4729ca5082d1aae6460174fe5410d862f9ab29082c56733e8d1d9f4c316b6c0bd25e2c84f93ff0f615938b84b0f5202a95a6793b82789b6421a7e44526b9ac3f357c78484efdac80fcb20b1a32c985e4a787bc91d2d71b3116ea404af3329ae6ec754c571d425cf9c294038e50b248376f4d0bfbc9a25fa9f63b8b85658e236be386fdf262dd429abfa294b6890a011fd16385e286fa4529671dbcc10e6119a01c5100ac21f6bb7b73e75a25f5bb0531fe9dde26f4d23c8de2172e1d4ded1c300408e19d61ba92f18abab18de83b2e7ab4c2704913df8cf699e1b64c78559e33bf3a401779cfa9a880f4f58ce2912494b60500925eb7009f4c5c05cc8a71186c9d0ac2191b46f9b2ace19e8398d22aafed1b31d228e45bf4bbe27268dcb71fef9bf9f468cf30886d366cd2e33e557a1a6286d71dab027bf0b256621372939333edd2f7d8b36b21abfd83030f73780e63e7cbccb9ca18279956c9064f57823811f39ce8a5ad78850562e8af9cbb59cb28c1451409b13fa41da2ecf00e459ba39f6b3e2d719f2afa4213867b3a9bbf737b0d72d6f5c0da0f79eb5727f159d00acd6584e6070ec8527d1dc6d2cf974750f9ae3d7f32db3259ec742af8973d9a91a3b5aa0c95aadbdd14fd1a6d92fd314e4ba88f05b839829a549a382ae94314ae95e968bf104cd8ee5f3b413ea01451a79ee0317a95172ba4f8921adaa4eb8cb6ae859058893c26a7c2bbe54065fa99a463b87eb74baa7b9ddde1428c19319122285bdd757ba1de311e9a4a335bcb8680077822d6eb308ba8e954676cc554ed20dbaf33ad7352ddc68da86aa48acd2b74817ffd217b4a98c9369505a3c0697ab538ea94bd0974f7b3d7fa4e6a5726f8dbaca9445356a6a199fa50d2999524519db1910bdb874e537c091ce5e8b2d4555eee19167a28492bc0fd512e88983b17fceb9d1dc3afef73b3530bb6f35502f87ff547fe5dc5cd548ca0f049fa57a0592a06d40975fd2b44beed86f9d2a0838fd032b1c1ce88f68a1d53bb2ae2318db190ed0987964629ce365c24c649a11223e6b718a27208478a5852a46fde0b8f398b99057bc3a4e5b42abba2c751e19955ddf81091f12cedb552300ecdc28f304781ec98c3f874f664d2021348dae342299ca1beadb4527a06a6d1df3f193a0273e012ecfbe74332fd6c09f9c25ddd745994a8fc13edf3f930f5ed924a03725081c9a137823ba9f0aded71c60066cf9c4873153158365baa34df3a01bcd695a5eb902537442d672b63bce3efa68db0c3ab223af371014e528ce09c29146ff44651a61abf9a43d0c4457d43605c0a9b56d497fe759298842468a9be0ad42b5cbfb8b34b83ef55eb1f3726f7c06da0951fabd39278ae73520d8777d05c59108d8221cd2ae5fd02a35859d10fd20ad498685aed7749bb2b6871023af0ba06493d22e6f6a8a218ea2300d89631f6a486f1d35361d7b62398949fc8b205003e780bf027e731ac4822d620e548a62fc823d0b9157d995a71044d10d303959c92344ec4dba0d542dedf1e947b0462c9528c45c879e7d13a72d30790adb669422ad7869679c4e267011482e8473844159246e8f7bc760ae3e56c1b673ca66a07c5728f718eae3a6d8a076846c662a3d7533fc53968d1dab24bfb219920672a7c7c027208c4c706f75f089049c2e98898ea2d1338a08060ac2fd7ad3ca06256d7c5833cb67b4d40054056bf49a8c059465c0e332374c358b3f79e8bfeb15242b5511b1889c91e10231779afc9d841e63fa26da57d8e94fea2f0bc1d06a645726d8a214a54b6149ed88afc8052fbbed7e1ef0787921e145073e70e38b88910d0753a632f27cc7ddf18eb2094b3db039744d750ab6efed459324475f2846a50e2bede989a170e93009237cac6098b2de4480127cd7fd0c56d12ae636bcd83db3d2c336b481ed80812222d8a30d5fecdba2c98fd2065e5c80244f7296602d25c50ea356a69f5850194f75a5abcd70ab0de14b019dd2e5092e3597d64378c4132cab5b03b251ee9b3da458dfe7daf779f3572c49d0e82247cdf8ebcc17f8d3f333f6a1ff3c4309f6aa4b1ec31c951d3baa9ba3e8ea840c9bf2f85a5a718a3186d09d1bba46d7807d4f2309a42357e2ed322e08211158cfb9f123cdae6182f7ce4438b9db0a9c0ebc42b0565cf020abc321902203b278c871071931347bb9b1725811247323134723ebe797f8ce12628142869042faa4ad0b76f957b56f1b5cc01d3ddf10f83e6a86231100b9600c08918e9e09560d08d9b6af1dc60dd6cc6f495f2c117eb7faab58c374c9663fbb2a0ae8cbcc0544eb8bc14a4f306965b537ed2829847547805af745ef05705aaf3749851fb7e60fcae13020b8b06e70e3bb36b9249c95716d15a2315ecac3e846d07d836cc7acf24b2716c6b88e75b18bb20167de648d9ae9cecaae642107367b55a5904407f50cb9b95118948a5efa4a0b8b07acbcd07ffce4c1367bec0eb77b9096fdc429adcd41c2f51608ef656f313fc1a7bbf20134b7cb46a78ce5671aaf629f0fb3ec130d22099edf89df3d14a87da6f96314456e7afafb76c066d1236e68c47cca9274574cf37d90a2ffb72962a2478884499d4f8e87f984d0738fdc2add83318ac6ebfe9cbfe9f18a677f156137ba75a2fa56077f4fe8d26f5a1a675990f681eb8bb54a61db932be585d3c7a9e6d4fc023a15f895c34322e030ecefdb2789d3a691634529d6fe8c3ca26b524532f19f7849fc441345cbeb45d9f43680a28cb340dd041fbd3546dc60eda9ade42ce30d903edc986859acb4a395626519c2885385a305976ce7fb5887a8039038fb2e84ff67ad425a4be3ad380da272cc1367aa0923d99dc2c5885f3f7941491dd79d28f5f170166c3147ddbe47fce68c9024a1ef67f0b5b336995cbec9f99d9ce801f3d2afde1626472b1f85c8bb8b41ebf67796b88daae44c41ffc9134523ba70bf88ec6fcc7c7620d009b85d5a2634f813c1178ede2b2119d11c2a3dde61d9b74861b815bfcdcd8beb66364318418082440ce76d7a66a98db6bba48d2bd45fb22a875991b7c8681c0adc2cd4049d663fc84ae6b516a3150150b2564c5f6fb45f7de53a7da9e22b608370f9194878740c66acaefce9100ac2881bfe984d3ccae8007e0bc241d5492bc93347b8fa8b024facf81b35ee2f45875831acc180b0ce0511c17e7797dbd745af8c14b67fe0f05be20faf1fe751659eb40e7fc470511c28825fb42d43fd073d55a64589ba705aefdac62b78a4e442781e3d804556fd2e8d1b32873ee20d1ee8b0424f231948292ad08151e5437b8d64104ea856699f120e31813611b65c39a5658dbf2a874bcb942966ef39d958d049509119b07ddf61d36b19b9d18b73f469af8ba260c2f327d153d756816e8c62db5c5be8db2bb96816f190bbf0f74c0191a732d498561c98a0e0b5f4c5f848752ea92a9fe831c1cf9787addcf1f82fd7cb5b8c2354daaba9d366933fd10b34bda4b523211f5c0dada2eea98b2ce679aaa687cf1de42d3fb489f9ae481652b005ff3f0b7f963f817533a7a24242c1390fd4bb0fc558080353534314ee7eabbdb32857ee308c57667af2adb2e219e02d27f6abd0bdf50abce55fc6023b3ee4e890386c0e070472da09a0461727c9c74ac12c5dda8f4163b84a8bdcade281e9176b5444df7445f14c7c7f070cc6be91c075885179a53360d0b8120978a97d2b51ccd35f79ad71ff3abfd9f3bd6794dff00c43e9e0a02441bd4a9ab59ff6508e9fbc70710e2f5d18fb30007c2e315733f606e6e781483f266e513a9ffaad61851ba67644c171559277d88a43f4084799ec3e93b7e96ea7fef4f716879ef99496b8232417414fb3deefbcd8632e6c0a2a649d1d201c5286f875f491607baa693b0b37f3b1754436ba9d3e0d9c7422a2c27fec061779e0478132fcfb2a4cf52125d6eb26818bab4989be0c87c1a77013b14fe7e522e02f120f916f397d9e51032eb908f13abd498e4a692107e99aa57a8ca624ba5a25b2935bd598a1bd70d125c8fbc04c7ce6678d0c1287a39b21c1a4b703109ae3c0ce503ff7b4e4506d90ba951fc6a2dd62f1df81b69852fac440b8d5881b985863f5a1a9cb04a425b744d23bfedf527cb64da8064c4d6c89ce1641444f42402c6f7b6c77ffd08e009a08b46a29d7c8f204d5f6fca9e2129b3f6f6b7b5aefd0648b14b28f81d9a4b08ad8127836de53308ef57ebcee263279590ca00448f324ac24fd7d6be3b0f93de8f742a1791b63958a8671ac9f627595d12087fe83185bc9734e5408a2a0b30e0ad74e6c4e0cd5c31da36c7153734829763591ed2be0903e71aacb8d0ef6d51ae23f307c708709aa0b7c8468ac2fd9385016cc2350fd0a9b25c4790a5d067401156e61e68c4cc7d3e51f778f71f0920faf7ea1d7000bb1f8e3b984d32e7a7bbaa464026fb359d4735d6916beeb4c4b1a0d158996d77d2cbb2034cfef0aeb9ae953fe776d079c71dc1518ae104e95658cd0d3ff155593ac50c90a23d1a5dd5a8fe82a51da720a73e92d637dff63b2e4bdf7a6ca7143ee66c98353516f22eb56418d3c63eba3ef76b84464c57b263458655cbcfaefccfdd754d750bda65446957dae26241a22d86d839fdd0303fd98b92a8d7073b31d527e09d91cf7b0a5b197d473eb79b73e9be248d2b3ce59b3677ccbb2a3291cdf152b2c794f9b8da07c2aa9d27868e0faabeec7f7f7397a725de90e436f8f298e1c07f123e9682b3bac7b85b4e88a9a0b332a1da7dd93f7473a3530083b210df541e8bd72faad59716e1e1454850841ac853d9b0142ccbcb95a749d8ccd72ff781460f161e00939bbf310d49b4998899127b24b15a09a07c29281930e6ee56e1a64578c4ff503b62c043fba09d5bd6e83a0d3d9933f1347f429761905307052332132e52c9a5460a70c9ba3b8fd1d744b91657f48ada48497edb6985fed087c1855aa8f2223766732bec7c09ef3881f1cd5a48fe048b5d83c9cdbf5b7bd2052a0b3996d85b7efea18565dde6a2578b002d8ca90fdced16379f51aa527675b80dfe02a502a95f5cb9ffdb3ad9d513af56adab1bc8d0a2dd4c8384582dc8e22ef91acb90ec8899cdb4608c0b7880e82978d00a29f435c5ab9be52d597c90d26a22a8113bbb0a8b0b0aa18f6a64de3b9a7ef2fb66271c97a2c9a114aae7e60a5fc5e2b23c83d66e0d9e7a8fbb98782e44b88f608a26a9afe866116f51caa056a5425d014085e9f9d0cd78b9233012460bc384c08276d26fd74a9f6f6e45295a5331a1c17c6f85911c1d237c78e4588c3581a9b995844a90abda723e2c64837ad2cab61ad1e735a5a17f63e098138c276a1e5a7df9d7915cd1bec4177155cf52cfa32a552b0a30360edfd817ddd25f3498c09a1975141f84e95c4e60df7c4c8548f4ab267431f1df53a89d190b3fa4a8737f1630cc56ae6ca47e563a1d4f923c47edd6d2c39a49d08930c0a989494145814f68c3fa424806426d8131da37284dacce62dae96b3fe6182af427e306cee0641ef9e5e4da05dad66ffe117dffb834e115a69ccad37693af95a91f604cface8f09f58521c30ad893b6382d8a129d29bac1318b649ac2f5a2a47733ecc16d312bee80bb3f9b3a2218d76b4771f10690dcef6bbe3385d8243b8fdaf524ec709e45c37833ab6563da50dc724570fa61438c43f5d5366fde151137cbaadadc4c9cbdd51f9682e9e0cc73316a07f2eef088912c6cd896534f78208cb758e5ad5f0306fc454bb487023a0793c2fac5f02766ae855ea0314258f5ce485dbbc2eee55c47645eda470ff08820b431f00eed9c3cadf2b2792cea07d9dcb2deb5b79c840db920d54fb3ac177a136189047be766c9f9148a4a05223bd34ecfb97d73d0fcddd24a24bf663ff7b93cc9c9eaa5defd65ea4adb16d91b8dd328a05c6e8f6632e011684423e00f64024dc7615f6c2fd5867c0e999bd7cb990bbf1e8c7a5da5e9cf5ae4d6ee1aec3c103d550841d364731403d19353e81c000d77fdadba260014f62dd485505a38ee8d33d241fb8839bcada5ab50d076060f3876aeea34697372c1098234551921f777960bd276ef347bf865b92dc378cfc6f3d3786ffc1608fca51e15f126566a83b14edae6d8173cf66bed547eb817befca27fe46dfa7a320751edde08c951be5cae5a85350fe015c9baf2017e952164fe23cae3dd5a394cfc740c78b57829307fcdac0fa2db3c4f8d86c6f01174b3b5a24cd858c8ed1144d72f100e90c411b2d5795ce6f79eeb3bda45413549b108c76437cad226c1ab57ba6ead4fbc854fef76a3eca398440e38c162508c5f8dffa74f9c428eebb3125d8a001de873bba2e1005bbce59defca764651f5a9c0c0ce570f48047b306809f38cc84d2b0d21a30618b520c2824fb07f9df07f91da6c688602a11162f275ec4873396f848ade6471ce1f8c7b8fbc855ad681ed1963fdf5d4f8317959c1e45e8e998734e4578e0d9e098146439427f5ce6d87f6aa2e74b15e726318d6d41c165c4693d8cc75fb7329ff3d8238e97e0addd518bfdc3db96352566df21484f599430b7b3593872e27ae0a1cd07e1c3ddf3c96d8613a63527642bc483a37d7348ac17b586058163ddfc00aef7b0aad0ae8359e43310c0053edbcdad6d732cc4afe2f4fc8458af6c8f541849dba33de23b06d3dac07bd0186c819ce4fdceda7842d9a645c5b1a323dc03094be1d400bfe3b31103403b6a6fdca995698691117a2f4af63db0c09f5976506f0baf768c7155254677c7e7346d3988b97e3d69102ed2e2d2653b3fa4bcde1aa17e80e7bc8c1a97815a7d6b7b7961388b618133db3b0bb4e0b5b4895c9e9762ab2ace14cd8d3f488bb009ded470a651159d0ea33a48d884991be0612128cf8672bc4dc730fbdc6cb29d976730a1868e55cffb92cb74424beee86c16928f9927e98abdab770a68b958c4628883ffee9e9d5bdd5064355e010ece7a5955beeac7f2b7ebc2fb3e8971c308a142e68dbfde77033244c1b8cc342f21c7673c1aad4db60fc9da27a6a0f1117198c12806a158b32d8b79065e0dda3f3f4c215efd8d0140dbce959d6d829964e414ae209ae7b0b6378c036acc624e8e155a041d3b500b509373d35a18a9c31f0662d7fdf3a7dc9053c9cd401ffd435c6b50c17dc2f7d256bff8d45b3fd1776f56769e6a7f5b7678c3804e0ed7ca537e2fe6e68fba8fbf211fcb33498efe1d08e171ff0316f2b5eda17226722d53a4336102f86e2f1a2bf6fbed38ee455260c4116b0dc255165cb62134c9908e9209ad2172231ced0f87619342c9e72c2154423d33484693e7d661da9815dd517b1c7649754abf2301a649ad9a2f7bd4a56cc4b10d5fd629ac704135cc01e5c673bdb3e2071ae840d4ad8428d427df2b3bdde043b13b4fca5029c8ffd465caec705e0d96f7865f4199521c1c332bfc30d78e0db1b7ca8a8bd5c5a2b10da5d3f9f1cbdfcd1e2253ff80dc160599fc4d7f15595010a2e7e2a198c581d000b38d25dbed9b74a6d7e388339020f026baaf3d50a42122f30daaa23f9c48b2d8422eb730c81c7955e9f04ca10d2c58eae549ef6fe8e1ea6d563506cc127230e50acf6b16c19678bb3bfb9b820bdca7aeee20b3fc53dd95846b5b6e603e26af7db1181b91ba3e1ef877babaa7d5cd2901058cb6e05a9efd4734d20a85b175e82c5c0f79bd6d69a03484471d21361943d0923ac24b63c4ea6112f579aca841bc2948757cbdebd73099b8a77642ce3748ac9d93be8b3232d21bb4bed550de461b0d6e1f522f2b3a067266e141d415fe5b7177a588d0650c33ca292cd0e734842b1fa5cc153e392b7aa2751a8a0501289a50321abf6617c70331368cb5978c0d8210f7905f66fd599d4f072facfb37f33fea2c4e1a1b2719ce90ee3fd544aa78714c023a3d179da633ba92ba6479be45c8b8fdbd3bd170b47ad66813ceff240fa8b4805dd112a03976f058958665de77582cc0abcdccd1b9d019454ff4a560f7598e8ebcbe6e533a22646231b19403bc85a7fe1465417e085f2643ead3c6c34d58599c3857aba9108ca34d7acf11607a00508097a420f187a48228c97851c6b324f72b8387a22039a92a07fccd3f3114d1bccb782260a5c0b49349d59e4480b06f81b375af542e9364a34fd97fc42300577b2867590535774cb5ce03b31f10ffa0c6cf88cd16e1f28b94ac56caf40b6f6d17b174a4516002930565127c2d8069dd4042c91c8e6c9167c204a8684cab4cc22edbfc071aca788e653e284d0165ca3b418d5b9440fa9a915564ff7e20f0afb9e6c89233e4bf34dd44082e5255a9ae3c1c8e618227ac4bdbe31c76368c743e710922e223f61044e1f2100eb04ca6e607761b13ff1768e89cacbf36e32753d93b6f42fc2fe258b6d44a04bb56d2e1c4378650ac5427c09254b0cdbddf0b2db14a9cd7374354e35cbb71924c1c32b832f2221d1ab8a47f9dbb50184294bf9135b45d72bc7d1dd06a0d886cd0c16a328353bcafb0820f8c8e9b7da04f11ba96d9665c093a3b2155600fff81d20465a6ce0d9474fd26fe9aba49555816eec80356f9f819e8c95aac3fea0d35785414dd03ca5b663dedb8847d125838778d90e331bee2d37bea354adfe7f3806864b1e7a92c4e54cca328d9f054f5da9c3ddf2a32b54de72d5a4f2815a2ebbde4577c1098330d8630835f21dd2c9af065a8868c105c72f70b315516b651b56ef1c016428139d9310cbaa0321f44b4bfbaff1f62c51f1c5d4b9ec15cbf17ed9957c6dea1f38f155870a2df7e122de7c6e25c3b9b1fb49eefeac78cfac13b01b39c8c2d54117e53fc37df5db9129420d90ef2b8a374d162ed8ba7cd99f29b81ac6597e5391285fa6c2fe52b329c2f5951014c6a71fb3e33c25b5fbd1596fc6dd3dcf4507d8e35609234a91eef8ae2eee5f00d66c1215a18623618f9672a856e1dac58f7622a0efb314b39a98df2e0ee8df29f7931d79ae6fac110b3cdc6432893538a3e1548183bbc8c9b819ecf801c477aac58b9bb0899665db6b7b3289a532848bc5aad2dc912e78924fe1f4762eb9d70bbb1b98b5585c8d7412f2af78390378541e86eddf8a2edc5e1cc06ca94ac1b95fdd8e2bc41d3914e29a31040902300a8f615a8f27cbb964dd6b2d72de33da4963a065e811fd738a9b7c2897eadf9d88f38ca461f88066f1e45359a47c76112e2248ba14bb1c99d0357885f5a732d905c2a011bc3d48ced7849aa3e88b675abace2559e0b2d655362e5c9b5d254ff764ab81cd3fca6e07900d4f0dcfcda19b0735f8764ba8078e9bc0e7e1e75d33811c4d132c02e5888d043b16b9e407ad8cdf0fbceb7a66614b1aef5386c6c6a4ab3e2139035b882c0a53f5f17cb3e1324f0de64bd4d6f0f5001a66509d31929b9706143b7639f4a0df5a9a2b82ffe8f544e01146a5f8fd04f62d0754bd95e4666ba61e9baa82bd3f08a8f7801f50850114bfea65a9788887e1eba0c25aa33edff79bc4add94d00b89e301b611c6c99cd8d50f41934804dd6177bd692bbca24f5be14a003463a4a892da75ebbc09bbe872d41f8b4b1aee397170a5b9069f536e3484d137562705dd201686242f97817a666c4614e4995749db15fbcb9db46bb0733363bc672f5af465d1ce7ed92a7dcc2b6f6108ab79dcea234c608454a328728b9446c5617f1c8dd0fa86cde659af1abd83abd9655f6d52269d798fe3cdae2d790f0e69ceeba05ed609fdfcc191ec637a0ab1c8bbdb26f6924c5f3fc24a03daaece783871e18a0650b4cf417e901fa3798927e833c3c8d2b2ee31982cdad2c3fd66785352896ee1e3479391256183d24e036fbbef8df707fe47e5049ae00501107060c6ebcb156489c48e6331a87f50e87174b78618bf0878380c923e24e9241a92a6ab7d9b2083ea72a3df85932ee59d8154c57dffa8ce55f86f3447a2a2ea321977907f8f3635feedc88c0d4b2c11a60537cb90c92dad8fd2ce4cf2b6d1e7c6596609c1214d8e10c1294adb1a15451e5861eba966a5203a0bbc262c00f73cc608428677f158922c10edfd997ea0daecbdaee264952c12e537785d2e4cb59c40cb9987362a4b1b8cbd6df6ba6f0465359be8f5e4b552f3d9ec49513a90b7e212c006575f326f36cb1f3de862c812a550c7bf37f9d9a795db031d17920fb1836008a2623842e0b0e3ccf4b50237474fa77086cc708f42918436a9985ac9b555e710f04d1d0d6462f42b85fb3a96be99e3d7c18ef099abf4217dd5bf823e6118a91dd6a1d3dfe2829becc91dc3310ee069532503cbbf9711ee83682f229ecafaadad3bc6f04d5f1dde8823697389e53a3d2624f4b013e5cc740ce0d8dac580ddcb9e3d437246063971a7875243b4a4afc62808d32edb24daeb30f75e44b5d1b793e4001f280062dd2c6e5ca154cd9ad5922f29dd146934bcd918e4f24a8f14ae5a8c4d4258407e1243a3846b4b6be2a68c85b8a8dd6ca2a45104701baf6ed406342d2eb60dfa85c5ff04ab732fcf32fed8b34d67acec0a5bb1b06f35329881497e5e9780962c0a8a92c9a4f11cb9d9c8b3277df7d881e013ab41d325b96f4aa81932522857c69373eec630c316ba97c45e5461f029fec85197d61797db918fd06ced07eb5240c4102d7fe63753c9497ee5832c8562ac81592bfa8a995f0064a1f3c24196cb6b6c9542b0f8208dff44bf6a3b9b84d7e5a2564d29d3303919d19219516a12a86bc27bd45a715d45baa442d8dd59f43b2e2d76af22835943eec54cc9c9e9fe854714c50e14d18ceee76f525d37b93e7bbcc725af9368a0a5b8b2e9bb1235e49770c617f9acbba56908418b23185ab6d2ec62be5298bf7ee997bb220231e4548279a5c9514a8e1bbdb23011766476534fbc713d09eac0f0e42db3cf196ab0c3977f1b82420834c35b296f16b7bda569acb3c71d3b62035003d9b9ef64b3db1d5c0db3b7e890518d425f31955e3d028b999fd58bdd993fdb416a42861de7f400912775702fdad2cbca574dacb9a1616f7159eb781baac192910730634c937953ea2327c3b88e5287bf6fb62fda08a89b4b64a572063ad06f67d61fef1c1bd3f94f8d8fff0b147ef6ca19bed9177e7ca26b1e99c4837f77425bdec024e1567cadb65cdb2e9a2a3b14357203f9dfbd4f5120f05da904589bf9cfe6286363f1f5b5d03184b4ca6dd27b0bed2fc28a89612bfbebc86a96ce50553e90b998eb8418c496a614e43f94fadb5457cc1ab21d3cd13ac326835a1d6d876abaa9bcd2a370ff11e15f3bc6a2e5d4491741282ff8d0c149bca0fbfae0fea62a6be7cb51d890de664c9fb31c60ff1b9b71e1c78dd6647da558d0b5c63e145b88a012d1feef07957fd3a2554896c40d169f8067382f4c53c07a1cf1beb80900795aad40dd0bf2584587e23fab7214aa7491a2b1738380eb8c1bb1ca1a01db117d1c802551344edf1b8c8b0dc9cccaec21ba9d787109819005cf07e6d7a3935aee2b122c5aefc2cb5f5b39d2f1819eb5331cf89dfae37ffa58c5fe2b044492d9499fd89af50390ee8d3b23b5db552f7df83a6e088498b909732ed12fbdc9cdea3739a7e8c2afb1d89de329f5db6f71341dba2b9756fd1380d283e72366ce4ed9a2954db3c5386f72c98bf1ba404cf1dc2dfe85a46a831d1d972fbdf72491a5de5ea432af6b0f937aa38f99e8b7c0b499fdf7655b1de950d03c97206381ad84c368d4c996abce458515ab493a0b9ade7fdd2615c79453c8220df29300afe78ddee1e77eb7f8c7d16f6aa07a3c3dab1430ccac79c67c36452bd79d64a31a885e96e2da4bc1dca436fd11bf3fad9d709bea03da059f890096aa1ad747ad28d6a2bda5487986e51cc65e06ee5d86b688475690e47382c778b688f77baca6eaacb2cdba3d4ee3cb726e89c1234ba9731c81d9316474eed3e69d98bf2c4b61c0238b157c549d0907f889fd8133c027c4a22807292d9f98902539106e1e5f4405a4050c0b8441d2c233195d537ffae580295a026aa922c5e5060985aba20e25fc935e076ce3b12c1af72b1f79e5b60e8aeb668c44d003a57f845d0b9c2cfe125815cf6f91521137a6892e56ca931424f7c66e98e394b98fed607fb4f8fad70c6ff1d03e9f6bb089b42fd986d8fbac86b8072e5f8e7af483093ae0cfd6eef1f3d6d8827a0c2c8c93b5c51ff38987f9e203fd85507f99158b594ee3990f70c3ae8785d71a8de15a42a590a187f7b2a9ea33363e22df9fe4755e3137e2739db3cf9ebd4a46608e7729dfa2447f69651f14d4540ae8fc01a96c1e73d510e58a87cce15ac8661a430d9ec980d5721356eaf5efe44dd04b208766de90d6825af2481e0e658de9827f2851772c6770097d6ead0364b359c2de633963eea034b08e932700c918f568e0edcc62d07df620a949bd8e344d5e121724b4763feef0f9db853f1e284ab33a1dcd8a8c3ce805b50347214ba19696c8d8577331333ffbf53f32b6aa376a0d2296e7eadec836bb28bbb6b0bac297afb596496ecf4249e579e11fc683e14c28243df6f73983e7fad58715bb20f4230426d2c708792d913c30d9c51f3255df512f7a67f98a097fdcd939243f2430c1059781aa20796ed3c6335baa049de71f0775e7e5c7e8b78e6c475a855ca0073887d691d4fc2e01a6e0e4cefaa90353491b398ce64a423feaa33d533ffdd70a82db24992dab7d0379a5f713feff28bdb9589082e746b240a86e444457441838e8fd56ea42910830d658c92a2e5617db89473bb999541676eb03e46f372e8e2420f1c7842fa81497bbf6e9ec2ee700e273552a6ae48b4fabe0c0967b68428593f9990f4ad30c6595c642904bc78d81adfe3ab333c663e277b8879715a7ffa5f2d76637cced6aeebd3fa18ebccf5cf62a12f57b85916c9cd9856c4b270a2237d9e3c232b862a43a42dece83efa871f2cfcd0d84f6d947190ccd8bbaadc198a6c1129de93446e0131753d8b34bbdaddd9ae7838cce2425bcf89f2b4d745a52735ef8cca0745233dd273b86331c122034dc0650c0ec183d9b69781196730c3633671b9d459802f22c449d120c103a5d2d73a5bd4c2fc4d6893494808cff7a835aa53009b9ab5d756f4afe920216b3cb9e9a056ce199733a2bfde8793f9154becd4f0770652191aa766fc95b702502724c45be72cc48e7b04e65d836c40fbb65020a2675d530ad249829a3ccd80a62a3685209f8387b91d86578e6867ef3341dfb0baaef1ebcd475507a1cb37d972d354d4d0404e593972b79b5be71dd31be2df75d46aa4cca7dbd815308bedac6715d4bffed56c097a75775fd97af6df960f74ef30d3227c223b2fc54f3ef69355f99f5ad53c760214a24d1a011d053ebf04595a5aa05a67d48f25e256f166bee37832c6b662ac820d89b74b8a810c5f78fec5607d469387be934383851944fb098cd60740108080fb84296d9a65a94f9c25610572c793caf7366160d6b3f3e62d27e5e8f693160e88512fc07f4e4ea0b3219e391510e9f91234914664e17ab39230f99857b31fc72b623f292da4078e24d4e4908d0e9f0dd00a8e88c766ca372aa1af83cd60f6199b522a17806090c17dcbf87ea78803afd18d6d3062c6abb7c6265de45ea6bea423d9f2b7fcbda679eea719ef7cc6b89c33def28e301339a4944a88fe83ac2bda78202847d8a563f3815363a80fda7766472cf2310d9c7951bc6cf1de3f62da600c55f693c0d519cf2fd6ed336c75f5b7d14582e837b6c62b6954eef72f381353270fb5a8b7c0d00b9de220985a54d0396ad2fa58afce30335d78d0e8a5ed5e18a73cd87c1601a5cea00258f57afaecea3ad36ecc376ec70a704b1df323d3be59447aeb4f202b47220e08fbd903b661821699332e935ca2f2ac5adcbd0d22dec0f097e5c59f220f962402a1be677ce18d8bde0d5977c9146f375810b11ebcd95a5779499064613d35232846f084da4921d30b782b65767291b0839fc395621f568c39547bb7f35c56b710656d9de50a3f1d58b6256bcf0fbdeb2ecb7d04843c67f1ad6f51d17aa9dfe428966569382f02541c58189e1e483124cacea0853636b4a793a0d238fa6a353b037d5c099021463f43cbadffb6a5100e407a500b100a09bbbbb919bea7dc4cc2951f0239124221d87431ac738dfdd9f1a702d99c9f3d11c66619f1cf9b902a32d6f0c72d1808be64bb6682d365aef4587b7a721dd4739d583f4e8676a7141631ab5e020080bdbeae8cfca432253fd5b8fa15b9ab0b7a293750c35223195556a41d35174248bc922758ce1ab0e476e5ce74a3d5ade2ceb4833f0a17aa1d0b0dcc6c3b260e2b0b7dbbf24e444beb77178a5fb1facdc19723077719538989b263f3faa02616c461e558bf5c1eb8fe0a99b785969bb9855e02124968716b3672cf7e6e210a29b519a899d205c66b420f04f154ad4c0bb5058cdac2d3ca8b826fbb0fbc8281b1aef63da62847f3bc640b3b70bd55d6c41af9f9cd0515d3b46caf371f64c86973cdaf62641e50000d5614eb1da552018d8eae809822ab2045b00e3991e27c2f2c08c5c1ea14a0214a592ba3308cc3b4052486f2ef0a7f72855bc7681ad12d89d9b01f48670eb9765b0b1c8b588b0641e4ffb7813ba2cbd6cb8d65bad3716531c880335f57b845791e7893bf11023cc1b04edcdec18b7368baad86573f3a3568b59a4d276a090f3d519da7f5bd4d2256f5c537650b092588e7ce31fba5ad79e2503aefbf6996dcc3c64c07f3ad70ea171e0dc82fae6485838b0bb1c9931531d993e5cb10ae78b137478f3ae5c729c7e5f33cd6181016b98c23879d6e177cafac0432afd93da563bc3bd6684d94ad62c123b8cbae6491d49a559dbb5614b0fa8f3de97bfa3159b92952a03818dcbd28e950a9046eee1abd1ea07369ca4284f5ec4e45dfeeec7af4c3e65c91c869c14ff5a74389ed6fcb844858b604409b3a28224bbe44a3c152e5c050f21cbff4cd501f2e40bebcb1c75c2a396122561a8a3c2c16a3ea799e6eb4dee9025cc7087b106d68c6136ccfdb927e836a90550f6bd75739266e689b4d1b4480d898823e725ab94a5eab5b14faff25f50262813c402b050bfe2cbcd71dbf9b16688ae12d00f0a73a7b83ffbe852742cb022394d0682c416aef91ecde5a564abcb292ff0518d8855af84f289ce1c8d6dfab461a3730166571865801844a0021d2e1b1b55e93b4a4050462d8a9b38018048fd15d87ef66573c590d4c4c2314b1c6adbc795b6a94d36a7ce61b8eb1abd4d2f642df8c75a2f78b419b11ed0e1d37f12a7434c1f048dcb8ad6e41c16ce9c35ef7c337f5f45348a3b77c9da6b7d3b12f8955fd7bd36ca0e7bb087cd25f478081e51ca5df57bbf96b390e7531babbd46cdb5f1f75ed0a442b2696cf32a6c448063a74a93978b7c826619e01744f852fd5e74ecaad5a09f57d2c16784d54f8e5278e5ea0fe402082f8c84db6cdcc73bafdac5f22718b9ec09f28aed8ea6e577c63c36f619badafae5cbfa168e2e682ccd8e2ba9bdfd1f46906a34037dece3cbd01ae7b52ff06b3b6f89dfcabda39dfd893908c7f69c810d3fc61f4d69ed27c5b5410687f33af71e01e9ba70dc4f89fcd95020f26e1e2fc7b4976d5926eefeb18085441c4fcb1a85b847987f1ecf68b6557701388dfb82349b4c1bc5674c78c3762599e4a8450a53469cb9ae2cda19b77eecbf80805669abde6ff809f9cc9f0dd24be70f8817288f29af14d693f0859eadc72729e6003818832f5f13809f4a6bb4490eda0e6caa0bfb09532670035c44b8a7bb02212698bbbfd1e937349bf88c8952a0ee3a6fcf67cf7bf18d447369127d0babdb722dc411a221cf84af09077d7dc218aa334074315fe98270278009a7b07b83b9afec745f7b47127258f00a6aa7eb0ff99961e01971cd5f65343d41ad13816b104213491477df78a4a9e688d6b5b82e3ef5a9e3a2edb1d17b19154489b73787939dcfd427f0cd6e5b149f743609e0b835d37eb53227152a616779fd32789e2766c8909ff8a48fdd6b5db722ad588d312379d350fa59c08f67753e1e88224d66768fcb34ba955ca72970f8bfab607f823df8052ef0f5409d2436d397d128c7c63ea285f9ed32a1cb0330f34cccd5935844c34778dbfcb7d4478b4439e9d1d50e6ce7bdc523ea04c7ada4753064f3d516e3a1773e68bbf53931e9f33ef893c243c70ee74fb3544fb960cce58241b0084f7113e7f7725e670aca423a12dbd5f3203931991d8293877bacfb1b975fae7dbfd2c604d60672c5e5d34e2d793a06811b81a51d991c2c5dfcfafb660f8e2e4ebc5566c377df3632f2f8962856721bdf0a191fcbb6df4c982007a18dc3928fb2ed48c31e7abbd3dcb28594628e4cefee5f1b34d6c459b65627f2a833fde4a7f4cae02627ca1fa9a990c99e4ef4b3c2af9b0f22fe5080aad7ac6780f14b48591055dd73b5e4b7e3bc11a583cfd5fdec9fe7e716e787acf8bf9f57ce24be1768233bb5cd0fef723493b9236cf5fc5ed25b2abc2f79b6884e3fb7cb3f8513038ca0e54f828a2ad9f0dfba46824467abc27e6120c2f0ecdc5c0bba0f90bfd27f911eef7501b9de9321a5c30bc0fa28dfdc1d121ca5cb60a71b3dba17c2063dc771edb10041d6a20b187c8d7af4697f507e3207c1efdab542fd25568492381879796b8c9d4b9616014f21020b123de1f7468dac439be331f7122bc8e6452c86ec26d4dda6ac99b04a8ef46d93c2de2d95fe9c1a29d5bb9ee7adea24bcc2bc2daecaccf53aecc32687cd887bcb6b603950679be731202a775dc410821bd9a8b5bd34e18f9121029ddb3d8be20dc38e9c7775a3681ddf0e74917555289888e56e18b9f1be1fd549651b2e9165eacc94b5d7fb7e2555e110c9b1814930834f6b023d8a8a0d9c14f4f7c0e3558c367f6053200b5fbd6fcd6b7e3adb15ba758a2b59b6b62764e82f854766919c760848fef731f252bed873c71d62baa4d85fa29ad1d294257499282b23d60a18935c31b9688f865eb28359bcc922d23ce46d7822a663c8885fc13c29e541246a3c1d5a5a6df2b9ef0c97877f5d0aea638809d49c58483206c938b99dfc131fe06307211db7419efc5d8f479816d0a20d293402b4f67436b907afb1255c25830a0f97f5d40877ae1989e56275fb5d93a05d8e314fa0917bdc267a4de8fb9c391c81747f0165b78fe2a3880c1533102e901787500bc0f5c63238ff9b3a99a18991eb5b2f87009c3baa524a3009e98a4a325cac99a6c2e7b08a5e16a6cc80310b3825cb1ed313ee2ce416ab4d26308def91d604fa259b2ef20dffc90a4c397f29ccb700697ae3024b88c775649f9ee16ba384990b12b192638823d42becc209454a2c0da196ebf36b2fff10a240c6df3c427c6b1c8609a1885bf46778aeca6cb320e31162a95fbe9b7d9419bbd22167446de2afdfd33ecb66753a6543e4b3eeb5057d54a147764e533f823c80023100df1b21f71b110e9c8e8cb20b9c86062205730776be136e00faa2bb538f959b2a3f4ee6f17e3c1d4067f1e5580155c3b67725da9df9dd9470cb88856cc597fce5b27c5a60dd6217124dc9caad8e8070cd04909904fec32ef5c868b44a061b876f6ce384012614f4697c30032943b7d34d61effe0c7da4ca890f989ed38d39823cb42eceac825673b8a36492658effdf7d3b934b22ad27d7bbeaea0963f1397785cccaa27819686d6aee972de8beb62ba9270da13906ac85ad7398c6d4e92e126256d5c3545bd886ba0bccd7c441061638352ff2e364cf1e23b0cce6e2c955b71febd0a121d4235e8690d7408f25e27dde8aedb256a9cf896298ec3710e726ac65122883eb3c463077c9ce9318b7e79eda1d10d87aaf012c5c3b8e45b6f31a6bef7ec9cd14f3047dcf54017402afab2d5f7ec609eb491f1f167f229d042e9c096b3da2af66e03b3d98aeb5e3301b0ade077cbe6a0aa2203fa18408fc89a5ee509155dab7c773c3189763fed8405bbd5d32e0115675e7e4475177073a17037f3f744c81e2e146e7f1d45bfb4de66e43acbf50dcc8c47f2ce39946691fb708dd4e77c73fe99ea2dc2846b74c39595a18e6cd7d14965c838680b84bd54a8fd6fba707c75ebd969df69504ccbab15c625260d7b3ebae72285aa5ab1894100441f56d75a31118a29ece9ff7102733b82fee897ee2edf9a32c4cff45029936e5b737052823f0097bd6fd91acaa1e956839baf3e3a339c165e20bfd77f6f478b5e87063defcd19207a1266620ad7238880b9bf9598d049600be646001123fed996dbeb62a352b787a48d168bcc851360cbcb5551309ba5d4e561f67a61162499db45a6038d1926a37897ec2fe5168da15e6a19fedc1563da68b455043e0a25a22ffb71b584474d6e53545167cd2b4370fc78f6ae9ac057e545c81f14d9b6b5e17ab09752a915e270028b38c8378d76834762eacc4128bfeebf61607e78e9a6ffc45328aeb21713e4a18c02893c5c9ed2fcde5f591e6457818040dbcd3129e0e69bc2865aa6f80649af78002a6ea113039f331ca06b836844a9444af772d20b5fd697ad02eb72b08f72c7efb0874e1371dd6afc4b6b20be76ad6ec765f8056cf485ca73f63faf9ad203c901cc758e0b3e5b0e1a9006aa9d540290a28ffa929484a3e4afba23a4965dd0a7f1a6e8c461c28d69d90be5062a37ac8fe10746cc077293a6e58cb37ffaeb858374be3eb1e60423b97ff507aa967901506b70a6ce8e34eab14bf14719aeceff8414120d83a8d2f122aa61e4280eb619834a4fe23595e5e29135cae52468457b9250f1b8b7bb2e03047342f43baa377b400455c07389f5464c85ed3e64f04820d332b72d7c61b7d7f2e826479d1f088d942e4e5904b57c2ea37a26f491b6bbe779b5cd1794364844b7533ac63a2bf02c4b822ed6ec2a6354d33989d2d014096d5b17923169bedaf161b8f259cc9f1143a1e0ace8862978651d7eaf7e73191664a151cf1414e36f2078ea291ba9347e105b335e4aa4da6f45c6911d3e194ee41cbee678a5f2f3213c8a44f632d1b9bdfc27544e3e2b9b95ff048f0a7ba43c04115dd831ddf27db3bbb6fa156de46f35bb92a46374e2555773d404d826098a7b19933087898a3d0d7a8563dd1f4ce9d8fd2b4c44878a419dbd147d940f5e9e7b9aaf709dd35ae6482d3f5e54f6f38d517374b23e4f35011b1b9189d6f7b0cf0916b71391f8f1632a4d2396d37171958eaea0ab34e7ff95cd99c8b62d29ac1d07817e8f86fe281ebda95c860101383c4b3626b2d58bba93a8038db4116b7a1cd396c4afab4e9e9e6ad4746add624a84c4419ddd26902ec15fe60a6bc0c959b580d0167020b3b1aee54fdca11b7f6a745772ff9419a73f653f86616d7980c40a72ea91b5df95d90dafb7b8c2ca96118a85bca57b55bb1fabc1be9763375f7e9c445434dbf94da9a66659fbda6c78e2b08328b21eec157add510150b66695ce3ce04ff1ff551f9c9806e16a0f4041059a0140ffb6950dc7fa0d0b81d72a1c3753a9acccca3d7a20451e1c09008e029d4571770d071292023a9f4ec2759ed35316f78ebb0e7aa8a02b78f5456c55a724dce51ac2cb050a87baa4651c4781b43e800201b3df388cf4aeb09219249a38c70c4568951c4fc4035ce3feca21a54a3584f6f332a52a8a5e9fc521b6e51898606ef24d4afe744323329284cfcebc8abc0b873dd23109c664f91650e845b15b882042de43f5ff8681a2a663929330319157fb7537f48073c4789daefd4f5cee8a33bbf2939f4449e6c877ff0f4d559a2a2434972f9870969b123412c77fe705f3417a6e33c59aee581d2aeb8678fdb8447a168f9aafdf449cce4820bb047e99bc3b093ce5f47cc0509fe850545b270150dc515deb3a02f6dc2dd842e734f48b107d8ad094aa65a880460cdbd37f79ac4afdf9a4d8d3e8c6488dedf6916fa8e900785b5f20ba664acfb6b33d9777b7b5c9be116185a5086a23af9a2de1275e8600759cadc2c0a0d73449fe2f4112797f116fa3f7a35ca1e9f59c09200760d5628ad2b893af0e5965642d7f5d23a2fa9169436eb8347ae9629e40d1a1e671c0cb8897530d4751fb771791e7e309d9b1d0c2879ebf238ee39f8989c6946e12f7455b7b071264fe96e8aa9fb83b365413c448dca4a49b16e902b4b4f7702c22c514e64ee1d0b589ec6fca148e0ec3a50d4dffbec92f51191a48c0c3fa706e92aa2acf18c6577b41bb82f9293daccb6307635df40072b0831103cf6fc52d55593c828658adca133bdee8722c3b586129f5fa7b42fc41c03fdfb0ef4bdea1f6eb655e5d8adbbd31596aa4b092bee94d0629940c8e656cd5a952f580341797c5cabc827836818d5a27af0f85caec5392bb0d2fcb7aabdb94a30f633358465d8d4068d4bc1a62be6ff6d62f62f08f83f212e251f052fa4a188cfda674d6eaa9eefe896c4c999c03546dbb29700fd7f8ef83619cda8f871f474178005494c8c48435ecd9412431cc1a2c6b2989f6003730bdeb26b67356f71fc0b5efb43cefd36e0e7d3928c79e5ea8f8acd76b4b4ea27fe30af6f6befab6bdaa6b6868c96d1dfa4c34b3c8780a3708af1a9bb1125ba54152deb9ed007787bd658c85d9322459ac39299ac4af9716c7e6e7df73c3f7333e7095b830ba9212516f7ac502abcaf6522acbc55a91b5376a5da3e1de2260d3f96b1190a66a8104e852d47950b0d1650491975c7775d5af0e372b27d12bbab1aab43a1f5ac46dc583c80b60d85e3460e6596178cf765804d8fc5e862aa918741462fa89a2aac50f3a03634d52f4b8428b45c365351e1752b2ac165e317e8fd376ec052fc0390e452f64f090daa61d1d2deb0b669da7126d3d2a85ed4d1276ed1cfc9c69caf3323a576369afdd993ada8eca34e99d4cc58fdbce29d13fa3e8323df6157a6faded630ee6ec473bb64fe5fcb7cf4faaa088b2565f17f6eb5901e20bcf5ffab801aeffa49684947db12e08c923f3928bce5dce55ebb84a766ccf728ac49157b5f0e7b8a6e26835f62b9f290bcbc9a7809b65f50b444d089d99f038e6538e57c949bbf8c0af774b989979aeaaaba23bcab2d570d0057eecd9b5255bf2f69ccac2206b0fd7037380cbd2c7e4e3502e5abdd3be6f107d07e9d3196f06922586242f67b6cffce9492634777c64c873e10ae1d43e0177a4a0c8c203f26dee701860a043cfbe4be0c21d693027df73826de9bd48f5edc54042d50aae80042784df94be1e693381f40ab138062ab86257269bdc37ee61009298189ef0deec53ec3e0a82428c6c1f021ed9fa4d7b9e593eb4c9be4b95f631a4dd5d80737cf4108df2cf3ffc62fdf3b983ed142956e811f53e2658753ae21f4a5d18da34ebef27da27191fac597d540a6f985bf8f9c484f7cdf45a721e57aff9f9efbbde12b1361cca4cbd283944db73a371e0e260e15f749c9674b08139dc2957b6ea7c6679938921780838bb21a67f3c75fd83b6b50b3d608e153569ef0c172e0e3f14edf66e0184726563c1256a833bf3b70e2ca26e07804b1c72eae58442a916f8b52ae3b7f10e3dff8d960a2424a978feb58c8d533f38c21c434f184fdcdf1fd27139238691694864c33aec6894184f46864f352b475f03878caf4d251e818fb8241a0d35fc0ecf8629aa3881f63f918de763c723d941f5e064b0e1c77cf9889520fc4b560f89c031fd4049d51b9809079815fa50159e921c790d4fcfdd9d6fe4c363f2b417b00b8b25f10c989fb896ca6959fbdc42ee2f410955ca4266a0427de80d6b36131b3a1e1f93fa1dc3f0d231406a9949a42a2bbe4fbf73413162b05b61f19493181fbdd1f381668fd9c48f9a7ab1b3f9e06fd6b8fc1c5c710d0fec2d64eaaf60e669e5721035edc87abc74b9e8b8ccaf07e1a9affd25b90fe083c21099f14b86ce0e1c04952f62f56e69e876f6aeb05d5319f749396c8d24102ca4f3255aa27ae6a0038b109a267d9db5b84af6f70ed6455f978018a118139024bf553ace8ecd6b6c9d4cb6b8b85c5c78ca1f3b1d08aee7b52c34aed98f76e4be2d2e96ce217e5e6b001b221201db2efbb7482583019c3016d9f13e7fcf13790720ccae9198b5f490236fbd656f1015ef864ed8bd6c8059b0f9dfeb04bcdee3d9bdc689fecee64360e7a017537b2f8cdbdcd91859402b7ee3b154274f27d67ac100f207d1227548652bf1fe9b1d644e2e1aa3c4b2ca726325522168cd5668c1d5d2c1685f9c85e308b67f78ab98de0b0c06458b1f633a4bc4e1511e2cb8f946610d81bda0cc5b55bf35d8c82e6546836f0aa57ea75bfd5b82e78cc9b5aebc69cb576af147f2f1d1d32b8c044d48fcbe54ecd3843880dca7c37aaf492efe30ec6fa89d92d783072f86458cfa08700bdf4a0967db4e5932448b00788999d77143d5a7c5ecbbd2ce389e2c8682ea987d78468c19e7e3b9777d1086f19391a5b4229c0bb5322cefedd1d2be70cad69ecc55f1c00730ff043bd3fc289d355620a3151df903746dba9e9a66d64e0598fb1478a94e0e4aa164ddaadb35cc34ae15f1f34752628f48904a0c251ca617028626adf91466decdc913a2c433199b30e572e4f2bc71eec365c16a377aa64627c59a0ecfa90943a1fcbb13528f7fba98f9d0ed1fefb8d6266513052a21a880bb90e16c47e39b1ddd965bd8887062ad074362441dbb297f42e94cd816772160340aff1d90b578854a4ce36f5e917aa2a4864d8c4ad005e439ee84a47d1c58dd048adc0bdcd8f997f616f550c36348bcee50165f614ae7f2c7b0143051f7dbbffc6408dd6ac7139e20e7295763b8b711f322f8af2d6fed9e0347dad003d665d719ffc5e40e576944e48ece1c1dd44ff0c1243bf4b749dc6ad8b57e40d8cd34a25efbd742ad4bbed6bc5fa9c5f590df50bc837f8655dcb6941d333cf4d3b1162eba1ce99d46dbda947bdc258670280756b620dcd30e256d0a124b6ac0b48acd33988158fa4e10b68107f981dc00e5a48855de97098026f0d18c4785e1c2aa6681b79aa3db6222b0d633c7aad96f8f900064837a913ab84b316afb5447db26f9fa3df2542aa683a325bd8ada5bbe0d19ad03a97c0cea9daddca7e767fdb520ca0d3ce27e9466b693b491def7ff7278808fb67b5abcae32312a30c81619bb5d84014c92e7633cca97dd0247323bd4d4cf3e1f8a0314fc7783090d96309dc363cb63f1ed059e31288fda025ad8f59bfbbd04dcdaa2b11868ef95b4a1e975427f3faafb3245ba61c027f23338349fe82da6bac294b72ffd122dca48c25a7f09e9c39790843cd4cb1b51681a4814efcc9a7902c508bf12dbf66d2bffb7ab339ce490d62957cc02f9999f567e0cc3c889b3aa6e7049b245f8364962000b1d58de3495ef180463c2ec48aee33fe62514c21cce671c6b0ecabf023243369933e4391b2ef5ac80eeb3a922714d463fbc59f6ee0420e4196a91d3e24574368654eb4ec92ca1fba695356ca5754f4e00fe7f279bfc505e08f8e9ec66ecb1e369882c8a0f2715a726d42614eff03e29b3afef51f8fb98a747ee0663dd43d99929fbacb6c5f8172676a81ab042bb3f5628bd34f823cb448ac3afa45432737d415f4ab99c185b196cee54b8a9e62faddf5daa6b9ee072ab9d78a550584f93490aa0896af13d9e577ec1c92d600cd69632fcd5905997093ce240cfabb5c28880510931b5fbe6b09465bd76df784f84818c71613c11cda403483e00bde4a8096e95e89cf08604ca5bbe294236d62735d6f546e991c7d94dc2d209cc09e27c22825b219ab95326864fc58846ed03329b6ba0eb35f979ab91c2b4f0ff2e7d02eca49fa22edfd2d68d4942c2c278062c38659d7f93c551d21b877400094d73f40cd773227bdfc44376399cea62d37ce054334a60cc2be2a79102e1931292459b488270a1689808724013bfb8e9027ec5eefd1a3016572ea621b4924265dc3c09cf616633a6f82db55c4be7a9456712e44d70eb58c12dd6810c6295ebff1aba81c87dac2dfa2bd4ce1bb32343a8813050aecf13352fbb8b3a3caea2f4a879808a520e4be193144622886ee372afebc774faa19a2e64ba2465baf01f69927bc7937b6e527723dc95c0f729d63bc5a5f3c7c8a973b3af24721ac548126f1d8c25d9c8e29e372eca5546c590e27be1dbb77b51d92d46efcf08771029759922a769bc81f6a4348f7cd050c4bbb77d1f640f16ce1304c7c1e54a2a16cce031d39891d9fa7948e9061fa6784d212ade66d2cafacc04333d0f9f0fb36e812fa8ac46b241a40d0ad15dad0757799c992493b58069d6b5992c458f66e7046a632282a1c86b4392b55ee82f7ba4d63c57266ef147d93880fb7c6cb902265cd7d707f8ac73fbce4c264f1de6ffc22a8ad67cff0bddfbb0df836711efeb191fba287639264b48dfe1997d263f1e89692051f884d34fd6e20b1b50d9e59cf8d8d04e685183fc0cb98402306177fba2eabd18dc6d4ad267fa722d388154ac211412d162380b9de447da063a8616e690f0024040c0b1228627f58e461d7df5815314a01085b65f46121b148a85e23ed6c0f70a75ad8a9b8196640cf745cb636b36d0d8f48888f6e413943888dd9ff36cf7d678c4c32ccba5e72ddaebfd7a08a99d5382002bcb525a390610bbe220c2b15944a19f2da211a965c2c6164ca5a451f714414d112a1ad04fe906d8bef7b894bfa72dc08e03040f87db51490935adcbc0572461a4c76a90f39b18427a034a8ca16591f04a8ad821e19f016c40d3c295a262ae1df165e16e8423b8ae4fe7a6898d946532c81e42fcadc68f34955d03ae4c9b3dcc5500ba50356b655247586c1505b1a6f758ac1a20812383caf0603600a94c050093c52c9450f11046740bc887108c92470150fc1adafaf12fd0de1f88251b1682741243f7bb823e2eb806b78193458084d805295ef1e05e68ed5953b0c0cf5a8b198f24a5a35f0d47958d23ebb5b533651bd980ff5cf42a0ad250408dcb54c806e767be71dd404ac52209a1cdea495f1b2d7315e435f9784e37e0a02fd34fb8862bbea438eccd8dcaa784c7a213236128d0f92e7ce6d4d12c97afd40826bc8567651833d0dc71c66d2b0fa22eeeff2d0b378a4c30b4abcb0b4161a645882613b15169934be4a9dd70a961c575f4e9e2b14d08c6a24f130dcb51ccf5c73af45a5835c305f0eb85b9d5f6ede0da037129395bcfe7f1da8004f18e83b66c36cb786b0fddc19ec59918af223610a91b98db4c7f848db9d313689c00145322b5e9bd9d1489157b2761c93aa03a317577a094bd04f0c34cf4e405c9f96cbbf217688a86b6172d3232c1de533371eec7428c8013bdc2dba250e2d8c54142f3552c8688196e4b729a629d1c0824ea100f520b4c7644b537e0d0ed68f57d7a49f106e7323d8c400368b86b14e66452626ed6df7762e98884a08ad58291def5b23c3573381f2344e9bc366471b34379c683ab4c18039913a9ef4ada428c0df78ff7ea94b6c5d2a024846ac994067c22188f3548a37b14b7b1dab2fbd5239d965edb5d91a5cce17b3e8b4425f7d6f3e5e6c4ca548fa954b72be92a8ee728d06ab49c44c6c78e1da226fb7cc3d51724bc030212ad966e5f3a6b4044689bcad685b8ef83548ae022c7187d562617a3d9730ba7ba0ec4ff66c4c57319901d19d5aff5caf51a0be133d0d01ef359d3df4d5afd86652bed7d7b78e295edde705afacb3f658bfca0dd189a81ca24ec097c041f6ea30b7d3eaa19877b435c66ffe87fca4e61297a9b925f63d8f06131b5c6f845751e8a70eabf4481994587de545d7269135bcb96a772dfb18f74b8a5f594b8ace16baa191e566dac569d80b2f11cec8551de15c8f6d86a7034dc5039bae60b022faac53192d63a992532f8760cd22ce84f7db7fbdd590b3b557bae478a90b2992fb245fcc4a2ae985d0a4ac4ca20ed5d5da0eda738f861ebf44c33eb7d44cf504f98f6854cf96a044b72f50dbf10146f14d8860db6f89f6041883aefbfb44e9585b189e23c5ecb5b4425d4d1b6f7cbf2437277c28dccb12b27e3e90396d3da51d3c6e0ca0c6c6c4dab60dda9bded1d94f586c6961fb84fe517e9b41f4b4ed790f0a264ddd4bb5aee5f0be7b5f68e1f724b07cef0e727b815035712d56d885a1885af398af03ebf5df69769a98d6ce169f87ff715ce7a5b97160a675673919632a672f16c6366e614555402db57b65ee2b6ed2f17e988e852ac1b913d2ad5a3ecd6f4ac4cdae98d0b281f8512f91030a37e0d6f0d0b228d9f69565fcd079c0905b50dd4ea3d28cdc5c67c4d6c98dae665f0a962c71f39d1e037d5d0b8dcd70ec02bf46e9980eb62cfbc3dca98064e9a82f4160f44230235b881654e856460e8a95687d78b4e17475a9dbbfcc6f1311cd406489fb6dfc3e0e4918af82b33e28b496dbb1398da06b90afe70c240209b67a7e708c41c041457e7d74394f56e0e7cb21411eba6e674c17b7d93dfd51aa19acb0fb6520f16e111d3d6f55c1dfca12b24efd9b27773a50935a6d8e648f33fa431a187347c4708d66c562b2fcbb663fd22e8778047a86303c8159808e082298b4b7ae200f29108a4dc941ff3f22d502d377182075ed5fcd14e71fa2db735924f4a7ad27467691f34f5682d5807b76c4ca11835a02fb284d8c1103ff94345474fb399b84237b1c5829d05a17eddd563fbbb98548ffcc94ccdb397ffb10a2f7bd36adf3d20a096e1052b829d1825293ad165f48581cda4923703c6b14b0d6327c4f7f8d12afdfa2681766e068b75bd16754e7686839eff0d490e74b38a47f766f51f4fcb86aa10980e871df29ce98b9ca4381008636da55532706906a57ec199574d4ad8433045e4f5a63da4b3b69b942fcf78cad64e8732d9a52bf47530914d5ac60a9c906ddd61dd311bc182a8d1b12535efbce83f23b6c71585337f42badc4d39367225ce49a7899566074cf4c3436cf4b4f973caea194d181cb615242f3830f730e9f2c599c1cabe0e85f48698f765965a9ba97c7ac88c89ff2f614134df02b65d3040c086d261a138fa93ea10822bd7a1b52103b7afe268f02c53e277b421ec2729060166b23ba9215273a1fc9212a21c21d6c8f0200261af3f52b0e112ca55c1ba22d2af277f7b6c75a0a27aa9bc48434fd1d7fd4d5574c17f6ea05615f8845ffcc6e69772748ca44ec3fdd6da6ede676dcd4806cae943c356f693942cd54ffdd54d569ed50de7413c0902455c45b979fd8a00c7360934f97c5a53248f5b8cdccf0ad49bbfe9f23240fae74628b60dd0fac43b2f73333425c9ec6c41ffc3bf780aeecad856b00d8af0bd5548f5d4b47c0c7b65636703cf181d5040327124bb04a73468426f40fb8468e3155371331988b2a3c433242bfb5a2cf39ad78a77bdb6dcb2b373b6f465187fc710b642e961f1c4d2c76120bf268c868a4577d9ccdc357749241e410ff53edf47c2b726e91332a62599dfc11fdd758b1b8fe9af8ea6c608505b949286f90a544014ff551a0ea38e945e57f97dac9f5b507487ae09a0a13a9d0cc4412e15bce8d1549c3dcbe36bbb59bd01b94ed5b9736485f80c29b3887060c37b46d3cf4ab273927feb85acdbde18c083b14a929d325173bf9a5d8252c826096b398492d7c9406583bbfe87b19cae6e30ae062567d880fc584237b7c1a0d0be3d30633ac8bb05ecc8c99f897692a7c30be84d0a6e9601c763bd5d54532a19c9c16524409824f9c769a26c9916d40af803fe2544e5cc1b2e648c8d4b8d65b58dfd2ce3efac55e006c02b58d776d485cb09ef210686df977cd8e4c60ce323390a734588f111a3c617f3b9413ebf1ea86e172633abf863de8b98ea8e0ffd2b5bcc7413e787c3a86aec8f6f3f3a684c482b271df1b6cd24ee8e1da1a9df186d30066fa0d01d3b60c6ea4e7e07d6e569dce7287504f87833e229168a8a46bec3c64b8c7a50dc8893d6d48d1f42bdbda574bcb8dea53259281ad9cbdba00d715d56e8e28e3eef3fc3ac7cdd6177c1eec973880d3c00c3bc03cea796da57f575edc1042888a1a8d6017782fd5628199e9826110fd645b8b02ba98e7849e61de34a60407990cef376037e093c49e15d5b9b4c26b9064ec0a1df23ee83df1665a3ab9f772ab1d63bcf61f16b2fe484c60f356ca2925720fc3aeae43bb50ea1967f8a221974a0a7ac11ba29867776aeb2965e3cb290910c59c66c8c4b6b860b057be0fda6817d29d8860781c3c7c66907b17ce5f1bcabe50bdfeb85ac8d3721bb26db7476da97aa10fcc84ea0fcac6bd59c5058a30c94578208d179c1352a702acb1536201ed26d8849fee6d0e3e2679c6ce3312de28bf8aa8cdc5af45022504f0c5d531f21cb95f2daa180ef79e6725dc973442b2096d9d9d0f1aed7625e253590505f783e6c80fc96fa3076a96832ddfa67a5d05e2541346b7982d786e245316d2a60bd95eceadb78fb15e8375ada6c302161980aa11e779297acaa3f0fd2a676dcf3522c41d86f1329269be31792e157a0d93702a308da3f896f0832fcea76d6de62aa412b5862ee06a45029eeadb0e061000c41d73d19476fb5ad681dbd49007236fea65d1a4d86a920a26ae3717dfeb8346b21eb5c08f9ec4ce52f06b08b03392c4896c3c86012d000a6fd5553249f7e4117dafc91bbcf584d23287e8a601b14bc86bfc000ece54a9a1ee4954e88bb754d96ca49c9d4cdabd43fb8d30aed06ff013509c68690d8be118a8897c7eb878c3b08de5da9676ba70dc33dbfd748f97500605ec7765f23751462eb87cbe8941b9405fc038b8323f8ec96c405140bf477834d728e4f2984152c9b69a88a006c25225779b6c696698de2b5968c2dd287c521cdb79bb57de5b275a1cb24916627ad51393ff347286fb8aa83aad4bdffb6db2c28b9c26efe83461ca21ca92e3f04575a38c47a5c37b892c4dd109a7c7352f7152e4e73cfbce76ff7e5fc504a8af5b8ba7904c10356aa51a1f1d173cd29b6180e1b03b08e54847b84627d2c4ebbe4507eaf9f6acee3387af985183fd6636a906d191f6f37b46325d7b2ea66505b198474703ebe69fe19c610a0fa3bc4e33c28ec0fb07ddce48dbd14c06df80cf5f23ae90069c66d8fe515b85cfaa7d23b67c3ab0fa36707cb44593d86df5edec9d4ef216998b4b59cbf8088f604b734555c50e51fc7a3a978af63b8de3ee29e33c77751c8bcf1faf9eef26470de6b41a9e5fa6c8c951cdaa360c0b84c22fbf2808d1b6a112911b92d7aacb6debab2ad692548c85dc79d94f938a0590b4e803b405db1646be09cce1d2db01e3f5c687b9a5cc7aa07faab9984726b1a04d50da9bb6ba95dc4c5a08f14526118939e94b206e600a8ccf3b52371ea861d75115f269430f7384eb67a206fb96ec9cc0474126a103db9f89bac0acd23f2b379d0164d4771ee990145c14460243d22ea1a4ac551fc25b2868646704228b7bee49c27d496c6528d29503c16513f061b516472b2f9be365b80a1507128b46668251f44c1925dac76a73178f0c1093cf2ca3a9db6a4bbccd53b50573da5439a613a61dd6e6be2a369ce914fd3814cfe84d94bc7ded4dcc672e38587e006b86765efc76d353d6d40e91481fdd7ffba8471e4c9977bf5ca03c53bc823a0894d57a4d1a8b772eb71ed5359032825bb2f9548129281c506b43b39a8061e13109793f14df59096bb53fc0a1ab1be214889764262efaa90693d5cbe8182d567609645347cc75f6794e352f82b28951aaa61e5fd7c54f1b73f6d2b5abc89403bc1d4fd20a83da659f319ea2735b1e4d5cc955e2242a5c217f2681e92f6204d49924324378de0d0414e88a967d1dad6ec5c3824addcd57cf03e8805f4df2758763568239d652d80a2f97daa963d64f748a8fea12d4e53e59d6183093e198fb1230e1a9c65e4a5f0bbdf828a516614ceb745b72a83f4635f12771fc1ac75ea4f233f36a2451e2fc9c3678cecb4b5176a6465c740a8f97f479f0525ce00c2481c7588d1e2a984816c3837dc49bdc1abd6e99103f366882702bace1c00d518367b1519794da4d35d08eed8159d7e1a5f4989c354d8c6f9c7e2640291a219d98180aa3fdea5c8794c2866fb052c1252b958bd8a6b818abe9334fba7a0595804e10657349db41816ff9ff815307c1980c0550e5328daf17bf83fddf1ab6b771a449a3eed5eb634ed019d8ae1b562101d6de991a7db6d7b4d949ef88fd76ed81cdd39dd037c22135182d48a12b7986f6b0d506d8e7f3721f996491dd1cb2fbfea656b730afd6dec56e7cf2b27559065a24c3d9b09d10e9f81bbaa0fbc799b77ebadaa0b43c84c5f043bae716f2d0f4fa1fee5f0868a50f552b815ec2b34f604015f70636cff0c4022c98a23174483bf798e93d841acac3f33cc7c7a42f4c4af3299f057aaccbe80aa07315da89eaf67bfda45ef272cf344cc5f852e40ea6ede4b326877fd0948e846efa3f426852639fe462b21a8b07a56304ce2fb117fee9505db1dbf9ae30b81f11d8bb6981b9b49f6e6d71ca0fbc075058b3624d3e71c296592755085ed11e55d6f1f273f3145d07661f93b43df64fe8fff0801fc82bcacbdd240f8c96d09dd917546685e63f29abe7b64efc7fc59f699ef5ff4111e5fc65dd0a80f33d93deb54aa1bfedbb127622490ae84658f088f3e05c764e20b3340243f2a9f0a0ee4bc5ee8bbfeb1e924f3d2c8aad0126e9b6a648d5899544c5cf97089a0ff154b0ebaa3be5231b8e4b6dba813562f67cb8c5be0fd8c2cd6525e6ec30646b195cbbe9b9c01c76c79422d5d2475ef8e603f9007bd69be6637f5e1bb35943bb7e15836c3e281169daf8ffac934a6efadb4d4d335793a2242a39e7f46e2ae00af8678f8fc5fc476fa4bd35d3e112d8979ea1d5a2f647f65cddbba67ea2a79e6d0b49481a86c126e54138d2c765032b92fb9b08834ea505d689ae3f108075db62289385e35292aae58c18771daa68ec55a58349117f57d9d1349eb652e88219b53f8bbe3b18108dfdd2d60e614493ca9ddf938ddd72cac9517a048b6b0ee9db892740c46c77daa0586f7934039467f4aef5c652dee22ec290e9d5a083af2d3c0963c87b106b78bb3b190920ff0c64d9b2150a5e658a86e6fb5be610ff0baec051ea6f39045bf25487512d2d136a35ae63046453e08686c0e4e729ab1058d000abfb8ec2d64b12aeed0ebd6e8c0b475fb3134f9d3eae70919a802499885c0c8facf0cbbc09e6499ab8a84f1cdd7703ccff2c6db9a5b985a26ae9be9b231b755bdbf0e7f6d8514374665936b41d0e29ddb9be59cbf5d5b0bc15eabc39b7cafabcdd04a259cea6672e91eb518fc2ba4ad6ea7d5032fb8cb78c9703bf6ea7072a981a818f53e60e5493453b151f5f00cba9a1ad78f01bd2baa86e9d67ab6ba9d457bfff93d0bd955da0eedd47faaf895b35567c54f935ee87fe445c4f965355d253522cdb03c157764031459e15aaf46487c60a4d8483b93bf266ac17b4b10d3639ce0fbf1021bfbfe1268e035b65d22b09013464995cebcb8ccea0eb415d4701a6eaf8a89c2c4c4343dd8d5ed72b2057c2a1d1c935eabb72fd7d491bb416ec1d048c49168b05d01a370d1128f908265362f4825b19e9d842a93b05f6494034bad0e0b4a0a748051293b5d631df3c4b90cc37c81433582021ca07b1a7fd072536f110e2f987791e45ae511dd1d6e72859472f04871df0258475d6e913017b7a4a6d2cdcfa6f88e59186f6e026a8a4a648296ab09f938637ad41b3bbdc43ce5ea89980f5895f13acff579ca5646630bbc3ad2f6b41e4c8ae81ae6c55d100caa5e4875d035600dfe2c1c7e472bb1d0281c60a8db6f5b0ff6a25d7aa0d7af7276fd789c894308668dcca60ca229c7502e3ff51d638e062d05d6c4f4cf132f56d131495065b1db68c6fc534be93fb8c1b7a036055bb49bcdac0d3ae8bb474bcd68eeec3fd9033c82b2eed5938eb86206990afd2d7bfd4bfe05a58adfd62e25dba5c27248ab11ff202acb0970d3693625b3b33119452fb6854460a23afc35b7021b2f1be380428499e3c3d0933a28c71582487853521c46cb4e54591544b023b126fbc66fa276f280775a3e9a626a60110d718f22ee1aeb902c4a44e3d85298d75addfc6cc11ed01f028980d99c47e75c14355ade794a053bc44590f4803f99cb67c33cb863a342407b6f00bf9655ac6ba89d298a5cf7f0407675ab986dead9f709d85437508a466abb0bfcf3ae7d40be598458221f8b9745ddf257b3600832144ae73b800c041dc19e2bef3c005ba8db715ab61bd6a27986e6e278ba57b04d0669d406bd102476e78c98475a69f10441d2a44dd1ae8d5ff14036d5b34c7b3338c78dac69f7195f0e076a223c09dacc5c2c2cc2f5caf94706877526c32f9c66342f435b7e44f8436fa2943fb8dd05baa82143db1e06897ea0ba36e398525020be7f47f8b8a74f9f868d656f09d4f8e4d36b6fd45bd9f64fd0025b318f49c962fc90ef37de8031a2ed969c1f128752c0466331a68bfd3c286063b5169e3b20ce8bbce100f07a0586cde3c87341d6e04844c6e828284ab6fa396ce293b204199ac822540fe41629ec30d930c1d05a3d24fe4fc60b411e5d1c961ecfe21c6627ba70f77d7151b74186db2ead403788b70250af76cf9edc6ad719f467b42d16a9ced07ef19bed6d2c76446f9593e6224468ba4367439d55038c33cca3f6a9a06e104174a80d3b20665d964899d14531452a2f07c1159e49f47e90c0503bb1a9fa048dc236b870dd50059dc808ac60a5da5d7127ba67df9a0b358879df37e0cae43815b5684b677d5a55a0b8fbf749041bff9fb7676cbae17d86864d450c0ef8bfee2b45fc259414d2f134f4ea8b360755ac5b03d8b4f8bd06a4b4c0bf895730068378aee55a4eedc6193024e706eb23e323095f3564b2e19f39ddc2d1be7582e0e05f90fc1253b200112e3055a8ee361069ac7e7e440b28f9a91357213e70e2d9e4370fc5e82853155e4c8a252f497ee1f5cfc9d619db94e4e5ccc22ddb071737915c8e545ccfdb6719776493cad7a69b2bf33d362e09d7c45adafc353d549af603d87f09521d286c3a52712f1b804fae51fb5b90f8402ad7db53558b23056f1ae7cc3dbcc05bb7d271f8945340db0a4f33b6f7ed0dfd9560586cbcb086fbe2721b8ebdb7c0224981c43575a2c2399968606190f4c3b203118a279278990796c398a9c7cbecbfdc447a9886b23318110480299b3052e469d416905481b17caeba55a1824880607dee3a4fbb831dc33d9cce703a6d88caf052ed339634664a3846f0ea1de65b87b1d244553c9c5cdbd4a2951f8a02eec3f9282f507dfe4c7410423a4194261a08e40ece2a81b6d2d99dc7dc8ab4195a58f7d021772fb4a5148dd93eb27b436fed94e5c8a09cc3ff74bb8ed6fdfbe37ea034dad5cdee38df81af082bb12f23d79bc4ac44ac43792f4646d7d3d9c049df08e03e3311315d9a2e948ad9bce23918c719c641aec493c82e7264c05e1fc2c335e932f8afbca3616f8fa6f52d3c3368f95b50a42de3bd152eb1f33f7d01e446c72c18f309a5b4cd38467e4255da1119dee5e79d0a09f3b3006d6eeefc5fac9e584964ad67076b6cd6e38f0f97d75b0cdb6c402f715d3e75e15497b9b5f26f8be85d95e3edfcc8327bd7a4c7fd576725d1f1dc9b649c62edcf6fc6303e4d089c00cc14291b62d63a43cc637086d0e900e5a756722183c27855b22c1d1d401bcfda8d57e6029b9ef6375297ad93f1023e742018e433edd948f80671f2e0b93603ce94a750823eb059d8c1f136570271db1a9de24ba56150e76d47c38545d10a0360810a020fe80d8412695824a273e6a8429a6fba79574ec6ab83126b3a80cf13f43b0dd1a507a6275cef75f4a23deb485b96e50d2b7526191abe7495667c15ad3e4f105b6c884e08e3c12fcff50da842ebda59d0042c3c25d0dc5f1502f5c4d535c3ece4fd748d81b05732937c9ecd34f1dba66b7f1bc548b6b4a21efc88faf9084d03e084005d73f0406365bfc4920430fe5fc8c326607155d0293bb0f8fe25b8314487e642dd90cda3311d260c5c5322fe9f9ffc286fee5b08e04b5da11c7b0f97d586e27c0ae0c60251b08d4e8894adbedc0a37394c3f1e5dc027b1c2522fdbf0ef2d3a45ab5712ab8f213feba0d980615a655009efaf051f17ed6df6a95ea4e8ebb674ab67ca65c649f447d941d0dab589650d7a9545b3ee14cb2449ec161d77d54388d5185bf156de186dae6ee6bc350a45123cb7f0ae465359f4508b6c303c548f0344efac969f2d457f7d117a1b0495582e2b95f974d68f48bc83cbdd58d67532b57a6299f9007a94c11ecab5c65776507870ea9b1b8c52de49900df49e6da511bedf6a2c0bccd70940ec6c923aa0b383c7f936f5fe1e50c5f07d462ee3ef411984488a33ca8ee9b0736a94bbce5757a417b811e86a208fadbc5dc2155362d0bbff29464a77a6977adcd1aa45476fc1d30d055994a9a6879a4201710ea0cb8f1c03995665e6b9264b1d404614017136781a8f7266544e17b7153601e87f0856feb7f203607e8fa7c51d6fc4eb0ab7f64859cf4b0f4fda9bcef4a886f8751224e8d6338d312f242a40b399529d617df56352a23a6ac415e453d5c44527742a460fdb9c5eade464ba801de1aafd76b7cb912c428f720ed560f437c8952013c5c80d3b2953e49d5c2aaec0ec9f715497791f2c463211bb9f9319daa1ec88270086c5d7b63b0d0951bd6e085adbfe62b28a6893d93891106957a771ad90b498604120a1556af2c9d01c65a61a57ebd917be6f1c5c4292ae36a3322c98982a604867391df5f860261447aec521a7adbb432c74b989886aacb168d5065772809ee51820b447556337ebfa7901805b3d1a7dccf2810e6f51beece58dfe9efd62c7d543c3bcb8c879b7d4b1fe5e81f07b66a545cb3a600d149af87f9f73c4baff6942f3a7170731c9587dec213c7f64c16e296323282220258a35d48cf454b448b89107094fb137effaa453127ff2af0b8b388cdb99c4f707aadae7b49fbdc888e1511afe275cb707cdfe4e6a4e2b3a9a872ff66639ca42da69c125858533b30dc77fbd0a5a7015cd87686a12890e1d2371f3e5ad067f42473cb10d1a80261f0375e478dea85e7acf9d3cec32211930e9b858abf9f729527bb39577685977f8f8cc6aff81ada757f3a53d1883034eb1d95f8a779bd536c5253f786195ed3c31706204b96f67818707983622890fd594da71e46a7da72f2b669a9c060f230a2397ca296930c08fe8e7f51da36a9c3f2a5520f2afe5bd5f99ab785c19bef5d220f0a235e99d953e60028ef9d426cb601b10ec5662099ee1e4aeae8e8404f29cd46ab15c8639c4b2a8cdc3cb5a9fa699b0ab9cdf6018b727c19020789b524250411c99ce31b825d7c13b79e2094d8a1d5626d9463f6b5104ef3ae1b2c59296e2a29a8c2b8564c29fb337bfde1d50bf0d77510024084d6812a41d3fd2f9946aea704cd9eba74f5c4814aeebb63a5abf7dd5469e7b4aa5797f14b3b099de6a3e451901cccd662365e9aec1b32b238663b85296e2650c0704f55fc78123775c88966504db2e0f0986daaa53976a300dfd7f6544a560f07f190eb85e89baf97d490c9b1be5a48e366a9de14529e18a0c235bfdab859a29d635a4bf99c59ca953a5b3341fda6f3d978df3c8bdc514f18f004dc5c01a306b6d825df62cb955b5f2f6ccc69e416f9bc058d20e87aeaa40c81ac684adc64855fc4dd70bb94f042a382c08e3beafd88f97f3b4392816ae35b28d68d013a37c3cbd40f6ff688e0d6936a67f8c9744f5a05e252c5f7c6920b77e56c12334e489110b1fc0ea20018b6ae20e2ec09c11f27f14e05000dfa1093f9dad8b448086aecf9318a7843fd60ca1cba2ca7628b52e16a935817deaf3cae3ccfcb7cc5ea04631ff7a8b9375e72f9900bca050e69b2c62223b107db8b063c4de51e037134dc0ebb9f629a3027f5e65449d2c26f28f58d8f79897b9ba7555647a5e34414671aefbe83c22dd34beb1b168d3320109ffd085c208115724592298d1386e2f2086d72eb214efd85de74c5526d181df14df050a2655d238659ca1a3734240014bd383ee735160142e8e2eae4361f6c1e392ca3fa3f63893c89b2de6e9e1c4b21fb23b2d0bd92141d99b96101c0e954cd54275c21172adb1ab96f4840ad4ea9e727688cd5bfd93afb83dfd21c923c3f30314006cf766384f8839e873da9bbeacc159ce4b351a9c3d6429f185946f0e23b62cf7c61798be37ccee818937189046abf8f83df0c40a96a5f349c28acb01c96ef1de0088c35cc025dfcbb61bb73e7ff63c61202ef842ef8f4ec70f752b7dc9c9aeca114b4f4b7df5c7676721bed4dff6ee41ae886af0b1fa2bd18f8e02ca3b0f982dd4950c1a23ad5cb210963795e2592cd72869915660f92e1dbbf08f68552cd3d1e7b59b3d85f1cbb357eddc646616596a882d1853b3b5a15730b6a2af0ed2e08ad7bea1b1cb4aa844e0a77db22f8a1e9428884c2663072ec8e2cac5d30fab75bbf440aa4e0f29ef4d11990bb557c9a015096692e68ff7c5bf93f01949f8e8252ee6cf02a5944a3d37823890b53fcd4aacf6805cc178d140d216d54061d6f7dea4fda7eba94f7b8634fdd4366c786494ab4da6d6b3db4bb064e61c2520d9c03ab13c916bf4673a988ccd3f77153159116b5dd88d0d33c4fb2f0abf31740ae1ff4e1bba17bbf9aa1a47790967b4b8aff1da636af6a308225ce58931399262b55ad8b5d891e6b95a5b533a883f67833b2019620fadf915cc74a0d255159d6a7b8f7e11172165e6e68f765e5c086b8ffe9918974aaa7812fe031da1c6d931652de0f3624cc1bc8294839fb4091ef71b164a4eb25f2893a353620a4a6bcb2e5336a154c3ce2db7b66d4c765d8c1453c2cb4b3661127b67d5a04ee5ae78b4ae4393eb864eb77f4a9312855097e5a2dfec52fce9b51dc41320e51974bcb2e4e5334da7ead363433314cc2a36997fa88fbba2e28ed617cf6a498dad9d5f31d400ce539df39905919c10a6db6924f0a89ddbc36025fa92d26c7d113a4b1c92a6d32cee06fdd83c8e0b689f569af86bc445c4240fd087d6748c81ca35b31536fb82dfbdc26023fc26abf39d3c85df6a572aab9ee5cb9c96e79cd4b95c5fadec17e18fd19ec7d0ffa850896f938eaa584c16db528dbbc87a98ab0eaf3a44c91e25377271a82cbee096ac9bdf6e5d72a32a60179e22f598a2cc5586b1ae167988e4e4c2b35cd36851eab3d484a0d86e0bdc55ec4dceed5e277bf7881225f879288f5ba5d63e2d0abae7a5ec16bee67333bf6217170de6b662e7e79608f899f56405bc2905fe5407af9536317fe209386023bf32a2d3bcfd3302497ff5aa0c134f947c226ebb1da4d060743e47db0059cdad5c84dbb51a972ef88efedb7c8659f0cb5bebc6bd325e59eab80726e6c83aea21c372a9f39437f68155f2ae6c7038bb414ef23284c8330fa0327d133886e516f2ef40f23a6739da9ce62bfe68ea05802bf8ecc5129db67e552ea729f982aabc5729b4a67b83086df50ef37fbe384b561271439a5a0d61cc72732390a1effdd44a68de0a345e990b2ced917020e8e25b44389e423906cc7dd85b8c5989936b2f00378c6b071a414879467f06eb4967087ba484ad325cb5287180e0bcdcde89991bf5247c9d017938d9f704a8df04f1447dd33165f096630ad7e1da7ad18db2779f77a4e569f7b2c9b75752ed9ea9cae4ad0bfc9ec4c45cf0c2f6da3bd7990c33ab15ee22c1e5915509ba27b34443a305658af5ef556ce704c97c26b65954228c238dfadbb5c9971a49900f54c6c34c25dde075f9ce54d0264f361f62bcfe4dff7f80c1f0dd3ee7f984dd667545bd3759ac8840b263e5f312526b28b3236c06b3fd495b8bdfcc983f8ec561b71bbed8b64a239013756de196ce00ecdc9c6a35b10819785a8470883389db97525d392e63541a0e917f9024166a1d6fcf2e8e6fbf6092b87eb263be0f782d62def1f3c6bb49cbfab33735c3a2b9d8a9caddca8bab0cf7194f69a41cb1df29d9d4bea73277d66612da0a33f4ac9b17f586b72f71944025d02eb5184109ddddf01cdb9bfcfcd0c3e6a7f988c02dc2b90544ea2981e95eb1dc3d78f0ac1cf3affd676c06b238599eeabe3043df3970e8982763b28784ac360d7d11d4149093b7c2bfbbeaeadf4916114c8c28bb2f49a8b2db42b43a77139b2bd897fc271286c3ef60cb9b722936d4b937107bfcbc56ad735f2458c03573a8c516fbbfbd68d56cc7ce4ef0d48fc446c16353ffe3ecfc916400095cf97393b1656d9ad2d02fa6c3b710a09e0a1cbd7cbd0e9b2716598f11bcac013241cdf6c47496a0b8083810fa0362fc4dc05b47d4ea4b60bdac41dc04cfc4f634a56ad40d203b917e57e17ee8648dd26ed48178af89291e7dc11a2ba3361bfd2df8560ca9e12d731398e2a1cea48f548b6c443656235acfe4cfcb0ea5a43b52fa476c643202d97962c16425631b08152a9cdd40a593efc3314e3695d1f2b88c91c65d54fc59795d77598b2c3cea56966c5189a4b1bc1d66ae5f565be5aedf2cf2ce4799e78ed2062061b4a006bc71d175b28b65eb363e4fa2b0f2b39a8583bd6a142e986706b1196eff892c0051d3f8f045a0e9dc2c75c1c2108f72eabf2b70eb551d7be25b83d7438242022bcf15634a8c13af8bf928592709b10ea5dec15ee74f1f4fd43b0713b5bbe69e8ed67f52097a13a88bd40a51b2acb7610608527ba20d881c0e6581564d74421d762222a12a7e801a72438f768b8115baeeff5954606084b5c3358500072ff7c4010d4a2e3a612b518de8f99a331e323be89c88f11fb3d653d7d3ca4905f5a62d6ffa75ee76cfcbfa9a88e96e9a3c68d7321d15074e58a71c720767053b2a178a522882ddbf6646b968b8b0d22214d87eff160526653a635f709a99870cc3cd99e9ecbfe603e2a06019d5e40d6496e78fdf89f4111a8042409dc57bcf7e348e157f3f47abef79abe36b5babb5fa326745486fc69e702b3eeee4ea41f4a5c2437a0436ab0bd880b38aa785b895405c97575e10ca9b0524ba4be647a0d9a47c0de518327735808d07795a9d034ff6334e5ce567441594f3eba6400b1c474add38bc5ebafc04e70fb4e5da7c7e9fb12955b0114c01e49153620937f66009eba5a9142b02496994297e99d3e2430863a78c01993ad074f60ade879ada2b27534272d87c14be4b5784f4677e97c740aecf4450d8b1f688162132ed3b833fdf3f75e1e323909438d1ae6688b3516afca2cb18e86025112ef0912198890020e440a7ae8327dc9f2dab7bb33b262a8ea20de3b35368b46237e334498520f444be6f5c654fa0725d08334c8f36c8cead8598f19092d5ca4fe63429c49aa388a01f23f259df159a346d2b86049e0758e995f04abf9779694c7188a890f4d70b0dc5ee76e39f40f6f582d2833fa8e76c9ddae2cac2861b9728aa35c6971aa9df0c32e99056b229e5d2aaf09f758f6710fb7543a00e2a4dea86556877e4a1c13206bced6b8523ef67e402ad1902d29c2656cda3c8efefffa79f30126e4d9a8f01ca660f646f272aa757d67f5c81aa40483120c04646c09305367cfb31dbd376653e33d00694369ec973ae1bfc6248a013feab0ee039e3748d90feab33d307c20435bee786c4ddd81373f0d41f187d0be782771d82ac042c7dc45ba1be2bd8ae3907bedc98e61fcfd851c0194dd19d5a5e8ac5cb4acc44cf31c081e7c4e5c70f9083277240f232f5dc7ec8b6b9d21af5666ca73b53ab790a8848536f500adda6ea6bc063b53db15c1739e92fd00d1b53d5f68899df60b9957a0b9900040f84c701c308fb7c7ddedeb92e7f4c52a8ee0c5a15e7cf129868cc9e81f24e0a5e5f1548ad500ade55e0d42db5d4fa4c1eaf909e7d99919251ab4cd82f85f80a515d0c1bb7c2703a9749ac237583ee2e40a899c77eb465df50b759762d662215d769946f453b9129e9044b4f6c660efc75afd0e140b1c599928a8fe960f111bf54eecce8d72f1bdab9e97b70d4eeed47cc42d131a2363eb83cd01a399a785b803ee981f070b378ad5c82dda3e825388230afb9501dc61c2110c65ab2947cfafdc84350ee9cc600edd97512d4a8a73db83491565439f814d6a37bcff376b82a98161d2b836a7cda152bb218dc310651a8c0bf5c94ed12bd41a20613fd7680764c01c43c4eb544949cff7ce0b9447105a6bf6ef19c7da2df7ee00b6811d300bb317cecc7966f54a98cab5e14d01708cc61bc10a272f2be7711360694ccfe90006e5c58f59567129cdd8bd25c1709b50531ae7e417bf2a8aaaeb5229c2eb09fdd9882c3ad4b87ffd9b0781e98a5bdba88ce3f2ddb376b1a2f07a9b25ac73aebb01248aa0a8751d506dd13cddbf28824984cf47ad582c0c1f036b8c3887951fbd0ad534e5f7222c28222ad4996f1cd39b51b965f24ea1d3c87f2dbe4a0305ca3b3759de86f80ddb88aec784e718e2d6e28a229052bf951a82467733c52c024a5661aa9d160a4c2978e5b0e10ebbd585a5f059ccbe6f090eb936e90ee4ca1566c775db743cecdd0e3ba34c8a91a26262539ececba83be5616de3dd0740e1c46eaca78920eb1feb1e1dede4294c26ea6b334001c1f1665f1d40971073d4890befc67b2e6e95bec6c95e417e4cb370a953f534adcce75e3ac93105793ce38565cb551c69aad85ab0357ed621107b76670bfd008740fb171b2c4f86028e57e0201d42b38796fbf1d6d49530282747623df9473901b415562aa3c67167d47b8fe411d9929fe8638d7dece31c294f03b96032eed4fa05eb9eec1811afc035d62ec09ee37dcb38752551508604040c6b63d106572d39804f0eb1ba5acd8b5157299120ca26fdd893b2801fc096dfcef488e35c700ebaddab6c73d49fed5f5aea0bf0eabc8cf30a801558abd654dc80810bab0fcb75a45e584e05ec175a8495e9723a18a38cb16907611d960f5c10691c9db2354ae24bb1675f56b36e22276d45f3cf04a7a607804c75d63644fa999a95103ea12ebeebd8cad96620c864c8ad6c3b57b8b823687e0e6a5d6031e93a252748eff8f044e21197fe4f2332a6e3f909874968975e938486df6fd0f3e996921983652fed49e7d738d0bf8d8d17ef7dca91098ea4459d3b20aac16fbeb7e4a6d085e3aef8fb5913cf5958859d395b3d2efd3f259beda18275885073128ff49a26af73f9a99f2f4362977820f319d4cfc0c14ba02d34bcc0397307fb3cbb1c1a183a975a6c7be023a12a7c2c584e4008f430057c4260586e6ec788f1b93dd68cebdca8bf000cc47221c6ab1b18d2c87eae51352cf92274218d88e7818523d23e4535689babadf153711b8e44c56b946330aa86df76acee017f4dfbdb35ab0c6d7c9891d2abff2dcdb6f34899b1b41c176bb50cf163b78afc451b9777579784b2b8c697271e8407d0f79d8e5f4636d2dabd0a92929600e2a3ed2a1f98f49cbe65116c75bd584d9b25c90c872b671e9bb1827c2e4946423bc2badd6675d6c43c816068cda2285f742cee1cb6553fbdee58871596e5e6a7db1d860517b15a6d1d5e778a36b0d5b3b724ac9cb89ce365d29e4a13ff33490031e0618ac2a28997c9b8833ace0a06974d69c4d5680cd59661b59e86ccfddbbd4cd26b9899c20092044712433175ea51729532fc0c3a3c4549c00911e8f6a2c5365352812dfa308e1fcf7eb576b69618be46383106f7d320f426cd86089a4fb612f22f8650ce3ceb5649b0221a9e7ce486e4f57ed4d9756994a33c4cccecd2f4f845faf8c271b6fa2febfdc81dda5ae320ef072733dc2d598ba6d4d14c54f4602a1d492d3e7c7b67f37e9604631dda806430cefe48593c2a990ce1e596e722992802f0c3725431812e9cd617713487396a3ebe85812315587debbc8558cab6e7938e933d0346a4db5171ff8d58ce0842e4a0f6f45103b475ffd8fc269ac93a109a050687edd0edf2ff5eac9f6f85a9c6e7eca9dd49484737d32830ab2a2114c7e3ffdff65e328f008c4f546ac5f4b6745bb9b22a248884eba536dc9090704fb971604a6ee905dddbe7916f99bc67a7eb537dbfc1923d8b6ff76381d148782e7af0588f966046aefbdd5f52b259534657b2da6617beafdc9ff89a8ec8ee715a21ed71ff2e2f741e674ddc1c37acac9491419470348e2023e59c5de46a036bf9ec24a4b6cd7f172e1e708d6aef480879f834e65254ece1b1983f34a081b1b6c66f54eada1c4c76be82116a7af4a2400f06e32ca264b6125edd27b7d302646d3bbb8ab37d3b8c921818bbfd38271d16453fcd70a85f667e63d250d5ecad76bb3fb1fa0ece718a890ecb3023cd83ce2f8bce7d97b58cfa4de4252b913e1e4db6cb7c88b7f4b051b77b251232b9e18cd6601f86cac9c0e31ba9400740da9fc04e888cc17b64a79b67e0cbf5dd9fbd32274a4328a837408b8e6ddf474651ec966c7765d5682d45fcf45b09477f1b52f74de2578162918c5110561607a56d2ff4052c08d7a60e89d14ce8dfd10fcc6a55638765eed92c2bd9269dcdfcdc2c66dce0e7f1d0cf353c8f9aacb9f3ae4adb56bca83623cdb5692a444efc8efd034885a71191e683793613e5d49fddd5060aad73e33b7395d92f627444b7d67f3006497d33bc300551550e3d2e7f1d070f4a76bdc82adca090996d8ebcb5d757c79beeffc0d768a66617082eaa79985273785bd68d1f72c925cc80b148d9eb71bca76aa253539070f260e0e9aa7837869dd352702988e308d147483296822edfbd44ca4fefc1037afece252595608f5b21fd909f5de1f6a99a4649cdd0a651a3e41881ff7478d9216bfae63a518507de401efe57e2e31b07d66ae51a0aaaebd9f6111b7e3b580f3f9ef5da139c6cf085e8171ff0b11924976641aff642eefebbd135080152290f5cd69912806f45d245a1aef92bf7d812577256c32bd5de5276a9cbfb1bfbb89c7270be8369788b8af1e330b6778956f1d6c3a730f774949779b7ae1fbe612d4028c9668703dd47e982dfd01a60373e9a7fa8ba742ad2be3c548035ef704440f40cde63f6ab63108060f77def64f1f6e04dcac0ad57af5383c6e8761c7ef4ab6c3478ff5e772164657a749ab7e504dcab76225c4e9f075866658afaae7bffecc0049a7cfee69e691f8b91a894103ab472c3c807fa86e1333f5ad42cf7d4558572afa141c02a80df3aef5d3d38e1cc14fe78acfbe587b394cc830918bd68b3b693baca2ea863a35fafb4826c99e1393065daa0af8b344ff0d9088cb9a5a71d6f621159c59708bdb8f8008175714d15b4c10ac77a3f5a2c87fa5094f6876301f805a2388f435876b796db4d014ec657f6f3bd102ca8e55729caa1b6aecb966e6f4aec668675b74812a286ee8cbdd8bfecd4859746ab78ebaa86fa4f1886f3c0591343f269f731f866121c1c528425f2af0b6c3c9581ce992d2643550a5cfed204b2905ba54f78b7525190698a013c20abe49659c59531a0ca70e631eeaa9a676dc8121ba1797be9309e6c757f541679e0f49f02e47096ab1362baf1b77353567bdc5eaa80b0d51cc2f78b71448c65469ef7f8ef4e059e1f534efeab83ec1d74e62fbf999968448da43250283c069d8d4cf923436f6064ab780e3319913c2aa0b3995c8fd6fbfe054e4553095851a7eed5aa3c5e9b521d8ef70c1c79bc5ee7a48c03716af66ac4b18c7de75f1bb43cf58a36d01ea0dec22298f1ed37f38cb8408767e2edf63308dbfa092601442854d60a5d20d8b23bffa876c8f643e0ad0e4a7060acfdb632d2bb21f467ff85a905c80caa3c399ebe3d8e06b1dfcdfc87233693ad4e694e3de4dcb3faf243565f36c9abc1a6bd659369d3e3bb7fbc10268849b5f85814cabe43158bb8ed497fc7973cb59bfb5368a4eeaa87463e7799239fbdf176a255aa56e845880a4964b2ecc010a43c1f7c067d9f2b47cb6aef934fd60198b6948ac21bc3710d462320cf1f314aa23e445295f8182081fa3e4c904befb39442e2bce0fa66bc7fd83e1080575168e325a2a906a64bc28de38d35ee6e3b4458195762a6dc33d467ade58634f637ec3562585c042353955481e6a80d9bb43526650d332176203dfc9b473cf7692344a2fb2df92b340d8ec373cfeec2bf22b21cbbd6348fdebfb5ac43b8ef527de4da27a56e87489e52c81a68846aff0a95c0b0b535f07802ab817e436998704be4782b03d5b1e52e8a468c7401559907ea645f127ffd6f55187a449f6f57f7fcbf3070dbae272f08a1d1c3e4f8a0f794624b8d91266fd9e298e6dea382b64cc4ae2faea81454c2f3dee9c5abbc22c84098153fa222f1fa8add53d43b34e7a34bd569ac769f72b8c2d1f784518007a45393a661bd1fea48fef64fb23bdd936225cd4de0094f5b023a304151cd4d97b2e630711a933fc32ad46364a399cfb8bd99c5bdec9da79355f38a17df3ea2b9597fc4708f70ca6115ea960d0ca32ac233c7185ece7d74348d7ebe12502c3824915777fbe9f2a2abc9ed3c6d90cba84018a7bec012a1cdb39ce2739a22795cbce3558f8c2a5e081b1bb34b487bc1c44a3fb163c6a6cfa560ca4e663c8f799cd830b92ed0d90133b280ac2221b956f60f745bdd34644f366c40109bb18201fb21857dd273ab3949dde667c3e5ca1a7bbd6c40e4c3766d5fe9fdb6d89f75835847bb50630cf2e03cd89d99808d62a4316112b1157286e52b5a25cdbd92658ea25c712a901838e80312ce874febd69a07b7d93dc2d11f8c0376f69c861a5c641e4025e0dd212ce768ede867b33f4a3d6f330132ff4be6a2d827179829b1decb0e43d5ce5a0778e862f39d3de6a601dcf05dec397ea6df15b8f34d43980735a243651fa8823df8231354a3f995453a98a922f2f59badc2ff68f673e64a6637a63132857e12383f8e619b6f36ada14051379a590cb5e7135decaaddfdd35ea88c0483efe4a047c6f0fc3964a30b41102149ae7a583d226ec5f76f168ba453eb291329af80cbcd9a60a5c89e6d21ecdc97f3acb0083b25c3ce4ddbd49f449c7130fcde01f416b304b4c9f82e326238da2e364ff2323d38d5e65ab01d26dd1d41f544ac0dcdfd23abdba08346fb1b8d03f39e6d9a37c13a1069cfebae266cf47d6e008985f6210193273cdceddaa2d311fb0db4da200bdb20659d6f5e6c12eb50f682209c4be2a35aed3dddad5828a21acc3cd8771a2615be19b47d2f90e6051c03a5f1270b488ab8a1938f1c592ae48731fa7e486580932155d8c7c2660e2ce26a7b592639cdd86aef4f6f616713633049f4b73d2518e5edc5d03de18056ffd496ff97f92ccc2b4118c494fb631a5ee0d97c48e83072fb6b6f056bd3802d42e636843c51b84aa87728c973b582ac106ea590cd517b2e801db1e5672211790e79124883fa13683d0e76c1d44c84c0bffface76975e012f208938df8911831d9af024191bc93142d171b4fdc41f5d17f39694a71b4d3a43f3281943d039cba0d2b71eafc8e715e57879d7a3d0d421e23b4e55fb43feff8df12c3ab9ad8ed4ff3da91729547386588bd78e210571fcb491d4dbba7649c1d58d3be90aaaaa021d3fdf085a455153b104d6d68d0cac38aeca81e1eadfb2cf77b087ce8f1682b72a229e48ddde3a52afbd11a35e04391377b978f36594233bf308ce40012110a5ddf824296997a5d4d42d44c4e8277d005053b3f79465a4b99ebb8dd204363697fb559122f0ef79cd00b7bcc72b801681046b8ec2a5c90b48c59475a16cb8528cd07e5b405e4949ed2403856395a3687c02ab55958a3f830b067910330f197646985d8c20f75e327f2cd1c7f802d5f3d99da0ccb15c497aac9a04f6de0549970c17a0430c8997b223fe4f639bb147dc155954f8b21aef7c296ea716a74725f760a88aab824f499fb5efe6cb3c2c775c36e8b2937aa747f780d7d591ea9e0ee19a262be53cf0f5e7734f0ebd9d403c19b5421a285a9297b9acdcc27f274894444c8c00beedddbf279406c1bec183fb71d3bc9a542569de3f16a892c188b17d429f3efeecebc02e47f39dcf65c971b7b099125ff01cba7e3504cd1640bdf60bcf803c338d42edb5022226665f4dcea7e4888b53bc24a6b1f92f56cf1294447aca6c49e6004a626e519a034d49c638c38341fb6652e356b87132f649cfb38c8278d2dc3ccb533ece037f43ab4a53b2769e519a63ae3ac4e7dca00575dbecf9073cc309abbc8d23f996d7986bf5d9f3172f1858b2eb74fc09a26421d24b31693f5ceba202e858c0e60129930431a3c3dc3d1cdd78b84d5b9c1b070fb01172a9ec0929dac29ae442cf45409820858a88eeb98842e4b8afcd81a4e27d30d88d24a014bca83f509ff21b5c2a54247aaa2a774733a4ea1a3918ad98df2ecf1142dda933822cb81f4f81a3704f8c25f136f7dcef2fa78b581e568a322e839b8515328fbcc7b5c78405c23218eb948cde0bba539760c71fe2cb5af3ee5b947e10f5d46801b4571d434c17dc98d4882754e165b597051e9f635ef4dff81c12e4acd865fa1d5192f44e1b15d615de7c037380c1a22d7f0fa45d1fe9ce4088408dd97ca974b42ee35c5038630acaad64171f056f355f1477411fa0ecb3d65b325b06385961a4a7a6eafb8d20d72eb9739964a1c5fdf797d78b36e2bbb7376b92de73eb48aee9d2d85bda14eaccd34df44273ec0a26a3cc90d14ca258f6e88583be63f52a9490b826718159fecde1a5f8ecf22df9fe13b7fd85d35292278600069771700da0e76ca35c1c09cf82e28a0e805402ba88a6832417b0bc99b5f30b008e25bfa87f55464735466ca09c18fd17bb03a6d3f05f18808d3bb18d9c804f1fb60d42f893d270b9bf6a4e58ebfaa1518dfae393f0a349cc541ff5fcf27d261c8a4bea868dfd07273366fcdf8096b7be49edc7b1d1a25169aaedc416245b5f6805e443aa5adab3a4c2c89ac590732255f7e2ed5b64a7e7e6ed1d4192a29af64f2485e2b4405f40d955598e5524bc27343c6a07c5e9aceb4f27a24d7f2a185ded9b1ba409197d19d6e9f86c0f1e7f4678cbc16cfc95d09800198f1cfacbb9e32354edbb78ae87206ee3130ca8c0797b20b4bd5fb784d5f315c573417877e67c6f56e78699f31ccd44e781adffc740f3c9872f3120cd8db9874fc6f20acde9e8bd8298eb4b7ede4c67353784b446d1452404060014202015869c8056fbb42e3338720c76088a7d88e9b5d1ab7b5235baf5bf4f011022a5e1ce17c70f936f014f48310cc69d51b86f609dd71281d2b3966ef1cd4c5913a302f2660ba929b2955d2fe0e1bc50b9abb5a81ad9fa4aa142db9ec939c0f967d3759c14088e3064d00829d04c80d7231b4f0c68cc130f155cb9f5cf0641064a06afe44be9e9933a5ac68d9a6925042aed8941d8718266e27d2229db45fa55d64534e1df47858927274d8adc8cf22e0f50ff6f898f8fc55f214f9f3fe575b4ef3fdd6c86e686559bf8bd92703805bdfa305d24e82bcfefda5408f01cc3e42c23a8cea245c697e23808818079b93ea209abe8c276c62d5fb46a71b3cbf7be639b6a3b3271b10e001cd47542522a385929b841055e4782323cff9ee991daff62f017d4fe8ff2cb87e2847a76d6449746fc3137be6a8ff8c5515225c0e279275e271e71eb269ac647c62bb2c9cec6387935742a14aad8d6f78c61045cf3a276253d9b19f0184ffd7272e55786ceff03699ebfd7100dee1cca886f5d46051a26992fd591be3d98d4cf2231713eeb6359fc5eac779ea7c93ab9dcbc8dd7b5a5379d9112b50c82cdc5a61b98ecef211d23f2d63437314bc979b3d5a5dc7b85d11b03fc2e1d36a049f44ea7af73a9f484f67feb8a7aa43b2af73bba6c8f93577d7aab6f288c283468b51e3d77e147b6f8472f503f9b736784a781bd848ba05f5514cf78297bd53e0fdf694cc3a6f55eb07d602da845950a2039a91bd670af98c0de73eb9cdb0d6019d41eb6bef4c0311c9c8ce15b6bc6157de850f950d127061f1679743d17f580eed5528cf3f25a96c3f0f1420655ffcfc60a9c22f58c7d7f9cf942bc16ff94aa17154538b642dc96cb24018418ceb0fe7ff3b987615bd8959e7662d0f9bef651c51f44b7521d5cce9cf37c80d1ef44f7ceee49e5fea08785d6697e192e67ce5947bbf2d747623da82bc6e1426004852bd6b067cd7db75dcee4fba518396c1c423a02fb164d7e6baf18df48bf89125794e6a0f3681def3b520814f37e9cfbdc074e3c325d12632e706314597721b26df18a1e790747a59b35dadff71907c1e8864fe399fee72c28d3f8c9933504b22c9728501bd491c7bd09557994f08dcacb2eda2a79f859c933b6f7f37b389b625d685d9094f1c0bb2497550ffc6a1ba2d4e49bda5143d5720ca527b4a5a438ac1b41ae4a6c22bd71dec73b2c801687df08ba99745086440d55903986e9d488b5ed8d8566ee2f7babd045175e3391d80eab88b3f63acd6d9acbadfa78f098e5abaf1ca7602de6f7eedf2bc38e19649929dbcf618c4e569c21140fc20714013224106e9fa34425e604d848e23970ddd8cab8831db443fa2b57c4d8dfb1bf3ba71955a8ad0eb63a934205df7eee65065551f7b3b5e5c313cd362acba245e7833ee1fc8dae7ecac8fa71052bf4418a1cd442dbdbe87892a3478c3935869e3f53ab8c0f38862a0fad211f6274c5a1aeb916534988ab78c7cd293db47761ff88bb8553954ade98b005e8f4a4b4e18567b7a07fcfa665bf33632eb09b172fb1e6faa43963720433b65377599246c190bf05a85563357977535c85e847658f953ad99b137607ef8e517a0d1c63ef25d9ff86c5950ce7eef4fb409573dfb73688b0245d84116852289b39c21a9eaa769c6cd121fc222b7f755b182bcf3ca55cca8f88f6d2824c1749750ea33c1de2b66d7b0a95d778c247070c7a93ebe59c88f5018d015ef9f56efd1a5689319b8fc3b5614494005621916ae36916d728827b1a52468e9ebc090eb6464a24938eb04f4cf5cb2734b2b20eeb5e074d7a6897f792205d45006718205823990f603703f711a4625d5be2422a5b93cf8a863add8bd3b2b1893b32158060cedc04bcbc98bbaa3b2eeb9458716ceb43dde2b3a7d138a16d895d71157d94cc488291fa7bfba24c07e81c87e069ffd6cf4e20303d0eb6f5e1bae940ab1b2815fa3dad6f2baaf49272c5dbf941b0027146874117559ced965d8c5c9dcb10d3c377d81658dad11749995c772b8a874de92c3560455d5bd64a3bc97acbc2a27ac20e1cc7158fa56d40256daf268cde7cfb9ee1c4717540cfa639050832e0277510695d32b5e47de52358340c71c9e3d252fe68a48bf7a4988ac4c0395146b0cbc07dc19bf11c6891ab95fd938ffb687a8138c4cfdb770010aec338ac5da4dd8f6a1c5ca6329dd17d38af98a5cd30390595d33f9ec41799d927396f3002aa58696e66e4e32a07147230e3e82cd8d2e298444de0f80a4b26eca2ca9fa7b26a23901ca0a312c644e51182b3d1dc49facff2f56847a7ce4b029e6afe47e280bf42c6ed7902b5fa2f65dabb483c5d3f110d8570a4ca6a73961d61610a69a6c5eda3881350f387562267a2ebe08f8b6e6f921f083119e6273aa68d6bd2c93e6de10389a8ec7453a7370efb9cf5b7db40c83004386df23fc01b24e9773804733bda58695fc99051491aedc96605c1a10ce8d03a2e9ccf707d9b2c3b18c975eba100461d19e006a72e34944c07e5f819fa3f396c00c07f3916c21795393fc8a3ff1091bd121fcf32c27b6129f1ed21e849746f2208baff84f9acad4ceaa82ec1d06475cfe46eb7e33540c01b8f3ac3ef6be2d6bd5b1439c5908bb8a4899cdfe37949ee47f89029690347da60a194f1a53c04e908fbee29bd8435a4a31087d0083014889ae1a4336c0e24046a9ebf994f0a619c3ba959fa7d9f42cfd18b5491e98aa6d97bdb000a373153f1c754b7cd5ce44ab59ad73a03482b781e7a0a2a1a20bbac950b6636107aba4e1958239b1a4a57be89c7760d36efb1dd167db5345b32ba331ad43160844ded7add37db47d19a0643631678cfad16e4730d651b655e961798dc4bece480f94fb109fc2b2ae3a1218e99b622fe91f7ec3c369f959170656c4f944da96ab60ad316a3a21f8ba2f314f19e85532b8939e234c1f91f97d9653a03fe59b09c73fb83f12a4538cd88b48ff38b5018b5596168f255c0d971ee9dd4b7f7f6b2126c5df4038e41372b7f532e35f7bd2a4441dd59850085330e2465f5a2e9ecec5be8edf2f774f7c41e239f791863c97205ca8ea4c24e5f84b622ad3f277c4516240f02d0bb07bfb0030924793679725436057df286725ab3224734b5c1bcf989d21bd8d1ca3fba8bded1034853dde56eed5b06786c33113ac19bc29a1dc022e3aa3f4072e771bb1e07d3c72cdc366951203c2c79f49487ee07846f5b880790d70b92e342f91013513218527813757c6f91f9da6b1a9ddce7803b1449bc41da703847c682a4ddeb7e83d6fc0c090bc07d359ab88d6c0164071830f21b291911e783e815cc2453f59555e58f43f37c66352af312dae4ca9507aff8ad0393967fceb49de5b29d110441e7b76897ef1f86cac822212ee867ceec1d3550ba8fa1ee5c81d7db872ae6a4795d7be2c1fd26cc5263f2610c02faf507680c99062d875b22647863336e49d0af2bf004d35bb6719dc60925de6758c6e42da95d1f87f332b37e70570afa6c6fc2d7a4c8c6b7d69ed3ca31e8eac0522a1fa39c89e4c05f6d4a2a952384cd73e4061a66a0f0728759fdd3c878e5b5d730ccbc6e3863fbdac515b7c7dd7ead9db1dabd89ffdadcc4c5f095693d40cc4ea8440af7c61a2483e110088d82af68f9bb95cedc2cb4352d099f43d5cef60488130d35cd24b11344951f2636fe8f180a11258f9a34b34fc2b0230598c4feaaeb22d98727baeafb009fb7c6ba1fd7ceecebe1f78c1ecf3fd3e18dd263aa0d0c58906d508c8563c3101dd64e030c38775f112df7a4ff2266df751b2266365b1c760d00f8303d9880d1ecf8a82e237a16336109ffe11b433b469cd39bff8bcc03bed81999e13af72e07674217406d00b3e9e298d3204f3e5286f5842c343b3b09ed75d8c5441c824fe78890d2aa7f5c1707dc8d823433131e9297445da04dcdd4fb8e42c6e0017b6950a604eec20e3c444c0b3188997637c96e9a465b664bc2f104a085372a061df5f61084b36808f5dd7e5603d754e9e29588bd32da09babebdd76f99187d7e07dbbec081b1e89008a0db69e38ae60d0c2f1bef3184df3302f014bdf947dcdee3bb924a29ad0257957f44c062ee6ecf3780a14a87b89eff57b70312c20caa6b54445f521189e4d978a7fda01f5262dcb4db50e90492720e3ee2b26b097cb0dff97c86f279c55fc20bf13967ccff5a78a7ee593ec4841a3a4dfd3fd6c3b9811e23bea0adbd8c57587abf160748796c1330d45861d83accbd80527a67b5edf2252432978575c8f1da1aeb43cdc8ec9fa15594687076ba7c50ae850439364b6fbcaaa9df178897678645fc6d465b983c907d98e2b1e6cf01eda8f919da6c85772643c257a435cbb4e06e5049b3fd2f5b2a84d8f24a28be3ff0ca31625cd916ef5e32b2c15e7dc4a94138fddd0afc553eaa021df0f41c27c66ce974b5a9e8c4a463d9d5dbe44a3d81fca4bf78edf01d3c2e13ea6869b7f4aad6da1cb6e5b676ff8985b1906e7df70aa7c07976ea3f9c10383a8dd9d6d57231d3575651fea7c80819ca3dca70fdab16febb56d6f5f83710b0e2e244682416d7ebb7d56979513a2bd07cf87ff00b8a6371a04d695193cd4ecc5cbd55a20f169810853f679724b047a7a0f96f4e11097cb906102a2e825e24e17baae9bbcf47c60a8b259da8a49731df4aebcecee012bdca32f724825cc759f4e269dd64c8522b67507e5966beabc0d869169cba373299587b2d48302a4646b0ccb9e8cc12be7e0e3511633a1791f1b754b00ff97899b8270d4fd43a62253b2f6348e4bb5462047f5d6413c5eb32f7288c29d276f3f1892811e0a2779253372fd71f40fd4de124e167672eb4408218b825d8b171aef99023038a6b3ad3446c24684a75496acd2f960b4dfc513a364bf54a5f07247fb19eb7e9728be341e3e988ad38a238c8828657fca56a6c7f5394c830bc6b01fabec7fceba888f61775c0f55b78d64c8b1df307da8767bffa4dbf98756ecaaf274d70572a8ba383837bd692ac505de5218be37e7ee0aa0ca75d013a5f9410034cab045c517c386e9b22d24d5854a236904f7d5fd57d2fd980ccc6d3a40d2a30ebf8235a4cbb5c1fc01c2936e924608d7a67b319a689c4078b7f98c8793cb30f80762e02f9a15cfe42af17c9d2f47c87b40bbfdd55cd40c22789b1eb63661e4825ef7027e05ca32b66a4012e36cccd45c94d526ae3e1559ca2b6572a3a7c5fc18032aebd6bdffafebefc0ffc08a513107af40e30786294100486a23f0c0586a2ad0b02c4efeaf843727ce14f3b81bb0f8e368c23f173d4ce67e427f9578e22347169d765f520b460e18acdb2e2d674c2ec3faedade0b35e970e63d5ea830836ade44395215ac2ebe9cd53dd9f1c5d439ba6eb53194c6f68e7dc30dc2eb06b35af5086ac7121e50700d6846bfaf8f1413dfc08f9e5f98131dc00b4d81c573ae62c8a7c78b118ed8e1195669ffee2bf6fabda5c4cddbf16dddcdd94d64cf5eebdd4cc023de96da28b67e3a4dc1042d062e95e623cb9a2068a691295cd8613920cc8bcd738618f0139939094e69b968f46e87f0d5808b69677a8f31c12e3430ebbfbfd6f93f97a7f21733a355acc0efb1c9e615be0501509f7f8f899a856ff7da1392869b6a890d2779dda46b0059ef94cac619a30d52e455a4f1a063848ebd045eb724208c6b99a2aac16a7213193f804234f2535688049a63ca90499c3c13dabc683543288dca696f18e813d56d36575d6e3731c7d0d62278a1775563d864dbe1dfdb55353024a796e2ec9b0b3effdfd463acce41d552a7ea3442577109283befe4639c40aff2b80f5c3e4133b4d6aebeabdb86ca493c09df0c6795ac58546649127a2a08ca8680cabf77a024c8ba9299b4f69ac16dcdd0ea0586bfd59f29b055d1b3d73f5df351749b153e8c9fd5c4fe1e8b96877a0c3d8fe7179377454c57fc74f17ff4ce3f6f2294aaeb800daa24567cd364413650e6740e976e19262ce78dede0540fbd3b56cab315ba42d640400fe2565b4583efcff63f57e378af30fa7b2978e13334a91643abdc2354c12b82937a2e2be5201fae3c7cadf09469b95986181e0035c7f9b93ec6891fe6a03491a2afb2d222a3eaec48654bc7d4ff6809c1a8a06c8cce4917b004ff143d42531fae05b3cd7be10e8332a6b1f1505ce3cdb6d701d31fce6d6674fa20c9b9339d543ff7b5a124452d2e3d1a43d30daeade8efc1ba3108a236a6245db473a484b4b9d64e66c3d919ee6468048f9827e483d4bb5ed5da62f5ce2dc065bd002251fd36f6f1e5f456a08298969249683f7edcad86310d315d4e724e768fe26d4786800c0c193e943c1bc136a22442970776aaa6e9fd5ce5c3fd25f1227afd96e80ac284504146def2976a8aeb0823957ceee7c9196a60f7f7cf0317d5a325bd590fd9d59b83584c42b19535ca3a7ab8d4926e9ddbcbc71e41810c93661de77cd006ac59a70eb797066532f9d92f69785bff0706689658e0519abff796e6d574e991510452c17e979b5ae86b180e08ff7e2e639084d887488e818e5ffd2be332ae48fec35ef7e2f753a0ed3520e829c433d93e9362ace98ec355956ddefc4d5efe1189a2c973d7bade1cb95c60d1673ed30c23fd7b9df945be5778226aa5c7bfd6055558e1de0dd383900c0e9071e18229e53f812a87f61681cff8b7487e2571cd3ae01726625978a2b6efb9be867409d74cbe1929458380b8a074f2648e35c2232021599e11e5280578239b7f791c77441f1e357790878c25c4f6b4fd3acd0ac31fd3e96aa9eda06c424397f01571afa514c9c8d03677a3962d59265282a6de73cdc4b3cdd129e31b6f5926fe7d36c1902939df3515ada4825c604bd2c6826f2a094abe223e17acbd4afb07bf4998531ede0cf3e6417d6d46a8bde62a0a7fd175f26dcc3d7105f3b1dccfdac37cb85f6013f781b3781dbeb617e9bfbe13c2ee564fd1dc9ec22dc45d4286dbcf8888355ca231a58d2130bfddfcdbf16c1cf56ad6355bda94b8552df45759653e24d62863b67e520ace7295c8f6efdc4638ca968bc37670a11b95b5d71001a5f05b5f02fe5e022a1e0005a74d2c45c0a684f1eba54fe1193741ddec47123bba60968e967c37b74bd06093134bf5b0eab09a04c8d8eb57e8daa75ec9061858bc70166da9005711aad4be6f1230119ae9910e063361180c213e0c5435b73af31e3c528ea2db266bcdb21f8bd314fce8f732d3ddef2b0e2d19866bad961cbd374e5a66bf163c003ef636544beb00899d2908ecf086d6a604bb24c6a95c5c211255e4886557594eead838c706b36048968673dedd708b42b02ffd09e61b1deeb4620839293aab3be24c37a8243f85bd0625e1bf42d7efd25a6bf3da4a9201358a08a1f2fe5a9b018cf14e537f86f18d4fc35344f74012bd94f844e559651c20a1a23e054ec698f688d1aa8698f2211bd33b6fb37bbc17d8484d2e3061de1c54c0ee13ae8074dead4c994f043604f09a623fa478e91d84de56c4f4a6c3ed141fc384a87714960787af036cbef467fafdc761249a57efb984accd98578c1ccf8922e031c7ffefc1faad190cca5be8fddc0c2b03e104555c68be83fe2f3368711d5ab757e9bf8c347ec98dec5b586081e1b5df009e78e55b113fdbf8cb53ca5a81ad19341345075f5026f1696381f8cc80af5a1c882d4be776c8a7146f87a31a9e8f69ee7f1dff34193e7d324aff90f2fda0bcd05c64e58f982113606dd9717bdc2ee1771549209a10baa0228ee4adf7e13d06c3f8e0655f17e675c37aa645f88c55d05c5ded2589297e7e77ba1f1b9f11f86d5e7ef495911403a7699e7d5eb439b4b0d06faa91f6e86ec1e9ae2803fa6be9cafe6f4e0386df8a5486c1fdf23f3157a6a28b5baa719f540ad8f93a4b471700a72bacbb2a7d0c6dae203970724e195068b89f0254ed473b8f49b5b58a2783fabc868c90a15191a8dc3bd5b5792b40c97b4a4288ebe1a38ebf4b67c052f16dd46cc4e814800085d5480e4855d0b7350990bbce3dd908cdd3ef7eda5464f681f5f6c7195199bb63d93a47f92f523c43ff249b3141ed9d5a1c0d6fe6e78c1af82d9fb1261ec76557fc2ca271558b04150634b3dff1f21fffaa76c5ae26c5ef06a08731cddc2d67da05234ce4bdc1ba434ecd4ac950818fdf1891cbbc2ceb4ca81aa0a0ca07d00934d28179cfca6739274012344b7226d9499c2a49df045461955e52aab61cc532eed86ec0f578ff46dbaa506c3c9655a3a97ad5eb7e8fdb19bcd5fba0256f31aa3c16cc3e8649b836d1b5f1e4923fb62addba8a3211ad0160ef3f132f24fb8faec63d5d9a5519a6bd09b82ea0272a877c514e5b05d6994e72cb78132066fa0dc8016940618602db725e3282df94178a4cb3bbaaf8874019ac3c442b2de6e139165136c5d0f0bc62c63fb1920ef5c2f2490c0170bd4a09223adc1dfa5bc97cf967a2b07694aafaa1ff72045d88bdf2308015abc20da1e5dd96b50a74dff9e057b584647baa86307faa21c61c26e7af0f0422e7a2573e04ad079614e67d0585dcf3bea96ab351100080fe4eda52c4ea8d8cf1e1d00eff94df11af0d6673f046c0c5db01849e761335b74daef30454d3a632f391aad295aef2360d17124639e15e868b4a5efce858b22e8d5912f5eca4857b8466297726ad59876e9a2e02ee85b43f056d61fcaae85e41ee3bdfb60856cc9231a2c843f38d77d3cf74dbfb56b1894497c46b9d7d1cc722f780d1ab4b07333a84df1cd838968aae71655f379fd56138537cf44ea65f38999e627d830cf13e823724c6bff77770d493ffc7bf6076ac7a6ed0927ba5d2dc655c74e68ae9b13abf4de9069a7be7984c8f09b92b32232b8328396776e7082e1935cfaef9584fe0ff51d03b876148a675cf9d2abee0c717d122dec64ccbcdfe3cd66f73e4ea62a25980514bf1bc11f925e65d6b8685f2c8b13f6e22f67fd2f415d02c25de4add449583e5e57fa9837854d805c1737dedca56e394b04ecd905b0356c5b579cf801c92d1f339660a867665a53a0e25f445a37589a30c0b2e05829c65a5ae174acf0da68ab9156c40f746033de5c965e89be3f86749d99d20203d5a3624c2bc951d43d829c45af0bced456067471ff7388c60b79ec5fd94617d146deb49980cb9f434a525fc647c08cd30541d4f89f17403a93d7a960e7b0adbb8f624808d0b977b9b1bd08a0c4961453b403af3d1947e6f7efeadfb424de1ead82c7bcbc209f821f6d86049470a2ea13736fa8aec257e5dcc2d4ec9f6e7676dc3d46ecb8774c5dedc48957febd6b5f4e11a417ace8a6cf9237bafc40a4d4d720ff9479952e8a90919d8de4006eb1df1bdb4840a72571ce63e01f34a37e1839be402740ea207dc814179c4307ed4f1765d2a21116fdc06c5b259a0e796d7e47008658f00c930029a4e124b688d619db30d52daafed8610797c6676184abfdcd34d23a9ad1c9e1ed96d6132fa1efeca8d1af15a5275174549827e2e33e3d969eb34127c58aaf5f6ab8d6818c0acd379ff8f2c24fead40f9b2669ee4069fd4a1c12e74c79e8b870a2d244437112a6cece6ba0bde90a866c5cc0044ec0ff60f8bca614f75fa9c06807d2a076f4830fd4cfac12d64b0fa95ff7b8db42cd0ef61a4957678028a883ebec31093d3e0b19c7e267d26df230d9cef5b493dc29f524f5676ac9cc56858f936e24a67e99b048118db3d93e26e7c3f3da0ee6aa408cc80dc77ba9a7d64d4d6be4921aa7fd5c1907cead378e0e43488966b47d54ff09d732a009d69bde02f6c1d8ba9e579a3fd6a0923a09fddfa8b327d1db3de969ea9bf4d97ce02a750a3ba995fcb72a7a9623c9214f7e33bc1e1566ac5dda90a8835dfb84c920fd7b3ae63d9bdc3192d1f21db966c4b615d5f42488cdc0ce39622348774e5ec2ec3eafc63f229660da90fea9b811cdcd610901eb7f95c101b19d239f7c578b2d8b4d272828bc9bc7e427891ab0d1d5ed1c816ad5a5374fec55d528134dba3b0b155c3d722eb6a73b74832c96ef06fc8fb6a6041ddcac23370d147f07e38263fd5a550f453274715ece28fe6f2d35edef9f951c723b233703435b9c09721112e9643ddda266fd79a287158822933168c951dd0df3eb9cb6407adf585fafc43acc52d9fbd0f7327a42efa8b110ddbb69832927557c7368b38b6efe9df0db2e1e3e229bc229e8eafaf58357dd62122600d04d6c93a13222030cca064feedd95ef1e45670438a7a1f37bf77053d6a3320a4136b213f5fd7d68b94925f4604353a70d652308a479cddf330318e896bb1dbca938cff68e0f2678f7dd54ff6a4308cb312e64add0e27315b9e99ebb29a3025eba0960505904eca5eb8cd708b8279f49f0db95baad733ee347c24656cfb9bbca8ea27ac715ef6466793d109b8424e81f61b0a09d47d8c85513c6a900128bf1b2556dfae890d1ea962bddc5be42b7400ab859fc87386057287a3910d23eeefc7a732d11a2af282c87a2be9af126c89b3854c65c9da40afe65023e8518a82478e79b15111b3ab4a1ae298053558e47b04da0847d5dc4f413b7a29213741526693e15e9e2e829146650dd0307c20088eea39a8c2399a515959768e1d77598be2101e660ebcdbf98033bf2b68d64119d8fa4e174c0841ec4595ade50452a67992d56110b0d4d5319e9de073a114ea5ed4463e9fa225c1bfcd438feb7d943beca1ca55305226f63c47008e72b643cb78a5add5e975452cfecd014eeb314a4c3205a961479aed64afd1cf8e8a7c79e3aa97f397b1a28307aee3585c80ef0b8637c550cffeacce8a5fb3a9dd60c8a46fd03847d70338601348d6f4fc24bc09fe683dee873a812f9dcb4726d1f7f73e054fa4d04261f5d44b1b1fc71763aade8f0f4c3f08a3b3574fe156d9e3e3562b0eb5de9b4f34fc77c815b459eb4460bc04eb64ebe7eba34e9cde4f17faa380b1cdac909a46db05a390941d56576f16ba64452fffd01d0c46b3e62510048d8b02b264df4d30616d52444f473bc016d1cc4711f9fc4b49c37f337b9d2950c4984f695695e36ff0726e699c1765f3ec56ed4a8ab7e74a5ee4fc4fa6be4c5b43ab482aa5e2c340ee4eaaf64952f56dd59af993d6cfce882402a41c90fefee73cdcef054a5e86d59183649bc1e8b62e216e69bf5c07dd63c14dd6873d58a1939398fd66500df41f644d33a05eb227f7ab4dae5b944cc857d5974d06f77af356a117a77b4986b40605f8c5c29c1794ee792f2bd26c22aff3282a7dad594ee2a012afb1e6fc98028368cee22e009dbcfc1589865d35b2a7a9ad18d387d6a740131960e4dda20300bab9ca62d32e449996ce18ec31e34e925fd2202e5cfe65efd6ae7ccf100397cda3b6ae49d0f96333d960df6c50006dedc789292aad247c399eabe804d191f8dc29b169da5e5c61da36d768a21a522a7a12ee855fd086c06d5e91870d2a05adceb06cb82eeb157f78f46506ad50e09bde6cb42c21bffde5445df97e287bfd8c83da5cf71834c270cf16d8e67af2371f5e762a93ce3ab239c3fb6ab79c29956067af90e5db266baa9fb1f7c3b8747b7ff3721f0253b95ec736bc356fec4a8542409dfffbffcabe4df53f1bf0939a5da44ab0ca20664580e251f979179c3751f5b9d1ee190174837f247583d05ee4559459db8da0dae2a90028f2af5db98c99fa889ee51bfe4ae045b340218028286631db5f4f8bcde6233c392a7e67e89ee72096bc4435607c65d1b951d421942dbfb4c71d815aeef786aca88088628d47fd0fbf586dd6dc2e86fc41e73e9e1501261d1e8c548cc0e97b89735faae5fd967cf2026d3974c2f6f63993aba6e726b2e14ffd019e26705f2f1a5421b9ae9eefaeb46330a8686b4af3be306e087c537bd6736ffab9185b0c06218dbf6276ab7c2503f1a9de6b892c1a4e2db96e8c31bda04ca9ba36de1d83462fd17d02db40acd0168c4516c8be8d144708cd59fe8e2eb4d6b62471ac0f8870e8c28bb37544740a7cf0ef556eb79c87e6579d1ddf63d960eb988f1a88db89630c08f5da4211903a8d8fddca6c54ba896e32f06aac041de8a1e2712406edee61e6674afcad1d2078d61050b5edaf39058e20dae0be2cbfc8214b5dc75df1970bf6f44a93498ca441810238f5a2d479fc767d198d191765340979825acb79b2481f1b89bcc96231a9dc3cc3a3f34074a342c6781ed4282f466b54b71ddf1ac29ba63e11178568b48c3a555c649b2b940fa868e75b8de489a249cdbec2d24367072fdb06f47a64cfb1cfe39736e200723a71c6c440854cb677d5c94a291ed009ea93ac96ee56e173ed6ade4233ef8a0d60c1c918e3af69e161fa9d5f7e493e517b8e2ee6369fcab0255aee556cb43da982e45a560eae9c3c44b284cd2cc1d9288b20f5c55c57312a7c5760650a34d5fbb1495f22a3c91f25df58fcb1dc9e7b858ed0aeb1658ab7f2cb973fc6860159dbe214e572a5dc0639f32540673f05dce0dfc7392d2e23cda3ec071bd8bc38e2d00563c5fedbfab561abfd66a9feb79e69f0f656286b4f9bc6bf0162f3e2fc21ee910df907321c9821ecb2f6e6169d9a1e5f197de1ca9f961c00cf02a464ce0440ab66be8ff90abebb6287d15356ee57c3420e836b552e0be4b30562557b61a61a3b6a40d7ac4f1c8dd9b6f11c17b3d619b33e473b373c9f92a471a8016e845a2568a4b7e13a695116f7c07bb8e4b1189989d7a19ec3093334a3cc6d6369dc34530651137a871ead3b9ee9932aa44944e3b7425d5ffee114d88999727a8f93639a829d9cba351854f4fa75838b61b750c8dba409f1b7c398733cc6b5df92b85423bfd82c64b3cc0fc627ba6f12f4cbaaeddddc76ba95110de8d7daaea9fad7cecfde4f459ab0b4e48fa8774133ba6b326c16a9b79e3a42751cffd1a2dc93835b62c1887dd792fe40f9e8698aeca59fe8a7490a866053c1f44bd439993a499310a791a017be6fe8704b83009092d4d9f7fa5e91d04a86805b709970efbf1da59988599942859dce39e74676f60d3b283bbec6c18b16aed48acb420f37e324c8d956529668b9aeeb1ef8100943cb8f792e44bbebe0bb51e1d054170543dd7d24dba3659b6097767bc628a7042de4760138e6b604bbe9416b938d6a594f6bf88b407f4c4f6d28919cb09f9526fb5b77895fa4f17e76f958ed6c78e21c0224cc0c8ddc45be2f6e468d2ea5e9d8d8f7e5a9bc3951ac034d8dc552e74d88bc781b7688caf279f841bd01392a8e01b4e37661bdcad5baa2a83289309deabca36662200835ae201051ace815a77c12bf6763ab6d8aede3fc508efb5d72461ac36566aa66aa44aa1ab67933fd5e95f4dd1379e8063814468adf90f5fc66ed95a32ae5d3296b41a348af93a2df278ed78e737b701a64aa0b05f15ade07a5d5bd00cd82c779c56725551f51b4ec4bba6f7ce2112c9226b385b5398925232c955baadf5866d5e604623cbf754e226b70349031d96ac47e97612aaa02c0970eacd1ea89b3ca5452891eac412b9da54816ec0e414df2958c32c64f950ed4b663cc38c1e63a6aff3ed71decb523ee021b61da7290b42ac1cd88aff91fdcbca28677754534c80d83bf7bf63502d706279f3058d80ed72435b0e580e9d3b0d6a944ef668d409d5470e4938bb66e60f67193e708ec734635e94faf7cdc0d049fa43c9edbbd837d7ec883fa860e6f27ab21dce574e44e62ffab3f885556659800ebb1c807a97036e193176eee9b5b700049043cc6e02896366f12f33898366274caef61f2c8fc2b69872a7c48d78abd5c8739afe235388ce0e2db97ba0daec27b0f439fd880d5827706199ab9482c1d511247f004aaccba85090d9ed9c11abeccd14972bd4cbe694f298d048e5ca8f2783ec27fbdb9dcac76f4b0762ef72058d81b2ba62d855a1a20ed851b5adda18e9120a60e64a5a0ab5f7833d2bc09936f39dcad6b6cc710d4105a4a2b1c8e4acad1d0eec237c97f030ff4fc3cdb1f19b9c6976473b1ecae125ddadd1028be706821584cdde5438cfb6fabd76253c1ed1bb4a738bfdf33a0831db0e9afb993f770fe7c0a92173fbc51337a342a931069b985239b70d8e2cdf551e77b468275dabe06e5e1ff39537cd4ab56f06c76553b891a0a0cf06166982b9fc1e91372ad7ee75220ee4264af587018713aec3b440c6bd12cd3b46f04c53d8c8c164714dbc9f8573214d4ea9519bbe5c9e15c2e26b7ed4e24617cffbcf32d41eefa0447496a6ff9200a8bb1939a1e66d2aded95401c95f5bf83d244d5290387b6b3ac5069864eeb5782c502205e8a9cda9b9b499bebfdbc4a398f27e19cd26257ac85124b42e37ed28efe323229ab7c4f1d31edf480b55289b458c4d95e998de2defed86e6dc6cd8c6aacfbeb813c6b6f7206b29d4e6aca695ff2e812f1b7fcc452d1fd253b0a3b2ee88cb47d2861359cdc51b07151f059c260960380a0b46fbf6231b0213b0e0d846970686dced85b68f626f4835c0cc37b93a08e8585d63a382e08ad5cb1ad108ed737456b85be59e6215bf2433960537bc457ef82e33625cad3e8a19d2b49f84ae19f2e1edc814b9b1784425af4e4cffab0b800192bab4735861e4a0c264dc9883ffa556f4b508fdda167d25c80e9d873120fd1f96e7430a196cdf800f8eef56567429a4070524eb19d91e69af48741eff82d1b207be16da6b9e6081c6c8a087fe0fddad588d8e644b7b4bb74dd999b0a7f64f297f8d94de0bb978e7e517c03002234e994731278bb153411bb8d005fe88ddaa638b6bf5d288ccf674447cf70b4cfc51111fbe35a632ab48a2b4c2c8e4c541967aa8bbc2031fffef8a10feeb9b85fd7dd6abdf7916db0cf1f1a9135ecf3cf5563be94c4a1ec1e09a342ea64966405c692935ad893401598b692d0e4cb0eb41d8632f493d2cfe5174a74044997c10512689a5a32857b510466755747704506255e49d3fa42a626a82efb438f549f30caf866e104f7f9275020fef5683cf3396e566bbfbcfcb790ece655ef230fc903b201af40faedd3464790c0488ac708b4dbfa0225411031c28a7196d397fde9bbebadbca2c2c9c903fed603497a6fc74c91ae9fca36c16a5551d622445ed4da9313ce751ed090d88d8ccc64da3e8641145b3b7757de2075b97305f762a8d2c880f9cd2ab47e797122fea520e1a2481383b842bdf5392bf8fb90e85b2af5d3f3eaed35e8b31053ac291dbf94238a9c6d5350c2122cb433615d94774e7090bf66c7290a1fad66ad85027590f315c47243178d580a06927663ee27dca7d1c4672ce7aa83ae66a9177a881a5738c5767e71815eee24dace28d511c0e8baaedd99b497c46ba26cff7789483a9795b2ae13830d6833f0c20f664a443d03fe0dfa126d6608847a65f9fbe67fa9fe47ff298ded6c6dfbe1f0c9bdb549eb05fba98f619915deeed2efed5a7dc489c8544f847f421e307a2f726d9b9aa6549808b6aa5fc27adc9562424ab4688f4f2e111d24d2e32ba95bbd95865181988e5a34d985399d1c012c91377b81e78c9e5ff4e4f5450a7058d1aad7b35ca1b92802579e165d1d620b0fb02665c453a3392f980eec490c0f147515fee100e2da4653445c4a41baa0aed7824e5b3fe6ca281f84bebc0ff59153d700040dbef168c1d7b128de999eb547c77b22a6389d9f0a36c3ca177483292eb2ae2b7df32a6417a2838e1cb8f90e62cf239ce7b26051ee2107d1dce7efa811f87e2e5fabbcef7627f0a0c2ad66a07c1e0281230c24935db67fd9d42bff298229ad431d423782c00d0cfc543884fa48fffa7db5f8d8a2757a296a5a02aa856036a5ed854c6887303fbf9671c8c890aa1ec177fd7a805ec575c27af7c1e94c82c9ef57a99a119ab1ac2a48cf946542f77ba18a567b3c6d020c197919dc89eadcfb89d0b857349a99528d68b2dfdb11359add23c21f0416a5efd60dfdc69f121007fbb418b064ff74f41598fb8890fd792f34b8f8bd34d3f918d895f1340632e53bf43b8d56d483cc09d7c3b0e4d069bb7c4ee46928b189835290b821a012ee28bac8025407f6b229fcc91c100f98229ba7c47fc299e33a0193589d17da2ed48e1159d76304485d726ba171256778cc9d080e1d2cc93f07720a14f896b8b8a1f95767f2bc00e60c69f981d423eab7d1e96ac6fbf696bb6f1af828be7faa714be0fe5dcf8c6e59aec24535394191e12deb24024307d9cbe970d4915ecccffa5e30a919bd5ae2585ca9798ddf6a38daca2a6bc713138ad4e598e6906b08a3e2c90308fd5f28fb8109869977c5d242daa69310cea52968b52bca962b9fd1885549ca9b8a7786a6330566029e9734ab777a22e635c60f061163a2d9ccae51891bd6f6eca0d2ea99fcfad706f384d4dd4783d89f92c26264940fa31bbd24614140b77889166fd13d687913365142067d4bbe4af04a85b0a845bbee331bf877ff60ce4f15c93eefcd95aad95cbaaef629c4861e367c2a29c2fb38248cd6664aca0fd0acaea2a879d403fb4ef91f42f4e028b40e6be3176eaab0fab1a1ebe4470500c52680bcd37e72a00b2c74f3ee8705ec9346efd8d1051b3f55bcdcf462877b3e6ef08f680a66b28ac886764b0182a35cdd6f995a5cd42d4fc5eb1bcda32a6bbcdfd9c14e05fb7a9c44c70654f3db2591ff83064a19823a930f99e2e103dd66ab479e0599b96c5bf64aa7191a3854ac9bb29e78a1ac073878143876b2f3054f952ea6ca4b6debfff45a0349aec3de581c69ed0c7d136b18d2554e38762421ad9b8078c0d45a7657965db6e31ad64d7c96b8bb923bc5e64486ca8be1c0d61ddb899831d77b9f1069e5a73e3953a75be3b0fb9ff97471f60b0d9fda690bb056dad3949b16c4e3060584c62d1c7b2f748ea9625a52fe6d1731403df6973ad7139040cc39c57c982915eb9da87ca747142a968466d77a8c0660320baf845a08333ca664bf417cd74fc1e2f96fb8a26766f4282cf113b971d37e24cf040a93f8624c6a5ec4497a27931db3eac6c56029c5f4e4fbe55b648df49b67913f350464223738bf93b80e69cd06da9386f1d3ea3842a8a81d67bc1d7ee089a6466d02f2908aa1a8a5c3d1a5c81e652f2093dfeec76abfda4e58516f34cfa52f8e5ef60148625d3458c3b58bacbcecc87c4e8d0ebbf450192b73c807ebe33ecb70ab09189eabff85a6e51b0d0e373dce2069b4907d22d836b64e982ba84dbce52e55906f071d0a66c86f06715be12b36b0f79c4439e570814f404d1916f85ffb2cf0de3767fb16ae487bc72d59118c098c711bfaef961788b82e4acf8cf7d8706e175d41348b96c3d8c212ffecc282e5e1e6d8901feb55efd9e05d78c51d5973d646b385e0cbc7b5d198e7ce26a62ad0014cba9a57ac681d9ddf17e7f5a39a4c71c34c8a26e089c1f84e1196dfafcb09fa4a202597ce335b5c344fb6382312761a931d23420f4bc763141c8ab4958dfb5ab98833218d052b5940a93677b08eed2b65c983394582d087a8a0deb6b5a2223096b8ac5abad051b0dcea3058d3ae01bed74d652523168f6299897753f128c5868a374adb5b5a9cc4a788009a3e5b9c4e8cb6519cf909dde6f25fef217e7e83af0c7c799221ad00cc10408af34d25d30f363052406af754ac993a407a7844b7dcac5404407a3a1edbc3aa838b66b78b717124c03113a544921fe7c58d78b11e87ab62ba06fc002580591cc2737d109c535416d8b7eb63d29288e67bc4975560faa9a0f37031101cd6ce2384277cb9a5cf282d81685d7f1b3997ad66a285e529523afdc92fe1a6a1291056e41171eb2fdf82339dceb7ada0e7ce0d27a5c98271322c49942881874efb7956da702c5e0ead17c4c2fa845dbf9dcc9680d756074a358c00a809d4f541cf9f838fba006fefa45f0f16478536d9278305ab4b7730246a1e933d6e7c6edcb13436026fd420b67e4f1327463774b8d385ea0bf6e4595b8d91bd55ce9a78750c5e155717612f0bb07be58837b3210fa0c5aabf887e7e20215df3b8b6de1f818e5359adc6287b6dc3ac6515225f6d46a9d00a9ecb7793c9aab0892e0aa103ed3162526375261eecfa8bc81810f2f2dcc010d96f8766d83d9fcd69476f6cdfda598d1666c1718f6d45260b616f96508df03b65df8776635809454840982abd954ce39a2e5d27387bc065856bdcbca58b9fe2325bea053113e5fb24ae7bb5485dc2030cf1c217899cd15fd24608322d391ecc0368b6ee48181a66f283e6ab97ef9a9df08fa6bce99c4458325daf8638d18559d82ac2875a9db49047c7fd62b0dba946476146e628a3369d8c7ba2167d8de880a32430a31b989e76f4a6bbc47de27e7b5a01e351444017cdb4c524dd8fbdb9ee814f3b450f4fdda720f9e79034cf05a294526d83b24e866e32937cab82a30a7ffedfa1d9aabe3f4c6c57f63b8d09cb73dbb73947a4b4ff88aff15f69146afb9ac2245cc27400dbf9ec4bc8e9337fa3d8ed6298cedb7683560a4b18b434bfa1cc8e8b94bbbe15f15a4cfa4614e2a6ccca614e21bc3cbe7e2cbffd213ba6ad604304f7e96cf86c540d98877e70a5bba45babbb0811ba9780cbba162ddf0ede0036b2ac87c69bf0e75c0d34392e644ab551372becc3c4a0c0b6886c0efcf22429a8ddf6ca92c317c79105ed792ded785063aee14464c142d318de1dda046f1ce972b6abdb70ab1b62d32f573a86ad59c2b09e7cf15d69d08df1e0c63eac0f5c01724a6aac26b3599d4f226d99947882f22cfc9f1f630281b7b5deaa87457c05beebf696cc2f8d3eaa869d8375eadccd35727fae1c8e9e099c57ffc8fed51300b674523cd676fa094ab546fac09a070f113cf53cda936bb14eb412522e655121a186363b11db99ddb7f52805d40c5fccc42376ee716724834bc4223b17401380e38c4bbe4be1b92a6f201068a062103cb7ba32a562d309902d8a35bddcdbff03e699bb9c69a95211b6b523fb0302020bfa9ad8ca5e20269ebee892916129e719c7b33b7fbf0d500cbbdde7e79f721e687d6eb3876b7d42045aad15d2e0a4ae12037d2943b4ff2a37d9842a7c9990162675caf95b0ee55c6d5c59c5f06981f1d8ec9df08de56ca4e02b1615ea1b683dd033829656c829f1c90db98f73d47d593d2fdfae4892d546e8d96bb15155adcf2bd57df5d8c0b79669f76d347530eae546868ae740ba9620d05c9c0edbd0c8500c2d82c9effbf1393f34d1d9f44dd26b8ae57fd04fc26484957066892358746a565fb8623bea7a7bfbd329ad350c44c1d4e23de28f2b9443bb6dc4527d9ce3cafa40138d1be74f326e8f9bf81e4ccb9bc43fc277d62b29e23d539e50118a5f89544effced3e4e845769cec118f14e64b9e8311724f87fb14637a2e0799f527a97d5ea789d7e87cd4a2025b6b60f26722ba3837f32b57f3ae56c6491b7d5f1b321790b4b6fde4faa2050789a437e65e0a67cd2b7d73799752f61883716c7428c3133dcae5e8d35b29483d71bedd40b88902dbd2908973c7e72c06619af16f72027017d5eafd6ea97bbf9a13ceb8b4db32b2b4115230d07ff90b168003b17d2d2d9d69e5c748180d2be0574bf1288dc45edc6004f0b91418e44d2da941b03452e97c0e224bbe8d0d2f1837816ab13dfd048bbc4dbd06d60246ffd704ac1755493999a952416da1d93f2193338a79465eae2eac6a7a4eefa6205d8c3322ecc5f3a8c10a398d17f8c784fa128fe8db7f593c2b3e900c7e8772df921c8be13c973814cdb18f7be90fe74707eeba4482f337050e3558162e1e9eecfb93eba40211b8989551130bfe341b5e9f3cce7946314e5e17134d5f120a705d0bc6ea36c5331aedbfec1f5592d29170f2d86b63d970d6d1430ef6c586e0cf81c0a998d4c80fc64b850d783a1d62183503240ec70e5b09ed5697e4862af559f571c87e27f89dee57f9a15d554bab65b90db53fac572c80d6cff160ddd647f25dd0f739bad29878c45e2f9826df60406c39217a9d02ebf56f498a7404eeb0e4a83fec23b16c53e12f2b4097bd724ead30262eae32aab7b3125f42d6943c9181d0b27bca130875ccac00adb857356d3e33bd5a014ab8790a62bc9fa661a313731912cd70870ae75913635bc994f288495b3b058fb25483d5efcc1b2384f4d21b940248db5755a45e15f15a99f6d098251c57a50ba64fe42ba68089a64b8b159c04f988182ae81a60dd98f12a53e08650ac22d28bc9ae6a0c20fcbcf8014f99fc40072925be052d064d5cc77487079a859d046fb460b6bbb79ed489ffe591d50a405127a28470c4d024ab7e508ecac56db4dc6659b0729559872681b8eb11ed62faf09026cb80bc42ab8763e2dcda659453869b7745daa614370c334a35f80115bd982520fab952ff3ea5717a705a3ca15afc3740862349987f2ba9580b42149d95d9e776d987d0ef5764146d07ff589140fa3e102da2e618d179df98fc0c80d8da0a209de25f355df13be0e2db1a71ba5b33a52d3f6b0c8bd18abf0c9d7e267e83e5634055174b840f6694a4b254dc24712662d2ad850f23e7b735937556f56bea0d04babbd29d33b1de1aab452abd71258241b8dd0ba5ea6720c82de6c92c44cbb3ead07ad3b3985eee87b6bb643cf17ff74920eb1dba06f38d862797477687bf46027b743b1d686220c0a909a56bf2e63b6c47973432ca3c9f1cecc7cc338e4d97793f2ab4de93eef20b5061373c1472c5a2159a5f8a675d8ab70e65faf94cd41a8692d10b12bb5503881ee8671df0a4fa9972c3926094a78f4f275046c1818acec81e71d2779d01d854005c35f225f16e1504cf1314f8810db3bc9d56d6af5199d2005ec633c257c69187f8a05a35945f0119c7fd68cd11d5423e2317966779d0265b848f49250089b8a52e9b9b074af3ab21d1bdef478db5d863bca2157a777c657e77b2f3acb443f885e2bcda9faa575084f0fada32db055c88b24947015db3cc2d291b0259640b38f0a83eab00f275c7f7e823f1347521c0735dad38b2c4f6f04019f568efefe1d73e07a31db5ce9e7cfac39de8b77b894fa97d9eb9a01dd8e802d3078849678814228f97233af4d2f1fbc5fe04c63261d4d864bd4ba7ecf35b43a19509670e28f7d49bdcb6146848197f5b0ff56e1626d6324f67e3804df002e049a8d3847f69602cf30c0ddef5ee093c77cc767e377063c852b971f072e455e4a4547b68a3b4f75563de206bbf97819c1a279353bfca70334fb389e66e3372ff9bdc1f92bfc907e57ea40a8ee03cb39c97f3e4d28e754934455cb3715b3bd597632c6728b9ddfcf640aef7554894312005eac709787533489d5b8e1a392ab5835eb31c72e53d37cae19c8af61f0e35deee652f52b97385a09a6c3a25b355d70f6f66e306fa88e0266fa31a377a9ac57f873d53385df77546617c7142b7cea2b8198a88400a2b8e37e7f50b20f80f4e3b714d7b6c1f12f836e397bef6b83b7936695e63ed70117233a9e492dde917efa1a943b874c1fc545a1eea31ac1084398ffbda11f659f484aeff6c20b77b76f7dd71c8a531bf5e3ac1f178a5e722c1b387d5dcfd5d0525aa952bf9577215b5d1c3d0f601099b34f123e8b41060adec5626041d36f557ab349b879ca61d665a65ec6b5c297eed4c917ad7b468ffbbdb9b2a7c7e79bffb7f6e3d40bfe25a1d08df0e848f9a67fbb127df4c8f7c2034aaa3afee0ed423c2b27a0a4328efcf427c3a8491ab92204556d6fbbcf7ef4bcb22cfbb52623346b9a44a347e3e18264b516f1124be46e914c16c1553c92f2754f24cb497283c53989cd942c46df35ad26ca2c5323baadbe96aad2178941e86914ac2fd2a4f56a05dd557a8e5f05f5f95bd8bbdb49a3472c0026aea26f6b21830140a6ee5db0d23c0dd466ea35c744fac08f50157eac9c2e031f52d88c47546dafb33e1d7d1fe243fc5d6a55e4065ee10a043dab904dac5b354bbb9414f7197af19bd71ad95f6c36f7c47af12a25d71e8f3e090cb3aa7de9abaee6bc08f764d492a3537a9da6bc64118495528786467525c739d1110a1b2ab9c655236bfc511c246e0067c9da76cd0532ed2a81355771f7333bea56f4bec40adefc868dd0a7ab8fb55e1cf29ef134f4ef86ccf15fcf2eb563a201887b59a201f61f05eb930768d899b89715af5a597433859121fb29517479ee945ab308cdbab7566a7232f50ab6a8bdc98edde768051926a662ce94476d1ad2b7457ee4339f9b93a1640e6d57f6266fa16cb794ce60cff4e8937000b884ce8590a29e98daa9f51c220ed0cb959ae45a7dfac132e4134b8a6411a1df5c7b0e6ec3b9007354b63869e7af3bd083fbe15583874236b3608a19d36fbf880ed4e1c10f54392e55cbc08817b3664d6852a6d4013a98669707cf52f6c57f12ab3e924ea5c571d0e3073bc69ec11a4efce52135f91bc588430f60406b832ace420fd19603c0f1c41eb0b62ee89cb5c12a5d6805493d64930175a106e53c930a124e5bfa8144603559453a6a74c2f82b981ab443aeef1b9b4ed3a99df13f4c7306783459c9d245b397ab4aaf3c52bb45d10e0e5ebc257aff505122d6cd553c4d6fa6876dd0c37bdf8e70e0acc2c545d9d6394d673bb0ece184bc35dcda207629358a8c3761005b132014969639097d5234fcb20a999fa59714b743174eeddc6b79085962df1cd42f4f4cea7c20bc9bd152db4e84524ea40fe20e1c70519b766ff5161408d4339d945398fc8dea90a13cba9868f050ca0739ecd2a46e9486443b6c93226fbd5db6ab077739e0b195a17744c1b556bd360d9f02804bd3e0d8789c93afd8c8ffbe8c68dfcda2e7e68824296dabe094dce35a4381e7bf6f454e551b73bd40dca7875dbcb27c94fdf6312970fd5948c05a35a89648bdef96d52dc88426231771539feeaf28b5031134956a9b3c63255bc6c2ca53aaaed0b8594497c61c729931d7b6caa82723dd8c13364c3b0a68a19b5f9ec069918f1e93582378dca9d13218a5cad6640b503c7a8b84404b53541e93d8178a7ab6b8d2eab5cb66659d2f7cc135330a7ccd842597510906bce93575d276f2684d24fcc82e0e6292d36776dc1a4ce09626ea722580376c4b8ccf7a41cc6199f23c24e09520523d7f0789f86a9ed39fe1b3ef6729f3545d8b997bba5a85cb9ff69c968ef0ef892898322f3fb2dc0909fb4a1642fa4e5e2d624196e0d0bbbb923c26f66ef6df7306b221ecef85b2b1c4c9cd386dd8fd5712c193ff7e5ae9e433afa0d95a430a065a78fc1a4557d3f1f8acbae4b0a35a86c3e17de107178032f510955db77a5f854b7bfcca093f3e320aba535aec79b42e3df70936ba53053980e6342181370296e13eb7222bf0621f219e415a15ea34c471f15556b7af6816bfdd158bc6b1b21188bb00c574778f3ec59ba202f6b7a0875d1f0a4531a20d13afd45fde7fc688474dd93f59bb39c18a26476f542d11c1da5a6bb37cc8eff5de8ae22292a5a9db630c243e6f5cb7cde52d93489544344c80479ba1087a42e2e495b05e41cebf8189abe3c4a970ea1b80ce67e3b5937cfa435def8ac6e94292c74af4fb7b88cbb3b033553a69be66054953155cfbbd545ad28fb929b7acc1455a58ada247ee5cec4a7a305700fc14e07c981714c9e3c8a41472c9fb40a41a4ba4eac0596dc94044d47c932eb64eb2728c0029a1046b66c2374d6ebafd234a9d7320443d42e676d4420d3ff8feba7b1c560b2724a7f2854b9e55a74dae891aa688e793c0e77095ecb1385fd21355ba86da046ffa75c4de42cca907b67285236ad29ef5456a3f5d74d3368ac96fa8d8875f363af309ebc5cbe807b15311dd7e7bdd3c515a26980151fcb927435ba6b51144a998b167e5e97559c12f5c69d76ab123293a9a909d7f18203ddda180dec066f68a54ab251c00cb24f634dc3b2314f0405f549777ece8bf1b8d3099e31155cf1443454adcd20f2a4ee4d187ad3e1a1d2bbe2e4e44ab77975531988953856854f36fa4690e7ab8413d4c4690e3247117419c8834ac4003f41e09d3795dcb40a9d8ef3c3515eca682008af070725aa97024941e349c9a74494ab4eaa8ccfb34c5af92ce986f660d59fea975aaae616248648c2d2b6c2541c032523e308b559f77f6ab36679e18f0fdd6925b2baffcc373721c8e9966f9d5f50c2c5f0a8a04bea6b61273b89254bd6b33f7ae6ab8b9973ec6be9f69603c7c8db88d7b19a6d65ac64d41e86b84bb53c3378305e1fd229a2da553602445b38b8a98f89302284ab8b99b4c5c3b4b6309e949a76e4a36965e34afc9ce95f58343550be006b475fc61f185d75a7c30c04bda0ced1fa9bd1c6602ec11e6f4a0289d16f843c4f1c389d2657a8e394b4a4892b1b15320b42c7d7bc09ae6c0e953d18974d58bf6579c536345fbaac8a5504954255281aec859177653cccbb769bcb78002dde54a278a0daefb8a87fc5625ba27edd9e550dfce42f7bd76c7df6280f61ac0c57c249b830e24f8c6f26672e0d4748e6b61e498ae39c6ca137eb9a7081044c6da110915d2329910a64807baec1dad2032be4a90855f78f8bf3310bcb4ad51379408043ddc528e7e909e6ef354475aecdb763d88e052e29fb5df8bf37c44a87c4ef63a779fe496cb1b63679ab049e492679a666372750d172c8145f28f044310349a1996e3a34e9accde57455e467d2732a3461d932c898b0dcd0818b390c43aab61389fef74f87c051734b63ffc28fbb42d2ea58530fcab618e162306199f1a73c37ee26b23cea6808da0ab6bf93edd1825f375c802aee8daa25ad3d13b0efce3d50168eec7ef3dabf6cf3597e1098a836844f0dcf3f5747d2e1399ce2e4d1014e860f218de568ecd04e3ebafb6ef5232b96df83ebad33a3d96677e977d9894489ecca6bd0ebd1ecb60619efae95a5e0bcb62d3a3838d701588d9a3819ddad208cdd764b4dadaa254849b15051b390d85458d50ba220990d1b70cd77adf5f1467cedacca443adf72919b70ddba548e6e47de14399e52655432ea5143ab3a6dac0b9d695310bce3da04e62aedfb5f5d6a5d17381967371649665710f3c8da92bfb72f631844423899af000395e54e77023a7971f44be3ca10b5df2f02c0d94d9688c928359f61c088a44b8d8a294adf82fc2bad49f3ccd10309aec2d9b4bf9e3d9733ec9bb2cfdefab661c971cb776cad400508540bc84d4b3232054b155ebedace9f254f1423916d42274c66392cd8822c5290e4d49189b8a287e4ae637dd4f0efe8074e9d416684df51f3a78c9b2d5c1b627489482546b27843b989bf7aac3c212952b4558810ed3ea29092bf2e549208ec10e9d186ac897c3054cbff456df335153ab20d1a432c178babe0ca5e3248db4793a9303eec89fd899142d9a19dce462dec06bf53388a0a1f1220846aed4c196b91b180f1843908b10f0e1e1dade00ced9e49b9f3d4c5a62745e12c7fd9212ac36e70179a01e942a1fa86e1174e893b1e1bb55a1464eb8910d8923f640299ad50121ec7f8f91a7df3b0459c956da5e6c46cc8ac7ade041cd640286f3e192205fb74c6590135325e5024a35f486c4d38050275bc2333bb8a4dc1eeb87473bd03ca0c54f370305150797b34d3f23d28484fa84208dff9b2a811711d14d6e35ff5e4af0f3c4cf07fd769e965c18280ecd33c4fdb624ff22c2a334428185e3d194fe6c934292392e284d052a6e6f5625e116a494802d97ce1e55334a6d9b298eb46877713a6dcafcc44942c6865b39875b64d339b309be182fbd4de7465637e214e7693e23e0032b6f6da784666bcacd6cf7003491bfec9f27aae4059590f7b8b3d2f6e0c9932ac188e3f89bf2856b528f221d8bc08f6fce89a106fee73acc90c636c221eb96619eff470103fed96824dc97f95fcdfb95c002ee5a88e2d6d598035505bb1eacdb4062ac30b8ad82b3ff8d63c62c472bf9c978f2aaad70591d1258c806544d107c4c19d20f2576760b215dbfa315606cc1e8d0494799fb763e1c3225498a3f8cfc675d6a7d0454374dafdca3adaa7b1e8b2909789be9fe8ce9beb2d8185de69f19f5b3e42685d2e98e9b9048e61d997d89a500c0d6700a9fc06df1a81c6805e9b2e4686c0a312c1d887f300f49d4711cafbf66cbc9f31a10abc414aee975150067d46dd17e77b60330d1636ea654278a9539e715e8e4249065a9cd5e247f8f9fe80096944d172a14c2f2a6ccf4bbc57ba87cee3554b1f4701abd37561783afb0164bc745d5d65fa31e303e7f0ac3c60a767fdb83014c1e9d3f4a587c4581815120d4f6b23809e63e0ae37a7869638c921ec892351d12c45e06c911fd01cfccb8cb1679b17bc62bf30c3a6cf3c832309966743d74f0637bd29ce3fe372adc598aa0b37025204647bab44b814df20a3df379fc77d6f276261e91696a5f87980252e25d5cb3b0d3584216100cfc76d401827194c4ddd7087a7e1b79c8c0900e70902f5df8d4b587d87ddb9a1feb8750a6d899230c952e654d4f11ac5b7c6b12c12eebaafde1f067b54bbfbd1000165a384e5e0d0adbde84e8c96a43cb993f10afe46d74ae0d23a174e813476b3c3408ed33e679416b557544987b6358d36f3a1eba43c2de97e7b9cf2275abe0c257426b716e28ca0fb021dc0d742575da3942be669ffdf5a94e717cc212d440e4fcfd508e39b037faac2fc67cafb94d1814b360b7350dff2b90ab694e592c1ec4097d53bab35a2401d8937ad144b00867edae45d51d5c8fe0c7a83f6c70ef819e41b1fb459b2705083b22bfd6b4b210437eaecbad5863d5fd5808feeaf27e1cc55cda8974d9360e4726eb4b9b4a21375d4df512cfa37395137d6e531e4e08830ac8be2366ce2e9b28214293eabf9a02a8897d689efc3eec4eb7e503f54e10d2c3d9c33f3b08d60b4e70399f66fa5ec6799cd9b08320a6bbf9f03413eb1231ed72792ff52f815263277d47fda59075ae7c9dd7bfd0f530cad298671a8de5d1973084d3781a7f93fd7db3f454230494506f5b64b3cc79414b6530b5349a294ad3a4875c0259101b516bcadd1689e104c10bca4d39ac8785bc48db4eef24379b26bf37c3a10109585266f18ad7e8da94b4a2bc33e1ac09c6b785ac03876c9d7ab770c61e3e8b183ec4b029302fc98b114ad3af46088b07347a6cbc3bd76928920bcebd9e356c86f77e4d6b843103cab54c5ff3244a3edad05dfba032c407a03ad71cc8fa4449845ea98701f0bf9ab20486dc9f3a0f42ce8d4f6667f29afb0908b53bb0f8e76882ac02b8cdc8ed2fc41c70c60ad30a445c866bce0ac9869d37656674bd8af15679a5ebe55e024f8b152c617c7b910526bf63d1bea61c04d11cad29c5315fa01b90615cfb91cefa0f0562d7ac64a80dd5e843afb5aed3dd39076b283b5326bf604d1d42d3a124ca4fe75e2096d4cd9a6a1cfa32a15e754fda7aaf5ffb786c717d49234dcf9dd09f27d164732d77a94feb5270c438d3727f293421cdbd607ae58591500164a8bd90a7744264314047fc4d275e59dab704918774491ea90774d2a7dc95fd17359819f7abc07a265741cb82e7f31a74523cbcdac3312cbcea87ba45bfe89a2dabf1995ed95879a1629c44e72d93009a0fe3bf8ab73e5dd2fd99b8ad3ce618c86222d0d7baf74681d3e762a3ae12a75808ecaab6829bdc671723c74a1b7ae6dd7295ca26ae51f6ec8687732abfdb2bdf7826b2f590c2af36bc17341326204e3d80957141ab10140f691fdc6d9f86ba2ca85560cf27faaddb4ab9c34df76f61398cec02a9b8f564c33864353e8b90eb8ead1d793889a16892e13a4d43919ed3553e025d359831469ebb30c2fcd490acce30bbd680caa2e89ee15c990d265d9b4da7d28354cf24391a6492697b9be80c23e3aa4e8ebc4fc48e868abf160192cb2ff6fc2e6d1cf558625566e504783531b2e27b5fb390cb827d32dd67c22a06fb4315a35a80bed53f691b2a9a8be7ea9e5ab6cf5dd31b229785926e3e461494d24c501c88799f8f68915a34bf7a9ee4958cd06712eee160284c22745cc3d6d4b61564628f1a49e1acf7fc931be6c4f632145b5f6c53b0f9577ba934e07d367f495cd5e1c67b6d4ed118765748a5cd69f06dd484ebfa96a843737dc08ac10b71d04eb9eaad053d3d58d41c8f3a0f6c6b09f85b41c08794a0dc77ae3521afb98c41fe9c7ff98239a98b1b634fa030650866092ae579286da444e49c6c50dcdafe314ed1394969d24c91af6bfc971ed980af4396397dc087baa57ef8f22f7f7bf46b8cd7f02d24c092756c0b0b035ce8de81108a118388bd8a02f7cb15f8bf17166ba6e973b3028f2a923fd3b484d82a5b3f3ad380320e758622008e8d1a59a83ba32e1cc6ee4e5d6c12d03b453d5a375d6f62005f1bceb7acb3013807c1aeb02b233a2983b6ad6a2330d996e0412d2ec69ec2ee5b5e4ceb23ee0d9e616712da5681bf08e3bb70f1838863cca6ab930392d3fa0718f7a310e8abef2c44f9f2aa2d2c74ac74fd14bc7225bc039fcaed54f3dc555aab39eccf39dfc53f10f91a99d354d013bca0c6c3a1f56ee69e891070761bf7940f9216dc738b3d573befc7ba1fdf79407ce9d95d67fa02789541773540a5b3e065b1fad633f3aab70f09cdaf46c27cdb0ec2f9dea84b39552e5703464a4616ecf4927dad7bc5b8bd1b0b65dfb244ad5ec020bd6bb0e1be0d7f616e04293d09a9bb21a453e844cb465289513d7d82ea4cd21a0935bcdd5c5b8c2f1e3142ca631f4a12c5a0624ccd2f3cf1b852d0098b93d17bf52368ce1e0fa61ea5871add67c2e34425273264259657e34eacd98037524b23a9cb7ee012a84754edcf17f8acb7a846b18f33ab36ce2b40e580fe38e38b9b2707dfea81bae78aa30b0f48aa4677a4e126e3732f10df354d2c9cb495b94c6ac215a5b45e9b0fcab9992df828d92ca1acb3bfac21e224b497165b3a2b6063aa8038a71201da28fdd5dfc038eadeaad1d2cb04567acaaedc87e79eba413324bb6a5c60827dcd24e1c642087ee2a6eff044f3ee412b9261ee7a548f1a5512d7bb3cef5e8ea85cba1f9aab24209b3ce64576d845d45611ddca974a983bccf9403ce5bcc0ffcd4e639e9d5c2ac0724351efb99d84d1c99d1ac6e1e210d46566ec376288702ee1ac3c1aa37e8eb66628fbf45217a5523c0326fe4cfc6ea6fb9b465eeb809752888f6101c354a3dd33832bfdb0f24ba815ad5941a1223f066d66fb3c9ed752b0896b096a4de142046a03c092abe4c01e4cacaf72f130d7cabb1f0570ae2963603af6dc54d2c8e2243a68570e09a58e4b5751319240c568fe9a8316a2e8a83cf77bd589099bed6720e14502ef2e595124785e1245fdbcba2eace5e1834d5af4986b880440048d859fc6d328ab4044b200933ae60dc65f6b84ac1ba126c7429d1e52b987a3da944c6b5220250562055b3e29ca7a5e8ab49bf5cc2f8c9985c8872ffe33697c37169bd3dd176e89f68b428aa50a4a948d0482e948fb8cb5ddf4118b513d492444c9a1b4bc8de8091605106112a7c614cd6ec87d858fc8e8b2145b3a82acbad98b23160d1bb401ba3b1e5de961ad297e369426d05bb47a5700ff609dc8adb268cb6fb8f64ac527e81d1e30bfc24ca9f34c3e8d536e02043d7892c9b9a5cb9f47fcb5735befff72e67b8e5a4343b116225c97ba05932487a5408d6fa5066e12bbce7e9a7d6e511ec050ec338f7b786111bc5cce52f7b7498ff0f0dc72ebfc5896b7e87c483688132d8f2eb0589789cc1e5a553e90bd97d7ef06452db2b178d3fa93430e965e61cbe30922de3ac4f3f8fcf262145bcb801f6c60fbcc3344fcde5ef94d3f14d645d92798043f4f1378af97dd01a6d444db910d6f3b38f33e226f0f6bea76491ba9fbf362db87f4386dcc99d85ddd7e9bc9951bb50cc9d037030cde0ef39edf74de2cbd29646868c8567981dda24ecf078ef5404d367d04bf9dd1ef719cf43ff5c31a30896da0fa0c8aeeeb12829a19b17de71b649bbd4812c6deeffc0bc3ebb93f79907b9dd2eea85ea3fab38cfa7755a480c259a3b3143348f5a28221a2879d913d7bb0ce67da9a738959a9f8c61348d73aa79978748fb2cd3590609f134d9a8d47dd5f886c39d710c3b10e18f2eec85ef2e78a241f629c0db67a1d0a7debf5f0642d5bcbe1c1cdef7c2eef0f0b40a410c3813685369f283cb68898abe4761632c9cf0bec0bd4f8d8dc8c044aa4a7388c18382a07e63444c43f3e8edccad53996bd4823a35be943110731cc55bf80ad2092666d7b0a6955ee21d6e416663eefb3ad63f6db058a1961596bf1eb13d99b8caea8bc35740fb7fe347b91ecd589794f66651977de1b2ba88fd08afe41484f3cc600088618919fea61cae33fbe10657021c7026d517958129c9fe03d7a90016c808264f1790bcdfe3e7fa0e3c108d0e1eec199a2d7b2d4d82b11a367264a2c3ad5cc655e766834e3238e0d1ee1d8e0d5fe3b820ccb257ac6ce098b979e738f70ba9fad059ce362a4172d9e3cabf54563f5d3f7ff8dadd231c2a5fd6a143fe3ce41ffe4bdce1514192097199e2e1724d7d00d3a81c951cc779515067481acc5b1af41c54680037b6274991fff9d708a2be12af262f57a05cb0e6e3e94b137aaaebe7293ed5f303d27321ae9c06006e3e3fdb33dabea40dd4ef6c8e08d2523b94b28a64a9cc243f1ccb61bbaf97cf4fe7fbc1c695928a91b5ba0c0a3ec3abd98023fe85335c2c0ed479e0c46566c2f8735549810121458e1c027ad29e5dc8fc69f133869ccb5f789a40947b504941dccb0cfc272564f1f287e94679f5b8c9e766446c0302e47a0de6b6da85a1eefa7332bfa5fb23a4dafcaf4a738dad8dc04d25de43c1e93dd6cc9bc25dbda0ab3dbe868c5671633701dab9702df2231a7290b5e70c1b1b2b0adced0250221636f460d3092fb8e3342519e2fb80a2d50a651bcc17e76331252a64294e36df72716d122bfd6eb223cef18515b098f0ab1bde1485dfcc26b601db9a6788b2b39fce9e6e194b9b3beaebf4292a58deef73185abaa482131712abfecfcfa99f531a61992dbeae5d8f9f84f34aac676bb79827561547cbee6852b138ecd3996758644029286572cf8c1510c81babd8ec5db17c3ba172af57db42a8d99c38140fc1c055e57cce492ab58f163bbd2142ad77394b5a670ddd50f158a0a52ddf55a185f285625f4f2ba44e66d38fa9086eb930e1f4e559267c09281a0753c3029e02feb5431451da5a1dd0b5c7261208b0062f3db6cc8534a8441be4077fe6c8ef1e0d7035b2635c14e9b0cf6a22bd43e2fcaed0175f6d7b124ec79f725c58a188ab0756c5e92a04b42203c9b260a0ef98b86f88f447fc5a15528a6055f2f8267b5069fca82453d4010112f4596b54a0cddd5b9a72477ece3f734e3d1d09a41f6909323ddb9a2580abd0d10a2c5785f876113f98f3db34f14d47823e6a3147dc1f4505bedcf7d70a8fd4d00012f5d88159efee904b5827851406f71a94ead2d6bbc750935571cb01bafc9f2048a095e2b23b837c1b2b6dcbf72dc073b8bf0ba52a64737521915574d6c8a07fc97822bc873d27942a6bba5306943dc176b84784fc723418d1666cd4416c366efee17d4423a0fec25659808aa12dcfc0cc48485ab9ae29c9f4fd5e45a5b87dbb62a18898e17ae12fd48b26ec833c9b6c96e5256a7defca45c5a481d5d5d17d769883f433c71839d52f014cda3c052afb60d2d09e6e8be15163eb06a4b27d82cea0f2a6edd303d0d0389a7264011c8fb068b1329a16517ee94d64ec96e1c484bf4ff5ee2a848674f416c2d9b5646be4c1a5128f90ac1a749d773a9eb5d3a18d1ece678e8e7afc655886cdc34b15ec973860be54af3603226a4ccc4193aedd6700ee9345079f33d4df1fa810e8603685334ee63207007d62456b559847a943bdefd9d3b371d2fe5bb5dc0c09315b48924a730ad78e1000bd32c78fa200cd03d0c9c1975607829fcc4ffa4f13c22727d2479793065a36b9ad32bb0a6a8696d5f9478fd4b3451f376c38ac70211a3d998855512522314e270ac44d5cb932ac4e953d5f2786a23dd5664aa0d9fd543eef1ee3f1747b3babd4d3f2a549a3637e4b92495142827148e36bed43fa8055604a9069cf19f510a1379f41a73212d016d419acbfb06f4444b0b5833b80d4fb8bcc707339e0e51f0c48f0ed4f7b7ae8fd25c3f7bcd2d8381ec212925a908f93899fec2991b0f1517433064282e041184586b025a9240fad4fcc0f7bc0c5614e478e89242b670f74ac044c497e1d3b0a2a1e52dd3c6a439f7026dbd2d3265dae04a62c6647ef972a094da71528afada4e51be23d7dc65f1dfd74fd60affde80d83dc290d6e52eb635df7beb76a806c1fd1a9606e62dda8d267a8513c2cad08b5f7a88d1b526aef2439a949a02c6034c4af81890dbec9c34a13e868093b03465a147539fcdd3c225ae4ba5ca1a8b4258331e6513ddea4b62f185e098b2abd6cc1ec1399ed528698e282814e5d52d0f85b021ab90dae6ea0d0cc15e78343d4414334dc4bd7422806998bcc8faa9d1c3fb09560f1bd6973638c9254329f7fa94a5b39a5cbf246aa0029f32cfcfe81b8ec533af343a33cdcec8cdeed714088d7e1e38b586ec258d8f51d7054de984e735dcd7ba6ed70aa3943646e95472756a389cc633a3b3b8bab7f633bb6e11b0fdb83f50e0a78961f7ca362e07272ad90f9125d2d50d02895016257a017e437360f13a66e9e0bce558a4f8498ad8ad73805a4cecdfc3cbaad85de2950c2d24f551b4ce16ec59dea284bd9fe26646cbb09151d212d0317c4969eca846bec04d49b639ced24d2d4e636f70a074f5c8e8876ef8d4135e7547993c49c899d62dc1e30b2584e86362eab85a1219d557640401362b3716dc019a8f8fdde25db6b3bdea1a38863c108f5e56d99e0a2ab680a38fc834bd648741b02300b11ba9a17fb3fd7cdce9cb9ab23d72c1fce156b8a0fd0b4249cf289976b02601dfece36431df26324a0581fd5fa95d3de7ab35d9de751a8dce9dfc82611d5ea6f3cef57f2c44581d4ed1d8d1764f732494611c2000c3f678fab75eb2009a1100f34db9e2c86f9956deba2906e076480487f93034f1fb7b8879224cecac1ed86a976180bae3d4e40e49ff7cb2a77f2d4259eb2ddddb4a93ed964e03f109fbcf194df6c434e5b238fb3d6083b69ffbcdb214e36fa0e51905cca92f1fda64a38bfb77d7baf101f4692204c9ebc6a39f92e38fd3228b2c9677f3b98eadae779d1fd746e511badcf294e5aec1571f2caa0a82b621bd06c939c33b70829250581de6f230545ace510d982c58148f0ed932b3746022bc9b25bea3c9683749d08aca4e6f84c0125a900e2b666ce0db5454f033a6a6b755382e3cea98d74bb7713d64ff3bdc7875400d1853371997682afbc4c93adf84bf4c61979d64d0c5cfc30b71dfdc3970c677f61d59ed4e634e6d8749969e66145757fa360cba10575b09a5b499255865896de5ca3f60363479beb5e0b59825b395c0a41b53224acad065d273df1b962b4e51b6471a2d8ff84ded2a21dc1d5f68f2719e1ec427d8b197065b0df8a90b28fde93becc6bb5f4656e71ea0e2e50709b468c2fb361ca7e4ddb945f81a7b6c2a2d8f19c0faeebda32e8cc2beae513077e34bd56b9557b4b57de53f23d0ce742ca7500d95b0fb2ae47e5286c4afcde1a92e64ccc35d74d2d92cee95528044119e9427cb4d662a6fa707104a9c18177470e6ad80290073309359d69ce1ea1a228c41297c73ae9e481172e84c020ddd64386b5bf2aca308c0fb3945e977b3e9e8eb980d93f897ed1afcd583d108b63e4eb71aed9637c5118f2c9295934d2ca07c8c43383d59faaa1708c219fe08a8170c1f53246508954e828fac0ab3b2802c1467f425e96fd2a3a2ffa13b7e52a2fb0f2693ba343d3ee5fe3eee972d76f9a9e7dc4c3b5f287b5c44fb6e7f30e1312f0f377a2e43bab560bc61d32bb8ac8aaafaf33e592b33f7a0bfbe508262d51e3e14e1a601d96a1b092feeafe4aae6b32faccb3c867f20a74ff555b7353b8584061a69d82f46644c30e2d39386f1df0334527ba42a4d4acb86ac6acbf7cecea9cc4c0c4b16de43ee8d92ca99c307cbe6b307121ec798e377928f90aed6914f8873bf1a6640621ef6d6829622427bcc02ca6585785b7d32661578ec905b462978e1aea4bf6c723e7628094d5d5e6a05ea5e34d880a9ea27ccb14f45021bc78ea5c991831214e16e11149c855571534a48116c0daf42603adafb49fe42b7079e53ad6bcee2778ec0de225b8e119b34c202ffaf9f6884d00255afd6066d07aa32a7d75b646c8a4af64330b35d7ffb3412526711e55da5a28db86150d11ea57af98ce61e62be2d4d012c4dd55d31271ea7c1d9f5f64c19bac470796e3af24126a59faa378ac5aa5b3db338fcdc08a5bb30aa504c9f40a4fd60bb822f5c78610f6d42595c7b785dfa4ba13d7711bf1722eac0e8c4519b1ec329e2551eed518d1bfa881fa1c8be8bc945e6556569daa72d612c60f72312c3da792e896084f0e8627fe33dd111f25e41f2e894570cfce4f53cb237b0bd25102dafca409ca5747da7aeeaea8e8d410a220c98cf73435c989e0502058983d496d17788fbdf37c17639cebd4cecc6d11e4f154048a2a6487ce1338e22f28fff9662fc6de357e866d45132bf5f5e414b8ff74f89d2b7a1435fbf11794593f4b22df3c976b70ed2dcfef936069c581108c57a7e9384b4ee05aaec6fb26a49ee947122444bbb8fe20f7e903f9afc1f708814718aeaa1fa52d40234e0885513bd1cb92fed51a52dfdcd0ace589bf275932aab2163f476897bc23d7b620c73bc99e37ff85712cf5c0b2a0e05813ba03d08b3adcf2a44ec6c20694fcba6158eb4085ba3a806c7639820d26de2edeba18c44b7ef13ab5bd1b3a05add1d37cd8d85b4223e26f647f79f647998f5f038cf1b6331ac3f151679626039f1cfe9b11dea6971bbd45d8697e7375e2dbd87b5fd359090eb445698ec3dc4d7336624aedc17e9e7091a50b8d694a602447c2955dc2c692f0f50a312b56f1a42269862469979cddc75dfaba263f0f28e723f104b1b4871711a8c2a353484bb259b8941c0da81cbc17e731afad1d8d65c6a1acba7d033a1e636aeb72c1bf7d4412d764e98666a84254836e65fff7c50568bf87403340b360ff05ef94b210749d82ae280eeeb7da0ac6c7aa9afb0a8037d446415b890014c38ecd1134ae31f8c7c3ce029739420afdba0d82c2d0896e54a98aec3d46b136cb4bbccf5c6173ad63e54696090d998de0387fb15277e7a7ce06bc8ee6876f9b89246f698e2a5e8f24d1dd9abe0a853a6655a92f9c5423a34e2e4a238f792bf6aec94ce60d1304a20142a647a14be3707e53173194c309d7920ad73863f0a6ae8be6890e5337398c12e69c0c12bcfc9f89b478c0a1b9b6bbae595f2e62b595df1ed38b9410e98418ef2924dc3dd1a72c7e822733bd5fba6c86b5dc9205cb1a7f54c21dfd0587fb618b7ed6a23d4aa0295df168cb26b56a0602e5aa473e2ab69db3920d2a8030cf1c398a19222b65d7665472d041a55875ee65987df555ca1beba9a293454024174877d3358fe6ed444a7ec8e480f063645843daeedae2f4482c57aa78b61310b8a6e8c36c3ce709438128a456059f329a00ba6d48f0cabcd771cab7ff94e560099ea183f1395ce0cc6124792e8871bffeded1403fb3d1f886d97046a2c07b5dae2e134bb8cd0f35f901b5ef42592d902c35f44885d5b57619796719718d91b2c0dadaa6152df0b28c1fea88bb3947f9222586d5ea0b24699aaf6af419bbe6a59d1202fe5ebf5ddc5b8fc3a4882bdbd6e573fbeaaf11c3a26af4de2df61f34d711600b53537c38039bd2b411a4802259245a836660d3a640fb94bb1c6beb792b786deec08d3007a8329348d18a6a99c9f7009d109e96df5c94528b2fa8bc3cec6f2cfe98c75f198abd7aad60d747c21f151a456bc962a70dcf54314c97a48110caba0215aa8f4932415c31d69fdf995e94b9ec1d9b35e8616fac2920acb30becaf238d3b8043afaf0558fcb8bc67e6e7507a6d6fe7a453ea7e0e6b8c56f82d16d7a66bc1de510f0d7c58434f757586b9890224c0ea0899bffb89668aed7d9622bd59e0868f1b68a17238c82b5cb847be7371d72f38f61aa9d71f9a701c11be633b573b57b81771691692096830d3aefbadbd50dea5c855c14c393538ee0d410c515432a63c713d41f3d3df384e077f379b77f5e1a7a2022b74aadbc60ea94a1edca9fc9b9cee226ce760c82ab9edbb0dcb2a7ba4be5ceb9a150ac642a385b3e97538a73ba915ec424aafc604578b15a2af37c676675749ca8d46d6e2fae47d085bbd50ae017b4c1ace9072b3c8a4b73f66e5d97ba2dbcb6343aa981c65bd855519f6e4b55f3960ac65dc0f7d3f52f62079494ae52e78e68b95cfa857cd99a09b5c58ffa02f1e7f173adc651b021e01361b7c8acb1e40ce7b0781f4e772d4ad83518a9cba23efc43e4e46e6a8b65287c4911eb3ea8198c6862547cb5fc4fb4b60cc985644e3b929cdc892e850091281ef6e22b1faf75d4ff41f37fcaba3e9631549efe1b712cb042595e3d55ffd17a91a224452b65116e21c105e54ad0593b9757f129e138ead0c308d13ae6392daf8827c4aa0ca5d2d154c6893d8185d24bc2e9e276cf782df4082250c16e43dbe193b67e9a416b562a315de06093bc66fdd6c44246f260bed59fa8d427414820a56ffda379e2d1394d4019ff1358f79bd1ee6ce78fac14c4964bfb9def2afc8892d3ce9d57262f704ec62d5ea603200282fa01f6e1529a024d2476190f8344a3144e6c751efba9e0275a7cb5380f7e1022f2298762c833123f4509c6b70acb951369d5f217eaba4656e1647ce0213eaecbd0f316fe6ebe0d66eb43a1e96c9f19ad010ed95f9da8831497666136d613f623e136b419951456e58d1a0f844714ddf92cb66bfbe98236f03b853f4fc7caccc4daa93ad5070cf678e0f1ed3582b4287a8e93b01f5732dc55dfa8bb1f3093ee42043942928ea4f6883a792887dccdf306b412fed39e41a46c519fffb174824c0fefcc236542af9f7c345df45711db3fef6626eecd0918bf532d2e0c3e2a24aa65abb9c2a32dd96f5dddfc029eea0cf48a278b496f250324c54c0fa6a13a6818296d79ba96ff20c5c88a58f223e17e9d0686e053168246e02ec30718f7f44961dbdaf367de303eda01e82ef4324cc45208249b040e87cef7779e4b7499700003ea64f0d50444a5eddbe7f02d134a0b7fe14ef15f110556cf86cb63694cf785fbac9c5e00b8fb8d82212cfb2ac96a92a91264f020ae57b7dc7f54bb8bf9469c4f2156af53c6bacab9d1bbeff4359c9d23e9e837db94c29665d1384e3bccad1b73349b5e0891280cee67ed4df01394f0a06741ef7a6703cd9b5343cf1b0c34b8f6947ef0e46504ef759ee1e4e79e1eba3a0690862c4b0134ab11844c107f7b8d5df65209d8f1e9e801b655191c1011f95eb453ad1f7fa4b2d3808ba839f8370283206a9be07d1fc46c156ba3f400cee1de5d1acfd9465aa4149b06106a193267c05ed02913f8f1940540c9ea32dbe77638d4302bf30faee1d8144f0a793a98ea4895e8e8207ae6fc0ee9fb18b20a75a31faba763abf131fbcef8b448101fe57aa5fad77de6572b513586dcc3e082355b2bba33000431da0b77c7eaf3d0f785a432234e6dfd454804602394e811c86a67f30116ab6831dd17c2aa0b21c828be9199eb2bf3657b1e977313c235d75f6c0a9cbdf7916cf7e5507f56a8d02ff68e2690973c41158f4c2b2401b10370ebd319e7916a2e97f15e2552970679340b2ec378f294b980b7cd471e1aabc9c6de4b22a03e40635435bdc30ad9bc9d575cf502805e534abaf4f3879c846ea0cbe72da1c781e4f66aeb4a4fdd1095384c2cbe12ba977bdbbc8a7b8f99bb9f6216e979b198b6ccd5815a7b418dfde4898d418f9d052dfee447c00efb5de9075e7da5d9df53ed32ffe36ec7693dffba8c479949c2d044944fcb954c98dc426c1fc508ad419332bb89058f73623f3faae213dc4ce13e667c951afe9ebbb206008175fd997357e591570687fddf70363efd0c3a8dc4c460317e22377bd220867193ad30ddbb9b7417c58fe3b2027596716517c9ca5e810b1b0e25ffe6010339a7b7ec70d4ea415c1a60135dff3bfd243c751adf7979f53cf64185703d926c406ab38fe0dc014e3e5dcd114239eceb69e4655c88fc8b01727310719111cbfd6e363eb3c7e7fcacd9d96260b6b07a60089b1ad715d4bd687385ef300d61e39dbe613835c2af7a566871951d02dc4e3d07abf6879857d880b3b14659646cc5eddba6d8c5e227612f89760773cf74ed43c3c14a092c09be1cd0ef0073b45f1527b93c2cc53607b216bd5ac56a698621dabf1168d6ef4be9c4c3aa49fb4272d46c1f5f0aadc395f64853e1c1ba96e70b1c40d3f17422314a3e6e609b9d70ebaeda9905cb8f26d3915c94ebf7bbaac97396aedbfca6300217a6073829a333c7e12ac82f99e43a36410190bef623a1acc3eb64200942db51bbc7085be067a08ad492410dfa6ae001734dd9139b681603bacd7cad2c8c4cefe7a3d9ab751544e2572cc9ac61581a0bc02aae3a747e589dd1095eee75b9d516e8591764c746fc4abd7cff887eff805f18a9336393172c8168be9a7c82d6dca54103f9b1db28818f79262acc14841795b731e5f3bcba87df3aa0bf6bb128fe98ddeeb6b450a79762e08af5541590b82cb42bdd505275968cc88d06809d42dceb3eed3c32e610034c7bade02e065d778b81475d58a4ae2914c5f1f344c1d52a8cd4c92c53b9965e5d175125e2e6b3b9948e4902c06660e2d6ba84c745b9f2c0aac8d968e798087f65f11cbd24a28e77a22bac08b05576d42949bc7951a02e7819bb551f7b11ae50848c45d13e44ede2731b6f547a8d090099652ad7193c6562fbf8aa39214bebb8ca3dbb04b0dbac4c4c2dc240460a0a3e4a7914e1f9c1a5defbaf656c79e76ec6175b7f72319351dd0c94c106962585966a8ab4438bf1eacdf2ca80985b7cbba16d2a864a3d86cfedbb8b826d063ca8b739e2f382564df02b5fbb5bf8d26c8fc735bcc8d9a7879d6d0cd4ce02713bc922a6fa29af97b7cd5f33751e6311b7098e37b43325d65f40755d0d8c17a81c81986f18ce489b30a2f7b1232c7d8001cd3fc8112377621aa1d5f30c74708d0f5e8035480aa2897bd2a9f0a0350bee5a17ac2fbc5e2c5b556b29ba6c3dd6d8866d7cf0e36ff7d7c5f69ec1caf11442461c8106b0dbd8c30358a6914e91d06b4f864586f7f56844e002423af5a50b531d3a12f6beb82cf363d5803c89f6ace651487b0fe7448ea34fe2882dde5a930c8c17d640f595f55593e29b92a540134758a5f8e09059818c83bba5dfae1b8713dbad255eeafdfd167273ac3711966dd728dc09437e66dbf77130e95ce4c8b4d4a607e7afb0ffce23feab629359a4ee6df8c80ae347371ba287a9bc45f876ea553435bdd52ceb13eeacabb945a72e926e58701865e1c543a46106303c5e1857d734e77da8c5b94492132e6d8e903791f2c016f8817313f6de36b2586a602aff357de96e34ac0f27a0dd75e4c5193675fcf34640aaade3b5f30ab279250da4018ba398e405415ab0f6882c09fdb66ad14a084457c547aba7f3217a2e0d16f1b3ef49b483b92305fb190be4a6e76f2b3a995f9837e28e2d7ec60bfe68db59d7c0cb9b2f9a81ba84a0fe84b6010a0347ce520c07889c1e0fdf14fdafa48277e34c7ad0ff0b27af1b44b3c1baed86fa421f46a895453714608841345da48a479df496555cceef0ce712937e0da3c89ff338ff9922ea827758bb9abc37bee22edb0640a6943ec42f241cb47220d26d448308cab433bfed4333360cbcfb6f83a04ef09baf4ce42b39ba2b466e6027735cad2da32adf5fafbdaed33030b69987d6ce660d8a04ef3b35550bcbd3986dbbca89314f941709628cb008c69d4cc7a6d0dbab449acfefee1a39799cce0dfbba1e0f79d6bba77ab9d8a07981e65f9904236dd3a352686b809219cbf6a57397103391376fef41fdc22538063b593e07cd4940038beebe96d9795eae5e923cf240f8d783a2ece8cc6dc79b48b05474a648598b7d991d734445a69a6382bd8c788c17542364a844905ddfccfb31087b761924bc602c57807465208288112044a3995d32a7a598bec77e95ae7ba3b91086746f32880654b0426bbcdac2c50cff7fa7b18a2835402e7cd476f59911db52391cfcecf8b27d2cb42575ef87353af3e4c768e92ccf1a2d6ce480d18c6b142d4fd2bf076b86859999e268f5ee0255ab3383c7c22c64ed5d2fc30e69dbb04ddf623c16063d8edfd61d166e6de486d4c033bb3b6049ad6c0d6ae2f917b8bc1f9bff6987a28ef42fb40e02f5105e004035fbd563c71db22b455f0784f080a3ee12a924b6b4f639c8ffe48e9f14c078c0536e798fdfb6d49ce627e798bbf7c1d6dc0b91aa928a90dccb9a9e6f5b81c52f5a3d1de39d5b31ae111ac095623cf6c422961e4d388aaafccfa75dffd2512bf3e54fe0821c3e00b5290f1cf57498b023b2e7284338eb8ca4b7d26a6dc60965787b39a04b7efc7c957d358d100ce86d653d5c2ba7ed50c22f64905aaf26659380d4aa125c96b0a9a07c2c33f23c3cc3b7fe927b7a0bb73d810bf5e7bdf31823fa0169d1d3219137c0812083b418ddeb21815dea74f8ab554ac13ac08a734e311d33d1001a37fc5d53fa7a9986c85575283bd1423517ec03cb76e70564232d299dd1443bc586899e5b39559c93f52ab2620d085732bcf56a641d0367ba12c31449ae5c56e01bed2e8045eb1729631c162d33684e6389b6f9df83aa6bac36a72ff4d0b81817a8ce735065e097c76299249be9ac21967b05b5fc5ff37a18adc62c3465f5c919689918218610e78d98268d627c7317955a353f298926367e4540d8068f329ebd0a361ec4d408e851b50eff2c719a63ff4a32c6516c836546c6af74f5b2012136919f7a8dbd78e1e577400bcd491590bced2f1f4a53a6e6540a433133100ef7c90d8ec1d07d763e5b1fb0b7047c8ffe2bd2a3098cd75862652c11f4109dcda2b7508705d1071ef14500992f12fe26bc75ee2dd93cad9709d8a9edd17b00fbb673b8c9990d70da9e3029438e9caa0bbb46bddeb0319bca3a726bf6e9589890e3e490128a29c38aff3b51321f001cd75fea264fd3fff2de771f1178531730e94890740bb11b6eb1e715377899d077a8bbdb871e7df48dfb62e57528cee970683260ea48cb5e37328f16e8aedf08b4c726f06dd53def095c662afa3debda9d40447bb8ca6ba79413ac81a6a0bde3bdaeca8d04adb72bd3d09bbc151f02bd8ff0961385526f96011fa1bd58e0cdad70d7337d8a9bc95320f2719584226b6338b63f9f4ee6810ce4a2b3c6b557c02ad5ea379fd2ba794b45b4db1fa64ceb2098db9095cd1dbabb7d9673c2e481772de9b8ef3657c8d90cb692827b2fe4c37b560740a3ae72574a0b3902d2f21916b32325af58ca7c99259f2fb70ad8f9ecb519c1cefed3b7f3dcd620e5fb409dce069ec80183a3cd1288cf108b370d0ee02fa5a3d80f74ded424890fea3efb5e36e6850f52703f528ec5e7669beb6ecf752fb5753f219cb457e8e8b9ef80d704218e9340bc1824d230aa94e7040619e43948f1a8ab87072390ca6ae355f42126869841efb8de512cff708d28ec73763be48d30a46b10e5fd342b57f6b612760985d8a4051a2801b832ec5cc04bb3047ce01afad915de83a53a39cee85b6419f89a1aff5fcf4bde2321bb54b473c76ecda96212fc5a9be6d55899aa9c3eb7017d49c0acc0946e30afa4a052f04e1dedcf19a159bf9078fc10d03f2f9501999234e905d30ec5188a8bf18703dadf01ef714d7b9855f01c2a059f0bf142ca81e342162e3c4983ae44737bf1ec01de74760b06d95e3c9ec0f20247996372d90f940dce2c5bf04a8184776e628fabdebc1dbbe116568250bd194c3703ff7824319352f986517529fa432613d31c432f81a6842e3011c96b970e7d15bdd10842ad027e21d4ed3812b8aa2aafd14ffaa94c103ce35d00fb58f79bf2523e5ce6aaa9d5c354863844d5641610982171f0bb89ad1e71b9730b94e95614206cd32864e0d8e7cfbefaf804df7809293049df1104f14eefcce67de0127b270a88ab5fa218f16e7d81a4fde8bc274891c1b906f76770e25f1588a89d7b0aec4cf16a0a8747a9bad1c270fd657916b1027dda40bce576fd15c26dadf9f2414076ddee55a53426e6c777b945134b0c3395f471bba723c769167ed1e2031ed2d3d6cd5b892523caa0d5994f1624688d2b86153992faeb899dfb54c4842c2cc8e90730131c83acc467dfd207912ceb865b17a108517fa38c22f39c6c94a16998e7a2209447e7213c7967096a267c2611363e7e63e6d06f1e94d11d777ff66da88011e87b12559da9f6953473834fe40060b0b97760e5775eeed52cf7c1ab4e0d3159fd171fc6df7f4203873f0306112407a7f168e8b9eecd85f2c3405abff0446cf30cd3652155a3369af118ccaa553ae9b2851b392f99f9bfddb3cf93ab04fe868092a810f76b7ecffa413e05e18fbc4e84e5f5f95d8ddb630fcf4346153ea5114e6a7fe7242f9e3c77e99963c52c362b304241b18cf06b377a95c82758df94380f71e068def0c4e3b19e4d56b19238d499c490b94b3a3964c6d41e416b59cbd3155e5490f6f0647f71478f675109008912d128314e6f300fc396d2b9d78ca7976608f33f0e84f0bfdc4923fd348d223802804ec552c295c58a3dba8700f015250707a5e10f30bbac8de9a337c89f0e93c6b4b1a7bcef5b624629e1ea5473e53dd41f18c0917c21ddec0f7d85a7798ec601042c43f9656d57f70a1ebaad30fa1f3010eb382b81aeb9b9e8547df3248370bbdf89922dc3525582d6ae008ab9738aa0785a0c46dc204fbeb2d00b11a564304d8100aa6c16497ad906d8df9fca74c0e7b797431ed432bbd2104afdade2a18249cfcdd637210bd3d85a75ff697e041da7e0dfc4458bd74c4dc26da74e0541189aebbae2e4c230d1bd087a090211518fbf6ba9342939673ea78584b7a8033edf68fb74be8844fc0e5ff7e4f71728bf9a10fefd93398f07510320012bee782c231bc02debfcde9d7409746feed27bb7e329dc26f30ecc919dd82d0c69c1705c8bbe3f54da536068d85824c7af8b912809f73bb3263b6ca5ce7f9de8b9de099706b7064d4df3aab88b9928089fc38ac28118d7c787a704aedca5050e7341193436f8a7dcf0c7cf78e10d7746841356ba84d45a1bff894df30d84d3a4d02efe989196c8c4601a85e880d36d28507f527bd9eac0bd75a253d9d6f4cf745b23560c9bbd3f077d725bf085b50fffe4de846b9f0cfbab8a0f7be5180f6acf8a631fe573c6c2e94d3d4e8742fe754ac20321c2f9c24f6e6ac6824d935f83860b6983bbf7e96715e8468461ce57cb64702ee82f0408d6b4ae3809935ea6aedffe44503d4fceaa9877c9483dbc9e02d8991c399f8e88dc1495c6b96bd626a5a148229897418669d0d18fbae73702d342b7d906d5eac786265dc2ea685897e40c28628167503b686afcc705bc5b1dca33db5aac712399b576d1986aaad6aa426aa8915f8bf3e8e194e18049c5ad0da2041b171371c4e7c5fd2234801b7c60bed7bfec4b1a4e5d4a41ed3850587aeeda06cb1797216c986165226f600b383a3d5358e266871a08fbbc0d98ca5b3a1fa5795da59126b180cbe5745ef2a028d7bee053650c0d573ca5b04fe4c47af00ede8b1d66f142f6ab1e973085fa6089aea60c823d95329aedaef68265361a5d5d36778a5bf8963a7b64005f1b01b8f2d0e8d70a18ebaab5a24ec143a42fe42fab58cb4a170a43a21a8f29b011124e478455966e7d11bad9d0b27b6cc841c90eafb56f40fe4cc895bfdf739ec2ea65c60b42a7e8dcb9ac064469214d68ecdeca6e727e8020529a5caac983ed271dce8651bc3a93d08bb1726f6b6e37644a1deee44cbbff544ea4997d7304c00f4ea005f6f75714fd9641fd1a9a3da15bc8c9c3b6c7528feb4cc283f2cc91d12c750f4e2b2e39781fccf36c0c50257b188413c4234e51b26df041f16c0a5dd4cb8ff956c26ac652dc487561da72ffa440844a8f732080649e4cdf365870d4fa0dd8505b3c504313aac3759968f5de8ebeef4128366d244193f0353bf095b2b2994d9b55006f1bd2626d2164a269fc5ebfb06b95ff660175114b70d7b723b7d8c428143a30effa0fca46890903de8d43c1d90dcdfc5209f8e92d32fe0b64a5acc891aab052c9d9b8e827800f94ae019239d4addbde60e6e4317275ad1269607bd76b6c259d7cf2e608ebda25e5ef1a3d49d80f6d777c5a2cb31a18f0bc73c57eeacae33e1aad8c65877930728bf0d7ab78bc56350138d9fcb33aafbb3ac3f45242f372fc2b594cf42889fdbb91fc3eebf85d3b36dd00b7533a75453ef521609e4147c7ba70ee99fef868373e4552319175a122c4133890b097c7107962054934e21768bd8259ec1135372973d1849bea54e5012432546a1bea8add4302ad809218893a81f87636a538c36eec12859d7c60460164faa75aecefdbefc9df47202370a04358ed1bfae81c545c64ae2d54dd9e8b5632de915c652cfd25c51ad32ae1319814bf362adee4625cff436be2009672ccee5898873b63bf109a5b134665a2da8d5138fc9f209560f1660fa80bd62b2270e1454e71f823ae4952b5be4589da6935e1d5225a9f1ae8fef0229b87571900671a95fd27f54274141285ff4e8313913573991aeacc44066d8e25371084ca0e09a2ca35585d74ac7eecc6872f08c9fb63e0a87427ee6270339a4ce55d252adda6355cae045fb8885932a45385110f3532407af2628fb72d25f6d8bfdc475f713e9d728c6a68ec4c100587fe4b870d624378745036eb9a285d0c6994b29ccf095bdaeaba88411c5f1492f8108c63f31edb0d33e9ed3c33bbe96cd81d5b8fd66adae97b0772f4a7b0aba576cff66c022ab4fb28501f3600f96648aa72351132a405b6ad372b87c0c44fa2826febf9006a1b4be213d28ca8b279ba472bca7a7e37454c79c9971bd6bf94202ba96edb4bb6b6caeb651c459fbe90e2a1b7fc35614e7bc200ec7aefd3ca36e86be9a4d85e008b52189eacd4b1729fba6e1d4cf5be8c921d15f68c7e63efa0526d6f81c6edf70cacf6ea0edfd1b726c7dc5add5a4cedc961697691004f925bdbedb8ff1e315c30658868254ea2411a8b3b4fcaa78bd152be54954bc584fc17724df86afd1ae5e211ba304c51a9d5e2687c70e67a4fde445b336f40c64800a0ebb8130732c25e02ccbf9ce5297e85a76ec1034a826ad16cd7f4c57b5a786c04163b8bf5077b63607e21f0c7c45948369c4a612c41db63590ddf0f64149dd977a02667b856d206dab5db5aa754b91304f32ef1e7f11e3c9fcfe77d7f603751e771bc4ae0b39813ae19226d917602fb3f3040d2bf8980deafd8fa3b599b8734bfc1aec48bbae029db76b7f3033a91d10d60f6e1c8624f1f251b3089be550982e9fe128ac4ca35b0854cc5e7c32bdff9bc06821b3af9f24e61705d84a6a4bba79ad0914716e5a702761113ef5b331116a41c6efd98c0d18d2225b55ad950395465f4c0dd95d1d94ed3212cf798ced77d1c92b4cbada8e00bba65fba373aae0eabdd7fd54c851c1c4325c0dfdf7f61f942b5a6bf892b27565cf1c1d5426f748e1009227ecb06fe3977a9a4d452a06c63b1929fbbee231f84a4091ddb4cab4aff566e9897647509d841dadb237522b2a951bdedaca905632d9483c899221e6cf9f0320ee2f7e76eb9ac335e3bed0768722db0af201cc782936ac7a77f22ac339ca1582d308a4de7edffb33ffbcdcd2e9053a7d249bfdfa2933a987d6dabef6e265e5933cce6e0b04913c7edb4feac1e5ed6d7703e66866a151d124d1480e63bde2bfc19676dfb14cb7eb4ed04053425204b2491dbab3bf9725df99b4b0163d705d3114eb4a09f84f932a09834d7a6bf5ec4c763197c07cc06e07799d73a966380b3dbbc399852d331542c8445e2cb676be38f531fc651367d95b9ede49a5afc366b3462a2fa8a3bcd835a65194de6d3f1039f242ff0fa440f1f1e301dc686f4e8ccb365d7fd29a89376f256cf7a5295c07672664fb16b35b5e36723e32112c3a9530c7b0b693482f01d21b9eca827df74f0ae19495bddc3efad9c1143340868e2a9fe62ed694d90c2135cf71cd4ed3615075936217f0183ab8f6e1dbfc6ed271395fde8423253d3d26e383093dee46990b71cf67f505533ff80ce45fc4f17ee75164ffcd48973aaa813c191585e3ebbbf15dcde9a2b0eba74ba64800fe8fbb2737f25d8127600cc50a49ee4089b26e571ec4bb0eb64609269f91079055702e8cd816de0a90c64ed6a04b5f4ae169872f8bc52ffe5df01a2cb6c0c8d1b5d66355c094609ef302c8cf22acf1b56619936fd911c36b8c95cc08fe6611d8eec66b33acb44c605728ff6b2549d686dd063f2b6427b10f7d0917c3a77b0f01f3de2c76fa9f1957bfdaf729ad6f495da46daabf84f5b332830e530a13b5c340380608f570d6644a9b281fc44100669368c3731cd672326d19fbb4cbb3773fb6d74e8379c9b5d0f9978a5241004cc06271bf3296e1b6054c4f0d9b50796bab14ddcf9a14d6ab6963d4c6f7d238910e434ca401951c7cc3be58a25005f025361b6ae4218b6e346b2e6e19e533495fb9d7a85c1e6417ff6f2a865a2222837ddc8331036b7d3fcdbb95c55ab5b0f4c0e6eb16d8eb7ee984bee51cb1b5d137a56cd50346dc98eb7015a2c74cc6f799f9dd688e79a7f485427fedcd725799fd1d2ee1322cf76b3fb1547c517bb334a3e707bcc175dd80f6a09b7abd49b43a7d81abae40d8b9162190f15f6ddafacac2099085ea9fbb4095f7639dbef22545c4c57b7cfce631e094c15e17af431904522ac099fad27df9d3fd58befe8c2012e009a4ce03c14b6bbe96f36b5814a0da1df342b265f911edd3f5837eb67b70551c724049517f833d9df0ef2811d14130754992419554fc11cefc56b1e933baa76a823031bd2e641be146f65cfbd49f5830e8f3f5a71e532bb81d644ded684c052c8d374aa21e3d7c3a7d37f828ddb4a3412570959b58530aca7ff457ec727dfcad7c9923778b1ca24ee2079c26152fdd9010396f54f1d1e4263d9610cd35868ef365d9a1fc805dec0657c7c465f8c9dec93206a3ad13b3d7a38c001e9eeef9f60bf04e46868e79732ddedb271d65c6b790db114e8f0d5f9e0124b45c2422cda1ec6da8266f56672d486811bec23488505e53ddf5e7bc5167a1d6f0700525fbf018cd1b71f2e1c4d938ad1cb07716575b9c87c5f197b4472fe3341eb1f096a7ca334d3f28677557e821bc1b09817218423cf31cc23f159ae549ee568fe52b7799cc0810bd751fe249beab78fd8aa262853fe43279ce88fce4d6409de6dd2b6aa431da4b6865aee6ec68e9093254e2b79e5f347f702b2144f4a1946121f8efbd7290d981c363bff929a6a21d6d97318cd8262e1b3ba7b302cb6eb133d9e3a48b76493ecabc84f8bda21a75cbbb76dfefb6004599c9c00f6624ec5db8793b317b1f8eb2ed55f32718798112ae60a98a0eb046cba3f84007beae10d0979b676ba7a1c0797d2baeca7ae504ad7e07c1c8ad561ad243409764a76a9e3031db0c2d23498534f0216bc7caaa0f8944deb56725e87475478ea4e70d9315c4077e1eb1d96c01206f8d3e40ed841df09b1df439b14d67546d1ebc67d3e3102e30538e8f739d13e37aff9ee5744946ca6f52bca289e0dba9aa6222234c7f90269f2ff49c8dee5e2bef1300b1f024cf439cfa5bf4bd16ec33e525d2e45c888e527464c1ef356dbffae5c118ec410663eba0435197c47250d92e368a1947742c83b967595d1b4a4a794cb53e46274b3715c331b2308433f7d3e633339d91844ad2053975afdb666b5cec5ec7154672c68c8fbc5b9f1368ecfb4822d88fb53a032e4382e4bacdee392c8a03080536c9b09066ee76a61a41134d96e929180e1fb4d3eb8758859ee9969aa73a6df743e3bf8a9ab9bda1bda3fb55a1d69f59b22f6a69c59d3dba8d259e89987f3ec5426d1da6f7850bbbb10b5121bf8acb4e8bdcd8df0dbc2518601b6fdf473738c3b63bec6390af16c0e454433e926c6b64a5573f60936286150d56281fd4e2bdb3faf4708bfc0a4ffbf27b8de34f68bcd1a2c6254dd2eaf465d10a466b81dd2c4536c9f53288ffc81e5b2c6c3daabb5bf5934f59a54c9b40c032cda4ca6aecc74e626e98310cda96918942923284b85483504315fd6003a0d1ecec0c5c97495499a5212c2b2c58349625b8469099f9b8375342cdde8e48666e63dda6c831ac3c5649f0131e3832e84a1323c5c1f7684fea84067d5f0563378c000097849c05c14661fc31b34488568bf61548b29ac052c36e09c9bfca338e9556d9f46d4a473f4dd0d7eff8ef1259f7bbc380ddc6735484acdbaf4e6cf5e6838fecdfe603c6a96d6278b259d912acd0555c40dd6491124ebc186c1b6f92caa1770207d39633d89d1350f082d5b5018f2cb1c57c226ee5657e268d0d96f41a595e2a239c8683de202bd38b4355b847b96bd3e252bf990d9a4960a840dcea8d5484039ae3ec9555afbec07d2135db5f171e24c4d638f57bcddc6dc7ccfb2bd9e465137bc6bdb17507f38d487904c391f5249a8c88aeaff53149b942b9d4bd5c9562c41e2c2c67d4c95919725ad31904888fd37c3e2633bd848847d83da0c5cc0da5965cf92230a43f86907bd242d330e4f86ffa974e9da45025591e7abd48852f7457b519d815da3e9373ccad504312af961064f2678d3fbe3bad09f3c18b0a149cee25f2ef19ede09d92622d0fdc334b776ee72d8710686be7cf4b675a25ca4ad961ced2ac4624d66f1ac11ac5c86d70a9c70ea9ec2fa85db0b2c8925871751562bf62a80cb35e7e17d11dfb6b649454f0d8e472e421aab545e47120c3f43f0ed520a5ec6cae27373b8b3d5e1572b7353b69b94228fcfbb2e1220184b30f34d76f3c16611255b0d08c40c339d29f1a96adf72e00c5cbf04871298c8a4879323409158f29928e473cebdaa3aba5f934a336892343d3effafdd672095049fa2de442660d7023420a1c82c2a39eb483508190393f0cf9d13adb67f04385be57fc571355a5b676deba2f8d027a208062e89d105a5e1a6b01b5398ef28e194ce4090322a55c36c98b1c67e22b88af85e60146c4ed90b5bcafc8b5d4f6a79f91d4d8ca6bd46381dfebcdaf2228fc04a342bd0192d714f621f2efc8d2648f899a69e9fc603f1e6423acaf2159f8d7b9e3caa6dfc95a7059969a95f4054b8a8b0afd95e9c9a51d5d34011fe51d054f42a1dca819ff703227b1165651ca18bc85edd16887ee1c6d9df06e3e69e3a220c2df30b4f790dd51ae025d44863f12ff5f1bd910dd32846affb1e5184d36bf14564967bd6028c243a03a4a78b05a142e7a1dae715e3f32f7bf7d837f6de2380ec64456ad5955fd67f3d7fcd12fea2d1aa0a32dc1f42de5ba30893e7cd5f95a1e842aca5b7226050c480ffa67cb04f1c90e96fc6fb868e2a60e123d3645bb541c74eaf4860377d93860dabc659f0b8ee831d821bb8b93c9fbcb28f8aa84ade2fcbec98488a906e8d818a61c4ba4015c67711d9f29ce1fa8da8c8ad59abd08a7c6c293abf224783184f2ea9d1482f953c7364c7e26c4a5e4933447749e238859e9f4eef93172d3d0629df504ac794569fe434230e81a66508ade851fe3473f2b5318fd435b0985d55acec67ccfb7e35dd5019a723f72bfd5d1750e9ee4b0fe793a161cc0bb1bfd09f62839c7cbca926853ba176721362b580feede3eefae3af2c3411b583bc151db6479e79b95012bbdaaedec0b0a90aaec71d7e2368d30853afe1a0586b837cbd881f5cf626e97f770b3308a400d78a2559220a510884f24cec6cd54dcaa43aaaa3392a2b5a8faa481f79ff514bd7a5ce506db5a3933b8255bb312e0b52a21a65e99807c8d9d8b3a52849317db2c978050630e51657333aaba1936d978f6319431a1ac357ddb17ba019cb7db37066c6b151fa0e5dd2cffc2b76e03ad9fd2872de649f7e044ba7da0a98060b219f4f154b76c53069d18b5ae6a5b10ce8dd420588217218c3821df189cf19555f0b7938d539b934c6902ce2c209e0068a110dbb58986b5a52b237155a62dcce12cf18b7ddd739f6ae851d253936a4b7de39a6cd3e32f4f2be92ea9f905beba4a507b3252bb23e05480201b145861a20fa9aedb528dc95d4722ec49ba33dab03e81875f0106d373df717951115dabcc6c337577a3e7d9bf57a541335ada35bb788f1f8eabc16ef09977bb26c4d4cdcf93f1e9f912b29e85c0c905e5738328644a8661c13642adb69bf0ef873503cf27de223991b085ffc84790195fcb9d98c28c6553ffe80f32bf50f07fb8020c2e32dd06be097447b86bfdf69803ab52fd586c96f996a8e5ae9851ff2278ad0e44f01315450998f7346cb276cdaa0eba3ecd9ad64c110d2e0beebf9a5078b4383ce889a65ba25a917e6fd90c89d5bd788d10d873b619b47f5fd46b6ca6bcd80ba4a3605b22bab930f8d47cdcdca73366a076c52eceeda840d5e7883ba766a3f4db3be7d24b79779362669b092af323144ad18ca11b44f0fa7683214c9cca3622d758a237a45e052c1fa8904f5bdd1c8b2e273926f58e4f68b70b3641690449ee9b174cec86f32d116278e4963358a8dac853c5fa7f86b23a5de0e51e6c84de56f307f75e9fcec425a9ad859457d52b38e1560fbb2c07f1a58aca809606fabb924810b089180b1d9124982889ded13d7d7de6e52ece5ad8f804a7f0c876c24a3123bd5cb9e7e8a3de14efa1f86ceaf37ff3e91a69f7c57032e7c2ab4502954d1ceea381c618dfcbbedc0ea55cf61bd3d0f6f53941e54db8224183035850dfd4b3ca2aaaca45334f699ba03c84a786be997061d2170470ffaf27a7fa5ab35301137ce5a6d5254107cced573ca2b10e61b3a1cda2940d85f85736a81e2190e38aa3342648e64f7e1eff8fad8437a884cbf8e709dc3c1ae7f66f74a738489aa9a353b6ac995acecc57123ee56d6256e4edf659afb2fbca82012d33f77d94c86efba7918a6f8bfdd36e80205de135e411c1822efa2d945b64d6211f833a8a812a597158bad0df4bb77f39f9c9cae45357b8573a8b11175670b252845b6aec14664e1e517d311174d0c8b36ebc056822dad189423a70bad8d5646c69e393cee7bec7c11af683f3e8ca3f6da7c4bda3079b1c7f29d6ce6a250352696f062cf44ad84dffd6a85859a921e85f3653b11b0dc538d14f61b902fa36e745ef4305bb22df387fddd159cf3f7264e8bc3fff611b82dfdb42bff7bed331df9744756b7e2d32c00942b14d99f123fe00ee51fe57cc8cdeeafbb6ebc369ddfc66143df79f4a0961bc10ef2f1e1f336426097f2ad2ac9d7884ed836b53f4dbb2bca6031ac9528fa16248a5758e7241d473cb4354a3fa22eaba9e53e34730db3573064f399774ce521041d4756163e53c049b216fe9e442648f81c81855747c6386b873d352c1dd39df95b6af8284d05307cabc52558d92fca97e247db57f8775734f6331787686d441c45134230231c7426e197d9c2814707b52d5b892d2030a129d5b60490c5aa3094c294498acd11a45d90bf1041c27bbfa52ac211e5e888294e9763e7fb111ac2864e684195fc177afb9d33feb711fc265eaf7ee519023ad645fa2d0c8c1a360c4759308ba52f4b087c8fd330db18311ee4b203c27e58ec11972108aadaeaa0e39fdf5245589e665d350cc218e56d361608251f28776617d472d57c25b3e11b6ff4250399e9b7140d2e4acddf10eebd686a2cd693f2737f5f66a7277013c02c9bfd50aba10086fcc7c8d565c97c60337c0a7fa45c253342a1134d7091e8085e71d9e7d1851b58000b0253b9c160ba9de26f56b1a22256d336c41144b372dc0e58fc1a74a00b455eed09c84065c5776bc113e9b8f629e98e116f927d62cb0e02ef36a2d4ac21df2181a432baabf76d370ed740207997586624f90f84c2331fa59b6bc9d11a4dd32812d94629a7733db789395c21ab418c06761bb4da18884e3ba3c4d8939312b93f6475fc7e07d03803af0c31db43eea548ed6778f4a8d0e56e425c1957929f84c3ec1573cd037d4e425de3d04d249f4bb7deb7bc755d663298e8cd944fafd4463910deba35eb568caeec67b1b1a5efd70293fa43c064ed465bc7ea040e9baf708d280cb282fe71153caf21420e6d769d9aad831ab2a54841c3cdb4430b06c7cd02d9e4dbfd930193ac620f6dd49b2a87a528be9bc87585c9561c0f23edd909b05e8761e0e97d0f6434c06b2b7860701da2fb7d5b1d392a95dbf14c05485b71c06f213e676a3f1e5e1f9df7db5b193001ec5f4e0d8232ed84d6355bbca196d0d7554bf3f208a5396651445ebafffa2ec802231a26e8314b9c5b0f6c894e059493af4c1a863e0767642b6626eb23bb738d25256bc0f0a6908453407e4f5a51250842ffdf5bda1ecea2b330937ccfab94359aca708bc990939356b41bdb62b4ed12024f9e07eec80c7567753bfe6d2c10d11808853ab65187ff66917547c54b00106eccfe460ee993449b03cabc36d9e4b6c9080b4e8ce26833c3d786aa51e78ec7ac9f486463844c0242d8ec931548b37057f5c252ccc891e67fb29b494ecb3cad4de92b607b8c857adc3ac0d26865d4aed6cfa53040b453a609c82a3738b7f357827dbc6897fce467aa862b656328c278fc2e4e038667003631cc6f2ad87f04cbd631192d34d3fd12dd5f9982181d7e075a51d1d625238b5ed53bc6414e7eb522cdf6f1ef9eb61f73b6c293b6db730066c757817c9dc4f951755aecf03951550cd31a1c8f211e959d989038f3a4d77b0e20021163df9c97e138dae77bf62876694c97e459f2c04d7bc5de0674c705df9d42a2c62818e9bfef896dc619aa9a8dd02701567919e9ec28f50f70c5c273ef449b430899c67abdd12958765f567d4262f966f8dbfea195e3c270713e903f5ca9ebf1dc296005a93c5631eb508ef25646a7be46545fefd61e93a2d7d108a48ee5dfb1593fd00ee6b767c00d6509167fdb162e932922bf0e7659eb7070e356038905bc65bcbf4fdfa3c5e3be43f576a70543a884c9f85c13da76dfec29e9618458749f05a1d5640c4cb3addb13a657f92a915604910214125aacd7e9bf3bce3e22ea9a8740170ea21954a8b547c333231e940ca397cb182ae47f856e2cebbb82c05dc5426c503f2ef5c43229bf07adf469d5d1c3315efea2d2a6c90fda54906a004654c89a99c0c32fad29070d77dc3714692b89fec1db7ab3823b8ae8a720fa2e951003edef4102f01eb1cf54215de457e164edb26dd21899557958a85a0757124dedf79548f1cd893206c553c145c9dde88c488d43304ef99fa39dc99e132392e11411ec72af374e87261c875878c1365b4f1a8b6520543f65a91b77f630382c6787fa34ccbf08757d8b87a5b254996cd3abf648469c7cc959b5de5b1fc5bd500dc2ad12b26c38f0774642ed3f27dab2cfaaec7374fa56bda8abe3f2b471883f170ad15c0f5d55eda7171cdf896ede77f078952878682ea951db3a0741a75d2e23bda32e46d77e5b1f289a1f576dcf420bcc784ee1213805015951a3536c7a8a6934aa90a8d5826faabf6ba3ac1259625d409796291e6daf75c527f3498bd05ceb2211159faef778f6f8ebbab2140fd586d56694392a8cb11e070b75c3c055485d80fbf116a9c93f4e7ac6401402a96724aa7032fefdf83ec52f239c1d4f44ca5762da181f7c86e2c1520fcd9120af212bc78e37e43ffa6a347a8a03ba749a6cdd63baa75b89f1eb834f8108addc234687e06980b454440dbc10811c452b02a4bcb1f08229729a6ff7c3bf384fde9b1f0ed3706fdc58e79ec3b9a48ad38990c5818076ecc61067d62e2678ee9699405be3f016d702304bd5025608f12dc518d31d6b5fbe3db99505022e325953117dc033f13ebe6c8b379c9ac1c5e6d17382a39eb24a3caf6cfa7b0711050758074b11208328dfc9f1ee56f3492f620fd7655028acae97171cb64cdd74100c541ab5ad20323d172796a8e2821d2fedb8b554c416154669aef030939abf80772324ca78852ce609572239aab718e12e17c500be43f7d2213c92cf163208ee66f0834679d747e98ea829754a9a6c9b72ff4ae832d75e43b811353698d35618b6ceeb12dfcccdc6768b77a84113547fe8742365bde49e8be6af474bc76bdd07e7fcf01653d6a4a744c5b8cb23d3bef7a56c1387f2c5d2867202b1ff67d11f5f19a80abfb84bddb2f21b1022b9a2d77622df0ff12641f70b6c91b83275028bfe63893540d65acc4e6f2f5d101d226ee636dcdadf4b72855c016b442008f91f9aef04d54e6bed36a0c33bd9c80fb2be33a94018d9af6afe1fd6bc10579cf3b158f577bc5ed9a6a4d04ecfcc3fae8ebd06bb7cd7034ed4d1aaf07506f2d5649f228221fdd48dd169c647702e291464cffaecb5d7848374d9e94296e526a126dbcd20bc5656c89d7d4532f262bac837b54b49487c8d579955e68fece6e781904be6a0928c6e2ac8bac412589296fbcb3c15fdfbca3ea6becd31c0f52c1d7606a3fa765461ef7a8f9298f30b4f1f355179d32e7a3c1c3a7dcdc2364c75bfb73f731ded5971cb5778a394f32bebc390774c69dd919d90cf7ab8ae91b2ecebf55c0f2af2fe6efe15c1c0ab2919e32ecb63f61a3ef2744709ce144f614c8eda3e59cc714e5f30ed7ec93504281e1c045b6f0f2f0537447dd3bef890d566e425e4188a779cd2f9566f18a76661a7647197ccc4a81492bd510ca5d5eaddb99b0ddd3e5e7d832ee47aecefcc05272b55843bfd22c02d2c4a95e94755e48ab8d8e33267ccf19d0583b141511ddbfdab55c80a284074e3b11d78ea001f1b43dacfd7024ead58afb60f10cafa83e333d0f4b142d8f6aed93d3d2f9fe78f521f8be238a4eb2dc1d14238fc20ffee38a7e4a9af03b7462771eabd76f12dc40ca08befc98f8136ed87b03e71ecceada51cdfd92a489f239623fb2d5c7aa26284a611b9856d920f87d8ec3daf604fbcb14bece39a5df96c7d5f0b9d545174959e4b654c98dfe954437853abd04b0732c495845b1251c57e7619667e8186aa809528352299014abdd1a43bd2981d0dc0264987c65c15572042bc8d4a2db12feb52af2b74c0588f03f02281127e9b3540a3be4872f4be2dcc68dab8c97a152f026ad24dc2dad6002f8a4873a25ff4e6861bd70fe966a53e0788804a77a84bf06ed7b5519aa0fb1c14eeb891cb110aee18a949d2def0f138d359d2a08cfd909a455b62c98f1ae0f60d84231b6a5fb21433a93c7a42bffb0f4ed581dffadae6c3fc3f5c2eb97f5b2e8eb725910c4dc2e01112786932faf5d475ca0207debb8de83d810539b0f422927b1753cd498434babcdf2cf9d9bd20010fe4ed86a16a621f64b9ee61411ae3e8f6246668d3afa472af4e513dba083bc6dd70ec8fe226e5508e99d96f970cb9d8583d87536eca2766f1014874383b45147b5ec332554127c5f82a4e7bb5520c695072bf53e290b9454ba37c10ff31302641a59a39daf0f13b37c0325007f2989c6daa96350899afb343e26df2d8d7c4a6055b88317db23aaa33ae4ad7c067fa741dfadb71728f0308b84d0eba09746f7a138799d4e3624d248b0a8d1ebaffff9abd4525a5cdd952af389a78fc186d358964730f32b7d5b4c54573475db176e88942b0efd0b3105fccee138c2b2a589d0631f629915f0b095eb2287a6397c861458e1bf43a8686c7b183e3bc956d83ae134e56fee824c652617c9206c1de5192e667d2f3fc6f8b9d0eb66d7bf14d4f30ca69e291c200fa7c01b44aa7d04f31c256146d23ba9193885008a34d14e068be86ad2634ac2dc37566f894976a93ca91ae00983d049aa418ef3662b4d2aba8d37b0a5eb1186deadd46ad15b71629b06498c0830a5be082556fa1d2bd13f6a679104b9875ee91b5dd606abb6d3e7b09619ab99ea665cf70c9240cd19297ae6195adf84cf042a9161f9cbb04db410fed411bf7774ecd11b7c5f5db44764cf692ef16230cfa0b2e61ed9b94a28483e8ba54689b2e82a6de340eab23f76ecd2de7fd0eaaddb6d0c012e29e610f3f89607cd332d1ce89a6dd0458dd0c48edfaf540103ad8229861ab41b05fbcd667799602b6525b9329cf03171def19ad7970ffd4b0b03aea4f11b686233806804649d4268fe5b0dd6551c30b7af43329402a249a8cfb7a22f98fdf61d1fd437f036879d40ebb8fb721fac7dd7f5a557adb92eccd7cab2e3a72ce24f1b61486b34b9e48fb43830f3ba42785ac8c166a139b75101dfe4128684fa724c04d0b32d062086d2d81a3c40297c0bc22703a437b2acce4e5bfc5c93d67578c3d4281d27e984054a9bdfc8f2bb31b66c7e8fa186ca846bfd214f9250c66df22b51126b81955a17a2178fddc74fb79259e04817ba3a179fb72c05f7775bbcb3b5eae13d522b31117f0715ecaafbe4d5635ecb27228602f8abf5761f67521060b137b4cef36cf9458c3884c81369cb71ae09a8f14f1df8bfa713a5ded3cb640cf8c9c13bf1292b36962d0d2d3259c53872bf8212bacd2fcb05a09ec79f4fd2e06b4e069c45d88e73543abf0c2ff3f18be66c1d1df8c29198d6a0d188ed75dbbda6f9e7c252ee51d66374da5b6e5d713641ee1deddec9fb76ba2577eb5066cfe2c2c4d8c8cefc319a3e3c330cf19605946317807bf1fd0458efa869a2d5b4ccd8c7ed5d53429a6d1e2d044d664252a3f3b52e4ecd768740bfe0545ae6ecc738b6732ebea4bacee74b8670d37326661f4ec4636f51050b477ef4c645d3a67768696328d4b312b9c0b5f937bef52779aadff9094694569d2f8cb8a7a683db4e6766f69008882498c0789bbd28996a6f6a64248869576c560a347b892ae9fb0b0479288720ed45897e36dfcac75b5e06134496f20d2cfba5b6449ede8e2fb17c2a33610f612b8dada876d25eeb9c20a20422573f72aa5156ad0159a0bb05a248d7988a7259de5045c91851bdc6a9b6abc5287acb278908181cce43e787c4f4ef0940eb6e28440d4b2cc9e5a4664e366c098d61e76d687ff12fcc50d8484e74ff5a784780da054a40d4962b2c0d0190c6cac5beff8c05401637b42a25e0e3d0aadf39c70d2b933338258838be7ac445e6ec41dfef0e9d695e3fb172f317e594e235bdf1ed8b45a370372393cbcb2ec39f56dba53e79ac00f2667a01d72ececd6f6114f06ca5ca77fa2ae6808f9d834f0bf24aadcd8e129b0d4215cfdd64eb3bfe7509fc07b2e7f79f69eba6a0c4a662be3a7ee158a2d34037ce83a62ce82123a2fac6a234fb5b309a4c6e2ac8660a07e84b13b2e58d8ce311014fc7cf5c0b9964d9e4bb3e5678d2295be45d45586c61a84944dc86f19a9e4623bd84d2dfe6a99871c21a0a9f85982f7684814eb8b8e93e06c1452705300010ea4d982eae0086ceb97a616684e73a50d0ea7a41a41003a8e799914557417937a2ab92403c60d7ee78e08170f9d9f6aec89aa6191185f36a1b2ef78b76d8612fdc3fb62bb63f90f9d01b7023d32e7271e6834be674bd47066e206e8001902183e02fba74e4e2ab98d8aebd7ce2c7aa4fac350797207ae6c881d316fd2d6278938ab8b1ee5de947b76df6062bc63b0084cfee22683bf803a24f78ad6606150bb24d2caff10047a1dbb16b83d8ebc0d74a39a1cd58cf7f51eb0a8b067dca3d114af06b1d1b9b8c79d82d7787833f588b65abb7a333b27e860e5fd791317783fbeac8bb015e6d32459620cf1029a2957dcd9b94b9908d6995693edadf9a539a3d1977484d775e020722a56e6d303885127bcce7d981faf4b641c48c58ce85d3063e19df35307b5d56d1b4a2289103f61e79b15c0b6c6e2ea1b8b4e35ece58ccb93b870529a4c6c66df811bab98366d4558a1ab39a18c4d37d42aca8eabb254d529f923af9e49aade08cd20df880f9b0229a66cba7ebe281424b421eb541f3a70832be4e40ecfbc4b8f62f211a5e2ab1598f8ebd3080803eb856dc856f22504ca8221748afa5a43e908c23af44b3cee6191a164b2848fc7960d730683a662c4790cbf0a1747863f90d4dbacea518587983d773628a451703f302fb73cb2e552c25b43e2479417804fa7fe97b82728efccf9b4cd457475e4047871841dc71850d9cf0714b21c2bef676ae55f992af91670ba0a34c7a6e0540517259b342a1ff673b15c1eb54a870a21e508175b3791dad28a48d60344f0cfb05e56234e40c4f9a3f1b8ab1d9e344567098c908d81d502ad134a174df2db8e147a5aea8c66b0ab41f1cf3b9d1ac88274486cedb8b9f03884fb2da41bcd8e82208dc8574d237b49e7da2b08e25653fe7056c03a6b02844ab9b3cc380b6d9d01e419f2a84d736d7bb5bb345e971174c0bf9024cf871e6c80e6f8c9c96292adab52d4ac2d0919a985311ce565d30d71c4432bda66b259b4e72473e201d754b70c294bc747caded77fb447b2b76dda11ad5c256beb3ebd42de0b104ade8dc693f61aa827bd841116b2fe8f05ab478e4eaece91b61d7c0e699d415178f2032aa64b97ad4c26698095b2e2b01bc8bfa459944ac3923f9ca21ef7ceec25a7937cb5c335565c5c5bf762c210a41bce89b00ae7eee4a781255e91ab81e35a1d0088f6f922d3a25f69bcba5a6af700d27d33ee518284feb8ae62238ff2597864c5d8e9ec3ecfd29779bf74be50b000db350518d377ead971dea23bc25f99a94dfad0bb6e612ef63a1d464ed07ae9216a61bb68ef9d646b8b21a7d69c69de22126012e3aa11f3ec447c3821f3c369f709d0880079c925308c7ec9f94fad436195767cd4b92af09dee7505e5141caed06d4bfa39abd12ae62336fc975dabc36f2376d3c997eee9ee58ca1bb8fce68351bb79e523a1d5f9da6578f69bf010ff86972c14e583f457c70f8be1af00425e14f28a8b1cea6de39626e770912694ba849fcc9584d51c0afd2b699d9958aea716b5672433f2dcc080c0c2f18b6cd6e4a0703b11cee49c40c3d71a8909a5f4958ca3c1f751a79b62ef887b58c24874277e359ade1b33475b6ac81d3a24b9fd3b69e5bb1faca1b3cedd3cf66dca0940c9839136ff23cd912979a1c539028e1d194e65850ac5489b698150453aa6aa609743925a36c4070da4ff4430406ab9c84cb2c114517a80b1719fc47e43bcfcb65ccfe27a4ddf147fd1e396d189acbd9821e6003dad49b562f65d0347cee99cfe331544acebdc92be4386c679cf2ef06482f55b1f4a453ec15dd7a8059211dc1804fdcd097e209d77662bffa9f5aad4e3f7161d68871192e39439b4e01e3efc976ab9929f66530732307b3246c778e8e2fa55fbe1103614ed4ee83226097d9b2600363f0883904ac2bdf00cdace0624b1451406c3ee349a00abc07e388681663600d20c43fc6fb73c2661fbaf82fdc3789071abcc85529b2be9921b99eb8961a4a71df2fbe8585c5fc1cf08acb7407dfdd18aa08f48027f294601cd468b6f2d7a42e81e26beabb084c621294c3516446453ec6c525eedd4acb5b5b4b15601e2195206ca930a4c3bf74db0e52d5d4f0fc90adce5d70304bbdf666bca89786986aa6f4ba89acb6625a85a9b0de35a3fc254c0accd3b3f71ab2e9bc6f23b040e9a509bc3e1c69cbfd875a1dd1c890276046b54182b397a1165a44543017cf2631d1656ebd7cf5120b32eb389af417158244e99563f12804c7f4ff4cf4c55e402315ce25233f15c40f5f8de3cdee0ab0b05ff209f0ecf114e91a06961e0a0c1fa13583601009572de9667453afa2e7e9bd816cfa6b9a3129eec678dd12b605c7aa5b63eaea03474bb1d66462eb8052744216aa5c82400b82658bf9bb32e642631690bc6700a59fa44d9b055ec7160c96e4a64b9f23793846b883a4109a58dc5edc07d810a3256418aa394beb2a586c208174c17b7e0cc9121d0a87a34002e000c8b9bceb6488bbf23184cddf2d312e1958ba58d2ed422cfc47123a484759742d641f384c855c90475573a4a10957ec5f5d9446d0cbef0d0bdcc2fd0c9a1bc20404dbf65d2bdb23297329f699988244f15f6c96cd1e38296bedfd23bd93a9284b270222a59088dff4b2d940fb558262cbbd7c013194ab17c7a980d87ebc68dc3b3ebcbf45e1a41cdd7945d91fc5bfe1473936da5dc5278c59427f59ebad25afab7235773ad99adf0ae88bcf93a409ca6ddb78a907a01a325a62500ce2142a7542552512566659b944def137e2365fc05b469d0e6c481a6d69d07bed3755aff18e43b557f1bcc641556886b7bc8cbfec7814adc2c9e8dbe3f3f85e4f5615b37921a98530fd6d9825caca028f68e64244bb5acec6308620c70e906c99e83c574d7ea2f4bff6af679c45e05b4b09681da8148034f81a492601dca22cc99e5e0637abb0e1801df31784ba2340485e03200140085ef0adb610b77b5a313e3d0ea69f245a8b8f1c201e3ffa28e9acaced9f7c5d4107782b496983b75ba2eafec8013afeb3e9af36b238cd89cfc996de7f3f82f39c1aa946c1cb12038282fe8fcfceb08d62115590417fb6395fa90d62832ea698bdc4bc2bc7c3d5a30f76d7676d96726ef3f074e3cb3806e2b093d82ce5ecfa650feee7024d74ce26850735495e9bba7d5f90639bac57a3b16695d42e2500202c34225c700c627e5842f71fb63d9e4012819176e1f437a742fc2a2ecfbb298a507cd95e615115c59ab35a8dea8bdb0c3f8315e7631241ab9f257a2feebcdba297134163d6cfba7155f498ada31cf8ee4690c62d855858992c5e082e96607d13cf3a41af46c206bc46a221e573a34fd74ed6cdf08db67d33ffb9db6a796ec4dd6f3fa01ba41efa9228c9bc3c53afd6f230ebb883cee245f227cff2f486fd012f3fcc69f8d25083881009e16dfdcefc7558b5a231c3a7c8791fba7fce36d6bfe388b8d13dbdee36bdcaa0000b8d3a36fe6ee595548d57edd2be606d6f19b3eeaa7f4e0cca686f459a11f3c3f66b2c2bf786220a014392410924ca9784bb8a4ea2d02d9d8d425d76b09dcecbe0c2d7a914a6761d7f95cca2bbea3f2134e424bfaa7420a1d11a7dca338734d0f9baf957aa75672ea751edf2cbf534f27c30be86c95ceda948676498f385d33d30eaf3ef7dedf57d914631f3215e80977e77a6ded4c977f1d216e1488a6d6865ec9fe014ae081b022bb967bed091ca8022012654e224c764b0f0af2a102b8234d432f29b7a778ff4cfc9b82aa86bc1442430502b30caf9335ee8c685395d90e92e1209520548c456088780a6a842de424ee33656c10974626cc755e0fa768cecdc318493a6353c9234614f79e58725008dd7213cdbbd3eea3529b9a2a75b00cc739338df4670727cea8951d9b6f3c92000d31acc8732e855615d77691b06f9add41b9ef539366b69f8d7c0c2372e35ec6e284301cbf5433753ad43385cc9b5b80888137ec095c43e9f0da1ce768a63f1645c55d30e69e53208b1f9f769034e99d48691a3545a18e8f30e79653786293c0ba77294b879bee4b2bd8bd1d4438b12a9ba8ca7d66d7ed0440052489ec3c667da9c08904740fb5f1a2ec804e073821aced7a136c5139d79a8cacaa961e6bb179db31aa6015068de6e0fe4bac7d1b5d7e59cdb39b20ecb894b596b03d54b5bcfd4c10b12bdb6d244f667fcfe20ce1be2d791a92e939dac73450da413aa5db9c447f3579b66b95a7ae7e980f74cb1cd70931379951f86c10fec3daef39081d397d63a88a34980f7d7ecc61152a44d221cb4503fa6cd8ff389448b7e1e1d053669622518d276287358cd07144772a3a8eaa183df8623ea5d43f35f03c8fdd0d4ce22fb3053e74c5abb3cb503a796f5ab7bbf14c17da7bb8149d38afcd49fd3f6a28358f66200b999ed974a95d784ca485ab200c7dda4d614b5d4ef685f12ae240dc649150664bbd65c11ab1538ab67a6b3f6a5db3c799fc651a1714b5d6412b31ceb5dddc74f3c5909bdb59e64a09035a023627c0c4611f57e69846ca6be73f04fc6f92baebd1d15dcb77b88df513d39a85340a9911f6a3f3b1ba7a79a5bd9bfe891d0afa389ea5acba2bd2fe4f3d52da8f129d712d4e1221f71fc42036aefae8c9f07971074aeb5cfb3a71db129282bcbc78dd1b048fb6880f269ad07095097320c453801cacdd95804f7ea2d365ac4297dfe4baa301c63d402c3e08f8c6b5fafc10d7191d21d9ba2f9ba52dbf5d46de6575bce40b37e9b02c42a820f82138ad86210d73ceba075dc2dd1e7e035140fc62d4b3613cf230f27cf74461c3a892364148fd4a7daad62fc7ba922461d0b8e9b33bb0030a15502b141bbf84b4b8c16a27454c60ef3cd7fb43f6eb08da387e07424c6cdcd37c9441940b85f16b4a88ed1b55ad2c421597d4d2cfc7f5d9590b05432562a5f7b3551c2d8c4667de81f752a6663e92d3121319a6b414e1592757d214368065ffc4d3c88ec7ecc7536c9b44941db7ee54e45925b710a5f4154c001a6c91fbbafadc2b278f3411f4b74c81b7c53922a51a9c2df60dc64db91313525b9610b65f33134a748d2c9c8cf1b0458363bfb92d32878cbc1fcf477cfd307d2cf2d11a6eef1acba7abeaa64fd4c66461e45527244847e2ad5957d4c71be6f975e10e38151d3e1b44d92a7a6d143ee9e030418230042fc477027bea5fa1c56e2f091c5994b11851a5c6a55b56c4df8553d12a9a0f1c59b3515573140c5a0c49ee6b6f89645ceee6faa079f117b3ab6157cd4674c4d2a34373802902656c3bc403a76dad118d9d7f4df7e641506a966182ab745aa17e6c52b74ba27acca71f034ed8162920d702ad584e1f8f41a40c764392ed56ae221c8999efc2e8e3807076c7de5b95e76dc562098f0eed960a99572f1c876ce41447068912ceb0718161286bf3c3f29205e6c13a72ac39edf1d1c8a992d6f786788918c39ca48a2d565d68bee64932e5137f89cdad86bf6c53c717d5685c3e2b5efcb30baa0b6ff5def053afc3dd99a706bb8eb134aab9a926f36de796bf053a13d612a70c5d1e9a7802608cf8ca8b5d953060327123cd8d26744721d80fa8942540912eec3eafe9eea5b14d727e6291171fa13c84d67f71217a6eef9f3044a436e4380dc4e639595972bfc5c8812d8b8e761bfb52648288c5b2e8a809bcf8c171371dab19e6785dcbb97927ce58c32da3825dde1bf4f00aae22a4e83861bd49f959c05ab203decb29830a83436a110adc461ab93282e01ff4b207e319d5e4aade1c306a641d4b3be72b039e1bba9cef7fc0cb1259937e53ed843a34db006917eae54274f797a2d025bc15e98cd1a50079e2d9f52df38698baab05a78042480f0f821b4f2aa0f7c60a6d22b07378e35b31a7d94bfe3fc7ad605f8b1d04bd05f891d21cfa3da01049535b6214d6126faf2ce0e29bb4c45b0d0e6631462e1d09de08c53f86617e5a90f35873017e5fc968dbc75ab3bc94f156618dc1870afe5ecf32fc32b5ce16a786e366b3c379e16d4db5db7b468bd00394076a69c5d2a0224a58da1e5758b8a6be31d3c68ef9e482ef6565759d766faea5b41d0b87ae4071c66a15aece10f158f15110d2c089438414cd062eaf8aff2f2176dc194fcc220ada788c0bb48c8fc4574ad0d13c8b9e6e33ae8b343e804bca1a47a82625d53aebe3e2835fed1b0512adf973f932d15ebae744f9e21a024ccc8b82f59538fd481f992d667d4d43fe6884a9911c5205f019accfc3220628e89d0dee20ac9b9a1263875b0c4d0feb694c7fe5b31f4ced5934a6e35659909a07ceb37bb7eab6ac0ca2cc0f2ecf822c291cda903f2ea92741fb6258c0a58496c7e0b5aab6c57666b892c884342233dc565a7c97ed9b34dbaea9372df05c8b674b377b9638aae321027df0dab743f748d8a25b61c715858244536e39ee6d0bf2305012ce82be4e196d003712bf460dd7f441a0e5f3ae11f2b80ccf9ba31de4d9210ad3062d6451573020203aeb95c86afab9c92c2da6b53499b62c59944a0b77a9deacc142c90d543f8d6f5b6bed7cdbd57a567a6c0c51784dd276d7b0256bcad1af2993cd69476e835c9a98312e8c2a3a7540dc30cc7c7b249e9a2a7822237a51f1ecdeb4fb5991d484c670c988d04b984135ba9a875be05d0802ba0ea37535cc1c9d8993cb302c9ef46183bed2af946d93ff0d2ea4602723ca47b1b1b4d1eaf667bcd4b87b32edc1e5098fa0475e37b4ab82d13b27d80e09e3ed22765de0769a0297e06391bff84b3f7a719947f79f4f7cdfaedd1abd1376500ef5498f48bbe76c402d0532c8968a036c28d49e1154004426fcba381a7b5dd01ff56022f2406f013c6ce185e4d8be5e376b90dc2474f9bbeac01ae6995bb5df6a72a2c6492c80bfb718d7f65d7fd4ce8243a5abe100f2a787bd7fe3666de2178ddc0f82790a2e0ee4aa803143abde80130f0e9ab42b8dbbf71ff2e38b196d167b768137ef850f7326588ad062ffe47943a30525061a7b4bf96d3ee19a91918948fb4f972a74b1e7df27c64cada553f380414dfb0f7f099150bf7e9cc1232d01a67dd8d67f7007f2dbe66608a8c25f92bfd053830e2037012699a9f8332633d68ac88271288310d153c4108b9c290e153ce9d477eaa0a5c9142800437195072c33b8f9c5fb09e7bd54ecdf29e923cd2502137d2d3cc0e6db390e4ffd32e19c03c84ce67f4341541d451bb58bdc6ba1031bfb580aa965d8ed4060ffe16c78c4f5c5dfc41e16d4ef039bd8ad114e89863e13bbba9b001b3374bd6434c8b62611187320e3a5cdd2ee97fefb6a9fee2395a6631b43daa68f4dd6b4cd4ed8ec0140adfd31ae74f596c49ca7f98a7c426a74807d18e2a69bb57a81895c0aa99492fcd447b6f28b568df7ef19288153764528d1aad42d4f5178e9959ef9291922e1a073c5776ab553ea0d8e77286dccda2f1d56c66aa590d508387aa062d271ebb8e215c3ae4005c39755d136a27d428e7688fda5f71c0dfd9851db95f7ee6c5b2768dd61244a8a6012c9518abfe171d020133a7c50f3231aa7e1ac4a9dd6ac9c5d60fce86ecf35adfcd72dd75231cfba198a6905cb1e70c29b0173ee91df7228c494096f5f324ac8a7ebd32ecce49f0a184857246765d74872617d69e0f502150572faad7b3b7ba97c43408a798c485e6ee736684791558748616a4c4497a0c4b19a540966e305c312836e4ce42dc04b6606ac3a357d7095c763307e1e0113ea8b561d234d5736d618191621d3532ed9505785c0d036c2882ae08f912836e04314e294c5253eec72e0ad075eb077d7f0932b6ac63ceaa075c235d08f1be85ddf62eb79f73055ce5a24da6f0e5c00ff06e88218117096eab2414e0f12843227f30ce3b9bf83b468f3fd178212e3b241187dc26516d187ae413d2604d6b6e68053b3828d927bddf49835192475cfbf2d50cfa2a56211122ad6bddea530443588be9ed979487e46ad880f94b93bff1e1807f003ccfbec1859f1ca4b6768b778368f7294d36211131fb27baadb6ff90b78453803a3b4a4c4519d609930f08c43d05de34c8087cb09dd7193dd4895de4869bd87b166ddbea812153de52b8905f6a81b34beaa6f68b85b5bb67867e25d4c7b4ea181e797c27196c39e1d3f7783a59d73f12ea62b80eb539a9b6650923f2fc4da90d73273592c4e2c4b8f72beeb3d05796d8a18b8c8252db7c5ab32ab3cba6ac92f066c7dd61119a082d7d88034fda145f4061f2914192cb64d958e4aaa72ecdca5b485bcda6de63dab92e2937094efd15081f7c631063924acfc9cb6a08d01311d17fa319e6b509f9207adee15e25f16836ad4479b4f8d12c94f95e7024e92a216fbac8a408fec35ced9862e2ea20b368e5dc0871d3ad1aa3b2da0ea77d6b2ce1c84ad9e271c28bdde432c9c48297ab09924fa856a466b649c98c26a00ff2757c0f5a4bef00016a1d2d364334442cf83bb32168ffd8fe3baa11017ae14070414bf9be19c99c10a3c29b346bf07f3cc4517acce5fedf6b34c7d03da208ffe5084ff588c85e55df39048dde35c702c988aaeeb392dca045bcbe7bc08eb6d777deca6a9151694e6117ca45f4eacc0e06f6d56d526a197214ee43d0e9130ddbabdecf65c3548fefed8a8523397c5b16768c9796915e662ca8f3a90f7d333f1fbbe6eaa0bc9f560a680f108b107a39f4135a752ccc7dbca461e18ab90f54fa3313ad90573f679e14140331c907aa1762d0e943971806d08b8b34f712a04fb4e95fd52097da406d86fb243fb1ff6e48fb3b815c4320dea7a88f8188778166af61da82a1fae04b6b9cf4c2ef54a4fd1f7509cf246a9efb44e9947b0978e683f0bc920081c86509c0b6feb9088d5d521646d92f70974cd5f0be07310fc21950c9ad39cf5718b462700ff1366af804111c22167144a70c76b2a419984a847a34a6e0775853244bd51b0eac5d2050779deacc6e19cd10b3362f75d8413383b95e8c1d914377a2c2ca4f789e778d147676e0a77a2e572d5f5c475b7795695a23e951caa4cca1a4625f9344f63862244c80c1b60201f43a89e204908118b117b4f510a19964c3ecdbedba96ff153bfa7ab685328df000af0ee3f46105e5225e317ad276725f61786d3dcaa2eb17158ce0c092da056dbeece2e8a92e5c3c790392258af2ec0c682c2f6ab958fb667e167e1d1e5314f838805335fdbfd0be039881c78496a69ffd14efb53264ab06d5f6a643b5039c3d44ad862828a818279139fa0f52cbd24ec00711f221eac857cf8ffd565a355a5e144594f1becadec52f470fa2b341c1c7d038187046c857605fbd7e0e0e3e74fa38ad757629f29c046ca47ab9f8b1ae58ee76b1a6006be8f3465eddf7aea424c6beb9d718147b85de3d152bcd7b78f679a9e342451ddca4d32c77c31869d4d2245b0c89d67ebf9057fdb679fc26501eb5f59bdd7231a131c42a6299ce38e659bf98e7b65e09de21592f62ae11802042a91be6f0e62498d1c30d8071c41747499e9baf73f2a7c36ac7b7baf113b42cbcc7040dd138520f0bb79ceab845cbaec6a1be826d4f7fb9cc4fd971227a64f3b6a81eb90419611db460e651700eafb7eb3273c5b6075911da0fdfe52d2c87765907f5b818db45bf3961751cb66806461e557d966677420304669d8b007071c7ff8843dd393243fbcc446b28c653f6ae1ae84a25f5ccfe797f0b29060fa42f018e44522516db96e402e9ea45c1b276b9a77530aecf0bda6fbd4b18489e842fc33ed2212c249611a3a9a82d04d7674afbc38d3905fa88f5178124a565f26893eb78dfc6dd15d16f3e909b22b439152b37605f4627a3ab2daef47378865ef389856b64f117d7af187f7eacbc9f30e3217c29291faa32368fa5b5a012982fe91f39ead0a18cd55cac4f8e147bd054a1bb322cf76cdff5106cbfd7fd4c9eefe706634f132f73a57688f96aab588dfbdd7ceaec0df10178624c3f5a41349154159015c0e544e90ffe0eee33f2fbd962ad7fd60c708bdeed794328967473372c7dd9d635cd85e186751811083d60525215e0be6629b848f5160e2c4f33735e47ec6c8eba06746be21230e35f3c6212de0c969a0f92e17a9b9d309a593da1094bb4be9503fe613ed1c37ff1e793e10793d831861a61c014cd77bd13eca411659c0121f76bd17dffbae552f8fac0f0c5bc19e0e97e68792bd1816327833a2d40fa72be8319ae0566dbde6bdfb9f703103b045790ae470bfae89ee974f634aa007412382ade4b5f80b72dbc009aff1bc3c3add61d7b35b26737530442f520e7bc117bf30c8c4f94405b958b3bde6b9283dbecaabf0fc1ef693d055451698d978662d719ab17bcbafa31df53922863828c8cbabb2c8373805b540a14a21d4a4077a62dba7c950c17d3a560b557226046862b71d5859f9592c779fba32e12da71f29bdde7268850cf52b14b1c1e22398c69d6801f870bbc086f508222eba111bf1983b905343757e2db4972248520b965a32a7eca99c2d07933a03c0d34dfe4b9880ba92c8b912e07095c62ab001227886c49ac97280ccc9db9aed996202ff68bd30e967611794dfa4756c8ddd59e0fba3a98e7b3481a62d8ad40ebbc9c644b1c197ddd627184db48dc448a9715182572be754dd666503a86742406210886b7d0d2d63f865219426e16b4767c0c54cae2c0733adc44f685205f0ed3234e9293818259528c73abea74e990f8df243655797bd4a24fad206c9337b5c83f06f10e74e59216448a17e12b4a4e682e14f839d85acf3072f8f12e88200f9de9d93d1c72c36af3c8b18559c168306a692980a5b3945f93460bb73cf9cd9f33868b8eaceb4e49e7b7f7b872f3657353d07caad9dea65c05ca5b307b283eb06948a9897b433ab211eac57a02763ecddc7d567b48ab9ae8c657b2ec8c4a182953b5ddc02293a416bafcba0cd085eb0997937d8fce5bd9b278cc5a7d37d82e02afe825899d6065ca7d9f906f893e4a63a568a59fd35ecb953f5a3646a0334f8851bc0e23829bbb09c177f62289bff95ac4e4c4d70202df7b3e4ba8374da1a2c72bf1ccb5ded8b75eba8d02981042e0a407402028ca5a5ea025db18a53d0069ec85679a1be9afdfa5248935046ee5ada699f966d33929d43023cde865e40a8436b1edf936e9d705be3810566db95238ab015378eccf28b029fa05d37da532127433f2b37f4b53f81141b149c36766baabbfd8bab996dd08db48b9372ae5d9c0b7fe193dfc1ac1d1e28c51125a2e7e95fcf8f95bedfb59e0afd9fd92176b7d1a941387ed0c6089119cd6f16ac92b485a267020c19e6d812cb1d40730da5c462882f6f4b683807fc4aa291f7e87a02a76cb4538c82a911e0c35db644edf351be12f6952b0dfdf013f5064a79858f813fb8dba2cae5c770e306f7519a42c7acde0710fbb5e78522082aae9484c85d2b2f21e822b3a641a820a351e294ce9add85ea820558d7799e8c7af3b5643666434927ca3e066db576f48faeb812b71c328f415f478c8928a72193b5aa51cc19bc2263f94673d0d512efecb0d4b685329aff40613df8fa71399138db376f29b6bf59428f1f639c83483b5f126597c311300911583daeb7648431d38401eaa71ac20739eb9d49a7f10b3e5bf6082b021690f8ba69a3dc9dcfd1e6e37204c555f1e9cd2d44e5c2007425d2c29fdd77edce17e6e892b870a87f9658842c6c5a350297c3e9acbe78b8dc43eb9ac9533cd603e202b147812e0fe57b4cc16a1d0aff1809f3b22042b20be35746f1c04a541bf81474f08cb5f5ccd5d30a8d62b05b1c7f39f5a4dc8c6e9c348b1399b0e83d1ac2ec85f11ab624582cd619b8f8a18155a3aa2cb8218bf3a9a6f995063ee5353a05ce6f4834b1d133034e0d32e4b569fc694d4d7225f4254193180b700ef5f504384ab4886cf100e39e715b29c2948300b62e78483a33b4235532bb191e8dc10114b036f552b2b2eb37f512fa6beb29f9865a728604e81bc27c32cdeae2b7db6e944c69ad26bc926c92234ac3cf42814624597f74bbdba2c0598c929c31fdb0e11c677bb4ae38b98fe9ca8420f18e2c7c2b24d31b5a97598aa2b51209e34eb2fb2fa41f6c0e22eb97fa03ea31c656570a9f3390a51f397a05c4d677c19d093f725de00a38ee36a169b82851853bb42548fe6e356b2f68e36b418879b1ab033aba608d0c3d0bc1ccb3c298191a87e7ad4f28a26b074e0fca04891a59e6db27e5862125fdceb03e3b2d2f3347fe1535cfc2d25d45371768f853b1ac17aca36e1a108e8d14ac8941ea4a87bec7d81145c8b11a8ea569f0085a93adb4e5c25b31b5e0eafb3640026bc458009abfcc157e05a0e0b609767e9cf35d13a6c339aa872b63abb3e30d6cc5a7a6f923b6209153d44ac41c04f5a1fb41a540d4df80bb924c391a64c914e1202dfa2b2178c67200c7de192694a714a7af395ba007140372bc19806e355f5e0c93555668c76ad250c0772c662ca63c5d4853aafac83fb8638a47c7e6ead40138581cab8e62ba78863752509bc477c5404079f76913c6345c1c8f92f1616674bd52c35372c14fe29a3d6c40a2bde3202bdb8cfba7da41ad99c07adc82d5a748ee946976aa3b48c409bd16160aeebbd8a2cdd697a070d9d5ba5332cbabaa771b12d0d7bb275abce4254d2d3c1a378617c995107f8a8070a143b4ae7e72c6ce76d8b5a09be87d730d7396ad10b1f10201ca03e20d9b558dfd910bb0aa0c3200d22734161b953ccb1caf9b8839f77c5a8dafbb76f6d99767ce9cd98de2df9b3499f86d800148e982b466f82f0e42756b764c09d08618315d6e8e4572188aa0ede9f23d8453e9ba4bc52f9862bd0e5ac7237228c5ba28fb7d4818b635289f7105f407646cd73ca70cf2b18defc4b7020aa893e29560699c5a581eb33014e7d1ac66f032d2e2347779e418009673863fe765a32bf71c7f94c5dd9b20a1e345c77c39f0f01f3e215e99ad4f82c72db805582db32bd66fba23d9dcfcb58c015c14c00da9409ac582ba2d9627ba0389427c3eb10d99de9131f98449b12acc5dd58b18bf40dbd11d4754c80c73fbc719e46398f65fffd0f65dce02a11c3704c99dd9e85bce43078fffecbfdc46cf1c3a26a40ec0da8ceb41436ae83a6fea70b4089d78e874d20b00d12d0b87db2ff4bc13fb8a9d1139e8680bb2d1465c510cab4870af5b5d58fa558248b1835190c196e2a29355b2aff4f906b1685cc62e2414b4625f57f3961d9f1f580bd56bbd316c7a80ec276a9a9ae9065979116a92678e1eedb4a8316736324d2df4046c5ee8bbf40cb011970cb4f8d99e4fe0d7b9589c562f8d7e150929f761a3d6ccb006362f9cd35c73ebf7b1b36b3be12972eb58cf89d6dd3d1d9d06641d2951f5a275fc815d01be83b1dee8ac435a1663a445192269dbd3dfa38410b4ef93faa8656673a6292a91aa64470ee4c0a11f65a9640f8fe6d6c6c0709de75cc8cf6d5789e7750104f8527ceac5b7c3f41b080ab15d5ac4fcfb49bee030a9dbc0e58ead8c5ec8bf420232c208e150f03c0f657ad6415f6f19316d8d52628539eb51ea9d664f5c991a81937db48f4b680677f1b607812e6a0b2593ab328c4e9b72b1ca876f84ae0af315fffa973b126d9b1318a1616de42da7dc037f17934af1d45a959e37e816e553fff81c10c21de208a46321a6af2439c76f7db09ce6ab0aa15ed12c6bc3f01465b0ae515bfdfc098320a32d6ee9b6a85e79f9497e9da7fd418fe175caa52f9e4acb74d0f7cba9478a28ed630349a2696deef43ade17897871b4adf2137314b33ffe52cf2485f030ad078233c14277209a9903098e56c5eebdab35cbc8c115a3af487d1ed5cea158b9577a3b0aa65c0e5dd6d0e65f02e0e2ee31b788f918d82a9c102950ad31ccaf448913623648e01a9be96b8b747bf169ef28f760cba683a4781bf0ea328f1024c93481fb1f9a1fe94fc1679446bf6ccabd957141b92f9358473bd977b58f105c50459e41fe11770da7afa1b45783167f33c38ef018b027af701e0f7b74b115f530e35df1563e32afe9b6c4a5ace1f20f7aa441e85fddfb3a18bc694ad205c9374cfb0613ef397de3e3c8afd35aa40d7e2123a0b3d93090266defa423e96b2ad59c62e0cf29664552ed2bc32758b267b0eb876fef6934fd606a7cee9bd40400515cac3d1f975804a153ff0c612c4d87004acda9d7fb73b5eff602ac87ad709f3d7fcdabcab8600b5aee5ec9f7ca98ad86eb2ea1d6f0e1223a0a0e5ee04b4032689f9c0f3443f4979890d91fddf0e227b460d3a7e39eada0931aabc90deb3bfda34c6b7d0f1d4138857d21d8693128f1bd4ee7261e7b29395f1bb5d14aedafb58530cbf26f8f296b3079673cc4f864a4dded1b67151870e430b863698e8604c200655059640e207bfed427acef527150bfad8f61283991ce1916a732f71d0504aaa5185a1f9c060e37c18022ec4553c134a6119e997645d818ca6328db516bb32212eba6d5ed55715817176fb8047c1163879bfa344b9871bf0e035937318785028baa5645db7484910075876d8ba8084e98f2a623966522aac4cd26fcea096bffec4728bc221143632db8cc286692c3641711a5bc2a162e01f3d304568ab8725449847ba973220cfe06816485dbab48c365d2eb1a1d240f58260b51ca7485a64fe88da535c79da229b5ec000a9de39ed8cc629c438983cfa5898062b76050b8d7f66ee6f59a9086e2294f3ab2ca9a1654244228a3aa6a2d2c730bae83f1e1ded5627b3a90e62b9c9327fa8e0d8809d706642f828429073bb026c3a3e91a17ce780b9dc3152c40a5dd2bfff4fd8775061ff4882708fd1df3ffb43c0e7f4eef562b20779951bcface0a388a83f9f8126c40b5f945f0b8216539d833a4222507098de3e5f1675eb0aedf839830c3a6819fc3c065c1084daf48cefcdbd8db8b5508fac4d03c6243626a5fc205a5e9ceee53b8c065cd6dd43111bb8eccef5545dfb34e1a4ff04a576c4cae0d1489fbbe2fa610ec386e6594bdcff93ac796808effd8151cccb67dd562d37a885be0bff1a2ef2144931781961fb9c0a9d9ff423c86ea6d1bfddccabcd578223e3353d28c57b406765f430fab5b1e5b003214dcbbd08e9efeb7eae2a7bb702f65ad6aac197c1a9e3b54c2f67697a7adda0abfc25a5a8fc7dd0ec43b1e62101971490d651c51511c39e616f6f77767fb302c1ec75c1a872d717416656042bd6bf1730dddb5ad68ee15ad02ff43e7d8ea78a36530d68df87c29b802373732a07a5041ff69088069ec06adadabe3c9a1a3eb7a6dc562abc14c45bb0817d53cbfa3d1bd7b99de1c14c77117949e093a08b8e31719fa384540856017e660c7ec2d1de8686a58b73070fe01bec18f8a9f36f534cbdb70b86612593b3354324e10cc664b973e83e234604658222ea71c4745c85b630e8eda38d54ae7aab0f9ffa30ed43fd2977da2545698cbdca2f97def0bb2bfb084caf8cc1019f25c3fb4f0df0e0fc69b187e85e4ad9fe4d54471e3e467ff8d87d697b21d2b24f09564e4bc24a6e0b1c043d8a4b004df9ee22b4cfe6749868e292df1d06643fa0a4fbcd29b64917fbfcf5fd3003cec065e5d28239ce8c5e809d56ed297e651ee825268456d34c49bcb3275f3bc62590e89b41900cdb83d3798089aff15a49d1f90e9149fbc35b3238475d8c1bbc68b6b02372536eb0994ed2ee412c0ebd76bd240c52057f928c445cbbfa869d2e235ceacc66da2ab62cdde3e4fff22add7a54e3137bdc4f2320a072883f3f3d47a43e12967b689509a29b4d7da70b27a2defb544b33dfe4ae0f7a304f019990215e5504103c9e6266175b8cc68c8ccd70ecfbcae929c0569bf3c95d1cc0d93ed265e44349f884f049e7ac9097978dd8b0de492b2597888c9a0bddacd8995f42b2f633700c149b54c6bf8808be6ec64bf1e0c586f2cfa9896eaefc6469a5243d12a8ff512589394b318a99f82f2becf19bf937d1eff24f5c24c4e7aeeb171aa1aab5ff3577e17f1201c5ba63b7baa9812d6ee04340a20504e238fa61e7d58c39018ad945adaad2bc4c0e4ad087aca2b0eba988a40a632358afb3653cc6edfba225051cb25e202d8a7a80a85ccd2f58f821a09d4e1db419539f0de5c7dac1a0fe4b61903cb9dae2770edadb6af77708577be63e979692c1702cb4e726b57e9b46f8e5b03aa7c6c1b7abf174de5f0340a247cac6f2b9f2ca3158ad0199b379ffc35e365711671ebf3c5be30d233cd4021582212820ba17b4437c2d2dac16d7b50f64deb8d9d5fcaae75bcfbd7690d297450fbf071012bfdfd99cae06ee11d25e564ab0ff6c787e2c3bf5d48d9126c92baaa4701b1cd8574b17d36fdb4aa8bbd0d7a27d4968cf081a118d52079751f831de7266fd7cea59f949f6f101a43b949376174900e48c3fc863b38c420547127182c4d0e7b62675cac944c47582bc252ac6902db4712e29fcd240cc56e79f1e8c606337eaf2aa3727c86a59d5d5444f0b0069008da077ff1b92111eed6adc220654a9a932bb2fcb610e9e074deee8660097cbfc267407a80877d53ff4c25d422dc2e9f77db92734a0afa6c65e689da20400d3f8389d8d4ae9d6c9de5d3eb95dcbfd6ec9a2b7823387a7fdaed2c860443b7ab9c7efaa0a015a1b40e420d3415e71afc4f84100073ff48ad9c31333f8778e7f15eb2c66ea3457cddc44e29aa2a1c38f55be999c66653eafc23cd6ba41dd18975cd154b687680288b72c1a493e151e25879d3a84236aaca6a4aded2ec02cf784c202aa0837a5fb8faa1714b6466d913962ed5e242bdbe55b5c1b7b478d357d7ce8cdcaf359633b19db9927505f172827d6d88c890eb5e566cb8dae74fa92fc9c498a76ef1291cca32713664976a775130090f54009b43d2050df35d5cfa0c6c1e24be11446d0321449a2a23aa3f24160a0ef553da70f6a098527f8dafc5a2fbd6f266dfc3fdcb5ee47fabe69142e8e5487135b568104c131142f705021c0984b62571dd5a202ae4afc9cdbb0e4b1b2842acfecd563aba21360aae382e356ef8c12fc845e859157bb452eaea0098f8cd068ad943e2cc69562645c2744c1e65af4ac48bc48bb88307e38220f618887dbc51e4468456f08ddb5d29f28da34f6b0f5633974bc0a6c7e04e36e2305ac7653d79423c142636d1599eae8138df092722d7fccc38f58d3c23d57d1550e84c68f056daaa9c1bd95f40509389cd99110afe5ef660ca560e555180f83f8dd16f0b73bc47204ffbf21c45c31a9c9e516d553d05fef84663201912ca92d7710179215b3de88b4dacbec5041b607b9da4f8eeaa17ad7378b62dbe7f3c50a149b73b732ab3e4d529d7dc2410d864abdaf3000bdfa26d143645a967250a83f269ea8072726a265ef4e854a1f194dd2bbee49579ed860bdee67d6ab664e154b7e9b7d84f5c2e4d7d3a234ae00502563b6b9f151aced5fcae1c91081fb6ea538cf6ec351d99f761138aa65b92b005ad1b54d948ad13c49e76b8d70a34e8942a8ea2bd0609d2b0312e5097b44005ee37ec9fea26a1ad9a4d1d713ae043cfc7c317a8618d563f54a17f6bcdc40eeff487126fccf08d699b68305e3d80290cfeb5f892c60137c92635677cf03605bec8faeed535d2a84b2e116d2588616e12fdf9bb91bef61a4c7a1669af34435c0317b2e72982b68c6ca4213c4c9c0f8adc529a83ebf5f3ecf18ef3d00aa90f56b3ebcd521088d62554a5bd051dda18ebab9f73ead0664bf597f21722fdff31f5427de9bfb41b1ca2be3a9ff5ed9b486a60436c4eb60710c0fc3d46502096f0264f057e8ee985796407c809f3380b4ca7015d347da63bc0d1d062342c224dfa4c8e16611cda5012dacb78cfaebcf7a958a2fcd52dede30b03f80843fad7e733aaed597b4a8c68779df326d51fd7879fb6359e8e58c3d1f9f79c55a7dcf28b22c09cfc5ec62b2fd101c3a63efc3fe5e10b9c2d45ff746bda66384c6bfb4695edcf4faecc71faf99f38d9d0f284ad9ead9d07049dee4684f76c3bfa58f39b26367ee430ea841c29bea36785af02bf71954661859c1e12da451b220e13410f2ab0f43e3f0dd95ca26690d726115dbd7d6a5ddd42a2a6046bd1983c6e8aea05fd1434100d602275a800c27fa60c93a3a959667ba125cd928168c1eb3d2e3fd4181cfd34bf650e50521f48c82074496f56b25758805060018eb47be6a46f5b11dba84fdf53a38b9f5a1dd46eb21fe21848975a116848914c9dcb0fd04586757ee00b0cfb238f763236eeff8e0c5f59f99a2d836215437b02ad223af40387dd27015f0b61007d729ca00caa8ff68242b36bfba3ee4f847385c93f7a8d7dec87369a13d3f6c4d372820daabfefaea407b55944e14a3b14ec6c3b3b2dc3d4add243bea34990b715b1f8aa4121a97458b6caa37821fc25f2b432fdc7f9305c152f9746c1225af97640013e9ff6235e70afe29fddae95afd5d34525db8e617b4a6ff143b3a5e71ab928dffb3a0e99156b41464d3b10a33047e17f11c2a5873097d9be31616134fdf2e6f668df54a75929dfe7bba76e0bf59bb5ac4d827af3cb88fc66c1e4028b35d4abe21cf504edd2ed1e4bb43f801c8d6ef4d865b575a155a5d6cd45bc11fa7460c9c22bc60e485acd5e8ab2348c16333e9ba21892e1478ae2c4b4ef31936553535a2c214b4c0f4c4fc60b21da49ecf6e91510f5e30bc924824a33d4e66e5782d83e6816ae8594a3383a8c643b43329db0ad796d36745d7bc03cead0df1aa94864ec82996970d3ad9ceb834fd77e36f09f4dbf7e83538cdf9d1b954044adea626a3323ea681ba8cda52c67f74164a22c82d608d795e6ee7f376c375e94f5aa5e6c916644c7b6834d91c37b2e6642c670abb696a4bd81e3fd83a660c3f8776527c000c47441fca185c4fef1fe034295617c369c601c89087fa53e20c31f69ad17fabf188c1aac6e9d8cd584b89ad02c67203ee2e078580289fa4d3138ab519710ac4bdb218294ee1c22c4d24a4ac4634fea23fd027727122d970f3eda40a1411b291b635abcbe44ca2247a948737b54090fa8c0a9617f220926cd86e8d7872f4ba7557e976f983cfd05432aa700912ab38f9fe9e3434af5bfbfa156ee14294bdd03666110a646fab128ae84d6db9291c0fea3919367d653c63f0f85e8bc3cdf9230cb474affbb0f42e653a61c50c1e3cadd90777bdaee9300a26208e2b7f42f085f3a59fcd69b617fecf635a2e432a993ef0079a85004898f245ac3945a680342f08b19950a6d2a9d233732952ab4e1587ba89acffeaf6f8b46b48a4cdce2cefcbd97a35070cdd3809fb57dd06f31181cc7882828ef7aecd2e7ea0d9326a7b7e3cafd2424ef6fb1e866cc0be3395120dddb944d5a5c61c4f1918928eade794b64810e4b011d3202b435264ba669e6e9ee49b1f4c32d1c4ea2f3e68569628fe35c1c857d8fb9d4621b898afb2a0bf49a575e61aa3fa13a2857c114889fbd152b0f870b694410ce007106cf9f8850e66628f553e1813ee5d749f12ce9a10ae333c5c02e0b1c4a689ec33b236f22c882efdb82db774695ff500bccb5a390236eab11d13e9ce82ad426a25b9c18e2ebaee9f136d7ee5410cd7197b89d36e66b6b13ff0d0efe34566a9c0e84dc3bd46360371f47543f0316a561d374ee1ee749dbb41b77fc04f96c390df6a21a59b7dfe8148eb5dd766957e1e7129e26422f05595ed56ec0d05d68f66a6feecbbcbaa95c2049ac13654fe104a2123a4ffaf1968d2aae1714df721cf31800c2718c623ff5b970a8e12de718fc1778716885a1b0cb963017bd73a56083b8f4e57aeaabe02de43f6ce31e6b5c9c03fd4dbe392795418e47f7c13c43f9f6846defb1518b6cbe74bff38a283ab7d6c6be4d7629ee7bdad7dee3dcd7cf78dbc28c844d50d84707a41a53e5f1f4dd161804a60233862fe24b552e409affc1e723d3aeb401cedbc3ce1620bac70196b452685f39b1bc86022f2e3d221c87db4eb9f99ef26c1727de027cc4511fb413876ae767f71100ff04f419082822509670861953b6ebcdb5497dca86ee445ec51b79ae126bbce234037175119e3c98ad39d56f191b95b93e276edae94bdd4cf964675d20f8c39950b4cbb9159fba4ba535fa3b4b60950ada5ffe8fa1bb82829248cf28a5c474c77b1b24a734958697ae9dd187fc0181c5b231ce1ddcf9377c2de54b90beef672dcd91e7da06a3440ceb8d52e4307cb6456548044127d4aa5238bee587c422a828794aae0334b3b8b2a9f5f9d9bcc02dad9d97c6422af9f97efe99c0519dc93d14b4c23a7c9517cef61d998f199e86fa0e4e3fa2ebfae0216ceb055349e8019f357d900f025d48c7af4bad9477d8b1262a2276feb7350889ae0928bbf89adb4c55794a3bed6c0efb786eaac3ff0ac6eadd9f915b158d5e1a55361ea0803a3d9fb50136636169506b9b0ccc953cb9387b497d8d45e124687c38c9cfab2bcde37c656d9a74df44cc587dbecac727d1626c6866c91b99dbebd55fccc25f29203e7e8cdd1cc6d20780ef8935b261372178430a4bde7c46bf9444c891d6e4182bcdc9083a8e2920616c40068d61619281069c79081e453955ca19399b488edcc9e1732e19ac820161a0cec11f369f0491f47ebb409a09fa773160cab4b15b006ff69977f4e3eb09d9b45426f1a9760b7b92b6111c61b8dccdbf44434db5cf068ef291c5de43ad191fdf8936568128d9969e3cb4bc909a6fa847c8f5bad9d8fe39c07bc23eb88fea2b6fc253140adf0ea515bcfbbf8c1794a4cb85fd7f5e218a10c801eabe018911bbfd1e7a8bbcf59abe6b47f87e9d1b96f71411ea8d0124e269052cc47ab139f98887614c18755e0254d81191acbdc6ee6bd1e35ddb10bcb5f9c8a44e59f5a94eb068528f56c3d4818dc48a0d98524ba830eb6772324a42c3c456df65ce234263252ee3f9f43fa5989a4749c5ae32f8fcf4655946793a4d43a754d0bae38f3cde57ea3d0825259d8abf7476925b6c28da9f858d370940d1f6baaa9ca6ed3d4a357e3f5e595eee0f785d6cb38e125e0983fa428e1c04986598801e24aca0c9aeb7effc50a8a7e8cf94863b28ca9e548cb4a6cc9eb4acff536a0ebb94fd8d9c3d8aaeafe2271bde2cff2632ff6d209bbd05000b07fa7db2c632e533945ae946188ca6a1ac36b96ff47ac2eb3b587e7181882945e447dbedbccb0081ceecf58040078e856899e98c7581c0cdf64736b4edccd8323da08b8953bd90f83dd3796aea956ba10d8a1181123d3d490ec75ab0977302d88bcbfcaf9b2b737f9e9b7bc97b7c008eb2ee847582f5656727eb57240c38eeed512c91eb522568e3038858b75167c9494fca50f363f61b6a718f7a8efabb957afc3c686c36acc61bfcff792e8a5d425dffc4a88d15d5c13b8e130df302d3500bfae17d80c83a3a8034c066d8bcad8e75a82449a1b8f802721ca18281117ac1209347eae43dbe884c55873a4dd6ba9ef055ee75eed6e3db76becdf5aac512dd4d6eb403ce08e505e2d9a746a48ebb46517268c48875b00164d0483aea5b009c3c1b083fc272823bd1e970e808fd93afe987bb84131b9836e8aab014f85db96352147024936efbe9d064c62e4a5cbe2906e1fcb24bed72bef94c404b3d67d3a43e33fd94b73261de7c5fcb1679fe85250915b7bb8ec1dc226ee5685e3138a59b821ba89c2f99cb3412aa381e22fea23a5eb4b9c5c1818d3004889598a951fe3f41d26e0194db2219109a745918febab9f9fc67ced7ad5631f330832d135708262e7e7581f264cba40d6e73f57d38b63551777ac395618f70d8ffcf6e6bea98b2e585813c9a444c74ac0e8f69f6432364ba93033bde4be48717a2248065aa6c477f6e2e5fef1a94bb92f71be846cb51b463ec24ff5bf4d2fc810a3955b36f9d1b3776c3d13fcfcbf7466a530b85f655de83ce3cee0880664655d794c8dcbde9a2c62df34fce5d8e3b97419b8ea78133cfc37afb760481405919defc9f7658d32f23e9a0b72a7ce5f4fd7711b1fd031d75c416023688aa1fe0a080bd5d5731b08d33d774ef6606ee91586c0f64a281f4a549816bebcb4e756496b12aa1b83bbc1f1d8bc3224860a2b144497318993fc4ea90c0d4104b0f864d1222705e831728f2a74cd73a3853654fbfcf03a7bd8e4a1680efdc24828fc4c53be2e8abc4f322b1cd2ce6453887487141aed6e4fb65f6100e55b611e6b956e97899bcc7feeb51c233cc8e73f1508ca5efb5448c3fd44a73c92149b39cc09f71e9d1d644342d12e6b0bd58499ce6bf9c910611042f6abb2843099bc6b7aa5914b30354c2ed454b1bb5d122f3e98400157857bdcdab897717d7cb6fe4484e0e1cb97d51724aabce4f5f75bf27ca0049c51e138b1e72281f7cc6853b76d9ea3fbe2439d1914575527c1fae6a8b6c6860e6401e14acc0d71fca7048070d9ca66f7b8a5640ab8e799116a1810e1a135306b3d702f9aa550b1274c3f8fff47c22fdab1f1bde5a7e97b3c0184353255072ead59a5fba048de56890fb2a89ff4f7ced875a3eea696154e219a692748b1c229f1142f45365d7a96ab68a6b1e3d999584f8e67af55375cb9978f34afb3d50f2cbc9d3ddd120fe6ac480740ea8307e6c1004aa129c0b5e2b83097ba269b925b4217bbc1f2dc2bc930cc33bc51487238d87cc9d977a29edf741444a2ca89712dc7bf72f2a5a43787533a9c7ea3e7efac7d1c834450868c5ea400fbffbafe853769fd13237ff2633a33367d0f502ec9bfa657eb3b764fdbe92b949ce22f7eacf79d06745288f68621f7ec7a604c7bdb0d571e16c8d6cb594cc42a4610ef7aea9a29fe3994cc01301ff49f7543fd2b3282da734d45f0ba70c4b182874bbbf7de54b93d249bbf5a749398634a9b32fb053c01dca3305e20b9716921ab7c51e62f2e47dc6c91e2a27bdf22eed91a92e8d454c97866d22e6f374db1173075e0ec67e55fe31bbe63efdb80b35c96b48d96db9164a3e50cdd4aa41b6623e19f06aa61593edb39ce0723665404dfa144d5405d79874d3c5edf7fbf57b0974fadf41deff1bb4157310912fb7afe6ba44e617fb502452f45c4ef593ca3dac31b67cff84d26ca7c0bdbc4b0d00a02bb98a71ea624f257bb3abcebd3169723ead45a140a4ee6e8a40096b71bf8ac693bba76b53e810ff3f14d95ca4b1a121fb5a3494e8eadfbaa13ddd72728ff5c2e9c1a75ab1147afaabbb7f207c0229f9ad6b7ff04c43879bb1cd00bed5fb070ec913d02ce362c0f31f546e97a472284ddd0863bef91efffeebf919316e5b43aaad4c3183a90309deb0157871ba4f2c26d0a54e2591db75253907d008a86ede9b132143a7326352e6f4419f4c9b765edcd5c4d684ef51ecdef389aa051ff80086975b2f670ac830f1a54db21bacace9e561e953f5a676a62e136f34d3c86382667ae732ed241aae8ce8bff5ceea91f5674a9273f648a16e335c23335fdaf4333337a1c8d3625882680b40c14a9437bda9cdf0685ca9d108f60c04058f0b5243a0fb4fa84d7960c7d45d61e34c3b1507179552b5960dd3c5413ce67c69334533a4477ef97a387d423c233bdb9900ffaf7dd6aed6f7f57757d9ebf64b0d89e4724a1813b167aa7cd4490973335da10552fee1c9ef8ce1d60963a8a568a38f5f57c470ce8513c252ec5ffe88b7be6f719ef54782fb61838a7f414d0376a938248502ec30d06e6ee208c94befca6a7aac319f100c9f231c95cdc5bec908031c0291af3b3ab0333c910cdb99a53c8e0df915e173274690ca937148079060de816ac2b11c0f2202fb568308e685fd0874e5a10a19f2773c37a00c45f3093140ce4ebaa1bca0a55e68b7112fd88dfedaa88277bde752c2c673b0c1a9d9b49c7cecf872b7c389ff530844d652d6489334cf9b7d148f232707b2e88a8159f6db035a57a9f1e85ffdf0d0b3046c49e835a0376607fddcca5858cbacda3359a565c253c5982f16f557f9d17cf36464608ac31c9cbb095ac6f6888a5ff5bbd4b05f8be132466db50ae0419eeca5f53e3b4e4d4c6ca2062edc7180607b3ed106e9713647da396c11c2863807eb91867ef4ed0e2335c4c129d26fa6d92d0dae57b440a949e66adea7a28e605f7c081b6df04e85ccebd34d077396f35e7936c7d228eb572d89d59fa1694569a0a4e73b699aa5fcf9c091ceabc055f69427efa6fb00ce6a5401289fef5e14de32ac910c67d6f1aca886a271eac20ffa8efa7789ce5a705d5fde176e5a2a780b7a2c98277cf86926ed6d4eb4c3599c6a9873e4b599270c7258f119f86fded73e53901ca422c65690b2dbc96c14b112a80c2293625f977706e4fc2ea91f7e0c4adc887e7658c91d6bbebbe52fcd328b8780ffde29b62e30aaf9542be6fd0de4c5c92544296ddf984cd7f96ac6553ed15e5a64b7ebe59dbfec9f253988ff138fc365dd00282660fb4a011938eab1c1f378b13adcd270f2b810d3ce4390dc32f7d72d7fbe031cf6b9a93bdbd2934192512b4e8afa33e4151b7dbf93860559dfe1d8e16df1d78d910502cb27834410d0ee851edcca10a238114652495f25d2cf7c24ac6a0bc7f3ab173ccb3dccf44d8d29fd7b111593639d229bea573ea3eead0f8a37cda8d5e65626f02ec311000fdfc796d19dd8038c27da76144f566e3692ca9ae6a90b781454320154adf97fe8a8544158524d125d31e780d8fb61a5478ca6e25fe41d3fcb885d3312fdccd7e4086172cce7e03d8bd2cf270bae2a213b844df2d1140c90f7f85687db9dd0db390420fc9f472dc72bc8a51fecf418a6eee6303ec9b610579f65abe5da19d656b69afb8f2872634f730edbe8a1bbcc77a6fd3ff3d0936f0727f56d8e855d54e75b1b266b05b6343b3ff0303f45959064be0fa11ea9b6d1482336f58ee994efa60588ed602fc9f5cd4bf13566d392f97d687dc69f3c321fcc3ef5354598d8be13e8ea51dfc1c388ebd30e5bfcf6aaea9a741c2170ecfa1c9c8fe2a2791e79f1000aaa102618fa1c87b9f620ea28a0224029ac763c9e882864d21e24e0e2f0569b53134afd3857220492f6c9af37ee76e9e504d472749c0d64bf3d56aac41c6eaac70fbe9c2df249ca11862fe485588280d7156eef396405a1d270bb217bc50b7d1ef06e75ba95c6f7a06d90c2271b474b457f63a0fffe4346404f6754e9d23ff2a43e14774b0906105dd4728a696be19a45215227ed5e70113ac064d7987f1fc8efad43a8d773fa9a1e492f7a02e741f8a45a98f7bf9803b2c000c66222b95d2bbd7698d0be615e96d96ac0fc9e5a52b4fce4911641c27d4adf525553fb8c0f5d46f6f368d41faac062d6679f6f3caa142f2eefa0f6783b972e4bcfc175587614bdb2ba0b08d415f14f2c7ce71203c94213a0ab05fd6effbd7212cd86028a5c787a329619b2e7e5f3e245649b57407e958dc846a4ac87d36c3442431e37d5afa5c49d6076bacd92338ae063dccb1cdb04a2b37b4f26ce02c94de1e96c41918f6232fbb7b8cbcd80a0b50ac09ca76738d95087e7940ba03fea70790cb4654b09cf6ff4389baa2b1f5fb455980529aa7a90fbda02541fcaa6e95ddc7f251928d8dffd29a3fd3673a7aed1c8b4ba9721b55f46f672703f9db87232de5727b771e419e9a6def8e527aa9c98b9f44cbd179f39b1c080398bc3a2de55c43b40aca722f6cff9d2e1b8c53e79fe2a933f91d3f62819dbaf4efe50b185af0e10c8ad62a83b2e0d4a49c53a007d8d9926c9fe27802711588362cc77a4e4fb3d34fbb6f2316c9f64e54f4f0ccc01e27d1c815c086d566f3e39a606256e2776450f95980fea0f51d4838708ea8857a3e7483a8579f6010ecd9025a2b467e9ca6bef7b1741de92a9f14778391e3dd35f69c5d1667c4de9ac6a176e53834a49339b6b5195a861957af43d2cada23fa115386d2658421af064d034156db4a4974189888db8e9dc16563fcb1b692b743c7f52c269c5c378a76c7edbd115e8a0a6053953723f4199495d6897477de5d08d58e9858103e30707e4709ea5be3abf03d466f6be5655e710206b8eac4d0e30271c910a7499db23d7785a52b22a82c4f1500536618d3342f34cb6fafe36e4de8cdf5b8f01a2082c64480380ed07904369839a2b61af5bfbd6493053b6b33aefa6b0c3870d43f3abeae5773a99d6725ae435861443aec2d862e2c21e55099edfa39ab8d4c77fb4bea9cb9bd134511e26931d8061319e82b35f7a967581efb978dc3d6010fd820098de81444fb47b5aa4b88c908ee79b40a42ed58a7e37d9dde168a221b3fb580339824d23b2f59f5367a8fd0814e76e53b11875a5c38bf51161cbf3b08acde21e627433fed1f962d1bfb2e926d9558fabd7c97f20c6fa503969c525c2ede7a634fd973e25c6bd5af6e2d627ebe8387c978d6f4175bec36813cc90c20902d5fd9b6379a08961bb3c460b13291eabb92495a7879ca959430d135d22cd03b9152e05c563c7cb7e6e07ee644bbf825da506c19dc4f8fa3ce0632038691cf90464a29afdb49be61ddef5ea6c47b9607f8428ca46db8102ac321f5619255d27130a2e54243f42a27da2553c9f37f5f559f8e4d7d4d81b97a87fbf1606cb79968d19d55855071d4941eceb4804ae18fa9f2781a85b9411d424a29dff9ab4f724438c77f362ee00bbe2a3234f53b324037bd9f708f5e407e32c5eeb72c66d1e37af3920788701bd4adaec92e197cac8620730f964a46f1f5ba1e6e76d3e9afba15b030eb83479b3a48fac9ee382d3e36804b3a2edde38d3948080cf60f8fb141c610c5346b59d3dbf03267a4edc8a2945b8dccb256ac08ac28f92eaca3de286883ab1615e32c2cb26290d1a91a454f4bc7123eae673694d0386dc3467623ba9038830dd4ed67135542978c64bddc9d487fdb4422523e351f5fe911952b358f413e356d976fba40ebc49b61d61dc07d002478ce5a49656812a8072ca793fcfcaaf71e346fbb2fa18fe133046ffb7c3d9c8e6b1638510edcfeacac535fa0fa7d34b1b739a7053473061e8492c56fa9d6dad7f1c8c79aa261d566a9938c7ad0aafb61b3758f77f4dadb1df0aea8f2d7cb177db096419070bce2f13414da877596bcfa3d52c8dbbad15b6c4d8af7408e833930804dca0becc990024e0918c3bb41c170581a6157c61331244415605060940c1c2e5f8f6973c17aea7570e0fffb7e26761b115e0dea2f44d3c2a1c256450ef35f071210c44ef92a4e900ebc5b61b9364accd2225dd189cadb91e0e6c08ae3d4d6dfa4b43e0a52b1116708322d7604b01fe0539f2b48f371c5ba2f3e53cf373427177fdb390e57fabb9ff4e8792e563e6f8c124a144dcccf6f74081c0b72490b0ed17056277537788fd053e515ad20c595bbc261a18772c114915c45ec862737961c9647b7d7efbfc4ed7e03efe3921697821f90f5cb48df313a00e8fd0c39b740a1f9ca2f01c7e0b39e32e895002cdf4280e91f2d3c281ee7739436823b27d5081715a6f6bacd71faf8e0f724357c83872e059d7b8b44d33559479e2a804910d09bbc707761df29dfda7073c0aea9304fcbf26c451c490cea79ed4cd677838ac7986de14ca8ab669be71dc0d076789973514662f13f7f2fb49a9ed213ef42a680c8b6e81e7a136a470027a83742c56316f3d0caa6fe1caea8bfd7f5d48762e350727d77aeb01a9a3e8588451327e96bd6c6286202d2ff0d2ef9e855aef238394560e929cc68d371d98130741fa9002974ba1eb50770fdad2902b2dfe75d388a99565e1c6d8c1df3e3518255ae9016c3a3c435a8d1240bad72f330399d7fbdb1598a4b14d95b8561ac878d63d87b9673c65df33bdb7191aba86a24fcd28f342377231397c6c55a32de74be22e3bde61484c7fb13c2df350037171d6fb1e5c2b49bf35a97e5a569181f4b72c3c79a4b2e9a79088fff92829805efc6748df09ded396c4e1844e26fbc472a86f5d9a129bea89c3aa13808b12864ffc13f7e8bd6d4eb5a594f775f50d3f6898cf30e2e46460fa518c0176d11783b46d78d88996da45062e7516bf20ec097c432a285e026758915013e972cee0e3cdbf0fe7ef921ba53de9ea294212e817168446a031e5ba2d78afc98a91abe98a6dffbf830c6f71ee6b98dcbc8766bf33cb3cf6c976b35b7217b718b6cc5cc108f00bb06037d3dee81641f2a6765390511cfdb3cbb65f64c2d84b9c5cbe59a02f2613f4ecc78d66f8d6170d8e7de49cc529121757dc3286dd15e785f408eea5d8afa791fb518a5f47e8663906e266b3116fe66a04b6216880fb489c65fd71a8f3f2c755812fe5db196624df0060869b6cc374f74d2d0630bc4f214f183ea44edf7fdd900ac15ee6f65e01c30ebbfd204eeb9e920b980418c2fb6ed32e0eda364641ee42de931669508c42cf74f9867dab280130a690947cbfc65447645ac49fb2209b6cea7ded291a0de261fa67a19aaac133d5b7d8e61435c386f695dda479279970c838c5b943afd6a028881e5516c8b6285a6296f1747ae8829bc45b9b71f8092fb1134db5fb5c643c6cac832aa638ada31dd3f1017369b8871bbf1cbc228597f01d2d7506812014bd6a27f85d86c92060e0f14c073d9e3d9da1a7d1c34d8d7331a545a8131876789f9118990414db04c25803d4d11c3c788bf0379a2943b17968f1da04912fec1464601a7eb2a06e862105c9da480e905a84e86956282841e94cf99281f9acd3324cb64c93d4f8ec21a8be50dc67fd7ff680baa0224d250d33508d058a38ebbb461af6972eb587aa1ee397ac26761c88c09a62a62b5b9b3b09eb88c9d01278b87e79b0fd59a1375cfeae7af3f6cdfb65f9dc74d9f56d878cbe119376d20d506a6319904c756a0647f150f95c890b6937026bb3e815071dca5f60b641df3e754fa157d81b8c3ef0faf0abdaab1ef2606734a10f073a200c1a3cd9eaf32396e37d7c8e331ef9a3af1256616cdf05e947be9e6a0a61c93ea4f65552cc788d5358d45ebc5003511faab890fe9d726c120bc43f8cb0e928eba7f6a35aa20c68486a14b27549d357b50c3b766922a5a60e07ea533af66322f186076df7cd7477fcae7d9aa8f0fe634cd2e8b911b9bdcff438476e1289a11600cbafa12b81058fcb377537bbce9c4f3ac3a8773c3b942ee0a0767f60ff977e09f8a8a56bcf38233e181523eb6dd27d5ec1b12e93f91fa5509379421be1b9456a6c2f8efeb7509a67ebcd9dc121d0663e49c84b1e812dcc46dc21e7de58740e6e0fb15d9d4e88fbfa7d621078c493760019e1ebfbebe68e18258c9909dfb0ea2b9f1e3de8c9ff52d8eb269424cdf5c0b9c8f680faad8f04852dc411ad4431ead0d6275214cc1b777f97643ae430016ae33e9d04fd7ae99c211773ce4e9ba7d067280297c00e663f05572b29d244a28c2ae6306ebf075be212838d11d144a7ee5c16816df3589d3f902992b66e4752f1eab1e86cd5d056ceb82cf45399605a783f115abdef635a6f96ea7a5b40d9645f8988a792252c3860a882815ccc34f8874df4c5389572e559a0dc9a616971a6904d6e8b98aa86c95bd9203fcbdf067418368d7c7013c425645b748505379489ec459d9e1255d71c91b2425721635ff15a6c872e5bb45425c8045ba7c86987f742aa411866e6c131e65749acaf63c6fd5bc2689f3f8a75f1e34579930cd2f7f07fab66521729529c0476c835d848e221470436543a3984f7e99aecbed238da159e3d0e867c03c2c7cc9e606a45bfe69376e05b54b52a8f0b181448d9f735140cc43029a785534723ca75b5d79c2590a1caf3b7163fdc8eec156df0db675849271e05e1b5d0d0dd8885282d101719a6f9d659c50619e4dad4ccea85aceb3aee0a597d6fab82b89deae1467969f8a653030e42b906ef2604f9a676ebe4109ba1a7f3aa1a8732e84c1402d1f7f7e29479dbacfd8fcc22dd98624cc5c11a351660a2d8e04618bd3e6cbd8f1c50fc713bbec848aa78a4e9f78b57514310a151ae495b41891fbe994dc5b4708838b61dd35f1df33c53db0dbed265d70712e3c9fa864386d18151120a31128482104fb81ed7027d463976c18250a5c932a618caadbb89544b5b647d37763f7b111075108f25caa9d929a637ba9edd20b3cc2f60ae39461b546ad5cbdee6de70ca095d31810ad0431fb285ce0d4def8bc2b71c7d261a94da54625622b05ab5535d869ef0f9886d59668b8e334e77de14b02c65a56d601d865760baa1e3a4ba16aa45efde2718d71497dc8a865e0f178b2b0e07dbc50b8a63d43878d44ab3d6e806acc4b008e07f9c25357c5e7e9edcac1d1d266f1b615ff1d63eaf240a88b2381e58d01aa44b3e6b520b5cc6176e11005f95ee2c1361e96f7bee4e1616bfc737e927c55b450ef4936d46f433fd4b4993f08e4ae3d6a498fafba6276c9c9905a50ff932bf33ca9eea9eda3e54f46fe4aeb73b419df23ebce060a38d4808b2fa3488c1895c24d0e8edb5fb423c4986857f560422a7bf4e3b6e12302a97c4c6a98d6f5fc0a643831b9e4a6d2de44119ebc1ab3eb4a8f478a924841421b660cf39dbabf0f42ec780e8384b113eb2212c61a5df33529730a8a396b45f4c9e3beedc6dd2f674f7c99fc3c39baf2c077245b331eae94ddaf9b562cb0e29901fad500e17b2362538aad7369452e6af50a2f347e9046d29a00a9e5f5f083284784b2a5d459f772e3d922ab6fea919272ff892a9011076040f94308c37209c46aa014112797f471fc14b5fc3526a3cf2750c603912b0100739ffad4ea26b20fc90b789999e16edda43105f74279b3594e7642932f6a210cb9b6d804b5d279a184aee70e475624ed4e5d4ff7acfd4105a38899677dea747055868d8d3ab2f105685d17941078282d1d5f2be4087cb0a39f520d99d2bfe48d3a16893b1295af2b680a79fa16ba7f7bc3f05f815067ae137098e9be83e89581ca9c626931550b15ccd3d08bf909257217e4a95b045a8d8b156d5f50f976fd5a797b28041a811f4b8e348197642b28ca9a3ac2f0bd86e3ea7659d28bd533a06f094b9515d42e5c8fa59ff8d096b4663cad7639d7d322ada4ea23bfde6e554d43f7f95c392f76b5a7c8e397138fbee192a40209810cb4e8a81a976e4bf2e2cff6d91d2c4959c0c4c25db45d20c3cceb58e30b7ecf96611f1d71d4f6b419f42954699624b99f1d22e1f536dbc143db96c04a28cde24965fde84881b68af7508e17cc3d21f8780f802b2df7a6e1d45420f8dd93f4aab7f2e1e2b026b380eccf719fe45aff80fdf2fb4239535db2c0566d496bef19ac733701b3a4f0222d5d5f49a2bd7d8c8be32f7f81b05c49411d991d2bbfd1b3fdde7999ea302cde90f82c185086a41de396854efc5a638919d9dbb559d94b1c72617f5f0215d001c3eca49231947ef75846ce145a314bcce8722c0b335784ce9125c403b28b15b271fbca3a826f6340e096e9f7572a765c2fc57c5c1bd12b5318154fbae6439008c83a0d85a669f8b00c00645152ae07b8e65f095f724cb172460c26f914b3b48a43ad2526ad995af5a9bea977ec23a440d75bb451beb2b4d9c1ea1e750d5e723d197f12a212bf453911498cecefcf5d1c1cf9601315a0fcfdc518bf75ae24395f0a8876ef3c13c74be939cc895e220f1885e91b9da0804598db3223b83d6642a4cbef75b7302ffe583cdea7dacf655ae03ab2840e8a2cb76c6f82e34db74a7ee36314ed16fd33d8d150db29a7ece767db9863e1e3b9577a32ea1f573d51ef7b9d974a0020b3b3d2d0e62773cf0c65cfb7a0de3daa165532d0e3050d58c240af1e5e329c7af41dafefd519ef2a92230f1eec50ae2fa369315fe31f6e34a375054fb0f5c03b8ba81f1a3c025834f20e9c0d0413960f7dd9cd98ddff71c0489ee93ce15d555f0a8f29b5c7d7b9d283a45bf874c909d8e0058a739efb0af94b90cb740b7f103a761d16ba7c5b8fb4d849be7608e9b5da286d226d481d6c8d22decdd6939a82ad39165ce15779458bb4e1ce5bdba57a21bbb092ba955352b7cb587aa209727376c14c821e109ce28f543a549b47ff27b0d7bd5a7366406633f9774cf0f332a0b1581aae9b91fd1549cfe995330ee156d2b14d0b45314bee74cdcdd45cf4ce1396ee611342fe8f2d95ec90bd4e76e97bee3a2a4aa2914a041c4bab72e70c9b2286a140ac61a08099b12be871adb165bc423ce3c18d3340b50232e25d3b3c6945b0c42ede6aa57c417560d711f00f8a24458e83d66c5ddc8e1f0408c822586fc16c49591518538d6fc0ec15994519a02fb799296dcc4d80f58402a97e01609f3929a6be3e2cf29fca94751fdde6cc3ccbe80366d5cc82f98d96523e32e88f8be0a889040ceab055c33e66e6c15381d283314c2508565d681f9a16b99bdd06487458f3904c5c10723c457e980fb38b7567df8e73cc6573577869ad1360deaa4adf533a409078624a161c093860645c07176db31f6a6e1a5430c829ecd60200d96e8dc8a15994702a7cf1a19cc58f361447429c714269f402f6f634fbec8a376a3271f6fcd719ffb7e0590e48a8882be3f1f5d617a8b2e53ac35df8bc4554ba3e367c05fbc8c6b40a0ae701cc59f4ecf0bd8d0c16c64d7b52795a6a546317121176d4550bba1e20cdd7d04de4afa69604d08115fb6b2b3f9708b3bf4333eea0336d7a446dad349723e719f435fc4b0921e199d1d49e91fc3cdeb6389e2a18e37ce355d0dfb9df7835725405af0cd0868feed210d746631d788e31181b873b902fe160d5dfb67aa460caae09797efa4c0f2f6dac47b60420b3823cf4399ff72553b91ac137b81814354df5c1a1e97cf99121cf68fb326dd561ad4415247ce422e5feb61c63199f84391ccf551f2c854e95d1924c28192288dcb5e879de610e9d1333169c8d24611d90389137048f9ce54a664380c3f482bda79e6bbc2c505df855e794a661e2323fe9f2cce717ad8f8c44722f3c6ec26f7a000a7a1ce14a5a98436838fde17dc9c30dec285f6bdda75010f7082ab4fc92f6bfed01e4bc9ee402fd707bab4cc6326215200d3e28458a1ccb48bbd101d2e69bb3d44e51374bab3444cb25d3a19641d095c6a66724a4c656dcff6a4440be5a7c3d46e2b89ca720d92424d9fda4fa582d098d8bda425fd65dc94d62c400e508f7bf63644509eaca5cb7b466df9466fb498861dbd8b2c9626d5851097f68ce35bb1a71abf14a21c33cb87b292fb27769e271ad1440622d60b95bd6232fc55a0750c936b423ec3522afcbd35686622e79d557f90939b966f5245a4832c0b0c468194ffbea39f714519e320ac6a762432772ce189ccaabfda4616200a366c136213a89f31ff8bcc09d5f469fa786380f7f6a4b45d915903410179ffcd7dec44677db629a401fea8a89f272f365df384f84e40cad073f399390cfd1623da2aaf824694e2a3a3fe499c2e1767169653d226a0396cad9efa12832a8e95df5bd3637e2a84c327debb5e65f51fbb47882ddef661c60f3785178e381cbe7772a5f15e16fc5cc7e3a50494f5cba62884e93f5cd7f7865941b9ee19a438aff57cf5a8de5c673fee801a0dec1e78730edd0b84f9689d268b4b784e35139010e1887c9da34bfafba9fcbab609aa28925eb0b066a7af33f7c154d8928b6bab8c1567e5f8aeea09b370420640bdca715b024a82a4dd4f59e4dabf0e798c7e83ef524f2be89c7264cf01d757de6cc5dfdc13d9b92c252e15dd1b858fd9a2400fdcba2fd79256403a4fbaf51fce4c0875988857161ec989ec9b26d5ba379e05030c96d7d18c51fd5f8acfc01d3fa02b1a7575243a2f78a61e00160bdd74091bfd6516ff7bb0f091af21cbb2335e8f5fec34c8c955f8762f6773f755276a3473bc230dcf7c67083b202e34f97ff5a2cdd1369c232c9c924963ececf6fa664fa881fd6a3391a96246b13949b21226e8db9bbc305f2aae0b21fc96a70f6393e2cc1162761106514689d78420a740f978ccbb4ad35883f5967f2d03d9ffc34537452bd37a5192e9245d577993faa6c497839ad8b198a89b051bdc5255d7228d9b77044f14d537ad1670ab9b5f7308623cdea57e02213d844795ce7bc543ffff1be8168b593d9f7a0fd4626e8846f55aba646c5b20c4cc521df3ad4dd8b451afb4df333349eaa3e75a5665e73e42cfd462847c2ddddeff2e8d3b2fca872e8aaa9773d6448325f41badcf5dc1462104d42acbcb514c60877d597f2e01cdd1fe1b8d3984c2dbd7c6817891c14cb853fc4d0c936c64b7907513ec38f7943f96864311dc1ea2da6f5256581f1c5ed91d337bc1ef67883bbfb2ea72a7a82854cfa6513d764b16e08f9f8d027648946cca1b4e92515288955e6042cbc35d96b5086293e89a9deea831ca88f590bd425c892892c63b59748158c0e93afbda160bc0b20f20beafd8021996bf110ad93b1f1cf7b8d48162e85eca22a1ab9e249a5d16ac558e63f9a0fd2eb4b0ddd362bcc5d9ae434971f41c101e09e88f8336c13f9b8116a3e919819059c61cce67d476fb4e87a02dc9dc9ff4853488b2646867928ed53c6746351585617bd86b269f432fe3428a638ce5a715740df70882eb71c85e3acc31d095b894077bbe891ff843a83c4ebd68565bd11f36ba8729f9950c579ee2b2e11c7814c15458907c039c9e379bad12604529305c580ee5d4a65bbb3c382bcb582d0536c1ff61ca82fe91c5a047613d2d7cbb79d3cdd8387f2902cf42e763dd5206d9efc41b8d8c5d26685079f267bb61ab4cbd5c408fe6d58f32fabfba1210a144ea46753af67c032043323daf282edceff319b52612f6b61b3e2439d18a69e77e8d8af64c1f2c8c9fde5230e894bdf4c001e877777480449820f7b3faf0af9584d67738749b943738cc12ac084a36f8af6d64a3f295dc9d8eddbbdb80902eb8752a17fe88d391647e96ea70fa6018f06753e0f87533d8d2b37dc1cd9dbc8c794fbd9722a8076efee05ce6ce394604966c054e7532f578db3aff07e491476c51a7c69038a853e915094c69a84d09f1977f185021d67654d858b593b45a88bfc9c6cf67af24579cd8f1e41aa164a5c1eb3ddd5c3be4108ad1a014da55b5e99759c54300e011a3e42710c76f974abfd5541620a534a31703e8d6df0eb29d182536816e6914874010f5cc8db625b29a15cf4e841c05e610a85f8c64d35202f8d79a5ed8199920c914195ffcd61318f77554241b842f8fea3132e44e8c41cb4953c60d7fdf7edb73eb6abc61b0494ccce0ef7ebf5527dd60945c092b96f3e20c630412d67a2501ab2590470da42a92809895ad0a3aeed91a3e85177fe81e6eb1f29246affde6736ab91b7f99f987149981d7fabccf334aab2245094f6aefde5e4837983dd2242436bc8a7497596ef5e9388e0bcdc93e1d71302906ce5e3cab519cb68183c61f0e1241d92390ff36e8749f161f3ac31085926c529606f09c1058dc855a3e2d83b14b957d105a6e9c70a7b4adfc625b130ebd2055924e95ebe3392003e03fd6fc7dd7cd9f816d4d54369f6572f36e2099f9b091f37ddb6ad3a56bcfb0e00e6cc7c326eadc587d1a5b5429a2a3ec0697e496b7b9eee78bdfe83e29dca91f4e372d312d5c6a6d831ef474dd468b5f036246d1e53124bf162f9a02bb54096633601de312da622f1a9a1e7b48d85d067bb241e0faacc9695818b1943d47a13686d4b787635056871adafa316460149c3ae48999d561216ab9cd2a8c14bd77c05909a2b47fd18b50b2459d0eb7d0d6be757f7549ccd4bf57521bdb6428d40ffda500cc0bb554afe41244f2d3917d2d01770b475d626402a9c7ff746c848378c8554f4ce686641ded9fa831eadf42d32dd159d4b36e1a28bb25ae74081d584b1ea75228ebb670f80e207c829e52a090f7bc5ba4c1da6f1faa949a8800c4515c9446e0148377ae968fab712cb3c281abd0e2701200b4f493ba709197d5d5915bda7e7c5082932b3f53562134aa44bdc5aea90083d039aec775f6d1c1c26b78ee42a0b7a827bb53480a60750b2f134fe6abff1d87b7115d8450c8c3a3a01c5c4f1f08439854b5e5d695011262e634c4f407a4441723fd5bdcfe3c2d4707b13b7f94278ff00dc36c05e00cc3ded82fd796e973198c41d2bf1e89663b8d8b7f7d34661452aefcd46208e09d16084eef7fe511ac72cbce518f85c780407ec3fa8fba3dfac0a7e7efd6c88db669de027ed5b5113a35986376d68f2c2b25b576fce4fb5502c2139bf9d8a351deb800e0c074159331e003ead92803a91696043a0e6a29dcc27426bfe2532c9a442ed12254d1af093e95801b239c47585840e9c46629d9a791594ce243854660ea8150c27a41d66ac2bc5bfd78ec91ced1791487f22f5d231a8d0d2c502334da0e90101cf8ffb4afebfb95187a5404694601a2845465e663a3b0c54dd690bb50566dfb0fb61c92d4bc1dfa6e1d02272a6764a32c759bc21011e5a2e7b9fe7368ba8d640094e6005e25dff8b666a9605d33211303bcc993dd454a0faf528e0edad489ae5418a4f390e6acf84080305677afed54e43d9d37d4a0fa5a9b25b6182fab3b12465a8e22669c987e8f6e86d30dbea246cb6ffc7df7fe5d31291e78b8a9f6bf4da0c2677404c6ce582f1b7a29e4270a5474045048c2e267302fca887982fa06d01ecf0f0a3d45902712e8a93eeb2df7be511bf15ae987aa367828841c6a6fe7b528869cccfb2440abb390506cda8146dd992b3529dbe992aa8718eb7750f7862ff5492eca9292947fb92a86560b9ccd6ad34859626ca7b244c9303a70f11752547a0651e150ec60943bd6cbbffee13e61fb49e329362c7a5b08c7f0c590b783f34447b58a26d702aa808e9cac89b039d0aac2fcd917220ee062c026c4cb5d4a566bb4f9f9191c026b94653fa74e0657e4876d1112c9f71bcfb61d18e4bfeeab40230914ed1b6993f0a2ebed4bf6269ecc36b0bb7a1610f3c02ad1847c753658d3911098da76de4380ab5990717b6c38b7ad4db091f6c227ca41f3127543c69b664590c6bb4623018fc915bc26c378e9c52f0839878d061e66e188fddf7550ffd1c07eec9d9b74245f0f81ecf07c5126a98016d8deabd68f5bd98313f63b74fe728747d05287a89032e1175fa0396f34931916b729cb0d89db53a5c8e21856f58e3bfdc16d59ce699a5e0ef4b8841e4f1d2b1fbbf800e4852bf67de38d4f111175b07b8d1ba8dbf9cd72d9e78d6ab361ee153558ff3d573f0f194c5f8f4479959006d0c08f9bb0d61232614f7d4e1033ff508e12dd7dd4224c4fd6f88e345edc7ca8f756c078eac35bde486b0814b2e7556c9baaaebf7f93a355a93bf96af2c92915e391e458e359b74f611941f5fba2c001f8e3d6aafff55cdeb21f40c11148c6597643a89aaccab82e6a8f3c30e014333ba3718cdca5c15b074c77db909f35924b1ad421302858bf2f889b9815f87149c232725b7bc08447b42e56261e4c4b3e38c027c108c24389bd03e9526f700e34e7252db54d533e8f8991e151ba4905cd36ed1e89596554e29ae354c0b3347a89695cc4232e45675be1240cdcbe45d2b4c6f49badb874c4f0b464a8e94f042cf4edc75a42bd597c2476a0f0155924ef8cb56568d0fb1a774cd6f79a1ce9b7ba0b2a725c63d2f57e5fbb89ce4c64a7c8667638fc9d678794ad464632f14e7c8e2e3e45e552531efcdd59d38aa6a2f573adae1bdba5f8f80fdd4113b0c3a3b7a0e25c8b480b8a53d760580fa2b71306e684f978140fb6e8b55190866483f65b0353e15f7ff1b569cf208f829c8840202ad07913d2b1f45a7124d7e25ba744ac85feb20ef3126a6bd1799c322166af19a67e07e9e6c838e56fb92372463d86e8637175837e019a03c82bd106b7495bb2f23621f030018f135c5a5a105f9559c2b0f2406b2743be4cdad2df63d90d3883ba2b6bc43b18cf4cf26792b70ab6e6b6ed0dd0af6c449ec3884b7de0ba5adbdaa5d2a39ea6c6246f77955034e33d5a12e3d472f23f3c311f66f7707ee2f2c495621b1bc1ae16887b20c54509b85a650737a99c67bab2372609c43c54a04413adbf9f7a009c61da81bd5289f1f20205e14a98823b6f0ad2952134c36838b4b9cab1821339403fc7c24716f75c5732ed1a9135def607519b7da8dc900d7e8aaf6237ec25239a71d8d12ade3ba8d9a73ef1a5fb83075cc8bdab74f76095cbd71cfe95de7c3555e678cda7c86b5425259b062780241025254b504eecd20b04b4846cb175968a2df9dc408b41421346348b88867efbe6e42565ca22990ffc91b4955c238be3706f47cd200cd48328618ae657d954184c11c8b0551b9fe381a4e1551ce8709c1ca2ce7195902095f625d54fa0e27c7a83c1af58875b61fe646c494d5372d71aeb17cd971fa0757464dc42564b3e6accdd78ed30ac07b671ca8f4a4916fe493cd8a153e23721a99ba4cf61b62f93f7ff2165e6aefc892a544cdac330bb191767864cbdd0e9744d3c5db1285572a711765caaee23217286acedd9ea7986943dde9283736e4ef18b2986b3a851d37276ee95fca31917f83a31b1c38a660cd999de3c3e2bc3713de68f739d1734954c6d7811e6ea129e092ff1476bc888f59168f97eb55d6c83c1b15976e77f5f5d17339d7663e93b6c2147cf7f60babb15b085730927f63288b6b5b2f1365d574b7d7e07151f89d840140af2038beeb4ae7973c437e07c3ffbcfb7835f787fdd7ee40efd53d128b367a6b81f65856f41d04f7d656c68e497cee3ab40c10bc4ceec4d98871f6d243eb615477f75438e83a523f6608cd667494a4c208b4d640ef64061257f71bb7b32f3095824167796600047ca0ace3f5060c79e56e079aa447d3f8367d5f8463c5fb1d4644bc14dc23f12dc064627f55fb0235520154ddb5f52b37f5e7b9adfdac00121ffc3e0c080e60ad3c87cc4f619c78455be377cd6497672103b5f59c64291da53a179fef897319a43174ee8ca7a37b52b4c02f3d9c820024414aec06df4902d8a41e18bbc190397c3cc5ec6bb0b15fca118a2f470c7e6350683c5900c8ad06d6073ed53830126fe5169d08abbbdecea480d1aa69a659b0bd15c6e99da4b82ec557926fca81b792af2f14599b9d3f526ce452a503142384d572a93d02debd0de93f235bc6e00bc1c6c9ac8c0362fbc5d3fe057e91ebea4bdbe23fc247f2cf1fc4bb5d119cb8ea456950260413b582c8a7bf85a762c0331080d1a782d48acac67a781f1ccbac5e8c43dee3c2524fb7da5fb27b318bc9469eece8ba355758a21723332239ac406e51d897e488644202d7d31232429ed16be1c1c39ce18063c7c628d30877a69e8c918dfebd10369fc47f6a8e2812e744bd02114ed23d646ac72e65e13f58e101f7f33fa48aa1b93e56d1d70a7a0e26cad5a431c00d15cf4150df12e15ade7ec28ac46eea5cb2fe4cf9b904a29a07024507e57cd37d23b2c3ee2e92a1c04ad3f83f597ed4d29915c650a3c1a6e110c1f3c94ea8319beec717ecbc9871ad03a87459404b5d63bf8950fa93d5c059ee86676c517df01156a1519122234dc8d38099f5c6fb60c246c042f5718c3f42ae1ad99777c0d6e12306200e208afd4558d80f19831a6f74e703bedfae7675c45d876584a6a2f510809fb45c8a633e6014ded45b11c6995872552dcd637c0d6f8011e4e4bd7e74cf783b430afc08e1383a66f1b552e53daf871f73b593c13a420d2f3aa3239d938cbc76998aae273e98fa40af370487d46e9a7eddd83d42dffe83b13860e7c60831f90cac19d2e804e6bb85ffad14da329627791731d6489eed4934b9a8812e448a83a68f263fdca351cc3b815a228376c58653c094582f4ac4dccdb2fa71eb81bcc7b6dbb5757b1df4b0f88e4dabbb617f663b83d0c1ec0f68abc505417a22e27fed637ad12df60815fa97d23b7fa6ff3aff2850333312019ecbd0fe1e19e7208903d99620f19287c55b465ce94d18179d56f755d0055c8162a69b5553a43177231f50317ab0a3f7260ba5b8157ed7ae4c14ff125a8691e47924cd9c8e2b6b90f119b57a250f00f01229cbb93a45c532f371446e141667f5727bf4f0e7d93c9e2637b0fe325635db000fc0f7a2abbd005b843867c8d957c4780e4aa0447cd708c1b8f4c3bc102738ad9a746938398bdee4a0a1bd8755e3cfd0cd2bd96ae9aa074568b2b450a2819fe82e6e8fefa0a4e7e1d46524e09e0bbaea469863701fb5ee71ed8db9c3b0b349aea7a0247dada6a04e35ff2828ed667c53860b347f52163c5e22bf90a406062d87778c38d8889770b96e4ce35051c2384b5172e3f8ac1edec5bb5f6dbe1a424cb647931ee8845138e86d7290381d94b829b2f586e71593f3a050e3b17064300cbfcf1bbb98d550d86ee76d428be18e49a305c3518571969da74503303f28cb61641a68a236402df9ef5be792e72a9f18d938119f06a32b4f4da88ef83ea35f8b123056339d62c4876b37e23c74dcdede5a2304db94f75365391b4fb136d0347cdae978e71d6bc7b1bebad3b77c7483d9801cf2eda734e68368655d84045bee1d7cc683254d563170c28c0660243488ec3677b6de2b919bff744e3857fe53a02ade066f6e1df83e2b5fcf0af2d73b874037b0372cf8bb77d185c9956cec292d96c2e4a1d0c5061fce754da92904c4b25c08c85c09206f543ec52dfad1152de9fc350677486d76ec8488287442695c9b892f274410cbe743a5a93b9132b880119b56aefc2e69605af1490a51dc63cc4bb74abb143d9ae82f76ca0f33a352de472ef9ff4fb56151b5007b3bc82534b17908c2d39c664b105ac1b079fa6da8f7ca49bcc71edf8a1adab14ec788d7b18ae3a966cc775c9e4e92b7e3f55051aea813b2646efd76ee50dc6714f55eb62afedcd0280f3433133048eaf473aea7d18c0d3b46d820684692a2bd5a4fae8f266aef3525a84e1d7c727695fa1e437f3f4bf7bfc14cfee30e9696fcb113f1d47cd4942b6b3294368bc9fa0201d67ce3d04f8e28b88e5079f0de30d470094df7e1491f74aa8f4c0616d3e3010db3f320ead239f717f92709428b24f71139f4fa79f4167cd7f1ea356c3740eb735fe5b38518825091aea94c64d419a4cfdfb8d5eb44583f52159af618281fa879a5e6a833e17445c56a6d81e9caa9d1e45847eddb22a934c46c7de1033661d1d0140d1ca41b9144b5732c7d42858953e34b29db7fa2f43feb46c53da382f44dbe26a9a463e0f4a7300f48891b762af9ae78cbb4e89cc256625b6d78081403dd0dc6995c2eb50c54ad4ffe303d3d8dd745f6667d74d953f56f694ada86aec6d43c929bab3b8814b7526e16f179e86f93f2431b2de45f5265c54622cc871c876d90269cb3cecf804021797d7d1d0b7f9a1958de2332c06698fd06050eef9de01a35a45c3e3d9c410029f5f9eca9a39c0d16a04b08130cc1cfb71d04bdea8f9bc2d92d4edae95d1386f6205f666a299135fe9569b71ec819863fe2c3ecb06f32ff8d47b2e5a29e24d12c62a3c311f499884f6d97850af231cceefe8c2b48abb695d3bb7ead29d9553f03b8b315cfd25c7cc601d82a634c6bb0fc2988d9e916d143e659f35a887f5d44ab4ae5a7d37e2441a3a7caf9c2a886cc7a41cd1b3c2405c63287d45de7a4cb97dd0efc7f897fee1f13a8f9ff32ab53a1e0f6f5c4e48bb5941d58ab56502a413d10393ab2c0659e249a02408db4f6b0624f6d828496e2116f02b980d3b349e08b2f46d093aa7db089c4fc2219ff2b9f61b1c1c2a2a54a9c2f3f7484a0457a2aaacc726e0835b84d4e637ebed528deecc46644e9b2b0490a1fd249c2947a23c4588d2e0a6233f6f11844417f75710276023ea638f24f2a26ff544d01848f6098a8d37e9db1e1073c9ed91f6ecca8e4c4fcc0bb319ae14e4475c0de4408a341f8bdea890f4f4a3effe57a1ba01a606ec88a3151c31d57261e4e4ef840a1e0464c0e51c3c49a004fb0cb6047ddfb8d8f880c7b9780d3eefd0fb8c8e2e4498978dafe0cced1985e33fc13a0238ec8fab81a5a21631fefce195a77f4f90ae7f05b794c4477468c85f75d75d3813929470deeda870f14123da94ded0ec75c3d11942237539ffa62a65281e3a5e7064c4e265b9ec4c6e70b9cdc1a1adaa1e9f316b64c70b81e97a14c428ad1eb4baa71bc6fa456aa48639d5ad92ced074024ca579c44dad47b92e80b1f90cb86899bb2d1402453bb5cc1f1aaafee48388a8e2ac61a1fa5253cb12d3b5ca73f504a7197190201a6509881884449e7dde4b345368d1897d08f51d1f5a207b54ef588b3762d8bf4ff286641a85c4ce6c5060a4ce0a8de7751d32b3d01ba354aee027d1d292c253903bbac345589ece6eddcbfac5a253d17c2d83a7e93599bb69061e625f21928b0093d0cfb7979c959be26543c680fb6aa440bd913e21c0e3acc04a532aa7cdf89967839e5176ddfd33edde98f5cbb4231c2c499a3bff0ed08f98e78b80c133dceee3afa2c72270ce8838ece58974f3f50d7d5c5cbe6ca81077b1b7cc2532bb51ba0348e01c3afe85dcdc40963132b30bda108e71160efd414cb17e51c6477409cceb220dd9cc7f2cd03b245ca8460f351c03549a2add6459dc49374f4de8aee9b36b42f47705d5f98c3242b914cdc6e97aa7d700837c79b8fd7e70643f961da26fceca217dc8fc01253f12bc7011add6ece2e7c25de3bf0c7f9dbabeb8c3b2f1c13ce67f0314e63b6344591f9d5ef7b0d4ba4b44529096f3b37fdd5c1e309e56f49115591c9c1c651c836193075f9f6e6114662cd18cbd312cb0273cf5d83ce64870af5dc50cffda34aab35255ca3167d08646567e9ddfb5c61ea0250d84b545c7cdeefe0ee4a01e5e9c3aac76853afd14312a0d4256ee809810c8e2929a846fc225515696113bc2b1bf63cf7c61d1a46b3ccee54be0cf3fe27cb55fe30981eb529f5826c87d7e13ebae9df5db3878d4f55120ce483edf2cadeae0e6c569ee96b7ce4997c46f50ea778b4ce1304852a0f14526eb6a9e8079a3e868be27184028b192fb161fe1371997f0174996bd010623d743867ebf3a84048fa774658cb6f2ed7cfaaff6b8ea4605f425ee06de4706d50c97f55deb19b9b93daa9ce14fe6af2763c9bcfba2f8c0ee0487b267f4766eae123cb1c2bbb45c323a670ec9a8442050fbbc38908093ac3d67749dc8619fc3fcfbf13f534b5a612ef78a60b1ee62d2b2259628f10446c9f17fcfd667fb622c28e7cfc1408351c3b931a7936c3664843a4ec4396a355c19b6c044e0201f1b834a370ed47555cfeea4659279b04fc9c90f7e065c29a2b74d30bb6c57ae96a5eb4476d42d136b9564e244a633c7c7f33ac3af9b17cc76c2067dbb92ab8793d71d1766371631d596b19a75c73dfd6bb53c5e53a1bde52be6db3f294581e54a68a656ba4804bce139980c4da5c041580c9f5d692fd498724ad28f4190aef7325e6f99395089da320ab236fbacd70923b22e53de013969466a9e8e6447cc2ad295c8bfcd7237294aaa086e8cc9b752c8187e228a58d7941824d12cd492bda38388e63953df4ff4c0d271b7d786663101cf3ef3ef9a1dddc5154f2125f384b8886d285cc0b96b90e95f3f600fcd472517f8716b25d205e00625733db9c719591fccde7a5ce6bf9bff0641914314ddc43b5854b2d8c02dcf36b46211e8dac97db76fd0db445a78e9b9d3d9a24ff47dec1c46125293ed2c6ae836f7244bf621ac5f198b56637fb6db1f20700138b05ec8d4db757c7dee89a10ff8293cc58631c4c90fcd2b67464f04cb27e2e565394700f966c31f6646077b9e5ef6e3a0d6423dbe7c947cd7fb351c4e7b2d8db690fa3263776193c677fbc9544b2d6b26fee5bd52e6f8652ffeb9cdacd59f7f6d69dd7eafabf58ff78af5113194fea6c9e74b29cbee44255173e6efdf18e4b67318317c06878e15648a7eeeb2daa8cdcb8c53ab243ac6fb108c04deced0dd5b6e292f58838f8c9bb912ab44e754efa865650b4351e7290a921db192e0f35e43028094e77ba5f356af2c0afaa12c52bd324c9a9345775d87e71d609c1be5421a943276d6fe33c8e7896f31fdc52268771455e9ef8aa65c7908e0c8d5d9335c3d5782321472336d78e091ea6143f6f70cc715fb98960c5fb8d9221df74cc99d293d37b1299cfdaa3370d85b553d3d7f0c2ed9b3997e1ef4c57a4f4b90e41947fa20106c62cb60a8f4efca9f96014e1961b2b3351a0b8586df34316ba229e51e4ce39790dc5760ba76c1c7fe59822c818087770238d2b209fd9ee0e84fb6f446a18844d47d5dcb6ac4c940fdb4b194a21da7eadb613da46fdd06d01776f660f50b8ee408b6b27fe38aff0cbace9926d07aaba4f5936c3023b0725d434dcdb76ee2130ce6f3adf21709edc2943d061299a762a67dfecda83f5923ee648c47e96202c95f37d49e80f41e1bcac1cf04216d505708cbd013522ddc30e2239bc7a1d89fddce1e751e138df0860b44094dfe372368b25e0f3196579ae09a232ca93b8fea995eb613187b679417b5d89c3794c868938b467f60bb8ccbba3881f94e4022c2d7231a80f4a0de5f94b2d5690ace56f3fa021cecff5d91347c243fad632d0efb004a9e092d807823406c5937b6221fdca1f4ad8f30b21e703faddaa16941b143f6cb2ded06e7c8078c98c8ba0a00e42d9fa9ec19385b4013c7db4c9e603e31b1185b55eda85ced6d131553b2c8530fb3915ecab1cefa2ebc965a723e65129986859a6e0a2bdb396b20b3f761f74142045d2291c849c8b75d22e7846095f4a32047d0e2641c1805d0fe69d859376d3fe6e1437166032d076b443222cf2f60ed8079138ec5bf532a1e2c1de92f4839cffd56630588a28641bb548163d80c9b3838105023de43a7be59d6823ef3a499febc55559c121f21a18c9771b64c3964cb03da68ec16216414d74153a427d93345e692468feff46a07b38d9ae184fe3c45c3c7ffdd4ac4991cee48a024c1eca921a559e5cf93c33a2e9b3081e01079f881cf9876dd259dd8854b01a141badff12c1bca4f5b8069e2895a19ec77c0d21e55dbcd933396810749e0e2bd82615af01e6c9cc3e2164619112c897cf8d3afba5620a7fac253c7ed357eca2ec523c4af4b4d9361b06a8fe41ac46bbc208cfe068949a479032485c7bd801cbb673ad2dc2235cab0cb2dd0e281eac7c5255d07a35342841c2e4cdc08edaa5abb6700c3c52f97b806676f64258c4963c0e1dcf381f069bbef03651c6bf4c1a35c3fc1df6828f66a2ff6a402d0027acdbd06f0d6b7b48d80d068c87ad5400283d58f3d7bdf7db6fc371a33a980585ad0a3cab00601f675e7a4e78bd01348d539cf9b9503e4cc7ad129065093266c7f0ab812145dc8ce6b7c016c8bdb9f20dcde6d38511f9e61262a78e1aad88349db88e26c72c81d86b3a91bec07d720d18015822f4a1d4578b7fd16a8fc7cfbb025cf82bff7f9c0ae08c85662204e00ba6621f9724197b09bb21a5eda156ec20a1e99dd2165330fba544b9de45e90ac663aea4cd584d4509f068bf481cac78810291b83bb9ae0764a895555f7aabf5dc2aa863b0098a00bf9a5b2668d03b0edd918f0cf043d05c9ef3a6c48e6714aaec75a43c3801f6436cc8cbb22836880616a8a401ffaf7b91be3b3ecc1b9fc041f71f6115bc3c80712a63fbb96672dcd5e0000aa0d05c05b923788f2542a1662c6a539724b801e75a7e78fe3e37f750de880098d830babb9f33d961bd813a0ab3c04ae3d4cce64b9de7d55a80b15020f2bd6da983a19a60c47d12957d54424ba0d16d6c0a12b3fbd61c48d15422d7175a2fe840f34b37950fb05605a70de5cda8c99c4f102f9c45d80911b0196e4aafff8327bb68e9b23aee087faca4bc852d155be4a402758d91203d862eeee1759ca56135c3364b587326c58279c98441a9ed428adf04770e223956e7c22aadf72e47724b2a0d07dd98bdfe8c12a93f8aab39bc3eb07812431a12b002590bf7a5543c48fdb7899353f80ddd46f39277530bf322a5daa461665faf971ec9cfeec7d14e24adef82327f2338493eed0b2a306e9ec7748e21a5943f2b67b832f4a66d019a93fdf9ca9817d5c77b5b4e1e7b85f144604039c9cde8c7a5af10332bfcd9f4fad9dd92ff3b0bcdd3c5bf964c6acee245c793eed75dfdc39125a70af7b4a24cb15635382f81f6ee82795ed67a9551a6edc12950aee6220cd00ad741bf9836e3d6e419dbc815ec1261c5ca2e8fa8fef9cac18a96a076ac40827b3cfdafc3c523a808393d5cb86b9df0214bbca7b32161f80e3b7b49d7fd69a24d4cd47a61ca8f452b7942d5f67c9732e3d4c12553000d90a57ebca85220b9e873f4e3f5be052ea007a5065ddd8183722ed4d648e0ceae06bb91bbc5bf2cf342444f489acaf5a49aebd7073970af1108903773d7551a74eee215fcd388baec3577a111564e11f071f458221415cdad823f5f5a982ac8827536ac14444a63ff8d0aaa4df1b428e17b42800702063e50e9a162e30c60b4da5679da04d8f007f8b5e6df72aa168b848d357e8b6fc0baa8bfdec8837be5c76b73d508edb28581a5c2e673b0ac08eea5a20c69265fa1b8cd907ae0f9caa9f1fc7faa98e386796b84dc05bad6163efe108a2a807872a7642ab4111343afe69f277817cffa4b55394813bfa5964c73e32e848c43c48490bccc918aee5b1a25b3d9c7759f139cabe39d4846186623949fcdf12d2ecc7e26ed6b1f56e62bb457e016ad49be4eb918233d5c90c1556ec51bc9a32272b6ac7f5708bade9491766b8385002f88fe79580d37618c0bb9309cd13ddf25ffb6b4a553f82333403a08241d381959792f785523d5cae94434a3ca1eeb1ccbc76ba60f652239391163da2738e3beb4ed14303fc4e3f67ffe29ab986d76d1436d57daa10715aad4d9f1703f6eb803e39b8a22790a528f7f694fb1b96d530779b5715be7de1256e84b66bca35d8ebb428fa49a466893edbc1b04d774e24ca5972567ecb7d60e7e5e43c1cff283792c62d94cc43e835dcfd9bd270516b1bd059643d882c308060ae2ec35a3054a41d2e3a0cb650d6ebe2fb0bba26a00689a9b77fc439496e04cef31ee8d5529b52bf09b65527a054aaa19e5798a1f4e4d3344eeb6f16bf1f873d5d4cd53ff48dbcb11363d289da526ffff5322941c5fe5852297a2768b66fd8ce6049569027d4e20df6a3d6d945e5190cbf5bff47698ae97fa044666689fff2f121f999df0b2ca15ad0625bdcf2c3565ad8051f19936281517a51497e32f07c38e68fa0a7e06c444957f010545bd1dc7d3a713e7588ee9193707d10b5a49730cd9377ffe57906f5b0e2c1e7c7170adae3d6b5918c92dc35f746f3bcf65fb93fcaa007fbcf03d19dce6ea3fe5f5fd047870f3cc15295d848e07ff9a428f1591acc4d1b579c18258a3df1557a6e3e7925520c01c7b2dd2749380a8708be8a77d554e4bf479de36ad4f26a39dcc1a0b69fdc2914a0efb006a4fe93e0623cc46fd329634a09b8d711f7723c5502a00cb9db79f6176aa1e3a7f23348f00a3a5c300d49f4ec00c95d89f595739e8a8e80ce5e7c6f943fd46cee76c1a54a260ef78333ab43d8a4f545037abc3cd08019209455434080a44245489b29e00c77c6918667ef485eae51a61e3d58fda531c2607488513bc58ad29ce6947c1f6c646238601c1a2f501f3e7cfeefd42eb007cea780b09c30872a62efc2bd008f8506c4cfc8e5aed496c59e7776f165e58c98888f5c8dd5de58cdf79d8566810ad46d60918c6ef92f8f6ff1f477c3b7f9051e0e66c64f36c317113269a3bcff8177a9653a6bcda2f1c7007126a072796ad88b521f19d5bcb70c79cfa62ef0a427f7a5218ec32dc7909f5a08f42bc0419e61c749290a4781d8b0dc529436000b2a8ac7409af40f72274e9db934d81ac478c9d7a1454176618fc2b645155adfcca8bde9d583ad7f4c5326fcbf57a792189674fa4e1390727b24a908712d4f0e9e1a1aa0ceb65f58cf61a37319e97a50e96a50700c8a3ec87367a04962c9b7c0a0299c4f3ec9ccb50e49b17732c6afb61f583a8252f455adf12dc30694b300a324c3b9eec71aae81ff83ee91d70f1bb250c7b73615fa1b4ea161843029962b7e652489db7506449b2dac3589eb1d8b3aeb4fa801e127076cab098ba9e52bf9d7c7ec7f5ec3ba3169ad019dc480321cd09bfffa299e190e2869217178ac4a960a4b37bf91d97b7e08b01419d4ebfc0d46f42dd6681ee4fade3e5213bdc3204638c0ce91cf97d24342882124ab9f6c29f4a923a95fa0be0ffefa0f55de24f5ab54fb8222eac406bd31c8f5be0a999ebb27681201e1fb7235b299f06e736cf1490f0a11d0857a54b15d95a7eadf679e600f9b8645f5e0f8d5b44783b3ba7177a33037f5798f445c48c8001f3e2edde7ec6b241b3547353178c3e833671a1f01bdeca7ef8553a5ba86ebd863115b936afcc7086eb20f7e214d666dd176a335e574fba00c239a4a4b21e495f816da435fbcf14e40fedf91fc2c6c4d66dedf60a5a9d5b9d659db9a6bb491f679b4c28998476a8d4abf754219c9d96c283407c71af6e7a14dd3e8ce94064dd6fe30a01173fe9be950bb4353b92a6e8cbe4ee2b494698a3f952d417b0ad760e6ebb77b6a064b7246fe5bd92dd7f1611e772bb7cd6e0b11c70a34800785841aa48b1c1c6d23af898898c79ca65816d4c1a24187f820b18a7ea65d50aa149ac2cfc258006e073cacac8a4416a62fae3808474ab4250eee631cd182a401c6b3668b18c87cb5fefd50c7ae91499cdf937bfaecde1870160a33ad0eb4cc8a287af8551f6ab4324a717f951758d06b5fa89b48cff97d4bc160b8641082094e5e7cd2d65639d96100692665906ff3bcdd60785d9c634b485c944f23f6c293baa9509d2e28c69f14737daaad4732bfd266e50daf85deae029ba953aeb28f0bed5b4a18c925b069aa7a3f426c513dda94b2a6d5ad32ef8230a6d80cae11152270adeb692cdd908a6c6b1f640f41c0cabc88a488c9d213199ae8d61a54691bba2ca43ad670c084a494c94c459cee13e0c2f6c9e66b2cb2eb2d84ba70f9d5db939890c319014973e6a4874e9ac936b2f26c052d851ce6109d981656e6e3a282988e2b482fbf51ddadf64bbeb660a66617a60660c7e3d564c2047d4f4d1f93498101cdf2d18cc12302560a13e4fa112e16ab3b32cbffb8a41758aa1e0caaee786ca8f7e35b91ddb34349cd37448a1c11de2b7906affc25e8dfb73d3cfdde3dfeaeff543931c461e0af3707c4003afbb010f4c816931ea2b1ad37304f56045a38cd0998dbfee5dabd55b8701643132b9ea0c8602bb5055a3951c4f2529431b4c23b2f71871e0ba4b51debdf87f41f9e07f9ff5cf37066cef9c11835a02cb0e9ccd1c6179ab3efd25992e3d0313f40770ed74bc26fb751019b88a5fdbfd5ad9c70049003503d6e933b005e558c15cabc1afe775c67e95f9853c7c63c9e763361ecb42c2fa97d513c13878c580eb7742f7fd063f4976df77b0c722bbf0930e31861c7f0354ef190c7e9f0784e9145fcee2092ea2ed4c32f273679ee4f002a56595dc65381b2793a483febfe770fd1925aba20c89e0a5aedc6e9147320ffa3eec66c98dc7232976d8ba7e948a2d3f330868b78021378c11afaaafb821cd6945b84397234d3c264d91ac419eff3b543dfde8faf6f891a79216e2151e364272c56f49d5fdd3c7a33954d6b43257ca13f4d73f922db3389d37534cfaee65b36045da58c0070695f8941d8df0abe8df0b301c8ce4227aee3a26edacf574a73d836746576f8e5a80093785697a18295631d295e1c878a2d5a61126b97c1c70a34a40072906ff32570b0cf68fc489f4a6873d3b0ea5f03068c4c8f0ca856c21ac96adf5d847a7eeed1e4e2810ac29b5362e9002b75135795289a28c7608850571e915651348a45ada3453130fe42ce69ec080db9d18fff60e19181780b3ca778666d53d7f64dbf1feece89a630f48079fcf12014bbd682adcc1f448d3f0fbf40446307a08bd9e9d5c12a76640861eee3383b7bed12fc42649bf9ea91916539e56c825aeaf8e5a61b035e4370582db6c12abf474be528203f96af81d6c606ab4dc5979af66f5558b43a030584768ea973f710fc611405ddff4ee7d5722c1551933e73048abc1d4041d911b9d2063ea7e0749ddeba012ab6e399b1733962b8c085c8ee7e4d7cb2897fe858f54266a8027e2e75f18f11693f8c717b0fc7a034a4ec97e5f1433e507fe33874cdbbc736f51784ce1c9374face7b32d791cd7670b65bd2adb8abfbc3f2ed8c68ba96c24578d79892ec2022da55309a895be348093fd2aae53e5d729f026ef2cfe7973a96add3a0e786b4416d576d60079da3c511f662449b26bab07877f4eb03889ae1c18f293ef0f38ce636cc49be5f50c554a372248ed9f7ea4646d7692d2fd95db1ee5bda76f9790a6c0572f80f5aae39eae087d05b8c2265ab2110a61ccb9342a598cde43d5eeafdfd1eb0b0e7292ccd6dfff9f0a5194c891d4285c5981a620e87c58ec1eb0e2451ec5133a2abd52fbf7b4ed74e41ccba550ee1ef879c24ddfd3c5e044fa5f89c47c4c8823dedef0f02f3a1545aafe80f84425fca3a41848a8e2dd7817c83a118af1e59d399fec9e13b27f6389bd2e68a623a4ea2a2465839e3bbf8b9cbe548f42b85ac9d221e44dfea98ba8cd8ef90813ce19e76a2306dccea4ac2f029cd7708c88907006a2aff1a5a2b1e1e18e30ce209255d190b9d785deb752bc0d683ef944e41c99252f3d830c3ef295b9107ab70648db8a11264ba405eb160376068ab67c8c35985e2975d86e3fa06ce49d577309afaf520bd788164fc967d40dbe2cdda3f102f9f674d15d657a30bc9dcb5b090ffda3adf4e78cc457fd1f956792284ae2caf76b628685f422fd7104215b65402aabd08af1e1711d3dab8c308eb9f3174677cce3d625358c3c55fa8a7bef579c1cdbe19afe2136d57bea1628d3619f4906d10a55f285e33f6563869dc7a8026c3daab2da985ee79e18024fe86eb3a3bae539987a82e02a7801519f12e1f952a3aa1cd3122a02e5df2f580d0305013fe8880704e125ebf3cba463de886b5aeaaa03b5e23e64d4483adce2c9dcf03f77922878f08488615aa5c2dfd0914267c0f1e3db6ec9e831fa198ed68685c7d3cbc14a324468fcf2900233950cf8e638a98598342206e1a52337f755dcc07e5a323b29c923e12c68c7995cd02ca223ac41e16b64236b0d3a6c0ef4b7142f3fdfd8def991395e5c4f23135efc08d7d76086df36a4ee0eb58c1b371411240db2be3e67665e0521c5f68f5b392dfae613a40c819d1a68edfae697426d7e8a454efc23d1f99064ff2d69bfc0b2d0be27d5cfd4ebf80f53e270cd03f31e3956cb771c261be9beab3784763c7af3b7557bb33656cde07196beab3f92c33c297e37f1d8f4dec985ef4f27f24b21c6f094538bd0553d67579267655adceb548f0d25ad0838c686e6fb1739b769dcb28fb2033b48d63de20c33f5337ca915e81f509fc68dc30393b4d3dd5a308d85b5417a6aee21ca835e98fcc44b13e2861c97dca42a04e21dc04799d6306c495063e4a9dc05e3c4b2acd810b30a8422c779b2d1cf204b4f79c7b500bcda9b8fa146b8f0d8d55dd9c4ea3e42a2fa8905c95fe82034520f0d57f99d14ce1fb9e978276b0db096fe593547c5ad0e73fccf17be06bad8723c2902e5f63343d5884aab85ab5d1ff1fa1c8102c8bf626919ea7c9be88d18c4d16df5edca71fed30fabe174607bc214591806eae11afab9b9f258b8c81172bef0367493f35629343ea28923516d8c87f9f8dc5838806bb1ddeef5be42ba4fae6fec78c1c36622356cc89137eb0ef362037d9b116b105becfe9c4b15957adf0d37fb62ebf1b04a8f6ce771cd9195eebc00609366380dc0ad9f091f6104f13c5b671d0454ab59451f16fd1a86a101df9fc64c7c31420ca88cb6a58bac5c5aa24a00c419d006d45c7d75607bfc2a06e633f9f0dc0e5c72cfd65458f09c540f3107ae63090e2aa7c2879bb00a1e5fc9cb627384e1adc80672f9c2e268027b076bc26d90a89b581700b783c33e8d1914a6c514cd908bfe4dd5ef3fabf3004d810984e8ec98e56e91b24d89b1e33aa2b2578a30d13ecd28960b7b2bf732f863489282372c4ad7805e1d8bce31931ed54c85dd4dcbb2b60c62344d14308ae11dbe98905a21542e1950ec5095f1d44425a2c98faec787b813ffc1ac418393b39b255fa4c06943dc8c117e4decc5428e0973e2655e9cfb0985e61cf38cffcef2c1526855875cecef3dc841b0fd2c2bbe16fdb1ba1a1ad8f0a6b4a61d374258bb46aec549fa8f847e5ca1c35e6dc762ec98933823c3aa6d43ced675858ddf16d9bda99d2022e9fe18ed7fa54ddf48087eedd3d478b0570b5e61726abb206a440c14ee2c945e6151ab8a9aeb53ea8bc1031641fb5622d16ed08cbd53e643b8ac54db9114e893a692c70dc1a4b3067408296274c96376eaa940c8bbdb9c11f9d55828fae2a5ee9db4b699ab5b7580125508546fe8de02584f882b3d16ae01cf7afaf49b546f10a88c62c3eb5b360979b0b6b37452a37f7ab32dc243f62d2243e935b2a6f1d9658e1c9e0e08f1b00ceb2977483325ea7701fbe07a7274a42ab42929c9031286a7595987fa92f650d5f8b9705a1ff037b738e1dda6e243790d95435540e266c6fc80c51711b2f149adc047d62170ed1bea0912c85e9bf781001dbc86923ac56dc8a6068ab4f4e4d42d52f6a5cb14144b055718af338b9b505cec79667a1e034a3d0cb10c78400625446d9b417f9ab0d506d3b1ad310ef3b98c65c4b4fbc7689503071db81f5da560b92f73d6817b5df1642df3bd4b4dfa1c44c65e8ef40597f746a1289cc9629f917ae250d9b75878920ab17f95a4b51cf19883ad1fcd03857e1d693869565bbbf5cc411adec2dfde08185da0c8e6074d51ff074fd1d398367db59a28548d9bff6e91acc14e9102f734eb825e5d51415a16dd4c0d7187f170cc217cca712b9dc87b2e213c3aedfeacdf24f7eb69b5d4111393b76baee16b9a909cad0ac9a5d9c040d5980a429bb69ad13c94212a785504748df1c1ed74004b9a57091f13a83c07c20992305ee8f2381cb7692b104ca27181e0e5f3da544e381bbf971dbe67ff3d5055411889c1b7a403261270d7b861807b1d5936cb7883713c2f11950b71882fcd49582e11cc9fd08733cb72111fa7bd3d47af2e9235671fd8872976f7a002ee5cbf8fd2e89f7252dcb8a991c46bf14f6262f0d6890989c8a7acb5cc7e6712955b56da34d75bed14a83185803f44abe3f55fb9ad781a065fe950b1f59353a8fbb01ef7cc6dc460326c1e8c951eb2c9ff6f2278d4c91c1071f6fa4200a617ec5681e38b6fab55e8ccdf40cf1f7b1b03f484f63dead13ce605a7d26a67ef03587a726b4fbc32e77cf15245bdcb06e1a0b0ca14c284127b8c25c265e3fe5eec2bd41c9c9f89d1a638f0b2906793336e3dd571dbe1097d403207bdba6f90dc8c8e74866b405306e24f76fa5fa6ab6459b7e308a50adef4763bd29301a1467dbbd56468db57f822421ef6404b9e3ac945b1324043f48bcf103d36cc5196aa96ad124ddd3e85375da0ade5b07c2d9b1805d663b3ac0da0f725017d6cc80a46e7ad1f3523975a18437a5a813dc5a87c143a4d75db5769df2417026bf05dddc81410cf57fed758ea269c56c049cf496c62c228f7bf796a61b3935024aad202d36d162a3d43242f2bbe9b74fde0080f19e443842093afb10e24555bb56bfe2391f7999ba67ac479305280c7960a0aec49d8615edddb638251d2efb463ce7c9053401caf9b1c3be85d6f2558b0b29af017fbe74c0f01cf9f63fa152af199b0babe73050914b3ac0bab9f7ed7415c014b3526e8f32b741698d92db8132ed7b36a71e891bcfbf8055b0e7993d86dc5bf873d1d354ea1f6e7a351d4ae92932be7a9c3efc24554bd3939335a5680726a50edb1e4825f4cc407561639c1eb179f1e168e6b90a30ae92ff0743295643ff6ab4ed1fb7a878a3f9cc47828b3c07e7464004e8199e8f1e279a80a4dc52c0b5ea370fcda65d6329395a61e0c6e566d2a5533222b1b415f9ef9b8c7fb9523aa1773ee25edc252a68fde5f11bf77eb109d0f536b475d46f56d53a53645fd062be09a2edfc00006670a582888db8f9903f7190fd7232a00a5b1803b1d717d2916b0cbf823a8d853d4200a24659b49e196132e30c18351ebd2fc8038aea5a6209644f6195a7ac6607212cf15e54b1e4836fdc259b1e5d3fd8c525e0ef214dc24d659911b941027b2a4e42fb96f82a60fa93becae9b1751503921bfea2d2fea14698242c77ed1ac12fdc306f8c47f8874116c1912c0b19574df2d0822548592eed7c1aed9fdf1696fae138e3c4b44d2c40d7f1d21ba6a127c1938a340d4b384bcdeaa5a73652bc0dce92958a335cd0704622ce901e22bcc95cad22ec567d23481098f0815a9fae28373822f708cc4eadd19371fc8aafe7ebb56c7e5c0b0abbd758dc2578275103e595fac597e41fefcd6a5365e62927bc42bc9dca3704dd499c8e0bfb9757557c38a915f3a26d4fad638af862e8706910a7e521772371f06e9ea26ace73a5ff9c04d37983b8ce429a2d310d36a5760ba01f4a0fb4fada4096ed2dc0766b466be9aed59b93df46187d0a5bc5950cd4f1509ac4666a62f531a705517fe9dc7d0c8d9554e60ec2780e4150bb030f3288b5b53ddee49eda48de4cf4908206ea6c4ab74b10654dd8a08b70d723fd18a04b8cc405d751e08d9c439100c0e83040b291a26780d1528a440491b2875c850a5c29e5c8470b7ee599266b0a0b05c691577ce556d764e9daf37904fcf2a2356e1b11b19777f265ce4cdb86b5a53828a6c8d9cfa4ae106e233684269c857f3654a537d9811cdd3f90dd8784103649e43ac09f214475dabc05cc40e223e62c803e6f1772856ff5475e0b3e0c45137468ba2ddde4e19c1aea2c247b99e7532e33681322785a6f8f376faeb50f8b05e12aa7ada877acc38e2c1d0488cc761d470eaac92cc352832605bd18201dd53a6b72f1bbbebd1686c42f2efd78aa378131b7abfe6d7f83bea628d4ea8ba3121b38cc763ad342ec76b6e1dc5f506e81ff8ccefc541166c4862ecd3fccf19036f38738d863ba7556c36aed9f12aca304e8e39f6e882b551fdb6be9ccb0f91576b67bc641a51bb4cf93b3b4315dcf57c4491a38bbd6881b2e94bab299cb2238cad475556a43103ffa93cf53ddf4497271079fad9c6b301abb77694e324eb32937b4f5390269102a93577a2b9fb17fe5224689ef5fe9e6de3f154203d9617a3356a82f46115197c17ec305c7a08c3ccf03ec1ed4cc5d5794b91a4a00b4895c1ed30bb5448043005d9d91d9c97c123051b6957158ca0c433a441824153a8e8749ce79ac05442633c3279c9ced0ea3e129b215446649badce36f0e046d23d4fc68251b9595dc48e9938696de91d7084a1c41760e4c44a1ea793b24ff5336cc73aefd1aaa27e434dc9116f1ec62816f7e84128490a0f3611d9bd98663b931d9b02817c9216b76384e769d201507280be96531be5c3d41b0500f0a22226575b6d048aa15fc0d2f2009766e51501112985e2028f64aa671708f769dfcb9a651015a17d7ee03c2d8addce2c48ab4069d3a60a4244028f88c2d4581de40ab3054255d1a5d97b31b690f898a9cdc2428896c13051437c76243cfb138ed4da7c8022c54929caf90e883b9fda311b50d9f1a4a1b28a901891eb235479ad9e663e13e12e1300b2b6682fcbad4cba94c629269fd05ea6725b826614f46daa66f4068ff9dcb36f7da480a0a506a77b81d65663bd8423edb343253cd30983a666d0c6644bf1ea616697a61792a5c372a0d417882edb90f50f2e48f2c71457e9e4d2195924c9d65b95570dc1bf9d7ad382c6be7da1c8ade44ca73e6b1e411031ed96ca1e35539ebf024e58164a40be6286a4b0c47fd1a348f3876e49058102c77fdbcc2d67f490808b966d83c8074fbb813452a24ab3bed43b60209f9705fa638eae6aceba502fcf6e0821869a39434bebb1cd067bdaf6d945595ecaba31b952d56bbe8c5186095e762cec345ed4f28a6df0d837608aeca69ad87f792289976ed62e8d002cf160c4a53605f0a9f7a3d035701af9a7e18153eb09a05e71f15358b57e9f17b3ca8e67aa7b38115e96df82b82bb49f8d8bad4951ef5fcd02b8b0df80b2eef190c7a885cc33928e4aa8489aad05b235b624e2fbf64696daedf6984e0101830ffbadfd06cc35bad89666e6d95711ff7e21a866b365071c67ebcc61db3dbd9d2396918c0c3d4833d2bf9d160b8415068387d5ca6b13d28ca257a2ee856e3be695aac5fe2ae1dbcc15133e0de9207a0c11af010217b5d008c8285344928a43b960adc8131ef558d2d099483440e389f220cad590cf8edc88db7698cfe0cc02ea3bc86da134c0a7865f334ec251b89f77493ad3923595fd83045a0d6417a6ba1ad85174758640484251269762aa429171a761c6be4ce5c30dcdbe673bd75f1b516e9e3472aa8497c7eef1ef1b9d0aa7e11580c329af5753a298605333e419842b70c2f4fcd53802600ad64a0b1f3f338d6600be3f9e8ff35d7b09735539321b6340f5dc22dbfec53d025d23540e19755cbcd91c883f7f496c1df38079913b9ece0acc996cee278018426515d9176ed05e4d895003b04181456f46e0610ba5682a58a74203d2603d1a7f8e10eaa6b1dd747165713f42e8833edd745d41801d5d46e558686fa883e606b90d5e0ef0939ddfb7e7fb010ae31caf28f8a82d0ea579bce2ec9ce4b81b268fa2dad648e8e2463fc2959d3ef3d79b119bbee75ea3ca39e6f8a6c4851921a2cba5e5eaf118ddd6da6ded7dac0fa24180984bd8ef8ddc654a21ed1367e1036d5217449f2b79b7d67782153e37f562c6f4d5dd425cb695267817b19ee70249fac82379d7f84cee7015e5d1760248d37ff7890864906f8a45228a3f77f6b41a202901821e48e61ef801b211618c43b0f57223c58fb4e71c95e5e40258666bcf9396c9aa9e0bb5402a17e897913bf3e7b0db9f5c63847eb353cc1cdbbf903ae373d25ce5f02097b5c141fd28744f1efb60e2ef6a7257e9dd215b0e21ee6c4c4134415891d6c42ebd2b27fdfc6d12f558d261a5d5b3dd4709eb4f65ac38eee3c4ad4230de8b435b80ff0f28b261731b05a9493017efe5455ebd8eeeab729bdb9c8a506d9f2a599ccb895e2289eae0138c3230bae5f31b24bf6158c26328a4b6ad71ff8f5c455d862b7d1161aed96a3a36e2daeef9564c43f7317a2b86da082b695cb9225c566f4f6a6d85b00ba882db89134c94f919cb4e4a44d924312d5fbd74fe9e296ca1b84a5824d5ea9f58046c44e6e50850c2c29de27032fc1da7f800abc62013827126fd72c98463934264842b50f1ccd7ee67a8f8f38c705110db534f4cf89e995aee9b893c0e51e5f24f5b966ee7751b4b58ff3231dcaa549dd3d3d285405986b749cdc611aaea5287a38e2112cdd2b87791f10ecc07e39beb3131ec40102e6f8d2baa4accfb96749bafe158c4c266ecdb2c32c6fd9047a4cdadd5c97c7c029dbf2db5ef0b60735a12d339e16648345b5027a051d9d25bc3c812e6c6ff18af57ae493be753cc988372a07f61851b6c4657027b0d6fc09c2340861abcb08ba75379f7a1c4eb3516368d0156257a19d4ffd5062f175dd83a56f6de3ea114ae21a0d5d334d39d16c6cf211fca665d75b5cca019c557f6b6326450a336f3003f0608297e099d9b452bd4d239bd9a95704ce25be569f47d850bef6eac0e5a80868f556974a186b174ab227cc9268c2103f21019f46fbbb27367488cc72afbfd76c6ea767a25a2b081abd69f6227ce1c081a0ff51e0f684dec0215fb37781c030c0276feb6b22960230869fed6ab46649a0e423e1c8195ed7ec48c56db64b5dea05e7ebbc7d3176d8fd95e9cdf0582ca911521a9d7aa4c7e3a8263c3feed123540edbf77a7163b3b61e7d7f9505a59c588c4f2766a480efffd647e53556d20c166e88069248aaa831b771ea3e6fef8d4a8529719f2f9ca691de7c04fc71cc9554604eb33e69dcab4eba7c4b0be0701935ce2b88186197e0be0b401ed6862956bdbc02b1e0baf38927cb23d8931703972225acf833bcfafd5bb336d0ff5f0b1929f6c519338308f5207cde107a660b6a5fa35234dfc5c7803373a9d033dc4b00dd417f7585f6de1feddaa8df34cac23d13f776ca23615fede5c40f2de3076800031ba5b4101a3340d8002c627a4d33768c5ca73631940393c5a90cba8e127181b301a1a6b0458ebacd5357749a8c33d04b86da1c495c32a95c34a63eb88cab26cd47e3cdee0bb34039fd66ac1eaa67b5a24194ea89c3a92e865d49749800c6d771f2ce153eec0108534078da1875617efdc051bdee2a1ae04bedb897ffa54faa4b7f8d611fe963be7a8f9c8fec3197ca42fbf8ed7c34dbec5f1b472df1b84e98f125a51b6ffa282161664c2ebb40b72c4912003220da116896e058bb6e4343f718ae565f264cece001f63261e90eb2540e3eae1763d889a0cf7307bec3fcd509d897dd0bc314945e7145288cb581cdd090e89bdecb2100906c5d26538e1bdab5260273273956a2a5391976ebbad68ff675879b07608a907d4958eb8ce433f00371c9a6c64bbafa89c25c85e25f849274040a2b1de8e1be0de10c2ac14bf25575e625f14ecc91ff27054cb6af5a3e419cce9d7b526f1df07b5d0ecc377f1239213a35f7c0dd8b095a103272dc822de42b7b1b908cf388a0d446f50d70b743363490f5f8238501c09290ad7d87ec44829849453a55a25e2ca0a39be8d4e5cbde503c476ad5e6e95cd83cdd7de6f47f99eaa9958953fc8cfe54485f97caec22ccfe39ac25c0b0bf8e85e654f3c60e1b1408e287ab9ff63526d553f2d22a53ffbbe5818e5e81822d2d93bf406ffaf78389814f19401f18965aba92f778d7d57c7958e456574ca58484ac72fa1c06da2f142fcd23b9223f5e0500d8827167f71355d7cf80f8ddddec106592b1d500710d32ef68fa062231ef97dab66962f78bfa5943e47988f23c473e1926c172f1b0bdb961c076155dd3d4b84f42bd36d7e1fb3a2fd60a5977c82183d50f4ced85c92bfc2b73d87c957514928a3552127b3a52deea5df0f8de91532708dfc4e9ce852612c67c6af0df8603acaedbbb223dad7596cba53920b95aa123aa450f78605c21c43061ec7b1a3c3ead9c0aca146a36e8e4c0a5cbbe521226b8411600746fd980d5b1d72c71b44675f15b3a9a2ebb09eab45aeee405f63201cf78bc65a6406ad8c98ab7482c51bb289b7cc875734b6cae700bc8e94d4c3240098ffde7a53ecffd8cb7b64ec6524fbea9531925e0735f1420d333e4471ae0a050961ec6abac072e4fe83682071043dc4cd00ecd42e3854a7d0fa3c1bd41d692482739549f814c00496979410e1a58b785268e04f2d141dccf16f916b9f2495102a79dc0a2c9a1fcc2a13a4252d6e9efa6adf8501397190661009d8e36a5c753ca5a61b1909f51de975f255fddc7ec78d019a2c46bc80639f915ca598c233c9b04bdf56c96051e66485cd5ea2a96763db1f9f8bbab5476fef29ad795b9c9d16daa98b4f5fbe33b5ba9923adb07b55f9a30cbef10e67b58060cd69dbf096ab80dafa95dcd9d78b9378117b20cdbb3d9be2b28bd0c17f6722d5e4d7884f89c4c87c326802ca240ef2bb77775286c752f0e2224d47db882d92306a52d2a5ffdf25300c010f245a7d13e4765af8583db5e0845d9bc43d3fe72145b97ff7ad77b464ebe93524667b773bbcabf504679cf5e40a4a44d80cf5b34554f348411997ef544010f6f201dd71c6dee3b2a5c224d59b61ce5c484783179746cf0683296d45715bd747e63d4496bf0d4263b3d5994abdfa9995ef7f8f42ea3837c71b947f40a9c2c79e438d1e747a3e5311fff029fb8b3f8cbc03b3473aeba8bbdf5c8d7a315fda2fd5036c7ba8011446739442b643949bd61de233e7ac2c485dcc464c284a13a9cb1241bc74f4ce0e63d20cdaa65705a91412b12b985c2cb24a0b18edc5a7addf37764cdd289cd03f336709909062824d5ede515cea05617dcfa6afbd1825b37de1878d9a5bcbab9c1358a8d8c5b732301044ef9511f4e16e6e4c30ca60390f3454bd8f65f18554c706173d6f98ce78b362ef7d4a595d4eed1b2a77fb48b02c72f1f08f1ca36bd036dd04052ddb71259e3833ff41cdbdb8abd5bbe74371cb6418d40d52f56b39019d8459da60d574a482009983aec2c5b9a44d0f77ad5b74d6b8a835872d032f7a82ded8db3efc59b6f881bab4484f9fe35aa292e78c01b30aebe8c16b80606114bd7c7a493b2d6556c45e290dc1bc2417fa5a9f4a45c3c9d94f0b815445e3cb8731eb102119f94db6d6c821bf3cd2f1209106432f3ec78c3a53ca7e4991b752082cfbf6ad6e98f0809daef9c2d0e3a1b723e434bf0f6d9148afab356719b4c64b9152d3385995dd88a746240ffc2014ae1468cc4730b3ff6f8d5b1d65827a71606c486ed2bb2abe010a2cfb5f1a38fd1f795ebfa99aaf944d9e62b409626d40ae08093439aaf49100f29d92547d6f8c9fba250f08d1ebe443e72b1e10b64aa180216d61e32bbe38d9a1ecd105eec4d088bd83446f8eadbecdd9d373666e7fbed7686fc4226a9c003244de37749fb53eddd05e87e367e7b43c8b17422556aa8b34d497be1d0964b68806d52a43de7f42ebe1898934386e21d6e6eab6cdd23a12e9d68982e37c660b53e7eb5d49679e6745a33a6a71f8debdb5b124868810b496d7e84c102e45117159bbeb36356c0b64223715c6aa6b4672f16cd1636c9aecaa4933df39426a2e6f378bdcd6c345e2ac351f9de3c8fe0d1fa9ee6ac8401cb85e3037c478a7b1a0e7ca2104842293e69263edb79ccd9d98258145b23964d8c6ca53a663cc144171a803e78b8ae03eeb4aa647bc7f247fa2244c7bc7f8197db7053572cb57e27c30f4e17ed8bfc3148320e04110e8508dcc3534d6514895800299aa07d0353de4471d9e705f2907912d71d87e59ac6e6478ff2afa4fc7587bbd0c55e7a91d8f322447997661fe47bdb5bcb62e13fdc44ce5a344faa6a381083151f9af04fd45f78fd7eec0485abca446112d6895964f17116fc36703b28726239d8891b0b35db23ef09c1861c50228cb509f85e2ff2a62769cfcb757f1d79a3f31cf74358f05b3e5f6abf512ce72d927774e6fa99a69639c14daf61e3f0318c11f0410dc40a4dbba3896caeadd12e2d12fd7355e76f28f6552b00521b485500d9605a7088dd271c4598d4cf03d5c3e6b360d27bd0d9ce270c4d96b4ac81e430556fd053c5075294a69a441134f8e2e633d7f6fb289b7c5c5f8af65e6c15adb87b5c555ccd098d178bf022bd6ee5e9b4933daaba514ed9a5119c88b44700ccca3bf5d25a9cc78ccc075c7b2a96375c571d508106e9f788775af7e0a48f027579caea713eff876cb87157089e735d7d018fba36ac1e7ccc74e637a10ca72d4fe267019a6f6f7ba2138e6a044462d83f2a5c1a333d3757744e11622fc63c9c4f49915a4d7fc175102c6fb826c40463360304875f22e418a0782f4879803b9b89faf4702a27c2e05135dbce57e4632d4b42222095584d7e5768f4d04e3fba379d7c7a1275e773a329f613b5836829813242afb7b26b866c6a1fd0bf94ad746b782cfb0cdd2f3b19ea887c7d856e7892982132a045a2bdf30fa9fef0e741ff0231f121e764621286d81614a41d84375b946398ae5c39e99c2ece23fee4ebe2de6d2c1ce613715cacac62642cdc19e99896ea87f9f97f8ff0785282e9e6b7f2980932b936d5cf453e0d774ac6df4f792198e0b190294c0244ef0a495369a21f8d9e5a142bb6c43de4b85ae5e1ab12b6a6e3c0f11bf4c52175f83bc2453afa20cd6137323e72559cefd3a4dd93504cd860aacbc60d40aaec87be13af4e12bb45d7b6917e5123dfca8f621c382b1ea8d371d9d0991e1be8f76e8218868fc429705d405f91edfdf84ba531198f2b7814fb9e0b7bc3140862d8282f559240e7e7995aca83a6819b59b04529a94608c588f34544fcf4a02e42416252bea1045122dddfc99626efc7d247618bab4ba189949873f14e904e546619a00d380a0e9a860ff0f7bab277742aadb4af0d91e8a90590c01e2768a4393d360e9a33281385b599d315788afd619fbe5353aa9ac9d44d0a3a856e2d8069af457d597982cf03bb6aacc7b3cc70aa42f9e1f328f515b3e79bd77375b64a1fe8044fbd5c4630cde5c74a809e95a7824723a4d2fee3711aa03ddbdaaff7eee65b8bba419555a19559949f405a00dbdf58d2eb78bce9f9d051aaa3e1543862ebc49ec1c8991b4459706aaf2b5bcb60f3a69830dcf87b0cc8aec9cf35db88391fcea8952db0866621026345d6d1bd567f55baad92e4180460c8165df39b56e4e3877d33068e8a982f361ef5af099871e9256221f78584b6090c73ac963fe4b5e9dea1bca957c2441f431862c2b1f0b44035de82823fc6991973b428210e9c31803a951ab3b86d1c189d9a42a3a42bae349120290119875a750a98e4c1895b4a7412ea0e4bcb26b6ac91523fe94f158af74b1dfe719c0b5371eeb04d6018f7274ecf1d1522fc0efb208b982591a016cb38d69638e6e52d11f9e7c265fff7f713702e6ff799341c1aec64174127b5769e35000debe200f7086735544d7f388c5cd6f0742b2b9e2afeb741939823a3882671018ad0bd71db9d195b25f1fa094b90016ecb9183382712975d5f5ba8ca3dfe5060c765696b26161732f197a87c407cdf73682ccdb06800b16bb21f34846ac93a7eb0b9564471c224acf07867f780cd747d30029c2fbe6bd853c0a9201ec8cca31692663d70647a808b08d977aca8b39aaaead15a2e7a792657bbf2cad70148167f18536990bef6168c2e3921177ea115361a77337d7e94c5196398e161276f3428d2a6444f362b25ec8e34f84927ac32a1bb56b6de20bfa277fb7050c870e52779b5c5b5e1ad77657b81b033802e1a83a5e4285a2e4453f301e11b9dd911e7420704e9449a3af3ef77ce0a9296af67122bb9e309fb1806a1d9fb7fc884b58a95dfec656090dbc46f739e2ce71ac6a0adeb536940e2dc941e8296cb38cf391860f8d9381de8545833042c5109b70fd35f281311b295cae2613c1304c31de74e78330d456967ee4afc7c551091198404a9da28ad4a713849b0089bafbcc4c780b6e6b9ba95d3a2c7db6a7957ac88d795ee4583a014700ca592d4383f2ba4c473a4ad28d9a78950247cd92c1f846370d81865decdc8d4a94a7f94373d8a8a9e6a1215811e9f1f3abc6aecf90935d49490042e53ca56e7932c041bf2d9ca8b191bf33015bdb78435f05ec13c07aaceb14e43dd5b3649fae83868aaa8aa1d631ba9adc304d067f85ea3401c5ec525c7336a45ef4d946644a281f38bb83b0c0f47f5e412dbbaef0bfa7c1337c9105382f53f4228b6887525a4b11c8ebb190fa851d2f5c4fbc160798177e21a3fb631428382f7f3c83579d83b6d469ea4b6882e809da2b767527df4fa0467febf21423f2661e2ea124bfed37dc9595ac52f61d49ff0e4aa1c47be5798a63754efb87beb2f6679a60e5ead3aff90c4aef5c887373abec98b27b4105ead11c4af6feb2edb100cbbcf6eafce4e2c73a203d43fb99a91d1ffd706a297c301a299a4bed672d83a4e8425ab07a7e13ff3dc5572cd26bee72de702a11f05e6831230812990400f93505800596145dbddb7f9be7fe1babf9c382e7459a5c57e77299fe5bfcea9134f9c2d1fe7fe6bad8644a4f72c128404097bd397b837c957114eca74789b64c8775be09594c89225ce24c5cbcf4c8c0e656cc8f10209f5ebfa5ba41159332f37fdf2f07de658ec330f6bee4c71ae83b13fc1eb2f43ab8564407ad229ac94566364d05ce921e4fd0044d6465e27044e2d206179ac629414a1e778ae44b3b18bb627c4c9c9337b2d3c39f14ca558c9ae7271fe5595f97653df02fd06b1848055f84ea83316f0099b4fc6eee888fcf276709a0346dec9360ea38fd41a9243a2d77da3ba6e4dc79576dc42a7d758f2bf4979c09408245b8cfbee932b8a1a39c25d6e283481d06a35cd21b0e09c6fe2892056d669c91c9f3a0422ef9b468b511056236e6d03ffa91fd3d1cb6caf5611475f8a23500a87ff4e58523d023a1bd0eae6e26583d4eaed99ebd8ccda1741eefa6cc45f95153a92654f67bb78057ac0efcccff5f8b5da3ee5e8e81e00ee7b14de5cbcd50a783e1ef5811157934a009142ff6f0750348193bfeac24a25801c227d49369496b82db7964d4ab0767ebc5cf3181d6c869c4e13adc07f2edd706a2f7f2dc30d49154926e98a5c9d328babd31c05e3e55931436928fc895145a0a6b262d9d0083d367c35d4c2628a2ab993c40c785f304b2a5366c3e994fea7a80aadd6c561557da69747f732b3086d8c4069dcd8db92692842f5996dd8de7525b1a61c2336e60a2b589efa426bf8c118542854437aa6a3661e3b503aeceae010dd8f2fc5a5fe563f934e4ef401323144c9fd733348a06c7b9a7b603423a1b867e84d1eef122da62a764140d9c2b27c1707ccc46ab535da1884a0f52d60bc171f9f373790e49451044fc903f302a351da8bb6c034d9fae786a0edff5e0304c82489851bbf88091d48d1510b4076143bf25958bed376c59a40b9ef3a8c9b9c1b9504f2a0a858367471ffb9cd036852f6108d0983729b3ae9f3099fa6bc6d5d98c7c324bc6290ec3bb0245c93bf42d22681bbf699df3576940a2d8fc4eff017f9bb0ae70cfb064d46a85b9434563ce048b7833e7752527957dcf4636fab2ec5642dd6be26f10d5db4c471735da6966193ccfdaba4f09c27ecb3ecb0a1667b047d0c1ddd4d1800615ac1ba7236e4df6b39b7b43dd51d1c15b05bd8c7f4bae4c4d3c89ac3095e374bb464f9af09a17a7ed8bded1206c980809b22c2ace0fb3096f0ef692458db90962f5d521128ca8ff4751856f7448904df942fecaa7bc0c20df8873add02e2093fbeb890bcb1a6b2201ff0768efd2da0306fc535b81b177aec5855aac402bd456f87928bcd60c5ea735669a8b619c65dbf8fe78c4dcedf22fc492c23a7215e9534de37d67895d851e9e6f27a073a2c90689f52cf1129805224113e0272e5457b5c0bffd561d1587e23d0007b0f2ef9b2b26bd6b876a128ccd0ae0536b7e9a038b63dd6abd215a415b4b70b9f497f38701681bd6ef8d97952f81ac890e37f74f72a060c5aff4327f7cc924ca3d520f9b9f90ffd59cc932a29f7441e181b18631e6a6b707b0cb2eb999ff38caed4533cb534c91cdff6fde6784bc58038eaa90623d7fdb3d075e7f4f1e213c5538e22226ba6903e678d3b2c6977b43a249b8b04a5f1d9fbb0c705656ae7377cdc10e35d67ddc0f2a6f6750f8965d3da4f16dd8a8ed4ac2062d887de18c517861b76e988f2015127f4ff6f929879038f5fe77408610ba84dc36d2308bd705eb5e51c14dc43ae092a3e287dcc5f776d2a011c2b7cba75762ecf61b00bd3d535e4517f89ef8c5df4321ca1d270986c02cc49fbb5622dcf2aa1cbed6e11fe87d56cefffd72430b5a5e93f253cbc11ecd06496847f266c2b475cdd2bd8a2c7869f6d7552fe0c68e0384501f9d4e4db250f47566dc2af9c954f691af011c823c1a06616fef08c95ba4e566938af835d8eb0a13676cb1cbdda0aa2be4e0136dc6ce2b05faf008919647774f8c52e949dfa22250572a6082406840b1911d62a161f080d87e4c32fcdbbbf89c211e3ec91c4d816ab76099129fc40e14e035d3c39d84b7fd9565075659abed3046eebff131af626893e5a986bb054db4e5c88ba6c994b4a01bcdfa354db8d333e0714aaa4cd90f272470a7d053139419fa1f267f9ec853c05ff6abc0496b514278d183253485a5d2e4ab1a43d0d78b897a6ae3e3e9ce95346db69a73730386d0f790c7f28bebb9c5e561da8c842d869481011074adf349a93526a421ef79f9825cd8716ef63144c29b3e6146f86d1e07454e9a5d6c621908219695e3c42a82bb9d10b7c20c79c22f965a1183cc829988fe4d501cb9423dd0887c022bcac6481ace9e42ef997432cddc8c7631e3123ad5ffa0c5218e977837f5d1b998127b4fb78740b70f8ba1061f09a42d5e8379c5e2663d03e54cff4cf0b27b9075b1a3ffacf5af4647394549dc849a47a59dcd63061cdba4207a42e5f7bd9a3a99252b2ca3dd68e6ccac37e0bd4b303cb85e3079f1249c6bed28794a2d4f77408e8c28bbd43bc8e0bad510963aab644715a2a145e179ec7e7796bbe5aad07557ca89c9bdfe1c108976816f349c7315bac43916e4d5fde3df28e018bf055af5ed068766060f4a175450b895696fbedd54208b77318de3c2bd97e7bfbea8463530053420afad4dc201aa0213281faacefaa9b4576747af3f68ff60bf0a397142f59b12fec105cb1cd60c2ef42047eae98ef1e8631af8f499d8536a52384ecaf76f2766dd0f701e30b64511ba0bce8cb55c3008dcead34e9ea78acb4052b66781beb59d605802e1ddf081c86f9cf31aa384a16dd2d433811c798f06cc555d3e1174a5d349dde1764f3f1ac4085cfc5fd3c4ee686a714f0dfd4e8dd444aead0c8c844da9fbee1f947df6fe61eb83305db81f218e76175c7d78a667672f0fe2ab1d3b4c5c19e8b32305e43809d1131e3bf7b7c76baab421ef7356265ee979d68054f38d8e048e6405d698b4086441e82ffecd55a25180af893b2ead201b80a7179180cedf88a4a1c6309902d0d45c4a84bf4c55f13e7cf8c8992df13116c32fd8e089c6b414640e321c6a6583da2f715959079d50565f930d19fabae03a729006cb6e1ca60e14daccfdd6044e3d6ebc42b8bc7c77cae01934e1b1c650a367c3067436a6187dbbde5a60bf7e7133f16c2c5279a8798f6d25d23a1dc66d91200d380cccdd897a7bded3ee9afc85531b07e7f3d3e0fddc0465964dc9fdbbe161a38c044467935a1531be33dc6f78e99b059ccb6939f70de07e6673c7665674223188a384d0fd465548ee199cd05044babaa285d78c761294724cc6debd45b0f99945826077932e4b15e4854adf5dd89a5143b0e42497c20ba5cc6c3e6c03a2426587f1fd4636aeb666642a23d9876a6d341ffe569e9df877ad4c99c2f5563cd130402a05290bac7483b68aeb83261efb65b1af594d584eeef8ed5dc9bacd39690449a7873f70fe7b63c095e534107cde046cba6783e74495860e3dad254f822b544d32ec54324930a5619a2caf17d6275c710ba46b69da9d9ab9a04cbdeba336df0b94fb77eb8ef0c1bf77a62bbcc2dbf26147f4b1ba9f81e0d54b58fe563b941c4e9e2b8168aa167f6b5f08acdd2c8fa1296436e18ac2d95b3b7893aac431ed9e857d1db5df8d480b96b9a7f5aa5b7e0c076aaca429e52f4582a68daa6e3ea0ff0b125479fd083e1de9ab019702849acfb9461a26e31acf54f007df1b25aa6855166f4a18797a7f070e4955b8d0c0cb9094d30474396186cf7d7bebcbe00a2f1721560b9731fe15705f30134a20e38c9d99fbaaafa22d5b3e436310d1e0256c0e025cd1756e2e328a5f48895af57fc280abcd52c65cb5e0fd065b1177416bc71672a2607b7c5f6188fd3fd2ec792caecc12d83d83f399ef34566dc27896cd9e211a1fa7aaec62a3d37192273690dd3c4408b7ea27a5ef83fbbb1586e3a05794da83470b1ea8672563b27de8e6380d0aae772d92fa0a299ca703d403347edb03da8d4a8ef140870d518575b4f1ad4bc7e0ada208eb01825c2d98ce4fa29fae1a114a2fcd138b060a0264771ae2ffaf31a1e63cb06f079f4b4ceb3b33dd0a3637975e198b574bcd177bdcc00d7978d06b57ab40933df2216750c48e61134c686fc0e12c177eccd74ce47d85743c0c84b79db3c9faaa8a25bc0353287fc046b6ab4462e7e211a1d9f4b313f90efd0c8d5b41b5694418625061a939252642a1926bf7d267958ce8cf349ddb600f3e37d0207e147b4c1382cf2fb94eae46ee7308fe0e85c506b42e0db02e621859804ae5e242f2640c00aaee8fdc6eac82d949747fc972ffacf9030ff98e903fec83dce23c2a2676a2a681247e9799ef5350f1abe15a04a5bf9a0b1aa0d83e1ce0556bdf5aeef925b87691f1e2e9559c4f4f96defb253dd478f31d8c8fa24c307ee4d0d418bdc9fac48d3e68297269911d5205682c7560b530b01cc3eb5f64f184e31f1cc33c44b163f807216bbad52451769cc42ce2ee97f0ae6ede9250843801b21e6cd6fb91c1ca1f71edd61c3bcd7fbc01e7f1e776a391cb14ec722cd798029a877c9e4499160f21fa391e168d63db4d6a6237ca264263ef5a4bf3a444028746e302a4065d1b0eb2b1ff34185186874fba323f5345affea36f7380cd45bf16c27b04ecb8c91e0bd8486a4010fed1468f1a50d69970226c016687b674abddd80b2658d7cf888388b281d7ec44662cf3ac6ea243e14a0eccc60fff7f68bfd3c78ab16eef9990649d893dc31f40757625e1e548b54fb27a20432e4dfca9872a56a052796624334d3efcbe064b3b83af2058044e80c66a1f6101a3eb12f101c314c316404dee73747ca40d6bae910fc946b72685e2ea77608f9aeb3272063dae31e360d286bbac5b4b3d30014671a85e9de7ee4de0e268f3ab011ce517e27ad733b560b235f015685166c5ef35e63d769a49719cedd68f288699ee85548a38076bfce43524f0b55cef67b5b7935a8a12d29c36ff06c06419730f2eb975067263897d30e1d7a54384d382b1e9f92871e8f75e920763b8d53aafdc5449b02e568576d87a91c59a5a438ba89634a11a835479f686132dd3c39aca80972200989af9455dfa6caecfe15e8d2633a29aef4e67806bd30ef96fbd319fa14ff8f56133a6365377a14f1c6140d15fcd9903a36cb494951e949e4ed74b84991dd196e49be958aef673c629646adcd36794b03cb36364a9b2607e0cf07e901c87581aaee1ef5414564be23ba00f6af4092ce8c7015663494fdf58aae44532e7bd21ea367589c19c5c4ae00c8e7d33be32d571e660049db59350df64af80d927b7165fd94dae6abe6013a8f1e2befcc0473cb1e4aaf94f033cad662cbce535751c4cbb6269414c38e0e7ada00ddc1219a25270c4c5454b649d7d4ecde675cebd5da9a52940e51e965a2ef324be0c18f4009bc33eb24961724b4b998dba2eefa13f28b491c70d250e93666d97f4136aa055f7515a98c97e31de43edf3050c0a43f107e38a8df2213a2a177aa671c94597c36bec07b3831b8e706a52873a0c2d7314492d56a5aa6c2f09fcc5557d12968368cf8d6e19c89b9e09a5475e032116b5d3fb77232cb6a8ab465349c08af8d2f9ec21773d57bea295f7b5c217b46e665b6912500426e63c116145c835ea65e4498d96c2cae97f736c1d053c42ac757f633f402f0b636824580d630fed0b66baa45f2e764a7144f433d139db33882295534daa06967ff0c3d123bb34ef8f99c4530dd1bc2d930241b4f9c36dd6ee77220d5c5dd8e03fea6b5cf79ecb3e51f8f4099ce072524938db8c060a2e9b5e816f3adf90ca187a374f1aea9fb7c766da173f413ea6e27d897dbf89869bef54fb681c234762839ebcb269b82d1d4df1cae678107dbb8ddb358e8c3a38828db5f378c978b1b64e4375f7e0523af85b9515dcd90131db70da654316213109aaa26a528c379fe202eae24c63d096607b2b5b3c99876c2d2640f2fdb2c433f9102779efa67dbf6dbf8d7a5c02b84c35c09bb888b593acbefb154bbe8006758ef42f7904d3e50d8e51b39aff8e74177251efa1f4d52ccc04222694e40a9bb18d2f49c8a1c5cd86db5eb471f7658fd63c72ade7070aae1c8207ece2dd89f602fe6b15f1ee70bdf853e103a1e4066cac819dd58d49d801f6a1a48cb3356d020fef6bb94df5426740a5089593064a710c6d369c9c6e9ad2762121fa8a86a81346cd58bbfda297b3606967dafc70b251bf8255c4f20de50c788e5b0b2b658e40fb0d0a5386347072210782b2162cec9d2503b9ef5dacc3422cab1ca885cf991e8e638ac53048f4b890205d69b7fc3c9793dd24ba2f2f779ee93901ddfdd1129c2cd9c0791b0bd4841ec3f9d3811f0e7e704dfa12bb905d53ea3c0f1d659f1c1657c267b5adce49d4486de02436cdd092e5ed9ce7823e7f148457b1075505e41a9042c7da0f8463fa4d0f3b295b5ea156d475f11ce3883cca280ea1499e869cf0ac407dc319cf22e669923bd9c4655d7c7987bba80ac3ea13d710ab2cc30d78419d1c471914be7fab1b2cdee9223e93ce54e85c46944ce5a1ec9e4c3c89b072acd244608a774dcd7ffbce7cdc09315cadd72583fd41112e0e75554e345e366db5f9db592cefbf325d0de790740f19e653d2fede2d54126018b93ba19f90deccb23375d3102b7d07cfde91422b7ae97cd58ab8936da1fedaeb2265d23079827d5646bb07b1314ab571be08a50950c991d456537ae1af853776f77f007edb87494f4f78ccdd2f7a077b65eef0cd7db27bbedbca8487247b48a81af9a0e967bf8d2a55da6f422453071de5d02829b9ded1bf3c81a25a575dc32d1a4a20d8a4d5151c2b65ef03536982176dcd4f2730406a17266173d4bb16ec1daa344484ecf52a97caa93c8e95b4fc00a85cc288788206763e383feb047697a33accba263b2550025238aa680cc56b15bac9fd33b642a5773f22a33096f55260c81b28025cbbe306cbebea099329c6978d0439b7ca6c67e1a960e83ab19aaa7ef41a2d1bd5cc0448d28e77b7a92c9032e0ae1801c17a44e14a545d9b303293a7b98dec58df09206c22136dd2d111d7324851dba097d41cb5918414c5a09656410acd23902fbe3d89a66aefe8d37dfe5ac8cb2d28d4ccf3ad42e52013e2a7098a6aa20cd860655745463587029087d7296ff524c289c42605236302d3f6fb476089d303f6afbca77e87c1320e04f36dd9301b0894b9dba2cdf002a1550cf999bc1b85e1db736d1deccf3b0e33fa21c8bde02fbd65853d6af4f95cf3c154bb37d7b9c1140e50867d2a2f197700b18cdc591d86d93a2be037b9971718b8160940c183ff9cfb505dabddf53f185919e87655e564dbb9b6a79c99c6164882b129e20a359f7bc9481f04146fcafbe12e6f3ee72e50513f9f10d06124e2598b87ee501bedfa834a7385371d1bac846f791673e752a62fcae004ad03ea95723de3a4c69d58fcd1bb8da846f445586ae2f887c912323c9a0554b14d88ca1528bed3e734fae9b886ab9182936dd1b697c9f42786149835fc628ec53a376414797be036cea82f5bc28ea8a4d37064a8419e665e74b685fbbf3535e3a6c4094555beb4947820e63541930ae63f36f90405820cc5f2b527c66acdce6134c75eab0fbd1e00c5763cd43ba2e87dacd8b321e87cc36816634621d9382c2b6adcc0443687ea392a18a320fb5f91c5254fc5324418fe9e80e8f5bcb4165e9a90cae0ecce44e1769649084207589ef50bceca86612b058a7b7da4617a87f5ee928dff1234a6e1e424f4f42976937fc3c19eb364aa00c62a7a2572a41c8fc010f83fd972014b3a570bc4e9b6d9039d3ed8eb7988e5a8188e48648ddfaba07dcc26a9b828e3f7ddfb77e948b96a838a3faaf7acfe923f77d12bf81de4138880b0bac53e03f7e6674c1ca6644dae26aae50d568c7e2cf6aa70bf5b8813a81a3bd7affa9be52763241017d831d1aa2c06016f84776aa8f009d25ca771293fa4e478881f49aca7ef2aed59b65a035e537c61237631698db80e6251556c2daab283681e935008ded5ddad873d5a72461d319d83093b66ede767d605a70aa2f45c15a4108ca83c9b83d89bfb8fe8b1509f6bb6e40b6482c154cbeb2551ecaa5bc3ad0f481f1720e86a6ee8c03f416396d0eab3394b45ff3d2790fcab47746a0103ea80ca730a82d777ac4c7884cf5eb53eafe5e839b7691ab019c4c05656b6933519b9c212e726bb5e15c55f4719e37e40613e01741d410711f97a170dca7c08d4d5b844f05d39bdbb5692398fe8feb6bc6341def4102cc003783c8e6f0767a91be785ea0ea2949afcecf0ffaeecb49e7d8424ce02219b44c49d7693085212d4387f73b34ad83f528e7968b9c678bb5e29f5113c9978deb9a2365adedbac09587edcc3477009b9a08307e2bfef0eec589b2677271fa8fc996d56402639c17961d9c211df8f7762e37c74338e7eb62ef7d796d0958e4fd56fae473be1fb04cf775f234d21ced5c2fa393221f563c0068cfd88e111c665c0ed2ff205ca902ebf0b304a36e62f2d6f6b1fd2ab56c39f33936dcbd5f0021f55607f8831c63bc1625df58d4b15395e006ed5599da17f38e1bed05593bea5efc792ba9c6092800d843d849d951bfafd1edfad1c88e74b40eaa9236694f4cebebf307072442afe57d71f4516199473389900571b7a33c634a75789d6cdbd54ab796cbb3c6cd2402339c5ceabb3588ecd133b3396a2ece0f4570c1d8106e6e36f2228c523f756f412d666383b86d742bb48f0373e50b2f07a404db6c55ee1d8736ee3c1bee07c7786c14b15afc6593b5e1572f26ccffe305c1a47a3853d44bf6a81b19a2eb8585b907b7cf5bb9d01776ce380fb201e73a7a4a33c937970140e7e73bb9eefa770bf5da0d0698ac73e303a31314e99aa541850609ea94753b395981ba563e2d32b82dfb4726ada62642094412e935fea16d08e473abd30f045296d8e96ccc50994804aaedb36379f215c76b1abfe81000821455dec94557bb7310a5bdf2730864835f723b722c7d59ffe5c64e20f3955140c65abd9da8ec461f4911f777adc9e0aa235d47d380ac4bb9f7536bee8cefe8cd1049fa795ac87f78dd4d8b8905c45dbe92198bbd9270d6869f1f93b6636d7e450f8546e5eb28f371abb0456b484809ccdc0ee97d13b1da4ea454779bb4a7f33a6fa5d78df9251c89179415bce9a172d22132a03faee8f1195b8bc66af507138d6733abde693de7683115d0181aa9f4f3ab047fcb6f7049292b45a2e10ea374f410e5f9d2bc9266343523541ff60f0dba9bcdfff1aa27a2343e81efd4de9da5c56abc2fbf5199f504fce2936113f5aabe06ac035b6f1a151451c2339d3493bd5d7ec865a52a2027ef35b0e3a66c0d5eb1e647eb45f0bbc6a30d69a0d8245bb118638a56c1400dea9186122cd14baf2f00c3db5e5c58c08bab2934ee4f33668e603fd2008c2d66085796a8bbd160e8ad131b6319fac8374437c7bdd4c2ba7b09a7b9212f2b269c44756b791ef768d967fa07440a8ba07cf79e9adbf045f3c436c067785524a58db72c526874d8c1e52b3aa382ee72035182c7e0168b698d8f46cc1a4e8513a46baccbb2959ca754818220a8b77fa3d54bbc958b2569771103b2b2a758551392a3207438b54b62e3808f9cc5a352272a4e15e903402a6664cbb6c2599cd85bc6b7aefbaed3e2f05af3ce59c1c12d132ea725fe9f6d764d7808b548d5e9af03fe2c7b3d4c17a330ab29760154eaf35a99c8c4594475167ff81c04991cf2fc042fc941d5e1d100c5c657f6b0f0306857c22dbfdd162f29ed4db7ed51fdbd385cd210dc35eb076e90e7e9cb362db72c16a8603c74a24309cc8d5f0a311fb0956dbac03024d94f84fcf07243352ee28761f34cd7370b908212f7243558dce954b4b9bcdeebc2f7375db5219bfc856998203d25cb7a9f0617b150caf1aecb88e2b33a6ef787a2084e3a26a16022d14b0f712e0aa6cd32abc86e927c5f512241c84874d9fef23212c5e612b3ee134be456029ea5814a02dd2f5203a72c93551cf915ce5636b91e11385add0eb1a359463d25054f784c5c58f9acb4ff265cb2c61330f05134ca9cc92a8edaab0ebaeb4976065a59e57707899db70b17fef2ba3b696392e03ae04b3b0e7165950de2f6ede15f0e271440959f21d21f0ccbf321a9a6e399c7cab89426e60f4e2a655c21460f40544ab3503a55b7f6715f3eee50a8e296bd2b7f46151cafc9b7e835d88025cd44a71906c19e9941fcc30c77bb8a55fedbc766ad59d94e97623784fd37e5c01cca8210df899f65589eca371ddf9ebe7abfad77f1eeec8cc642374d131b0c2df7e17e0888931ffe661fee5925922f3dc008d7ef3870a58abcaf98cd1288b5a680e38954e7623cd759e61b2fa709dd272cf8e11d648d786d5404c48ad661778799a893817f8b3874b654ec77dd7fde6decad7944e7fa1aa8d77f2a30d03e2db6bb2ea201b93c05d91d58a1cedc4dcc7aa1d526ade71239e303c48f37c2dcc4cb84a77a22acf12f4039b7b0ca2af43cfbacc9821bf42013a772993ed138361f5f462b9cc349bd62be3cb179bcc4b49b01418800838dfbdc49def43581380bad648e121cab7e989c453085306b7e533a3e9593bc6b283f053240b6d9bfb73871671aa8d7069bfbc92df2a6e16edf78d681d9d85c59cc6ffb4f8c47072d84769c4ee5ebed713431990d48d4cc55fe1a6856d6806c8c253a9b196726d2915b728c514e247c588ad8f39849a9344b62048c01a4fc9d7a2379cac6d6dae1a00071c38eecb0c59f46aef30afccbcbbaf49ac6fc3da94e9b1e1cfea584a9c254c4314daaaf6df36e817b2f61f6203280d1e4e052be1b1df70c11c5255a25a0626245ef50f760b87b3d80a210a77b219a4c36d48ca7c4d774de0be84f0cba6f0b7731d272eebe9fb604053edebfe47150d8a5ba28aae51cc2f8c07323dad0d425012f55dc4628ac6eea5df3c3dac6329af1ffde4e297c438c487dfed1a219ee5c9b1d558ba9337fc24d55c956c250fdffbc75ba3fedb9ce94923215261d0ffe5edd40b85957dab983f9e209a9e9fdd67cccb04c1cc4f4b2c6506c51bf4d5078bcad99e4b0f24c80fd3b893d89489543fddd89596535cf6546fa21e9bba1dbae94eed2a5fa872c7bf63f7c3eefa4c211b6884501dbace018fa2bd9d3944ec6006a867183009a4227bf9bffded69651d6e318b7c8bfb5d17b8fe791323bda0bd32dc1393cabe745699cd87f2674af5779acfd96bd941c129bde35d54070efa0abb2500b67615e47a620ef5075ca490d19247dc6e11d2f0e1ae0d16716e655240e3b98a5324e390af1267455ff09d5874ca034b47c0fe9d9aeb477e96ed60af32c7bea6f68b49d95b30747b30db85b8d96d75db6e8a69974b68d93abac0dcb4b55057039238cd61813546865f7e274f2adf96a19f980bd73e5438b889002251a114c78cd0bc55a0ca01ba25ff55f9c2d60efdfe9591a189dd49fc3430a5840e46bad0570c45901394edbb4f29e2e2a35c62d0264e4b2f1994c3a6e401dc5fc83467888ae9aad877e5bb93108e6254d23204bce54122a3ca7e1587a16e10bfe6969fd0e11effc9f8d14262b34d6bb833c9cb8fa576e1eb01e05fb3327cbdd91c77014d55f3c7572b007526e6c041ec101def7f26d8dcc67fbb59eaba9ad9e6e1dbbaa7e12978bba57b06017c45133226be60a228db726538f94de1afb0f74927a1533eeccf70344fa5e35aa4580b2e8aa565fc22f779d5083c319f95b1e893ad90b67031b6ec4e89535304f3dd670b94cc7cf109fd41ee508af4cc99ab64eba204047ebd2f5db355602c136a1dbafc067f6e79224b986fad1c223d81a39ed5bcb286a286d9a0420058a25b325f37822198be2a67e5239f2abcd2103e7f04c8318e71d4e11dc08ce03804a08f2e636fafea44d89863bd52edd8956a9d4ea3f45b1b04bb8aa0c234fdd27667a93d25387feee191f8857c6c912dad2f6b21348eef672972391c441598a88a3c5ff7d8fce94eb2a85449be68eecb8cc01e9a9faefb42711726d262cdf131f3713365b2dea824cf1f611c3c191d4c1b4a039e1efde61de00650c97aa52464392e1257a9f2612f774081a584bd228b97996e726b029163769a895c16249e2b9905e7eb282604c49152be0ec4f101dc04785c35d1d2cd47117f0e34cce6045d2f3a8e92a1009eb65b519a9885896153c3438aa7426d9aecdba9d930cbd0320ab7f16a3d164e95c61afb99dec14390876e5bbd7818081b69ec215daf2fa0a93c8b11352bfcaab523d5ff2e99f5cf85e0c6414fff8e4a8d9b747591d0715bbd1f5b1183ecfbc1be66a253006e6d8a82aa15656fcb237b3e6c889273217efdf4b2e00fb0af60afd567bca8cb62482e09eadfac64e668a1f72446c4ae77e33c38eea4cbb8efbd15dd46a1c4553ab7f6509fe6fd3090fbba2aadde7e0329f6f3c640f864f5b3b574627cdb67e24418eeba1ead853b46959337cb01fa34f1b1baf19129dce3dd44c319219b9ab62f350f4c0f62fa2c536a90a949cf75c62b5a8dd9e4bb47de48bc453f27338f473335f8fab1e9f15e228667b33f9a0dfcb1b41f1bf559fef31e1db29f34add164ba64edc73b7222d113fd5ae9ad2ae4aa2f595ce742b65a899f45bd91c2c7f6efe031e37c0dd043113135062bddbebcb3c1e56ad4b57d23759f71e9cf301406f953abf3b76d3308434a7e61249aa32ac453da856132971dfdbbfd58ac21c91fb09e5cafd49b8f057839946326698b31db74b7c28228237008b155f81322a3ed5faf604afe2f34037a7f3a7a5ac81d9910bf510e51160873ba1c59d1f068b73e2d4d4e908bcbee24066ac5f7543a61c6ae938cca59b71e896a8ae7908b557f6f1bc43c8622ba19ef49373eed24592cd8bb4abdd28b76b1bdc8f5db24ff9f8e0be91044b5cd0d68098db923eece157e4753fcd7bd77e3fa9bfe70cb3a323bedfcf3e46868b5a7f885dc692d012cf4a84126d63a2375cb4510237036801dcc31172b8f51eb37f5a2b3b81f89f820adf97d917ec9a074badf00a037cc9801e42df8aa5990062d57411ca8e81945efe98ce69f9edeee9c289112ef50c4124aa5f36f5504710929cf289284bbb134a0e6ee37904d29863960c046025c67c30cb0de45dafa3b6531f56b7e3ce99071c9f49baebf621e2e78c9f94fe90469bf09a006d760c64ed30ccab355064642451393e98c2ad5222e6bbdf10092e6c71c98d81ab1080e854effbf640659d2e15619f2eb091d955236261d6121cdf563eacb864c52bd562318b335c8f46cd1f2042591d24cf4c1f6980fb1b084aa66b6064a161c4783a3b6e971d9d974958b1062ebaaeb57a1224140d4a2eb67f6bab9bf26c6109b7bd9be545d6c732e9dfb8bf0d82520125ce85b21a736e6bc5b10c6fa32955ed6414eb9abce1cd580f9036fc3710f34f726cdc086e1a1692a6b031c1b7a98b677e53d3796c25a8eaa47b8fb484597d0758cd557b7b5bbf499b88e8d41322df9070b3d146e9ac33c3cdd972a2f33410bfca717e8c92120eaccd15d14d9a97fcdf518e94bb1d286df45cc051a9b88f6e04642a1e08779d0ee0f5183d05ab5b67c7e524f861188ed38ee1d711e96b6c93caa05d4dbaa63b4efe7c7f0bcd38bbd8efa4871895bc1eec3d098cdaf6ce0ec802f6433461904d492e68f78a17a95d118f227e681ace3c3485474b349e1fb389fec4079ae0fc5aac0c06456d0042ee778a50e1bd9892c07da55840c633cf435e8b365e07dbeeed1713fd04f929f89ca4076c5b93c83ac97d57b178a2301331a4e56563c50e34221bfec5e03b9c6b90065611a59c66ebe14da6e70ed0c1ff20d4260606e14f9aad75a594684a622e3f44e9bd5b0843cfb9485c4fc6ab9068c062eea6ebfc52e4171a1f0692b719a123f671fea0d3803f04b65795361f39160ee41a263608a76ad34d388a06d5461455d307a134f671185bcbc9b6a25e01876fbe13a59c7f5462718d4494d047bf7fd352eca75de0e2ecba155ba964f1535ce213f755317f98d5f13f1a78ad22d8f0d24df843cc687a447ff55353729f5b75564912c3ef1e288c35038a49a4cd6629b0cf185d2eb458b9c379eb9fc2ffd7892c6d127c9147b16ffc10de9ad66abd39543f3fdc9afb451c694a86a1cb86f6d08134ed9f51cd016fba508d595c0b60622c25f5b1953f3aa5c3754d284fe7d2714de3d79940bd8dcc3688b46ca5a33f9a8b8ed38d898f0a97a7c8146e252fba566ca5a916db3dc44c26b43cb121332965ad0d4902302284c2fa038cb1193de74b968b4445834ffc3579631ff060f2fc8e399494200c5aa81349daea5cd2cca86e97cddae084eaad4af7eca34bb20a727a310c41cf5c05456db81007d342105c36e51e15b71db136e13c47c6e4c1b24c04b0b61fa2c157a144f20acc336a2b632586b00dbb1de650596af7c520074c4bce4815ff471ea78ef3ec441c4efac994244a28381930e9c19f952d1509a693c1527880014ab50be8c70c8ab8cb943ea192f3a6ec2242e3e04cf718fc00188f77ccaaa712c1d6dd914e3ef02428481bf8afdee76e4b62ba4a613fb174ef94baecaed0090c8598354f02592a5e8c8d7ae17f4dba816c766ada24cdf008a0a9d112960395e904af0688096009bf4a207132fc055f98319c0858ec38b1801537e2dc7d216f93d69070998fab83db5d811a4f6ae9854ee4673df0badca581542041ae0f6d20816105fb6a9b099f2d05ef55ea2b54356221c292b13aecb469100700df76b7a0cc592cb7c9cd6c24adf269dd0d0919c6bc1696a3527c7e68fdc4487d0898d19cc24da3b87d2b4c9fc37bea1830e27270e0eafa5e8bc414949e466fd1c8ce35e2651d0e4bd567c08fedffdbd9d5e88a62420c1c79d939ade825fe7fbcceedbe45a1287abb34817c8029def515460f5a4008fd97af6f4609c4523565b0c34a7501d7c071ab146d6ca10e3a3b01b279ed1db2609ff63712b25787b55e48878ecdbd202d1eb8ca0257a1980fcf4f0700b841c226457e196ec76dcc2909c0dd061ecbfb6c1cd2aceb4015d13da5bca0d5d959fabe7230262f5089c645d87903704c6051b73d0dc9fdf422a6166d31ba4771650c7a746fe86efe6ad52634251a1f6d512e539b0b3e2f1b956152733ce32c4b98040537ffaea51795d88851634249b23521e2b471b6779ee65a0b7c19a3f0909bf8b7b7ab851efe37184c5dbfa5219e018951efee863cdbc5de50426a3eaaaf0b6e71bf4cbd44b148f42357fc3e5b27373459f7a68169b56602c37ad2025f014e91b874a5ac4ea794c2b1c91b69b9f7db066533641ac01c47b03641ffddd60f207fa416479332ad19276f1bd8385a7b20bcf1863333afa97aeb9d9f19b3d94f84c42f74f714f074c7916f415315f2116d7ab381b848ef4d282c1eeea02de131f3889a32b919d5527e052e4048e7336b606a3fb274a6146b5d4e50ee237e4b2bc0b44bbfb394dcd4cf6df69d674ebaed6a6a4de28c18347b0ea80c5452b5df61baf1ebabf01deaf1ab9e393d0caf157e074fd881913ee6b959666544b51fe4ba896178f9bcacd230398053b57c8f07089896d94e729ea008edd98a829c4da26a8fd51004154b0c4cfb43c10523d8e0bc688cf172c7831a2fca2a8adbca7b7c2a1e79307ed82fe0388a6d443abdd53a0dd5b1bc590352ec0cacdf3d8914089baac74130a375435d7eafbd8af22ad96fbd93375d384a8cbe2edbb151bae288d09a13267c4eaa6abcd9f505c4c77aa9281051f39d28f08faf4a6153518d15d75c568e89639e89c4dc50bd7a1db6cf734ff8e3afc598e868c15077d44d2888b7bc98cbb0f022f2ef76e723f83fcc9a76fefade5bb1699f84574272b5e91d6f5e808ca219bb440f1ab7ee7cb7c928456a5a83109d8f8bc6745c54af61ea38324ed631ea6987af78c8a2abf8fbabdc37e5800ced88b29392d1faa1400f176ce344fb471a4cdbf6697303c7c8d1541e9d34a135bbc7c1bf45d43fe5ee5dde606dba964ae16bac12b4686cbbecce2cc2d7d1d00c74f6b936094689c57a220b6f32e67621fef717533145a0017c5da86ab885ed92b758ebc49dde611d218d387670ca5765db49698ae61022dca208e54bdc5778d390c33d11ed554879a37a135dd68cf492bf3c9f37350442d5c3a59aebb44c805cf19c15ecb9a03bf79e120f2e1f2fce9dd9dec69e30f8d1dadcf9ccc94c7e8611e26fc0723054d8329f3acbfc1da8d9f2f45bc832927fb585636f3c58758848fde926781e7d203207a7c6428c63f5ed34bf331bab30c3a9a575a1370f070b544d54c42885e55b436992f8b04e0c70e32f8d8ab8f070dd618790837e8108eb6ee33f0a0e6cbbbfd8a7819418740dcb0b681aa601e0fe678a855643683acb8ef12c84436e5f3adecb7e0710d32b8fa2aae3f1ef6a00327f4beb16c0c9faece2ef3cc5523f7e2b290bb6ca116bfba2f10d2466946506495ae9708fa44910e07f00db0c4485f6e9da083e625c8e9b002ba9c053b80018d3ce5efebd669f1767af434b10117aa1f98a32d67592f0a9138227db9f76c748ade31026e2018d28c3a082c8c5cc0cbb78d2d914acc8ae3e38241bd32c5ec69c164df9350852981f12769a0a4db2c88c1da693d5777c1a39c2de0524d729c9536ba123cbcbbe77f5f080990eead0e472439381b5fb7a2becbd5d6e6c8b6914b943d7a58a817d5678ee6949778a9441a5d40edfb85f76efec884bce7af6750db18bd1bb547fd36873c655ce555d43494fb11431a516381b63245c97df472443d8a48c342889289b72ab2d27cb0e27b1b59f9b30b43f561c753534f32a83c436e7ee239ad24d84dde4faefd4bbdff658064e78f1b99adbd7a21ce2d25b88d20b271b1270873dababd6fa3bbd0ae401bdda358d5282fe73556de24c9b3bf38f6554324b49e0f19276cdd6afc84f0021608a07a28ae9851d8d397d6c7044b2f34143afba1285ce779be54cc65b454bfd812869ba8710a08724cdd639d79619ce8c965a750ce994664b63dc413b9b4d58e70fcfd815a17c8aa9d0797039c9816bf615a13d936d6aef6b66180a6b5085e4ab0d4807bb3322314a0fb486d207386ca2b8f1da8c808c5c084b31d9a2fdd94ecad73d75218d95c6f528804dc156cd57ff64d4567be188b3ee8c74734263ad71e0db7252624e5b573afccdb2e80186ccb0caac2d1d26629702f930a8c5b0a500d6e59c0839e05807fdc72ed4be2d7f6ccba732e935fc3881c77bba867056a9eb55c38bb19e695d0cf9ba82f4c0d0b6f82f405372bb866c735631fe968670e2286eff941d68d3b4b6207a4129c38c74798d1029381a93e1393c70b4feb0df8ed23bd0d5ed79022095c0fd7a766881212dfd8d00ceffd676718863b64e5c0981253e90694c1b040a4f9be2fd80f4871d5ba84c2e27fb5bd5a41414a885ce7ce0508bc6b1db3ad66ae8227bb5ed40e0d10cd4fa1fde64b3d7e320564f840d0d00974896384a607accbf17b3e7b80e2e4e4ef79c4c90a984fd05f4b1c58c7f7fa1cc92f56c4ad9554f1571776ac3f0927bedf9b1d866cc735cc538be6bc256d4dfbf3487032f8561dec2758774e950f0c8e132e12df9e575981f20eff8fb49224e1e5bcfe3653d67bb94cb51b38dee495c96bcd00f99660d90a2f79c45177c3391f3014686bf2f14fcdb5415cdee99c80faeb3b9b176954a6b5e675ff890522066c454ba2f4965536ca8610d7451a1b1cce4a30c2739fd8f808e8b9a2a9a6f5bd28e3ff291dc3cb291f05c09ecef2e4e56e3880b261f4465225405ee234971fc110ca6e5151f83c4efac54ae8be23b4e06fe9086dea45636c83358332d29f7dd68e6707d10812021c2d5654196821f134e890bbeddefeb7649779f7acf8ebbfeeaad782058cbe9203d10bc8a16a2dc900a346d747ea43566438c7b885d29f99008501d32ca7b5dfee229f7e318f004580e1f3c6f30d2ad4485886795a501f75e3399d634c1c78e9d14e1630e8e2ff70a09d787f498a6aa6b976fb7caf96592346cd1dfec6db16d0b14613a7b3ef37b7cf51cbc07d474a077121f6847a712310bf8e561d208c96d3da146793411113cfee3382ee23a699c1e449fcca1ad07e70d7e4640126a9cd4a8c55d86bc70ff1e2349560309d63fb8d237bfbb98b511821b27551ee5de019009c214f1125ac7f58a81c88ae732beb5e2c5579242174af0a99a373921a33646255f275eff12daa620d97d251bf2c385f44940c65534549f6b00f4be4284ac1eb1e02cd9efc17a1248ec52e7abb66628513a8f756bf4d9725542514704800161ce224796029073d751584f4c2c72a6d631451892591eee2bfebfe57f7b4f4f515c81893993809b2ec42b6d8d7562baccfbccea5770ea664d039e56ffa5009fc9cc6cc807f11b8a2baf38a39d9c02a9bbdc8575f70588fb7fc45e2363488e7c103c3ac6cb770b7367a65f55ebee457caf9b88b3bce08a05d1e0e2dcb71054c02b6fe11347e59bae094ba476a5b5b7bcf71ac91e18db063cde9b11ddc92be9979b0de0fa5d5a53521efe0bfbd5056ea10c22246ff895ee713586b8df298dfbe15b1d934542c1271a43b2378a82bfa682eb9fa5eafd300660b3e89d10731c3ad1602199a0e1c85960e6ce97c9ea5744f76156c3820817ec0ebc8fd311b4d1a05ea71931d91dfd3f291a0a5b3e6d4afdc0dc9811636d7791d7df20b7ff918b124c4614f39d7893224e02d9fafc7cf3711b717e5e90a7a37a367498b3e73bb3dcedc41e9c1baf95760429d8cbbcb6c1e13598c2ae53fe49246c152b272f24d996284e7bc6f81ae7ef5d64f253832b531847e1b8259b75ad0e227da66cc8f5ab423d18c5fc7283cb9ad7cf830505e4422413485544e97bbe447c0d3c5f0ef15da1cb54d3b40a0c083867ebd96e36fb89923855904f472c4d88f2c1e777f6c663ecc61023157efe97e5ce1e0157eb1104a3e54531c79c0d90ebe2772717b5e440e1bce60f44aad808293e3507f9c5b88202aaa0ae2ef8eb631def6244567340c490e1ddf2b7a240f22aa36ac2ebbc4441a85dc01560f23fe5aceffd97c5f96328e84e0fc97318dd3a86ac2bbf66c2cde443b25176f31aabf1b3102c57d2ccdc1c16fd66f0314e5635bb92866418e95bc39c54705e30a6ccf9a4fac52f8de0e74e38656fbedb1d5cc5cd5d1c8a8559cc29e70ee7bd21e3d333353f16cf272b659987557a4283ed3bc51f57a4f24bf42c80481bff7a5919d4c58a140c53bff28aa68d89b5a1fd9f0f3d53f59dbf99f37c333b3797fbaac5edce480069696650fb243dcdf291f75ac43b5c0b5817639c7b085dba1e36172fb00e1f6bc2818e0f1331880c108368a2681335fde67deb596c274b1d76b1059f7ef045711e87f8da0555edc0b78791406758facb60c6ad5b8eff0a8bb1eff88156d503c31c7fc924f1e20225517ff761d0c078cf415a6ae87f279672c6987622c973cca5136f1ec91a3af00885c3c26e32bf21f421719a1cb10d939301d92b596426b437a4aaeb609949831ee17032c9c3a182d11d164be88f2ea772773866b5d9c5a9c2b94849f7698f2ad134d4ef0563f06d8b21fe91aef4f445b2902873d4d7408bd37403f7a9aa784bda33057e40c2a1bb830d8405016409861d3a65dcff0f11c22a916954dcfbaabb0f966118d1b81308954a39dab696f5dd85fa649d8aded954bf4d3a518e86c2edbe0bca9e84aa0120a94b0551754b238902143a21bce2cadcf0f2bdfa8024df8bc014573fca3165085e4a96c8461477d60cdf23fcf0550888493ea1124ac4640f65a16438e5240ae6762a7d9280f1735487bae433d7b8d5d83a05e20f6bc71aba3167c6d8c184b4e11e794959245b10342b57f96b9efe24c5c367ac430daeeda271b171a76d85b148edeff84faea1bfa05da6dee3c8c8544358a6b88cafe35648b0d77320fe4299c5aa0229247fd16cad462871b101cee914a561840969a57c0e93a801e79460c129fcbaf4f278d540cde4fa54be9c9338afea15d7872d0b5ae6b03a584c7cf4407359304299229d9f8f2496a43d1b8ddbaf98a75167343b0dd5c921643e5c651367d39058808145c1075e92cb84d526eef4a1451c1c90db2fa824010d4edcc7cd372aabe7b77095d6a98cbf3b2c38513c333974a7cf27c5f225076ffa7c061c1fe8556a2b219887fb34380239a94a03cce25ee54e11f87c7bcaa4212980099aad25b34edc1b2a28e15445b0a699b6abed625dc8928fd3f58cef3e55134925fc4dfff9e40c96c3d03fa2eb69cbe41d53a4287671efbe61e837d003a2838a16cdcccc09d8965c5df6278e60693475b6a7b213ad5a783e7fc726b7505ad6c567b83f5a0556777c17a07c4f093eacf9371cf3ef9e91df2fada8db0bbf291980216820ff28f53f65b9c6b73ed34e6820b04b8d873f7495a0bb1c869cab99512ddf9784e9b8b8b784d00a5a31d66fec0a2961664f51a6225d63a467856654d30bbd875ac119a4e9cdc6ac03bff77343f34adfd49a86f039ef7257781e979fb30275df3f39c3ef7860d57529734f565698699d73f39ff6e653aa96832992dea96ea2c8fa426ce7bc1c281edb1cd6f9bbca4098709733884f7333cee77a2d416d1e83f4faf5d679971ddecbe5f115d3f68affe971daaae014a856ed20d1ed29ac10a6e6d622a26eee8c03ccd3530e61c2fe4dae8f701003a090da31aa8a39be2b7dfbe337911e640e20c99848e0f39f30005dacc2f483789f06967f0ef3aeb5b3a6989f9e2cb1a896b5b2111ff31916e79084cc21e283c581877e3f6a48d06b1258e1718cc596c0f43e9f25487fa390156f0c69195f8c34987966425620c64f014768f13cf4623963f091da28ba0bf071eb5809009a8407fdbe8bc47ef3ca1f9427f9bbb5565b5b75f480cfd2acd642ac1c1a9596e606a422dc21e61329f2487913f1535224519326436d1c72a3f3f84a79383b708ec22f77c3c116cb4418b79987d8326d1e92747d339b3d87733a1deefe15078a59eb5d6808ac03b72379d4d266362869347e64a4f1aeccc8f474b938cd70ac5cbc5fd72086e5a4f1d5363ceecbf516fbe32a8a09e42b4bb42f2b11240f3e4db7675d1632a07fe04415805288f75338d3c95f30ebbdb657045ce491e6b057d36ed9d13d9fbc0c606f7f60711d6e86ccff6efde1bd0eaa783540ad81fe11dafc4c5c4ab31b486aa29322106227a37ca1838781c1a7cc08938b2c680d0083a228e816395055c5cc8908c3367c2d91273ad692bf9936c9287aa7f2fd3037836917a0612371b2615c2154551bf35111a634305de17d29bda25dc818c9bb7c41a457aaa1005b6f43193ab45da1f19e81bf4f21920dcd4b0f0a784a7dbff7c03c9ecc312de86e444043a566381511aa4b2ad8df5526071a3135aa50d00edd8db10575051f583f738e006ed4987ccd8f8f6653cda1a6d4fc374323ba186c926cedba9426397604798e51f1544835eaa91fe3a07a301981bf62e2ffe0b01736bab9260c6b49a06e2daee122792274d97dd9bdfefb154b8bdc59e26693b6bfb55a5c20cd9ff9afcbe3398c616557056ede903ba4800c735098dca9801ad285adc43818e4626900654730933f1d4d3e56baada78845d5687b6bc5c126e98ba876a5587d032f7ade0f586ac000d09b7821a04b1d73bfcf121751d7e10faf8ed230c6394ea76ca532a8a399d2389ed19b32d24a14f9c9e47306648008ad9afeb5f6c3dd66e863c59bcc76b5b02e530a1d265b2b9de2bdd4d98541c5490547cf88800060ecc33cd751e4883aa20309b0d8101bde6b969748dfd0f7797d574efca752e083d31ce5b958ef02fc332d1172d6c075c0d8409fe5d7f2c55fd41c4e72743745ee1db2fcf1aaac32996410aab253df585c7c3b251b8839104acd94c0ed8a451ec756557aebdbea9710019663ed8a6c07f09a2b7dc01b5bce907880f844c597f4c6afa7a6e199c79f3486bb0d4bdae93e11e0e302692f5492d0c6917dfc9bd5fa3120643bf371bbf839caed26b323954d592da72288c513372610a58e1fa4f442cc7b502b263728546542a2f4d41e7249795c5ed70eb77f4e6a4ea8541289808334288da946969df0b4fc77829db36efee08766d2d4ef9dd63323e3139ea8e143384b11051d1981009b2348ec844b20e8d2438b75445ebb416c907263c7c64a0fb38264eb61e4198ed76fa90bf1e68b13e5f41537a36fe84bde43097ece33b289d7bf77d8fd79274866ec7e5a9f37e9141c27def7253e1e132f3318612b6097451cfcfffb3bba6b422ee7f40792395a936d1f005a5e5ead824bbd9dcc05c40bb97864bb5294b058e8ca417e6ba54fb0a028aa0c24ad0b9a0842c95e94d78d50b454f08fed4a157f349e629014f3081dc99eb8e98aa454045bb2bfa2d6f235bd8c7631af18b883d8d839203f7e51e4f06e021a882db0d5a53a75ab6cac606eab470c921011d7cdcdbbee96e63a4fbc69642352daf19e820e4a7e02c595cfdd4885319e1f327d43d948d80633754b91cd80caa12d3960593a1705046020485966c574c794badadfc5eae1f9f7dfef08a2af164de3f6f99a952b2ca3e79e0aaecfe4752b56ae0b0de50a628b115d49f894b1773e6887769c76f14ea57550a91851538bb89f1e5d47565b5baf3e269cc9d93b7101aa7cd61be170c906bd5369c47e3b186aa8102f1e5053ce3cb16ac6c891e5757cf144a51bdf35538aa62b8ac9c480edce11d12c006dd487647bf994b8daf8ecb70cc283f8d5ab653f12ccf3c127748b7ab2c62a9df86000f60fe7aec09cf55bda2b7c5816dac37167d4587b0d9843620c9dd8fcd6fadbb1ea5153a1dbfae0fccc85d50e75281119582986331e6ec277d02704b28b78a7475be11edfda66c75fde85cdb3e054cf0c1dfed256b57a3db22eb07870fbf4de74b964735cf90d52db592260140a43a5d3138f447fa7c7f9766c410470bea8f6285f3185a0212b390f3df9b717cbbd411b3ac0b2280664072f55ca8861ed12c1bef0d6cd490fc87a04271eb71eeda4101fbe980378f90148eda577993b62272a42075e873a084847c52279c4ba8c439299e5a1acb1100c1d54c2fcc45e575ad61f5894a1debc9afaf35d69b92056e68e7816e50ce0a313cc57e2bb1cc2a9eeaeab55016636855455ee71dcc0ac75f326e085a7a05af45266658fbe12afbe5b3fb5cd099b3ff18371aa784ed1c5f2863371b991ce206e2c0ad331d5bfe0be26c8faab8b1bcc375dc7f813fbc7a8319e6c6567d0d52945f4a9f8549fe8a20e444030848e885811d2a6337a1de4e275a9e2720cf0433b7c87e66b4f489f35b3ac5120abe336e8b7e616bc80ac9317deb0f78f08b49680f8eea2c192012341e6abff55a8be0b0158d5fd10bc98657cdbfcc2f85e17e9444e99997f29ab06806b67f755baa88847c5d492f191e7f02dacfb62b46fae33f1dd7607f23271eef8bd4a8e0484d469210ddfd68a27261fa2492e882aa0c0ffc78528866bb49a6710d67f36ab93b4ef28598ffbdf88fa82cac0a0770aa1a103912d4420ef8f45109c191319fbfe5f9cb7d25340def05be3a07c21fbe31904afc55905cba731dc41aeabf8f1ee5d9b1a91080c1a19d379880a61c1e8205ff47b08cead00eabd4e1a2edb0ae4c937ad246f8106de9dac015224b068ca342ee666a42d7d7ceab388d3ee307744cb371789c8ffd7f26a911e57afd0b99beefbf97a055807ac2d087a956b8d3c62e44a49b38a21f916fc8f9541fa1d37f138d24bd6bddfb4c6ce65de58a53290aa5d1e94a85c668d2241499854e28384bceb1e85bd0b16f8ddd59b5ee70bff4bcf20e67ca5eb7877dfe638e01a832a57e2329b7fb2e06b6f026d3e6cf3974b13771ccf039d38b21250b8dec81feecdb95ee02fae5e5983f368086646ff4025e2856bf1acc7c914880e13b752f71fb5925e1487306612b7192cbe2d712238ac0990b8026e79114f50cb4d286a0d4e2436b1c9358b137e21cac8135802ea99eed7f345d3c0a015ce22a6e37b51ef1c015f44954b6ed9cf206a37cf5ac3b6945e32be1e5ee10b47a546d1c9dd89636c363767c3c8a51134058e13c94acd6e6b8c9cd2a1595f725b260f6e6d6b9dd904ef0634e9c2b8a0294446f2ab2639fbb713cc59c0e3b6ba75b91fd2c1ccb437b0f7799923e4b6521840889dcfba2409299ad78a68266b57a1f846822e29ed27e10d2bd63458f79e126d7cfe9ff389d9e9476ce15a6dbca92538b57aca306b3b84fde318dc3b952032cb9e293caf98a164cabf461367de3acc401e1e4ee6359bdbcb085f018ed75940c36b839e728a816d377f41ce06be29e00cd4d4b6c69bdacee28c71efbe61be606e423166e49aeca8d836ab92a32a4d36399028c7ba7e8374178f93566923b86ffd0b10817820aa9b67f577bf6c9878134a653fc2fe8e6ca20b3bbc931975ab59be7a851fa2e2bb7b5759c5471df3c544c26528d8b615a034dc31e4b64759e025f8c95b863ff09a6a101a2f366ea20db1692c6de1b6180ca02c1ff5795c307405e020afc5033d1e95d639f5667f9beb963b7c14a3c9941e7095eaa2cbbd4183fa3b1ad37947303e9f8de11820749452301b0f57db5d402c5f48db45b985ebef4d36a8cf528111ba3ae40d1936b01de1aeaa6fa24a3b7d30e68e393016c7b24502114ecd1012493d5f160a1eb98fd1119545ac40d59f6ad26ec928dc97e4c10f16f44a0811e3f42b9e612fd79ff1a6ca6200d16714f5f954e17fb170d2942d684b8e27550ae25c6b859d5f3f75f13e3ba0cd4b18af6ef42e45b91c47d3bfa36462b20719723357a326631533d5701fe0cf8a5af12f6d2b022c8eb383b4dc0fb82adfd55a143169cf6156abaf8f111e02dd2531abbce9b7c034ec862a2d46af25b6a338e897b0502232f9a8336c90b967268674e50e6d5e197ed62d212bf339c87d5d56a4698137178f14e414e023136b7be40e00cbe7af8525b4f09ea639fe2de3e6b744350aa0a4fa789fe66ed19ed260b02dbf46949d8305fbf756b2050afcc7939b2d62c8eaf35503ea8292c14af48b1c78b006964d60c9e59c1e0a6bc7ce3ba600b70e798f43a99e531e28175519d53e5c89c2f3babcbbdfe8dd9a96a10cbbdc52fe73c801f068a6d620f032065a235f49c8224fa251015b2b3c662ac3afa49e06eb6a90d562bdf4a1a5bfafda2c3ac3e40cea945173a0d163cbef443c04b9e207ef4a64592b69397fe8e92e3c62798a9f13272ddc4a01e7c45c916356179073eb17298417a008d4443165e644490b894892098aab52df131593700d2a28ab0298e90d59abb423e8232eed921828d71fadd866840b7a9bc9bb095f38fd3de087eee76b32556cf432580cb93b09f5228a4c189ad1e471fea070b03b526536ffc7589bdac5325f08d99ce749bb09cac1edcbcc710f31987719c7223dffe1a6c9fd25530463d41d6b9801836d1ef882094952dde90f337f0e02bdecc4b0d5d113966e1f21a7ce585f1d33452318af3ee43efca84c3bf50d9d54073109ea67b0582da39faf318176b903ae3d320493c95a7bf632c20088836148e23b5987f5be5cf425c609ca4e0f1a1a52a4743c512e519fe2b5ac892a40402a82f23f22ae0207be0b9ed8d3c78ea38c139f157ef0c45db75d6fe70056f65d59be91a2532e5214ad619c2e60fd6ecc3c29223258bd9da037aed5fb10ed325ecafa313e45b1beb77e904edd323138ba239b4e9c9177311eaef69374b495c1b55a2c488ccbbe19e4aa75f7020e703d4230eaf6abdefdf3da875f6b5c7ca1c0a8b250ba4e467bbb859439964e7748729b777794f949330d19185797edadf5d9a62ba18f44ca7af5f3bbfad44cdcd2e6c7d5c955d0b097deeb80e413d3223e56fedd771ce2405dfeff6e572d8c80ccaf79e86172ca95664d618b33adaa7330885702a84843aea0eb0b66fffc780177feb7cf5f5ec11838f23885309f5918ec76e7bc5ffbf46842fd8a9839797e4a3d97a392efef08520b363ee56baf3a976e5baa684361114a05c6aa1e57b75e2bca0fe620895bfba2c02262a0c675a049c85c02df0ecc0e5fa3cbc1a539b3aa45bb885540d66eeb3d9f27e4f5f8ca03663fc50a991e051ccb7ba6dd0e91d6e30759683863c6975ac3dde38e5aea029f6d73ec154372ef62f5d52beca3006fc8245d69eb04b7d4155f4560d5c1eae81ffc082508c3c83631ffd44e3590601a0a96a54572bfea15013a4f9011e2f99e033303ee56f9c2d6470c39a154f76f2dcfa578d0b2d9048d71615e3f909a5a05afc243812c307b16299f3cce6b5b0ae628286c6e43877a30718e6626292ab2f9897038063d28954bcb1594ab2b084b8f8e0605c51bd44f9c356921b08054113c950e9ae91436899a84fd79fc287284ea1b5d221611a8673b3b8b48d96cd739232c47b9fc55ed910ef90d15d2f2bb3144756f1d8b1ebbb4ad4e1b0cdbedff27b9d1714a298c5ccce1f80718557b3a830879bb923f0f683d31484c724f1316c0ca058335ef27af29ce83c61b909cfddfb2a1ba1de2edbb92d794252272b918f7a04eef0bfee0a3e4bd4b75b8d37e9d25a6a19f6f090229042f17425b0e99793106982232c71c3004271432d4df3b1d4d25fc72eff0d1f4f6a5f7876407db76d4fb6cf6b0cd6252d130ee04c1a6af6d4dfa0c5292d028c2dbdb454dba2afd24354e30bb3c247472e2f55ba6507be41df46fdd0c3977cf4132b5282fb90018a12dfc8ce15d661108c8932bac07cbe0b3c2c4a50d1eaa55addab2053f73f2b9b6eea70cb94148c756729df35faba855322741a2a8ebd26fdc475ceaeb06a3247a36e5d0f244a7bf7e124dc8f0ca9d374b075c7d6239b63777996a029104ecc90a161cde5f13929c89b6a668468b25d48403c0dc5da8f7811bfc4f29974d4deda2497731c2001c241da5d7ae5599a5e1225418a90841455ace5a7bcdf6dfbba8bccd92b2896c11602e1197639e8af4428d6f0ecb330ee0538c9b79dea94126d7db7cbf0fecccc54bbbd23b20af71799f544f4c32986143bf13f9d1aca58a40fc139d6f59a6eb63ff978fe3e54ded11c9f58f8d3365d00944a29d1db51c165311261d8a726c86dbe47ad29b345c62dec632d854f450b41d31d53c2265476be9f1e192b3bb5c27dbf54211a925491dab270e4941b7030b219334490d02110415a74c1338e2a7f7163490a6769ba76699f867f29b2ded689ab9365f883f160442ade2773df6ba9e2bfc7415f32bfcea38500f848c7ae24e2f700b70491a60e7a026367f1b27613a11917a5d842fbbd23de3f2eecb94627d3da02b4689729273024432cf3ba5ff4bc91c8583b2d9a7f5ca36c38942918efa71e1604dd72aa72e260088cc6873169941412b657642f681cd8ba9dbe52ec04d92ad4f5fc9a8dca3d985064d0fcd83e737fc39d11bfebe93b1abe3078a97abb6bf086d3e342707a9f85658e542c78145fab1e1d9f77098fc6063925bef37acd97475505d0480a3d33e65540f7f20b737ac187937f512a1f0f10e06145b198418a21b45a01296db48993a7c9902b3b9ba7ed9a5ec57d1db1fad4b194144e421f863c50943827f49f189a03816902994c2e2a9f46b42a2fef9e5fcb709d0c6c1d6f4a92881066ed74c6e0e36fdfb102e0b7e00e17a91859eaeeb6ed779ef095819b3b1327b7f9b9eca699ef22854fa461409523dc759c8a079b8fc3ee9aa9999639916e61110b92f633af56c65b24530b6fa04d8fe688a58a446293b90f8c596ee13878ff32b20e152b84352f0ed7c04456ebe0a52657e7801ba2094c700d736b6ef5d159f11d753091d72de0597dd507b013b7e5e00da57b35babca73cdc73a47636f97935fb880ee8b8c38ef1ef6995dd59075b7f3a3af2c4a002575594482c9e9d92fde686bb250d30d2f54c06c3dc9ece494f784d85e69f9f14712bcafff67c0b1da264d1c08547201e81b5cf334604a081b920cc1ac3d4280a21b709dd680649e5496f5e15c76d868be4e726d90e84fdf7e80a247b17456f959bcfb123358b56feded668494c4482cf20bcd4f755fcc8faaf7d6879f4111b3102208fb5637cb41aca643624b614ed0d6355f49877f5c63f9e65daa2352ce9919f9a521800416776bb69a46af4208e5ebadd3b6fba98b3f74ab32ca90af6b9ec906634065fc1b8668fec2c8079d7bb5713d5c98a4aa6c94bcc8f77a445468cec259b839f501097454ff3464ce3f353dff3a6835c44d0f883f5371a3a45d38f25280cd3ee56f1318d912fa027fae411d09f9352073f8f11fbebfea0dd3e0680742448105317d9689914cedfc5d65fa5dffd2a5e2f8d6167429c0c5b1025cfd1ffc2b7858cc9634d860621a4b6b1453d2b5a8cf0a894dbc95091e94bda62ac0b1ee71ad35bc9f0132978fa68d37883f00e091b0aa44b7dba9ec497a32c8a9621a535a67e873cd78e894e05e2c6da605496607d758642983473ebba22dcad84bced0edf793e6735de1c9e113f4bc1f0b506491c68cd22075f052f256e5c01dca695f7ec8c7b74793e58d871b73ac84401a4fdc03ec3d02eb5b963f54aa1aea6051a30118318141a5cee6fda80a3f270d8a998259a997b552de0b235caf00ac613a44bec07c78c735b8531bec01343011bd4a546fa6351c76eccd61ac7cbdc70159bf4d6ebd1e00a2e389e3f647795f774c53cd855c07c49cd71dc6a5fc4c97168a8d74dcce40d2d780b623c40216c709db677b302cf9f32fe275657035ab47f858aa719e36126bd4261204a4d7a72f6c233d720b383a19375abdb7f1d83e52c0b17d232f7a902a9c1197041ccb8065c92921828100b2677fa42793193134c167f975b24414822f9279a2b8f97f53d26d0820b92c8684ff1143c76512ad60ffaf9387fea93dcb6dc6d85d115d20ae3edfe1d36f60c26636df693154398986aecf0a97f73ee4c705b1542503096ee8aec81313160adb92ef2e0b9447ea886c62725e01683a6f52b953f91ed68d3a3a37f571307e73e081b0b97521bb4bcb4cf06050a990595cb382a09d22705b2a48e8b6e2e6d198f0c0527e21513cf5db8cd9700239d13aa21528b39f9c56c6a840921fd7a3cad52a4d7150df71595c6e125294a39b0fdea5de442a9d069750386b3dc70a7b1eb9410b6146690a2308d55a20b23dba0078f4cd0bd7d6c5a0bdd8b9080345176f1546fbef79d3eb8d7c11819991fb57de3697c091d9b8e6ef4577c6b8d4f704452d796d3b4183280306ad77ac06436ab157722f4e00ac44930bd94385e399ddb662ad2035cf3313d41ab4b6ab6ac28539cef770f973e9ac16882d974c40efd6ac22c52f38f152215bb250b7b064900b7f8c1d7820b56f8bb3add6c25b26ee0d2ed0b41bc51e9483ea7bafea193504a5b38ff1fb38b80b29750c90391247e99b8ba2323cbc63a9b351190040f5ef751636fc83da8834f49d5b9f04ea413b3b0784199104003b05962a4a3bf414e8e7a70f841805b292b4e13ed86e8041d98082d7e78a3c4029946c176f8fa15f555f8d1ce392871c30cfac178f3d060bccef7217eb218ddd219ee112bfc1a88faf9a60c5d1f2f9205447289ee28259c7c918d6d2bcc1cece3bf4a420b2a052bdce02b319d6f5826ed6fde8a2d9fe9871c968b09a155911ff36c921633e18f7988c9e72ec0da0a19d95c055ea503afbd583f93f6f3886a2d832c5c435d052c67aaa682d6211948d9d5dd64ae6df7d278fac650f1e85e931e8bcc2a18781eebfd98210749da456367f5bc81505933e7f00062e9ba2107f46e0eac8593839fbe660f283d9fa37e9b6c397ac1a63d9811f2451a444a2d5467d4afca88b729d2a09a22981fd34093571fefed2eb786b7ae94024556cb3a0c9ca940bf912ee53230236286dd65fca9cf0903dd71104262794416f6a1b2854d4403886317b4a5d024a0f84c861bcc9ec2bd71c7840b93176f3a43e36e7cbdc23beb7fc7da36f2913ca18a17ebb589373cccf471e9d86543c42bc3f0643d8e30cbb8cbcd2183e432dfcb3da048a597a75291ece63605d68e657c98ef922b3e0d081ebd968a0c5d587268350aa75cc080309ed4ff4a6c378c228977baec75c7a76c164e740a9d929823a144896f25072feb3d55c1a89f094192f8b53de0f4a5ab25ab1aed614fa57ae44b15eec3adc28c1fcd5dd65e0d7ea8501efbee61165577de242317488dfcbe997366719d1840b8fd5178cc88c1c07c9941e655dbe1f1f095a8e80fb3b959b4f627340a8eb69323cbc9e3295bca2c61d0695f0eb97c94392075494c6cdbeefc521b7187f7f830c0e361a8019ac1a2da3342f45874a5433e840140b50f823e2d0488fd72a36b2862e0d079b19f091fc80d6bda9101a20b4da09d8d0cb9d3965dadc783141098a6650d181dbf8b09e6d0309b99a2f53fe8dff6a7f169528e1dda00c6b580bdba84232fc65caa4272793f4d71e62d6e7303414811acb609b240381161c466d2ecf872f6d8794ae5db1426b36c7a767e7795edd6c4572ad93c2226744de55f57e51b1ca53ecbc60cee97351165323f22e106c08caf256fc8fd7da46850cbfb8154212c3b119c8de05bda45f9e701bcf4c81781c60ba8c7374e6ff520b0b041858f829028bec75360555bba307a5d229f42920c597377195ae1a571eb32e4f060400f235edeafc4afa339e197ce8f98e1dcc5a2edc66a19868780371a61022ac4506346fdb0622ed4dfe8918015f1f23a7bbbabbd3309944915f90072fac9d34629f535bd0d650bc6f207ec422fb59e528f7241e6e86f34806d077f206943fc16f67e1b04b7cd95ffcdd43dce2a7e3623c3d52742be28f8d22d33def146a3d009d3a1edee52de84e57ce09b78785784d32e3caae0c81baf0adcd83e62d255a61c2ccabce6ed9d26d0cd24aaa4045e4fd11014ae0a5f282c4da6d66173ea53eefe64bb0d98b0e3e4a6e2fadb68db3f97f5f6e29356f71aecbe8186a20f51895776aaf95469936c0d74c18d67391e61054811f5cdd74cd9f3cdb1d999414cf3faa759c3840a79d72a1fb59e5f36780dacade14ad5fe7d97ed90b5006884f3ce079d82d104d26aaa8c1f55c2e15a9c7789a64da2b9334e34d64a3694bd95f338ede1c13387123d00d0c3307d1ea3f740cc1b083b40d044196ce8f26ff0d32a94e16b633ea61e49e1d8786044f232366d6ba2d9bf5df8a953dd2b28775bea5d207ff06084e2439a0ae7a6d904483c17f3d3b6278963b1ae4684766368b4c02beb8c6ffeecac48120e6586ae077550f6407574bf2382c9e44a288708f69fe05f74ea7d34ea18b2757fd9903a642c8e160251b798ce7bb73ec3c90d7e088e05df527218a7c46fe83819217f122d49cdc6bb3eb3a7b88be0d9e6242ba1569759bfe6956059996ee30cd91f3ce1a002ba32d72af3d204fb2e15fcb342141084da0b454df540bb2d21bd1c3c85f2796da747bafa006d832888b8a94a85373284fb189801ab1dbe916fcdb282149b37d27b8c9c01eb82f42dfb54fa8486d40577ed8952e79c4472ffc96146a51e639933ff5bdfb3316d7ba13426daafb320e9f75976e5131230536ff09013bf3693530090c52cfcfa22a3aad6fc826a1b3372412493d3f7140ef235131bbf483fb14c54370874ce675f0c6356db8f45997270d7f5ce1b7d3f1d25f150566cc7a76f5b80b27893ba1930c5358052a6ac550d7e3df624693477e0e8a850dbf3d5f0380006ec2106742d598a45ca7e835042b51916ba9c6c1b89b9f4474b68dfbb5767b0e5afcce87f6d9cd4cbef035d48db5987d27353394f45c40d22edc020e3f30709045e2a3d60a508a4959e059d6a9ccce05ebfbe9bd03c3843b60a47c971d30731277c2f2e7baa9c199e71a00792ac175e5d40e8b619412b52fe75d3bbcb4704a3f1be841ed8529a8762fd15b990eab73839db19ad6e97f77a6a50666505fe03c6ee4a521f6d1ccb5cae8b7e8dc2b05ad97530f94846f20ee6f7864e1953fc8b4bae3dfc8948dad3d07ff65a1f0b9ea43d7d4662a1f694a8f4a1dae11e10aeb80b5c423cbeb9d0d884c5eb8ca4b5d944f5ebd7f3bda89af923a3b584550d8fe8fd4d1fbaceab0542fddbca5361555fe388472f562c288da588f447d067ad8ee013394f4af723b705d43d0622c14bfc65522b334eb7ba3aba92b58fc4b4602327cf8fb3597e5fde982a25af56a723c7868c37def890f968294b23358775933a945afe0e6ef5ddde4ece696de0ee8063d89a24ed3ced0de75613b88deab7697b671584806afda1e21d1a6cf064c43ab3baaea44893c59dcf4cd1860f7b50adcaccbc37cd1116da0077261471afbc2a331e2fd099bd62813cffd7990b47f567a11cc324931d4d49ce0009384c73fb6ba1e44e0fc5d89a1379cac1680f27edc7ccb893345f1c7f53c052ae02476b5c7d959e06aba3f4411c36287a1f0b70e10a47fadb2d62d7d1f1738f7f945623cc8ba39cb9d453717dc3613c69ee71cd28c034ca9cef7d02ac234f6c368254af524eb149b4a38fc266b9aa0f38473b6dd629d0fd188818f863d4b590e725bf6c6649075c5eb2bb9512e830c617b0aa5cd9db593c4dcbf8c7783681cd2276f586324afd84fd6350b268890c1c3223ec11bff5af88001d45f9ab8bfc9cdb77c4ea4c0165662ae0a10a24ada18a83b2548c376e31595dcb1825af32c6ca4a62cc933e951b8e5145b246c62a9aeb07469c9ee26608ed8b8edc7775f01a5068ac3826e603fcbc039bc141b7811391acb76b70fade7be3e60b18ba275da28271e332c68432e960ab1133f0af96829f5921e011b1036e6b509f59dca81c751bbf137a710cb25aab65a388cc7be3bea4acf89076d47f8e8351f9092fcb39a96afa1e63f746b01ee259aae9b9dc5a6df3ce0b21e9fe7eaad2c9e86022067dae3a6baf38c3719c4b12c8f31deb435d5c47626eec935f0ede537df82295cd4089a4023d3ebb652b75415da7c97d5748416f93c6a5b8bc43968f7d94bb5f8ed512daa6d3d8799bec80ff45d5461dbd72617ba4d464038eb0825aecb37b30ec19db097be76dacc99e0784e9d718a7765efda1d421cea65fb7834227ca3b21b49be20412b1193a213a4d192a148972aaf45cccd32bf0ceb8648f46d2850bda8512ab1b6abe800d740d6bb0b01a803eb2809f800efea4266e2ffe34b8cdc16fe2a5d820c4328bf17e23db5302845642d25f2152487fff73684390e97387836deb204a850455680c9f51e27e44cf9478588926d94bf02824f98272e7a4ebb0327eba89e6292d8966462d1e68f1bbf0e55b3ec57a9b5b4169649f0822728a8ccae385702d82c24a0525e93bf3c9541fb543f8455957c6af9c11b7a40412671b265270dfd24533cd5b8bd9ec14287344d69b145d391477d66c5091ef37789873d7994cf675833a5cebb349c7b622278b7f78356fa2cb8cb9bede9b901b2d5a5d30f1748c862e97d1b98ed0a9752325e179a687975505725193de98ac730da81449c137ee4843dba46d401f9ea8a0820019a39fef7cddb92e4c3a6ee580390a9a5ac5c6ebdc129ee6bb6e59ae293b2a8ee8f06dd1089061e2cbfe9002a821c49a84e2cd1fbd509975bc22fcf7a13653ad12829922d794537599b32939a604efa3f1e814129659cf099530707bc9e11ef3bd9269fcd83847e88b84139ede1d9ea987174d88af60740c52ea5f49e112d560e751350b4ad97d977a146ee92ed97038d78afcde4402729431fd53e1cc9d5677acbdc4613b5b788741b30c3c39db810bfecfad77dcdf42cb2db4ead4943749abcbcf2959765fd22eba715d0ecc5963e6eac981c97b1dab0cdd789d0ffdd525ebc6cb31eb1a35183abdb1b07f857d9640217f0f9962f6104cb422d4529b4dd177d901ec4e7ae7dc51e8d999ad0c01730f0b00f2a346bf3d26dbff00395972e4b3297fd33de6c1810b4d53ffecc07a1237551231cfb00f2f9df9e10cb0811071c30aaddbac50b608dcceca41a6db7d9686d765c6f178a6b5ed36b68a014ce86fb865a7e71eab8aebb187cd707c06f87f95f0410afb9c8c9e2678c18aa978c73172ff57a5f289839c4b702407a1da0eed39a61c488baa48d4c3b4d1b841d2df87b31a85e089133fa4972792700c165c2af293bd0e8f0f34d28f56f7ab7e8698b89ee680b4e2752ee3df47ed7875250d6310ed12416defed1aa2f2dfe2b6bec39cc1b47c506183c4d1f350919527addb1c4e04d7b1d326159ba2e94a2fa2493ce4280780c4a971fbc5b09640a168ab58b09358c5839869cd8e4ee07c2e5ee364a6fef158336f8d579337cc7fa18e527377c516bf00c9e91a73c807a10a354339ccdf185f283a6b0be5d62d6a758369291455d6992cbe25d2bead75de4544b408705ab37b3033468b0d9dbe6c944b0629568a79a07303025d80b86910b11ee1f46441cba806191fcae08791ddabe71e02f95e69b567943479f94a7d6484468a507030be329462c84784703172798d9259734f75ceb8737cea5cd736c008320a30f84719cfe74b659dbde7b7de5070210bf6bea7e47638a4f9a0ce3de22ab9224af6be579416f09aca9451eaa02615f61e0cd2a498328bfdbc46216adaa0f70e35e35c2eef07fc077d675f6a8b46df5e3663351330bb571d413354967221bf9c093b96427a702557d7ead7af8d95366ce3fbc2231ce30ab09e8e08bb06fa6436e0b8f851a39a450f5b1f19195409b6eafec0d8103b465d87638d07082002095bc8ea8045035c2c6f0a63328f6ff7cc43471c5caee705d4543514faeee521679f39287d1868267ee53376b3df70ea8f2773a4e1a18c7192b1cae01a14861e155e6b6912712cb1deaf209be7fcb044f1e379915eabb965012ed9f77421e534166f8f04d54a11f89ddec9f9f844b5e4c2dcd314fd4b1a0640e829110417060a892c23be65128fc27783027d626c1dcb7c779a4234b4029168ce66112ca429c8e1b0d0339a7afbfab86a24e2f268b033685392b8b84a6d267f8bd03928d73c000ce80c9ac69b0c1bc8e6cd90f49bdde79c68f605e2645f4b7a43393fb506baa33585b5d097c26b257306fae507fd06be2012a9ab05dcbbe364b06c492cdfda61c8e60e82cfea6c4db45811c94d14cf8976931f75fc95ac7d7d7480f53e0cd454a28d89bb8abc9bed6b81ad1047d024dd39a49506a4083556648d4b77c0e7c1eb52f3746a806f884b4586916332c3f47cd7cc7c27969cf8aa2d0d7f059fed2bca16974037239c295856da8ea74868cbbf57bc39e2055895d3a96a44f9ec4883ac75b050472a4448dc20361d083dc3cc79d7ffb3906bc825b03dcdc5f4f2014d137b1ae7aabe42c6dba4a15b05892944e2bd3b283a5698d1f2bee99f6726dcdf863dbd2d7765d792cdf980e28f5a3097b59b18ce0af97fdd96a6dcfc9da90f9bc4e7e1def910a07ae4eaebd930c62962c7f6a8dd33732b6415e19391f94d4e7a7c56c01120e3c2f95c864363f0bc0921ee18f96dcb7508f4cda395a3f480da7987174062877bc079087cc532f6905aba976ee25a2f08f13bbafa638d0714a541eb89ca9beba5ba8bc3b7b3640842df0e33dde8acfb3a15de3a3a54a6ef07d8751708f1c9057e4056919f1d33c4a433fc4bf2bf3846f7551185b21951e7d5e2b55216ded93b7aaa502a6b3fe85dc5afdeeac9c3471913e5e931d4e4f775567e07fc5e24a1f80012bc329617a6d19e77ed6a6ead8e376f20a666964639802fc59ab0ae382c253d71d3f729902102eeb193cdbd3c302a375239cb1057ebcf368bfc0e48d3349c02a7e961df962ccfad73173753e9f2f4c1c79ccc08039157c241fd059f8d442b0a2141a4f6acf052ef7b928a2fa5496a6ef3f413b4bd1da9ecc84d65a9cb64a53e045a85c1728b29073e30190ab0b52d52710800d7495db119de5f9ac8a18a182059abb4bc779472d7676eb45157307d63ba94da0cfd0988133bc47d05833033fb9b803648450a1922ad4f7a2f3178aec8a3be0dc234902bd3e18e02d733e8691bee133c77fc19a1ac25e8bd06f7328ac50ac13da311a783240dcc56c639eaf558e6f64d96015cfcfc5017a482974c94249002c4dc52f281673fdc7ae92c11707f4a5c551f19ce3f7659b3fd75ea0358e284753fb3e1228c9a58964857db84914ac07762317e18963abd3d81aa5c894baf78199988cb8e2501cb61b528b282216dfe6f26db32904e42ce911aaef43c34867a007e469309626e402a9bd3ac92cff22315b5e208af0ab471850ca5d5f646c4ea91c751fcf9331329c8e22555a11a98f058742a67e82102a0e753823c750dd667789094d2d375b92532ddf37378934381a7787208d8f31dda6b3546e6a51625ceea8a2063d96d9c79b0a5d54f29dbfe49b574c4e2214a8da22ad887bc404c01a707ba66f7a9b82118c6be25d1e6da3d5f31d76952355c0f6c199df0edaab699b103a08ca35b7576468cf251ef92167cf895cbdbff733182dadb911dc7318d803d83b1723ada63b3884f9814cf4b4b9726f43e922630a66c155b745117d6c152ea868074d705fc1ac92a16e76ec5df31cb203dc852e82c97e891a08196c92d533fa8766dc4d6febda41b5cc439f008e8040684453349dc7cbec1a8408ef1b45129bb2713baff63e9ba2ec9c4e73e422dad682e875f12913a93f5dde27114e69e8572dc893c5ffdd78751b3b3bd0d39aab06133e7c6d3111e40c80e360c81753470d14ba9f59ece5efbf923f3e923f325d708892b86d3a9d781eea121dc3221b67fb17f2dc96f4efea47c245df2b13c9a60268b1ba2097841268d9da38f20634285016cf3bcb6b2e446d4e78c790d237fb47a90417b7c3fb21781b5c0fec2f8cd1f554490c72cd3e32438dc8bcdfce28fc5c1192c04334802210621e2ed92e743687115fd2060f1e35006d7578456387fa9b7110954318b4b4a783ebe346fac91494befae66383a61c5ab1f40a42ad64007fb097e76db3c33892ef8a161878d1199229cb0e8cbdbe8f0ee0c5396e23d7f188f2356b9fe7d0232f51ab13085dbf18f9304012c21ca4193682fcccd8be2222fa30ca6045e4464a37f0689ed4b53e8f1cb35ca97c7014633622b9e9af4c22ab3273a8c7fd1ffc94ecdd52fd3ce71157e1a6e398e895fb66cf046b5ae37a109387be9ff5dc5fbae7f5d2f13f111a38641f1376cd7be2909996b827939642c6048bceb3a1e32c0b9ba5935403e59bdc4d9aeb415f10e98b396b27d77607f85c231d1cc6cfd3a30e165262cc755d1ddbcd2251df93e98cb6c54e318e62f2a6eed344fb1099f290071088784274904f233d2c76e1b13984f42d97452f5fe744f52f2ef142900529aceeca9252f02804ae1a1e22990ab78cc599f5328d25e87acae63dd12449cd501782b5a8b2871e279861a4f02d5aedce57d8e88e733029891e5d34feb212bd74330da046409902be76b33deeef3f70e1d0dd17989fe96b26874d340af090b25bc406f4228f35ef91bbe5b8adf2533f46227a258afb5795cf076b5166151f292657526d66707fe321cbb353cbfd24fa399ab399ee3a62b35b10fad37d999ec2102c67e0ab8f12e92246c647acc65995c15150203f74d2684a194364496de526f24387b22aa10439f4ae16a505911b86419ca35cd728534c3ad316d34fe35d114fa19b7056cc79a84ee2938213726c7d2704f822b2010ebe5665bfd8c47075458535efdfbfbfa8faf70a8fa111a8c792a5517ff63301a7e47b01285fe79d0679b3cdcf420f711d338c937f05c88ca412195649b88321bcad4e858906ffe6db39d18523635c431b8e68f70debaab562697f6b643ab61f9c005fd804bc6f302dce21814e2274c4be0279fe34372c39845fb1ff32e10f4a63211ebe779d05ee34ed4ba1b700802e6bf93c95fb3587ef1aaf1f30b41d85d8164e945b0f307eda2f3069585e9a5c4b847a648c92d6ee3070c18203c16e8ea0e22711b529a3cd8b45ef6fd3b337a0bc1853ede53167ce8015c9e3ab9b4b7f82f5ac39678bcd0500c2b7e01f2ed4acddbe8c28fe64adfa7f8f482a7889a1edfcceec99e3a3e20127dd38eb72e029cc4596ebfe23557c5518cd8ac178593be1828aae04d13334f45aeac05c42b3b8c586aa5aaefacfba058b6b737b5b2010367622b1c8fcaab4a4ae2fb5386a7916dcc1dfd397dafad955f8365e95471c9e8ee53a49513e9b6f72464253090210a66e3ddb32e87e263ad61be8f63afd2bce1450278f7d5276d0eaa6e3d815ec71d5b5c3effcf81ff58f74bc8b0713a2bf437c9c335b1ef5426268d689ed0c7e0a8459c6bbb7c8178c66baf423ad7cafa6309fa2384f5b91c2308fd4419e1929c025c1fcfbf396d0f1e90707c08d7857ba7ff77f8c67d35e913cbee3ce8af94cabdf6643d61384ad23aec61d4ca1ee66c73fd8ade125d8ab51f615267fbf412043d1a5510ee06a51b13fdb65a62b8aadbb447fb500682c292fce400e26b216939f3d346ce4933d9b616a049740d9bfd1e58659e7bab146154997e85c0cf8128c08e18747b3a9587bacaac457e2234ee5bdb616c1211deb1ab985b6c094cf86225a13531eb0aff92b003e00c8b3eeefbb5960fcf30e2a32e5a227689f2dd3695dbda0ee41f4b076a01283834df3a541381a905130454121a8c502864a815a08e1e5cd81926385ba46642c8d361f45376feaaad7abc6d64c28b30487cc8675551091cd4962231b6ac5ae120ef7ccfbaae67a824ddf040295709e288a2fb8a1df9da87dc11254d488a75b176f6dbd9cd1e28d7055432e90a374bc14310418870f39f5c1e91dd081ab16ec71a7040bca14d1dd31743fe968c554d3e2330e555a1b2769d415f19effb135312afb7d941c67a4f6978520b188e4cb9d45f921221354dfcf2f9588820e0e8f1a114d7afc656d51df6084d28683ed9c063a3f15a06da1a95f7e7468f0e6428d2ea3cff1ed6d0d28be24496d04b01a49ecb41f2307718c1413109775bd59358eaf5563233b07e7ce1a1134569f3074ebe3eb751c5c05cb93fc3461db8267c4b8e657e095989cd8b19d6493745b5e6510e3f4c8c1601d25f9e670fa83f575754b6b9cf0ec8e8741948ce7443ced9d3ec28182b861f0816d315aae2a3ea4b70e86207d0604cc0460404854c35205ae1bf2eeabf042b66213950182858b3b9d94def5bae8dad34a0d270b6203040358d7572b4bbbb2e6e97f3444822e738570923fdecd55ab8a722840a46251d65cdce79427a3e497a784a57ad354211c53f045aa1e2803445ee87d49555d2f2b891e92383bf0db79b13495393c72321d7f75d41a01b0384ba2567fb54b703505d3edbea5d83b712c686ca8cb1b57096ecd7a24270c754ccfb5387e312fd99497c1ae704dbe4a0140a47c4f531e8559ed5dee6fa84c2cacff4c691ccf1cc17724fc8b42da790c330f23129902697a75e4e39ea86d672e3c30ac879635b6162c0372a79cc6883d97f713590f194eef7d1fbe6dcdd890b22d52ab5c7693a2dd9c8e028fde1978b484715ebae72be09170a340833360ea774918260a5e30dbd297cd999534d7ea26530ba278bd4315bf7e25cfb881ae49b7361dd6a93bd46f30a22a0e4884fb59f07573d98bee29f556bee772a34f9ee101386e56e0ddcdfd27d12933191ea931a86a86fffd204b460f9fc6abb76e6ec5a3477dc7b3bb42c4f76814e4aef3f042e483e11283bc3f27d29e5aebc30e796a35529b7d969677b24be8dd37449ec344e37634340043ee00df3e66202ee8938094f5129a67c6a9e74a10d969513639e38d70c951834aed8c033ed9430b663af9a98548bff1f1a3ad4045f9824323a835c9468b784f90123330c4145af6dedecced34b3fbb1839058f00ca347d6c79f22da9c07bd5917855109d0f147ddde829e5dd95383f1a06a265d32cb2d4d6aaaa10c6d2ebc69a7604974b95b159bfe8d2c0f6670ae80c3bc4f8ae63b66041ec1a0987c346193b61133a752519554729b4d982be46834281108f0c028c337fe0dfd776ce24896a573efd556bd946249dfcadcbd9b920cb62a563e7338e1a03489d07f5fb1229623cf04ee27df54f2d99ee45d3de2046b646e16229cd23246356ecdc3bb3348b32bdeede46fa31c84da3bc7772dbbbb50dd65160312d359abf079ca21db3b51d90e3030313891c77a701cf365da8ee57cbe15905080c220afd23affe4717e8042e22921d81e169c88b29d4bb810e0732c336dff424039a54449030dd1d0bee09dcad5700558726f67bd85e0a11b8508de51586e6e0b518114af15bfa91e01bf950953e80f25b045ef31b0d4e1bfb719ca9b99a4d61d8a5f64819bb9ea97e652b5eb2a1acb1489bdf95bf48d43c782aef79ae0bf20bfb64e5628925c25e254bcea0e8873efd805d2a90391b2520226777a8952e366e15fadc4d19b0e6215357903c870491e0d7497e983226e9dc3f686ce5970fdbe38e2d5fef440ac5b4d8d4e7b47899aa74f49d4b893e8d5374b3f5cae3646109fc8c565934b752987e4209c006dc238a44dceeedb5873d5df480e4b9dc711a126717aa05394bea2c775fdb4bbc4156b32bbede342bf032c223c6a5050ba14ce0a8b27e9bd02409f7a2c884ac3ab1622b725348fba74900841a83dea6c72a762830e30ce94c9069f7d29f7cc4a854f256ef8104b2e5b41f1163650a983804bc9202ff09d4936b548897374fea3c6f1229f7bc5284fad72472e4af6c3f6c9ad7c80c142bec318cf2071ca1ff3b275232234d4ea0768bfc0a97218b93082c73864ec773674db2c419cfcf495a40ac0368aca4f216a9273b0802aef772469bd39f16417153ae9f4523d394834b15abb8dab30e33749b0e4a59ec5f2946ef60fb45cf8dc1215597b1c75199be07e4f24aff281a06de6d02b66164119ccfc40050af5c01f70a8a477bf631ce8622af7af9b1d0e7929ee74165757f1e4e45588d67ee4f4516169e3b2b557428fc9b67496edae99aa01f1c3f69197fdefe72afb2b748d8615df4049b4792ca2a29b77c7ca2f58041db4e3b825b16361bb7683860617c9e52e38b24c34a467857e4a6bad3a7aea4c9b9f389f86f911d32f6f693ddc024ff0cda5e75e6771e9f9daa8c85333fed8d4423854a94a85453eec765650f4bf7c7b514e0bd4b7a75994f3aff3249db56661e57414718c620160374ae1170167179bcfeec2f4cb5e94bf6d0ea49fb9b6bd6c448d66a12ca1425cf5f2cb8c1e84b1aa561093c91c0d28c6b9fbf2fad815780a5059ef8765e5a798bc3b6cabec8e90f57bddf66e76b8735425f0b3a34e32d5e5e9b446dbf89f045e90bdabfedf5a100f03bd390f7f13d4fb517a18eae990637eaaa25874bfc63828f3d77330011909029ed087ccf02ec23c34f57343e54490fd8523f8dab0e86432db53cf1a3d8d0c0f5f0e56948b118504b7db8e2cecc11c84d311990affb05eb81f471b3081ad909a73963c54d8fa25a281e22511a431e62ddfbf99bb7a0455bcc5f6a2d5f31ba6a5da14e4a55e1283060d46a17dba8a31e13d910ca9ce1764b84063007fb66b62cd8ac22a9627991abfcef75c331eb70595fe56b991b8176b5cae07492bd0b603a2a3a752bcae51548f45f1e68dc0ddcf4c332b8fe24e3806e07d9aeda64e2f0555b3360bc80db906ed35b5cff60fdd5feadea4bdd8df9f8555161ab45f56ae22f2fe3320f8d60db4d5a836f58d7c42c45f28172d5edff0bcc9b0935014d02dd9f99393491e10f766f9129c8401a0edb05328967e00a97e6d3fe36a678547a3fe39a8f23445ecbd7a78d5382fa0798a083cf0b1633d28cd08468735f43cf9f748d302343e791588b7d18109c02056ce39c32ca3af291b163b385b3e3412ddffd683fdd409a7be71dadbbdaba3119ee92a5bab018a97eec59b749c383b4608622caddda214a5ca600948a117d44122291f7e5d39a19d9a3bd462cb227c550436f68f2b5e7c2b7bcb18ae61fb86caf2f2846c1b67f6a582cfc965114bdc387d76dbbd5db8fc56ab9c0cba950ea12c6fea92fab130e1490f9d5044f1fff00a0ba8a705da4e3921fab4d9594516496df780b28548e5a53647bd7016933c1b233b3c3d92d4eba202b7363c3f931c3449fa7dd808681d73c84264d91c24c71571310be08d1d2350dd17c66841e8dc514f491c242fbd4634a77c0caf81df10b6619d644b343cacf96565d1c07063fbd42b31b7cbf5cbe0e4b65ccbf98a29cfa08cace772b4b6a9e31edb8513c7440118ca47c3033e909823b83558d31fbf1b2d6df92c5ff88bc30d94c072d48271d8e88076ef28b35dff1a02a9e1235840c037ca1070f13de54c2cd702f9e473a9026564de2cc268772d31e9b2fba79e2d42cdb3c1f790e614d23e815ba6c929f9de0e98bc396e90796735108d25ff8ac9c67c586047c0bd045ee24df89f237301dc7bad38a1f6a42c83c012f0cef14df8ffbc38e750946ad6e91b9a9c1ef9c3175c14f931a204e28f1ad0031d728584421434182c97f7b4f58795e70539113a668695b67799a1bf72041f27b446a884905d99c4820d1cbb36c5cb8a3372fe0c2787d2ea33276ab1d51a5999f23036928e265b1d863c5a49b33db49ce924aa03e0595f92ff71782cc165e2ea3547313f20585e9490a898013f48ab0ab770c872031acdd7472ad8d0c1f3e4e23e0d09784940e5fd29a6be4e586754ce1ba247d96dd5d65c732d3e8b6463fbbd98e4f000faa9a255844b56c3164bfc2e633a4a3b05f115d54f8c8cee5a7a4e6355050cbdde70810445bd2c3b646e50d47dbf28ed864c9d498480d727b36dab880dd5bbba6174008a0bfe18af6d7577bd2a074e87c02c98e24eb39ecac36b555f544394ce9547801e74dd0d11ea58dd73c84cad154c8ec1b82bc292089d10fe6cef17d99720fa5826065e853c95f47ec35215238f99a8d0459697ca22f37ea2322d09d6e4e327972d2a6a498615cd1409d4820ea6a64f41dddd9a1af75149151aba40b2a4a8312e47bcb5a2e4b0a6499e7a509bf5c69e9d49e879efadd923b44fe3e1b94658c5075bf0f02690edbbc08fcc6a7449709bb2ef9ed8bd3468cef1b6839171b0f1d52cab011a486a1ba6a7f27fa3e7cfbedc0b678207c71338d1d8f16531eda4ae65f30d169b109c24f517be8291e707a376e6caa7bac949057df0966c81b03bbd877eb55ca3e1378decd1f461a13bd2e3c1e28abf2333d53e4133c55f82f459212c0e4c776970bd601ff136b129fb5f2092ea29867b351dc9ceff507f2ee7789d2e3f0a2e67c5debfd67bed72062392f98ca527fac0fcb8a70ff4e24043c98e0d0a656eaef7c261fbacc74bdcaf8c14fc98962718ecbd832fb6923367b5172f2bab95fed4f09fd5080d04fae6f2fa72db2a283202cf4e2ead170e9fe6bb6abfbb5c06efedfa55ec998080dbbda3abf36f4a43b44f7a3fd885bc2ace3fe5c4b67e1a2c65545c8e4fdbb387587d7e10f91ef9d07d0c2b492f79b1479975931d339985f11cf9ac2d3a4dfe6d119b9a921f9ba889210438657879af1870b6d3fc5cc846c98b54efd15840fc79a684a599458201d98354609bbe3a1c727d018c0ef75f3a4709c3612d7cd37ec0d3f710fabf4c071e2296bd1116e4fd3236dcbe6dce335c5dde47d2af4a8072f3f84a89fb7874d9215a49c83da2d3777c6acb0b07dc962496a5d18bba6668a86a2f08529d58b733ab9d12d65ca340e04fe4c2e1215953a956d3debb047000f480f8b17c841442493d0a4828ba9721e47f1cab6ae2de25a284fe8a501e492114f13e0938739bc69bcf094773c00cc199835661d96d0a3e9a7a62aca6c6fc73fa16c6b167fb980d9e4fd7e340d8dbf84ad295af5eb54aa41a03ef7a3263881fd289e22fb3a8d706de9750cb9cc5533f1a926060a9821c4678ddad28b33d51dba8a8f16cc6cd146b93a65896053782b4f34d69caf0b28e6b11f145b141535eda317b67afe8e46a9be82059659f9140613b21d6c42a41fd8a471a3dffe8ab197771f2cb4711e468e7cd0ade3b73c3fcb34af5f71043336d2b26852adde79870352f84c65b55600aa389f756aa064d3076f39bca3bcbbd732bd3293e4ff215fc8457c9a402610c6538d8a4f59f33362c75b9a8902008d3bdaffc78363c4361c4d442804a102e25b7725b3a5778b57928cb39187e52c57996d1d955b96d62f61dcbf5be3aca820b597ef0c33a315f1b4cadfd14c9b37e427027ce2598b9e6c7cc59a9f1ab92fea7d87cbf9f6c71cdee013b5c38f26ad426b377406ef31349766991f4404e798e1bd39a3084c99727f63c13e74cb097b4f5ab98959ded15f7c5ada63a4dba6bc8025d1cd0158458e6a6d2d072dae4f734a1ec91739daa0ada19bb96e4f3175eb34f9f79152271aeb7fd219ed1836262c4a84315f489f173c0148a6f062042762b4a75ea030864886dae51353d08a52160606cbbd9d1134ce39ec4f1312571ffe5c31dc33bd52172cfec7f3925266b0c188d0ca425ce2121c55d1f5bbb3c1260b0bbf69a33c68ebf16eae41a55a68f06cb81616989f0d0f83cbef0202af2f6b1b25e2071cf8a135266df7c71ac702b62c2ac8d59ff3f23cdd62c2364bad9a7face62e4623163738025e398e7a07e35960526b0fd7f963b741fa4e2b18dcf32b98b500d9e844cca92b38fc65dd424c201e29938327915397c3dc620ece5eb9d54bd99df714d80186e6cb71e3c12d8334dedfd0031425a33f79938a0ec525cff4710970d93a258c081249e455f131fe713fb165ec9c00fb9f523d0a720b85e6e363762ec93c2e0193ea8648fd6ba0d77e126a98e2f429315b338448b546a310301953b57258883ab24c965465ca5a06c5f31e13065c802fcf9a1706a6f40f6339a2d77293068dde48cd41ecae7842720c98e010bc6a8f22dc6a69690b7d705c6d5a2c696cb113c50bba55b8eb093b69d24aaecc7ea424d150b0af5791dce456834ad4c2b611499d8a7ffc38698f104a2ceb61effa72b7a7d0484acd5dbdf465a7dd20d65b4b449fc045321d82496cc1d65af8745a1fcce110acc0e9826d073d90256abd5bae02a96dcf85eb42518d99e85d22a68c7da57805eb0a950a801c0d0655cf235bcfa36365990b3da5f4822ca1db15764c91e182dfeacb8abd697f9c0f8eb9e1af7aa8e4ee69a5a4ab22b894111df5366dee42541b8f2b188b1afdf8c20fefc5d2c2560dd98955028559a39da41117bd3fa1f8eb4c1009857acf737a7211892fc354448cc6dfcf1bc6ecb1ed903bd71f2e1893f628ccf52bb1d2417f88bc30c781bd7d6cf34a491e799e9a0f0251d92eaeb1d80109e7cbb8306919d29f45c905c50e487660a06495333f5da00207106c51f97b02691da9f160b4eccb83d575942ac5f19d6beb2eef1beb166a5e6ef246822dfc1e895cd31a6678c4043dadef636bfa394ba06fc8398d2e941b9f2f724c8e1d9029d37e4d20e4a2117f51a713ac5498566bbfa92639e21647ca1580759f713c5ca8782fc5e9c442ab40d505a1a08f3f6dc7f31deff3fb5a51aa56d5737d932552d9b7287c92ec1d6694118a40330c14059eea627d9c4c087e03560c647cb73bda93a17802eed58402ebd6c452504e10f5714f7605719b65fa298db568bb43f6540aae073783ac0e2c3411a57ee04a700d9b7d781ddb89e6632899f6bbe83fdecd3441af95423b605eaf929814de79795e526c081f2ebbb52ce14af0c3e71f9c5b5bc988deddae161070666ccd7a46866edee44d6f1dc9378802c8b5b13e0ee0fac419c26514f76a44dd62b3ff7d3e72b4cd1580eb142fc8714b75ed02f72976375bf1a1df653cc44ace24ca698a2ebe3df18145a28f857cf1913759db6f6aaf27a974b37449abfd660db723be5bb988827101ee9195d0770d44d187deb9b4fd2135a946463f5bfc81e9c1cb309530d449500191251eb8adc7e00ff44ea0d9bd378ebc306a28991f69b2b5062209645bcfa1153849668ecb51ae72874ade63bc80191752bceeb2e01faabb13465bdb143b2654c25d0309cd0455b1b880574e93de6528bb4fde3dec5c76f5ab003ee560d9462f33ed7cb093eed70a08c6bbeec44d79994914ad937843b92b2014b5ac986677237091a051dace9ac661b15bbf1790a398cbd1ce6db114941a425128bc85316e0520bc81ae70bc0218537f8ac4c3bf388a6e4a8642b45aeb5b3208da3864e6d8878d69c4d6b1e68a1089638801332701293d66bb50f1a0997a4abb502838781a039f852cec55f9f1a1b0adde47c961213f91402c3c400d59801524aa5a1ffaf61ea6ee01aaa9fb42f2080b8d5967a04e9db44501624d21e006d6d38f49c25578b339948067d34f28bb45b69dbf85d5aef00f7709c3008ac2f8ce49ea011ef454a99e13c6e3100353a66d0cdcb9e1d7550e30576e88069567dda42e457dbd885123744426d1471089d71298867a3b763a1a688c7123d75b8aa0128b1e4997ce538d5c92502a733e9d0f23851224785e111597cdcd9ad2ff913e8d265e0bc5c5539cba5c3223b5acbc5c53184e2227f8e1c7dc553862e09b66da9af1d7fc6a029d6270781380d80a2140916a1413afccaca9b1780642aabd55b246919a2dacf70f04c7ea674a214df78b33f9a137e98c0d7c9a5df12f760f5261aea4ea817f7192acb4e0d704d0632015627fb0d0427b0a9bbb9cee43ec220eca173be87af762c88e5ebfdf361f13c3719c695fdf16ad3ffc2c250b0a159f7c73f57d4aa9eb1073b05930eb8b8891b4568ab106a8c85fce9705279edda00601a46b6d2b707c525cf80ad491bb5bcfa67a6ed7710d335c4200c176c6c6307c9c3cfa18253dd50e48b6002c4f9cc1b4cf4ab030ce4e344ddf0b02c7810a80f0c3e04f52904818439d3dd719047fc40951ac0a1d0aa2a8b7585b9f440031e39a935c54f376bcb6f36f565e8da05469a7fa2b75a2ffe6d2ba6383303b7285741e4e95eaca2fd611f56da21a4b192c6c90ad29d809268a1f85c14b599f7c93ead7ea0284fceb987dca4c6d9928de8ddce302a378aabce4d6d1647e684d7cb50565c7ee1d9077bd3f036ab844ed9683cdc198d18f4ce4cea2005037219a53ad85055335dc95615fbf374f869a00f96e68e3bf543f95f4cd9eda515e98e431cdbffe58ef04c7a8cf9024f06d23cff944682edd72ed265cc15cca498e2cf97b81e4b36ecb3b1898b05a18d6da8307a6675d277e8ca15f956441d82c00688f060085a63e86206c5d699f5d9aad1f65f003077918d1c5912f9a18a1183e01c6e86f9c708adbfb0f1d3888d6f1607f711096ad3469e60109b8bc778b333e30b568c8da15b7a32c69ad53e7274f65ca14924bf611ee7c6a4a514bca0a9bf079581458aded37509e2903c871cd3e92d397e6538ceba53409a6d57caf64381b045f07d8db7427d86af48529f14393147000ab796abe608a2077c19ecda508dc6fb00c9388011879059d717d9c7197619e54de6ee3b11883a3308dfee3c3344030952c313508b9fc4e355e88d34ffd5841d108aae0421476dfbc0e35d90a36e6891c25a78f06b9e9996f1573f592c321863affcbac94666d88a0cc2f0721725def28e891a8a6810adcd4b272975aa83b915d2e12b5f934b0d031c57b801a56219a93951150fa13299c83260cb0e2c1c9c0cb2a6ec6e01da6a0070d0a3ede1edcaa6f07f7eef49c286a224e4faedfeffc1871a27b284dce988b37492aa7d4486f6eb920cb431525c5a581718d397b6d42ed31c9371c76bdf91c84271c6a434fd5bde9b7f95acf557c4705d550ce54432efd49b4bbdcd0669a5943b13e0f103f299a2f6da6233244f354ea0e58c9b5341d75dcfec41e319f01db07486d9e3a434536ea5987f1cdc3802a94c356ea60281fa3718a6216fc07847af0df158709e41c4610523661084a1b5428a2648b56b65db11d85a5ed3973d1ed9388dc6474a8dad36f3d214b0a6090bd2f68b33e93bd8ae6eceba863c2402a2761380f76eead39ac66422ea7d9d8c35cb2a4850319e428ce8bf715f6174fcb4efb53f5edfb71fa6ba9b80c0f74208d4f7a106644b9c7181a5ebb620f8d6a0f11b1a796c26b358c9b1cf4bdeeaf86cf5ac4d60d44e2561a0ee45249bd1f708a5bbe82abdf582f115366c8d028173ce9b3ba886105afb5b262c855fec8b4d7186990e8f14afc54683e91ecc8bf8ff81470b456252942f62552234f88dded31469aa4fb920d7f5abf8303280cce0aa0fbfc14dde526260e329b44c0a8b81135c122062e93df4c5db1a3cc77f88a228518728376cef7627a577139fa1df3a701e255341c88c764e82c6da4c709267c6013ddff247781fa2be2f2ef2ddb6b481d588b97e718f49b5dbfc34cce5a8bf78ba49efae5fe7e47201af7a9676f243289d7a5be277dce116e51e724304abec91398e3663d5894f943c7ce139825d74a774a524d6c9663c514ce6bdb2710ae3a0e46267c174635efe0bc9fe3cc94c8403c0a56d6f75f83a3468038d3feb4730b5bbc6babd6ae7ba7d9142f94829fd29da3c88a4d24665bbc1eef6f96c094ff5f8b8a1f16ed71fa588a1c9b2f39d054b29942a348cf8668998d2b3ba5819b06e95b667a92fd8eeb832c24f54dfc9a0127801c6cc83231210ab32d62f49c4e0ae82d5efec4c59a9c907029e0d63536675808ec3cb379dcb67512e6afec817188bae53ffdfd7ffe95a80c5043203d66936cb53d395c68de75532e5a9af0c6629256271ca8e5e51ce474c26d42086605122782c5d9b57f393c5b323c5225c5ca96b1876b017551af876ce9949fd6ca7199bd7d98bff537b09a3f7ea33a607537df66470e36000c5a8ce69d05c20e451b00f90a0a078531cd1de23b9605d672352b9dbe827aea3d3783221479a7a9446002df1e4f7a4b9eb843ef564824d8ca4abd88d2cfe003b67f1f61a0cc3981eb0f61373a6edd218a236f32c23803ddfa869821f4461d60d1f455ff93ea8ed1965d925a80b57a302f29da312f1ca63b0157b75f60f1956d2fbd3c27142c65d2ff0c4132609a8c9ce15ff9415d254a9469efe2d5ebed12a8e19e527ac030b77ff83c6f2d847ba280c1d54fd8189e2d63ad8922ff4d8c46ce9644436005077603909e747390f988a2af985ab828938a9cb5dde9e2c373742afc030b2b14cc793dade7cc63907638ae06e1ed935eca0cbbf8e6f7838c752dee091d3a90f0a223716b9f615926aa8fe9a4ab14a94d38c7f1fb5d7cbdce78b555e24976a02695fa1aeb3dd0b63fabc2be0a54a7d982fa5c2f36b488aaa213b1670d38a09d30fb24050ce9755691fe162aee17c5cf7a753ab5bf5fe0e34a258c01d7b7b89a2e5de510b3161d8910f79e1bfc9025b98ff68a557af4fe4cbddb6e840fff8aab8a41ccfc011d7ceb8125819dc7284223bf4b0066396ebe8f85158ee24343742a856017f4092568eae3f42ce541f3f16520d244cca2791f9a923b433463bd79632a7b7bcfe07bf7f7d962cf85e87423179a8cbf0207fdea5d5b37c4f0921defb0614c5f703c0e2a45fb129fbc7ea5720081cfee762a75cef80c62c28d61c59f1d1ab2ad6d4c746b3119f82c1b3f36e43fb718305b5619ec16464dabb59038a21ed0e74ebecb9a077d4d9f18e8406a5ab0738229eace89df7f70bef947580f5989b1df1f7e26af7a8b7afa73e3d40f59520219453f81439651a92b8e7ffb8b0aea227b86f833984bc98101383f507094c2a26b0df0adcfaf1862a9767dc45fc05f2cc43a5bd9675ea77323157f5aa8e4b1ff8911e389fb66348c2e9cbee551f3c07f3b18ed58d22250a124225f44bcdb53ec123bb8cb9d88646ff408a4244dc5b8e888f70b04184af58acb352216939209edc29e24edafb5658e8af370d33afc87749c3af0ac91c1cb15621f735c5b6322736eff00bd1a53b4996e107d11df3d19fd85b73b61bccfee6c9ab59cc79df688a2cf50996df25fd19a7075f4368f60218fd6f9211058a1e156267d479cabd876a18579ec0e49040e51e92180c3a38017325b4abfb6a6b8c0899f1acb56ce6191b14128c4f22f982e85d15b1aae06a016f76c1ba4cd9e49676195b5b94da7a13f700db6a84310544f8e04beb014397debe32251ed4cf72693a1ca0aa92f96d81f22cc91bc69c034f9f6ff87957f264b0b9bf39018a62cf81a942c984a0073cdcb29d47cc26cd03b7e9b938dff59927fb971fc3d233ed308303edc48656098e7fe34a60da44a21f32ded59dc62eb401dfd9aa57f4d751c0298f7d3491e299a3460a38f77f5d83712f10b7bcb807c35b95f0b5a99d604d43ba9297416349629c733e7f43bbed5dbf4905c6698aa0617c295bf5d5118573897d141196032677696a1990400ff55e138db78c2b44a866b56bb221399ec03bc80b7c21330d66dcb142ad075e5bb9f4a5cae00e7335599eca01add9d8869b763dd6834f36badc2eee5f6ce4610c32ea5bd581afc2523a4bd8c6839ae8cafccc82e6376c2f82c667710610565eba0020f7a4251266d4e813a064da4dffd47e471c40af7e601f55a0f2c2b0ab27fb3d810dba8a8a5e9570c444da21e57bc387886aa300ecc5683681ef9b2917746c9c972b67ea0d7a4634929752e5f6d5caed50a043f42e624829e5cf400840887471d85695012c0b9f1f1200c0980872c78d1a12d5246513f65503bf24d98c19e716ee90d9025315ae11d160702c19e37453d2b195d53e5219849df8e51897c993f8990cfe205ce2868cc1f8c57c41882aa8c822053dbb15d34f61d81e79f65e90b51d621f1bd069ff00a28b60014a5bc4c9820543ecee766a6626f767ba89443cb9b1679035f9d7b9618ca47d0731124196fb62191de5305b3f4a0ee86e25d0faf5f47a13ac25f73ffb72aea5c5cfe8bcd4bb0dd10d7c61eba43dcee075f2fb3f02d43ce7f3d366fb045ece87f123c1bd9d1d73b49b503eb092513a006f3d94c10324e60738ebb65bf79bcca9b86bd87c1c053fcd1b981925f9b6eedaecb2441f42333bb25432cd4ad50a776a286ec76d0cc4df2ca8954b7629ffffec63456c896c6ca794fd20e1880bb0eb04b6dce0aae5b031031d7387e9cee9eba3be529dcab6d75c2d8ebe447b2868dbcd54cf823f59abab294309e64593572feb62c9189cce5d219488a198861ab50e35f40bc6a8c4b9c158dde86a84dcafb7b35f7a0b926e19dc23435f6d5a518418c2229f9d11e2499a8e76e0d4a28d429f822915bc4312349d7363255fbf908aa50025a461563df40aba99f3c03f923a757e6b2198b019b77bb29a17f15c70c68bed488fe8e9a714027652ecddbdc60a66ea451fc55a95f01d603cae3c0e31076856640dec6150df9e98f81b8833a4e4e80e4ed3228a7ca1ee2fa965dc1db72524d768a0c09b61089be0bfdad442c1e742966924468210a16678489b7a3971b6ce325ba0c6a5eb08750fb73c42e2265cc60b4e3ce81aa55502cf3de5b7c9a4558165e85858f2f252474ce89b3ffce47929f6b9cbe0b8e440b4af951fb6bb8218a2583da64001a3cb1436e70a77d13fa25851b08ec1371e0e00cee44fd849bde878885bc5b97bc6dfcd82104a1078e298f489d3eed50e6fb40dc57dd73c07b6cc967ccb243eeea4df639b1df28e334446922bca212f6f4f915e22ddb8ee1f9fc6a1b81dfa124ebbf367d601f82c27fb277b06f163f8412ec7093afad634bc8637512cf4b01c98c66f6d832ff12ea8cce8c627858f22cd31dc9e57ef083c19b919a7ee6e7aed4c006725990c4243d95a82120bc8a1fbe03ff03993b664033f3ddd38f631bec77509c39207789cb6c9b65cc8f6d7afeb0821f731278c9a8e3c919675c0f4aa6dc9c5a3638898e29817426a08e826c1518efad6c94c45806080227c27644a7d58a904eed3e33d7f05027a58b43fafef209fe53e8991d482abd96bcccb7e879459f2d014a890a741ae915c9a6fe4db213237f6b143209ad8a12bd3375899de4c53a15c51b9caa54acd81b88f9a3625145d0b33e292f6f3d981b6f056841211422fb37ab4807c39af35f5512667a145b7b6a6c38bcf21553d8487701a31b16d484333f300b96ae0697a7f401529b8ed7297595574074f84c4f85da0b3bcbfb303cfbe9b30f759b5ca979dd4d95051dbe0b7a44d68c564a48157b6a05e641950b9708207d70b3613d466f8b00355719258bb47cd30b8326b20dbe1533001d64fc0d5f4d8872a6dc79cf98d3d3e23b29bf3442f578b24f0571bbb3e429468c7fb13eedbd3a32e8bb78b4588c19ba55fc847ff6753502b191205a0469ccdd6017cdee13126972fd263b5ba28f8bdbca2704705d59cea8d3628461a092eb313747a7227279b2810ab2af0ab78e8ed7e7320ab520f2c336cd71d9f9b3d47f578878251e7cdb91f978f6914bec2441e24d2654b33769cbe9ba6388b4f21854216baaf63e51989b18de8e682256987789b297dcac70fad81aad10ffe59e88e02061157b271c4503af41360f0f7dde814b216319382168164bf525c0a13a1efde16d421c25dd433d5328765b260660e66c8eeff1bb7900cfa054504185f19d81ab4a8066349ea6f3035c529bcb2512bdd0b04d40b9d9061ccd9a29555ba6d04b82d7bf8026ade334899e78f935e8efa349aa2f1b30d3f9d68c4dd6c73bbf4fed82bb814f83cbbb0378fa6f5be779ef3bb8dac1c873f57fd5bdfc0fac81f942081f897774934f9d3896a811e56e97c4d2c2a0c1b31ecc5e72b89468b7945d81c1c7f8a9766695ed260f698b65b45dc1c869f7a08881fcb6b1cb4fdca60c48883e7a85eacb44b7984da729a99d0f8824cc27321a6a10e04a66e8e265463790a384c8275712100dcc2be4269ccfe71eb81b0b786dc2b5caa50fa36b1fbad5143fd3669fe5d30dabadc95e99ee4a4fc4e49b747f79996c38fcc3d2007d9aa02a9f7d5d389329c43acd49edfc3410dd34284d7ed9c7363d9ab3985eb129362a9010ba810340cffc13faaa5d1d25eff41536e14b5b146de57745cf5fc4f4955837b0c60566dc771258c29ef495bde627b04da1991e67ff0a7fd400c21cb802fdd88927ecc39a86b3d17e894e96255166c02ec81280e544d3b1b4a348b72143403721b6bd178d694b6497e1e6d25d925b1fefd6fa80e6f832f922b8a6b50394de8ce5331d5cfc043523c68915aa7afbf90309094e6e982230ac242eab9811297cc3d7bd296fb6f4fecbf6386500d1ce51ab85cfcaf76cd0bd823ce0d80d29040285a1b91df3457c99ca5dd18cffe9fbbca5e5004e263bcd815f3e4e7a7ae23372756606b0a32d775e18ffec5bf38fa1c8bbca78caf7df3bd580a64315d06f5978224f9197fc122d7a1fbac2881ece3a67c0f4770a2cda9ff7d847e3615c39573707bc51085fc597030fc0c84a6ca55df3f9a687fcaeb1607524ce2d1405839bad41b24e32e3b4d4ed7609dd047e37df413beecebdf27682a89378d7d357e6ac2a490fadc98008f2b74e231196ed5405d8961924dce263bd7f20153f24416841f7845e6f9344716ecde9ee24d8d6e2d1f9f749491ae3d651b75e4e4edf2c8c81b5b980aeee2aabffa9afda10b0dd3a6b36195ef045d2ca505073ad755d68135614027d2bd38b018cf193632d212ee3bb513f9a20797be69956abe34dce1f0580a40bf5f6dc360f64d7d553820d91f13d654cf3bf9b36e43c381614f4ef1a80ca9fd754693b75ff67ab04d2c83504bb7efbf8db2f0a14c6c5a03c6db5c97ccc4b653028d649a89529336bf6a643c903b3830f1abc8096b11ea23fc0a893ffab7203187c024a615df36a4b613b0e417ab203c03e8cbd5df828655f7b574e415a2a33694b5f325a96ace665ee3f7bec597f4cda88762e6f936f2c57dd2e58a00148b00efcd879e44303df222f4c19670816c0e67d7560a35a92179fc67b54e100461881cbec022f3ec35297605ca261748eddc8d068895dba0d504128926647eeea69fef1ac3577f88564109ea4a4ec59af91274e2a6995a05e154b03e88f5a15b51d9a4dcfac46029a8ed26baf324fe25acb11ed03f73ea5b4ed4970b2084b01753644bcbc1089a449b285f357f7a9a238c879596cf9de1218e74723a3c48e3debdb6c1ca628cf2d0f5c2bc230c130fd2fac289a9068d2c9c4fa4b10eba8a02341daf1ae57070c679458732e8dbb1ed4a3c3531b17d6a223fdc36c435413460609c956ffd74cbfabf72aefce84cd6255b2307845f3698a44de82d79f284f0efe6331d1fa1bbc4c924b2f8d97ef82bbd5ace7224e5867d2f4cae832bb6d81b83b4a23f0ceb3a970b5df51f70c567de58e2cd6c32c46fc23fe8b1d6d2f42eb10fb9aa42e48136a94de2740515bf0fd3600d152fbf8ae582de31314fb995ceac249771ca20831c248cf747e53a7af5271b8c27afe05229a9384c7ac8e7aadf7bda017c6f22e73d2f70cda8a022b201295356041c70b7e157eadcdd4522c7c31080a5548edd71fef12bb62fde2ca173a69e8777fec8f4daab916e3cd4893981f18ee317a3101a4cb53d3d99e5edce239543ec37f7b71347dbd8b052b3694b7107fe8e687d5bb89ff943d8f43e331e3254b17aff22cd055f52911c3e97a301782cfd1a76c34e8ce3f27d942769af886891c252b052c8d0fd331eaf8ca5e749ca36f29298c6a5a76bfbc2115ecce3877f6251c9be8d3bc1fe43e922e90ad556275f1dbfa0c91eaecd4a5f6d648e68376f80bdb7b079490289ada21f5b0821d22c3f8e0de3e46b746259b687ae713e61f7c8bd7df31a430f26fa034d3044fe87b38e331aaaff991e864f82008956c39bd81aef598f69bd4c4b790b2b4450106e77b6975f781c5bf711c7ad0c1b5b24cfbb11518dcc695de0b6e776349824ede476744128c44549d10dce6e0426f49878a0990169e2d6f1089a0acf0e07ed27a18bb9d707326ab5d2281d36689a2d65b6f71127e7c2f5fca044ce4db86faeecabb7d355da50b91f4e7e050945340fc09840c072d9a86167e5396a70f3c75d4842856c896630145113a7b461e3c1a8b73454e0ce90c7804d541a21de57714fc2d56136f288718a9e3aaeff0a2753240744e4ef5629dbfc5f923a62c65a7e15bb0c9f2cb8df9bae6cc2aec5e9f3f379ce60f3ec6c7086e5bc35a03c9f8e51ede206dcebc8917cde698b3ce694170067e02d7f8d8a175b7059513632812075c45b05d3fee9e8da4c9256266dbe89c28e87d459797ba7d7a4a7cf3aec070f3ba5f616eba1342059adfb6309d544bd9b53e6577035ba015d6ca145402116e7934b23ecebdd8b02bc4858fa52b69fd9213c62c3d6574c66f6a9555f6719eb1c5d75f5571c381805e5814c657b3194c618e0a144e0c773872057455a8212d25fc774e411a94f0530c4150b665f985fa846be529fbbcce2c0b333c305a4a71bee267abb1c5be8f37039fc9ef9986f77d9c6e82eeea81a67e784a6a01202856767d4090c990671c7430d9bd8dac941a9b92b021a8d6995a6f5b1c73f1511f0889aa537b0f9da52aabb9dc96b532ac284e635bdf1e8ab3a788307d1b9cecba13608c3ba652d6474bcbf81e2ff10e4188537dda36945d5ee9e4d5c59a2e1b4f7fcafd3be937ad2585e901ba528f0f9ef8d2bc4569868ad68d42360ca2a4b8496a1209e79c04c48ba49bc100ddc4372ed15d2a09f482f9d2e631646581a21c82edd700f560d4b7dcff3567709928614b1186d57c89bf0829c56e272f8a534234c2cdf3dcb40eb3bf88c6f6257cc371283436e5b2a282eda5f9b7807e1bd4fefd69dfdefe57162b77207231634563fd4486ef26fe35767b0ca6f0700c5e7a444f4bbf81e048142724537421eb5929b8ea7e85d34fc38d98919354b15472609daf09aedbc0c9311fab9e2a5f16da6924e414c85568463e54d19695b2a68f10d945796582e1da15df4453ec2e19a62ac4d24558312ceda30db11a623275adcf1a4c1d269bb8b98ddff91ef1adfc2f333cf94e14d22d9f62a2709dfac52ae8da18cf22fb43a90db43406b273f67ad706658c696153685f6b53388a66be935aa368be3593560b90619a8b583bcdd8c16dcba648c70554a78d0cbbb0f2d50fa7751540be27397d0da700c92be85f0642b06dfb570c2e1971031982dfb09c6bb8956ef5aaf21f4fff8edab57d3fa6cfe2ae941a4bb55de4ebf8b688e508c8a7d9118442c6b91ae12cc2b5de1ce5b91bff3466e1245f59244a6eab767b10e182b783a5b26858fa6c5d6ae6bb4c56972b65b813689d473ea38db53ed7db03801b32d21ab201da2c7b7c88b0583978f3d86ef114d374b3bbe28bac0a97470ed0e71614cdb39745f1fdc90e5407f5704b6cb92d3184c709df393c5ca4b942dcdc8fd2e8e03177fd7f3124133a1109194253dcd5eccfa984e4bbe298bbb9314b571b8c8b802c6f4e167618f40f16d793e34a060d25ce3e981edd30543943e5573cb47c56be4c48ce7e2c632542d5d31a67b58aca6823cd8a042ebefbaa050808ddb708b0b63bab586a39db464f20a7b851b3345c497f42f9934bd9745b24254138554a27678aa68ca08bfeab7adcfb5af779a1bd3387a550eafd44ec29825abdd8efc0cfcc6f6ea354e1b99da68d1fe4579385128c1620bb6ac4fec549de1303a2b2d1ab4946431c5bed0912a3b614c08176c14a2ed2a12b452f164f96881b1e4eb08f38fe1c71418607ba43f155825cf24d4f1a27507e1e00b64c1fce1d131d1df460a77a844c30c8027035df3feac52d11bcdc3752e2fc6e126baf89ab66214866633c8b890f212612ec52b08cefc50cfc2226d783b0618026885b5fb976c1024c1f51ac7db952c11772d9b5b6fc24fdef2e28eb9470409f271f5123ade08151ea18f2d2d6a09b6363f7e612c00660a1150db878b0b469541f9f9e21f6e6d409eb35c6102f8703a2dd19f90e9bbab8289597e95f8c3b1b557ce7611c47f457e3ebf28f463f966c066321c155db11ceb37f269c2e2ae8e217597adb03590e876dbc0ad3ef14c73744455b3414a86fed47a74cf50a8489c519c6ca0fb82edc7e8f3c73d1634882f0ce96e2d12d0c02455a85c803524eba5501cdcb0ff12a6990dd2e77bfa87b28a1cb2290919468733354aee86d4e8bb610fa3158e3d0416339e84c12399db7882dbbfd209b4df651d6961cfb221c23820b7d94f1aed92f75d02d87e052ac6bcb0f223a093dd319c70377bc7fcf9f59afec1d0ba41de9b394677e4ce9d794c7183a07494859a015a00597a330326fe2c1b7104742ee65ff291b72c5bc461b5ae2a0eff31f702c96d815d97c7897148a47e52f66be75bbbecac54d1a6ae795ae4e56909a59ee17143dbd66c3b15d071cf0ac5a719108a68f7e96293293a89477a0af7043989959784529b0e06227ad0dbe4239b15ba99ddc6f038ee85afef490c01aa34a30defb2d4a8a1969cc186c4d9da96fbf530c744be16fe2017f1920e1413c6a69287e45474084803c00af5fe9667ea081327ab218997a63c6f6a46b27e792b8307b25950c9e45ddeed642fa615b5a18fa31a1fcbe3afb297eb2f1e5c0e0cb4beea7e00b180a349a4fc5fdb93e73d72f22e738b9251ad87c6e23a59705e9dbd1131471a688c250aa853fe1372ef196278e1cf7c0bdc9fa17295cbb12a39ea49197796d55d8ae04ebfc400db0aae66650cb17189c668671a12b81042164f86f07bb44d07661b2a63b7f852ad8d9b36cb08c46b9364b95e7a90b7a0f8d868baa574c028b6e6a4aa47c5fc3e8d598393dcfb2e8912baca110320043ba3fee6d4044d8cb3d699b3b1a1bbd553ff25db839b9639dcdc6848b935132747b339ae77830b998cdf9434f3492f311b70bbabadb7c6c8b578feae01ef897bb57e98eac5344cc40a9b3fb247ab5c73e5d012a18f32679296ac9124635b465118e249e5a2d4ed00b38e2a59ac0d77e93b60195f1192d1733b18bdfe1b43c3b327c6fa27e99f2517e413b7ab08c3e9970ebb128f1dccc9a799c37559252c6c0a42d6592d47d911f463f35d102dc6c38ee3ee1bb8e6f5d8241363707bd581214e43ebaeec15e58c45effb69f6114133cae8cf5f36687504d54c9ac72eef5e792c1d3a2f4c15b43ef0ccd6219dcf2196e5fbe57d9786063a4c442d84f72b31ce030318d8da81daf48c0c73ba36f20c727b0d80debd37e9af111879e1165a8d41ad73396791cc201c257038a7d5cd36154d68559da502fb3ec2b67f40f4e598f3bfb4166d6d0582d0c192ed3a61a419ba186b065e715e44dac58ad9148d8392f953334d6fc4157d86a05ab76c9ec59a35c52bcebbba674e3c769162b2c8da5d58b294d1e7ecca8a431923ed9988c98c094606f233099f7e7d7c89c52d856720195eecd0288b49fdb655a1339c720b2508041b4ddc7832623c67f24ce1349b0029312e9338d3aab8ded119d4c2d25ce0f7f2ef9de13637f39ef17957c8e5a04b10562a80fa72e7afae3370f19debdc9fc0ba356bd9f382b19bb566336765e0dab8de8a3cdb46a0788762abe805d87e080a2253a6d93d8a123e02832b61e4e1b83ebdb91f596bccf27a7d340010689db886a63abfb292c072c9e5b0537c49a7348230365c3ebd8982b5cb50bb8e6478023bd272cb1407734ced281b16fbb75a208f128e4cbfbe00eb812e0474fa77352c8012a9a57422ea680d973b7543d17a810724ac4dc00dea18a5081eba731b7441649e549965c506562e0f72276ccd83d225ec8c6e7a36d4d6d20e789b0bf96de803ae05353f110843806a6a436c1961f46840b187a29df30222a605a892fe936513a34e6a435484d4067f27a5051b030696f600838506e7ef719906672a0b8937d3fd60b84f2f6b0881eafef0732a39436355c2c7e97f5de023e874ab32b14b2e298bf68ec4671d6b9084ce9e208d1d227d4a6a7073157e5c88feeb8f6ef45f11157bf7b766f3be6f99d3f89f2e537da48e299ccfda55372f93fb3e15f279c0ae4d11b5e99182b2a6c4092265311b7a9cf3bec614a065a39674d1ba4080fa241c8e4825100b7257560638394b6103fec5625ad32784af83b47b6510b31023cf3ad7ccf3caafe4083030b3164e62ec8dbf8c0fb60677ca000af70e30740866f028c4680dab4047226e207be00e629b809c113001dfcb5822ecef64425bde03b11089a85b04139b45c14ebb221b75f51753a7985889eb612695a364dd72c52329985fe8793e0c55f7ae09a76febb66683dc670b51e1fbc7e8788e7ab868a6136b020cc5b36e6b0aa184d2caf98cf10a6b4a2c644d1966d9238da83d79628d515b94505f63e9f76114fa777b0ad95a6a3851786f7d54f7274fb5ccb8172c8422ec5f477b157470afdc13c189dde2b283fef348559a54924107df7fc9cbb9a757a77dfc956a7782436831e421688911bf8654b3fad624a00b6e4c2374177a7f01121e27b0c6bd87743177770573ff9dc47345e340c8d9f0ec338a51f76419f1fd81830fead2c49210ec4554d377cdd6053a9d897ef91dfad12cc119d990ca5d3f040f23bab1bf99ab4ac6bffcc11d8bbeb03fa9a49f2e5d332a70fc623e000f5f58111f76e975198833c12a46f5cc555d1afc0af1caa87e0723b89fcd7eeb16ce95ee62d6d7d1331607c577e496605f0c81fca4f7cba2cd80b5070b671247b11b80f82721539b59958edecf4cfbccbc4fa47b68542196f7d461c0f761f7c281fb7a7e7a2807195fafc4a59e6288e51834715c6ed2fa2ac5bd8225b1c6b8d364c7b0658785562197b543a5901d7a824167295561f2725e120506dc0884c5f0fe55f139ff73a9f259fc9849163d433cc16bf32b887c1c51268295b5bd0ac377f76b21e2a81f8660c0e27f5887c5cec8a526b709c1791c63544e0e7106c5cae769572ccc58895723da9486671d0709264403236a0d6773f330fd55a2446e998998db910358b714cf1bb7852e0ff5e06a0cc116aadbc78140e1c384fe647c1860ecfd27d382c1a452a32a2147efcf15051f7f00ac240fb53fd9eba7623231aba1d7996b4e7bd274776b0e7fedb54c5a5988cbb24e75e608f87208515edc0e93f44262f9fcfc9a12395aa6b4851de8d9647fc60c547fa3e025845d0d21256507887844849b6cd386b99fe4383fde9edd67cffc19b9d8d6a19e61f088d9214c1d69219ae424c8d4e459d85b570e036adc90a80ad45bde7097c94c79d14d13e5a226c763f71c098d2f35e21c40006bcada63d2f36295ef24a5b1959becdbccff9d9fd7195f66c91428566e5f5ea37119c401fda7fd1035921ca0d513e8e372127989a0a6345cefb2d667332d4b1087a9c179af37df7366429cc32fd283df474f60994adfa2b07957484b22a0f1adb21b7f4958968c6c2d458a42d34e4303bcc8bed88f2a93a84f48cb94667b96305dbd2bc8e9c85ea2107fc4b388b3d13490700ca15203a0e620141a10cc40641ea4e4b4e99b927024cd13505c5c5a0ab8c4a09bbad1ab26f8a4969eaa82157b35a9a5bf38e8cbfe2b7c37ed47481df2e8a5dbfb1c897037454ebc0bbcf815b065ef3af8891323685c75bfcf77ccbc5c6e48e157f603f486b7941a25413a4780f69c49a542f23d667eb7eb6d0324a9cad0f6168e81040b375d027a2234291127f1d91384c262e5b7f32fba50f0e938ef0474ee4aded0cf63df13a734e90368d623c39c31ef9e822bfdd07323a54aed320f45fcd407f3d45543d739ff1f19db479876463fa29fe68363c502fc98603d363e2d6426b8e247ed1652deb6bfbc62fba1c5d971c115ff26f8c8355e8ac165130c9819bd080c103ed80ee1d74d4d7757ce4eb64259d7cc8d1ccbc78e89263c3677a7529f7f7890aa8a3849f20dfcfdd0b5eb10cb89f45c4f40a415efc5047d12ab1ae9d14b29b162ee090f61db4261bddedf156ef0a453db892be2ffd1469ed56d765af0c9e5ace2769f208b002fd2d58f2036b99cd97fda34524a441fccfc3a555ed995e17f6c040fa04d7227fb1701562d96b7ea64b46c5784a6f1c387326f8d4ec40ea9b55171462684da3ef595850e1bf0e96a21f94fbe38ae3a0a95c4ec195652541ae27d712828638543f9fe1a1165cef0218799a0a6789388ba8477c09e3363f943f92257296be77fa803b3e50d0888c58734596b3806fedd6b2579fad599370d386ba0ee6baac0e0c5f21b730d6cfe7313ff477cf856c0f26fca61667a7ba31d8620ecbfacdadfa9f0af4bcdba368badc08dd1a48769e6a81174950088df601ca416185dcb0680ac58d2438d20dbb304886466df3f0b37efc3b9705ca2de13b4933eed78c80e3082ae2f6818fed9532e797b0711ebd2a2f518d96235f1998c5e4bb62c2af6b4586675a1ba503ac450b6c857692396f55ce33da9aa2a0c49669782df7bd111d4215fde06d8c27b5d87b49652e74669de2138eccdc50d2d8e7d44ab08ec74bba74cc7d825b461e82c76dabef1212a6728ab1690d37caf0adc0ba3291ce591e87b530d572029d651c04644562900baac98c61f76e950f8eb6337890400fb313770e05121b74d09d1fe03d1aacf195a3f172549350d9129d405d317f7e3ff09f2d5ef6c9802a6c9878945726ca3ad53b644dd2227c8e2959a66d12325a0853f387ca7aa375d029bedf6cc0fba43faa096dec325cae45af3d7d0a5cd46f4bcd1561f3b5896fed6a15bd96ad893e83eb6748d6cec13f2d628e15929bafeecf725b0d22860e3b6e7a212e49a85df18781dac2a81fc5982a6c9099232e4f599f7e2006ebe2e352efef475f9a34974dc522e8688fcdf6c62e2c9983ea05d4e185c329c471808ce94422c31e68222c88cf32a6a75c4e2838ffdac0a6b3ff7b4ca2d1d8df875fb565c4dc50230e6a63eecde05c76f7daa18ed07d2d834906a48887767a8b58bede0b4e569f8020343fd2061bf01400ffc8ea820149d34fa80785d2682a70f9c48d7aeb2fdddb34869615a748a3ac8ab2352a97d93695aa445ce48c8c6c0a59ed1cd40141175b2c8cae15ecae267691ab514acbca906f806be726861a91577b3fd7390dc6da81d1952e62834341fe604e236bafbb26e1aad030f8f2685e398e8e6beb42ee90bc8ea8bad3817c76a2af1953afcc67cedf4fea6caffd82cc6be50ddefb694fc0e64c017628abe0425aa023ac9ff61187aa3afe12bf5d9b5b7b96a6800e3aed0a2e654db064df33d18f0f8ac4a21a1947a36523fb02b42d31e184f631da8455f2cbccc09773e0e3c67972061b591c42739afd57115586324e1045c373332e78a757e3add290fa35ef6c1072418a1d602066f420d3aea988988d67b152b52ed9e6acb22987e412753cec51ce3f671b7b6dbcf0cd0401901bd963c352ce68cbefcb36514501963de7071d2014b70da7084c068ab6815e427d0b423f7ad5d671d474fcb1a81fdd0fb6cf2e5adfdadd3dd406fea49e61afcd4568155c250e6ac831764221d6b851e1d4ffe3c4c162a7eda0e8e010084f2e6bbda2d89917bbdd183e08dc26fbeb0b81395cfabf66508df004a959fcc0faf3ae084c5300e517d3a372399447e92f453dc18cb1cdc330fc2d52007288a299ea68113fba6ad2950abb34cd9d74a8f484029bd7d13400c689df68f23f51237502bcd5e170f24a51d043357d2d7ae37ab345cbce409a8865c356a415df09832b647f706dd4be563d074b369bd025318afa237b0b4d9b7f9ebfe09d3a1dce1629d8a733924618f22588eb1dca4d1b5090f85f680c1e103e4aabbd0e10c39b6b41b5dca85f5f7b38eb381b4c9121e0f10499b6b06a715c0169e5edf735cd4acec3aa896c6b37609d010ee9a2b11e7622470430cd8621336a55436dce9325cb2b4e237f7b016fae1527a2d4db5b2be4eb06be9e2eb1bb6e46a0207706727cf35c883af89b57da5e2ad0d45268dfa644a54ea51fc99616f85abd133418d55cceac35d4405ac04b7604277b6b3e3648c8201bc8a25d48e782f4166c59e7a641c367fa3f1c40f1895a5df12c43c392a4826fcb294e3fdd39b60e7aee63e079a67b1ac4bfc18ccc6ee1103ec059095e1b78ece3673bb89ff84b102ad7301c6aaf6dae7c096e57d4c85df73ac0779eb9f885277af5ddf1a8b94a8c16386724b0a36304954663679222e5a49b1cae178507296e6749335e38719970838c7e4e86857f7526fa1e2f05f3e66d1e4e8130b353a519413b016b2352cb764008d27617b557f697466680d26a96ea242adc473554edcb61af5383148ac2a672eb5f6124e49739e0ea37e3b99522f0e7a6c7dbfd7297a314ad3602bd2f133c641f926da2eae37d5f7704ef3bde2125476c689e201e24212420eb5005a65a6391db8dbfe9e4c77f04427f6141d44afab79760d42afe2db1a17db17eead358bc9f148582429c85b9dfed5b692f743d721a4c75d7b1917a5599ef3e86ad035430ae152850572810be6c972ce9b8ee317cf1e12055932dd58349dc5eeb521bba31952d8c04e820b5f4112224a5fc9c738932c93ec3ba99984a8cb7bbfb4d96ec3667abd089daf820129a927dbce010aeb1b6ed4a38c06fedfbc28f7abf1130bb05cbd068fa8a1904fb3601b9a4f302feee8990914a0908f1a3382928c6b4947b969d8969c98dedd3f0367d0e27b9b3b5e741d4f6257dbb1bbca3b99ff84b75a190102590ae706947f5b0f9c20060e5b65985bd392ef54a5ca42f8086e02ebc02471500d6f2bb23827f6861561523966e40312005286fd0a183c90c69eab47fc82ff2e86c104dd46bdec8a41c6db3b90514d2e4aeb2fc3d883458c855fbc37b65ed7a317d382de789948beb744b4cd4b11179531ac4ea50add0c219faaec12e40a00e00d84d000e9c8293e0b929e66e7229907b004592cde9384268ed907a7bc7f8d15c71f8e21349f784b8a52d9a2a2e940f7a97411123f51edd2793c83f22ee9d1471894a278e239314750601b041c02626a2cbc47ccf9d33894bd5dbf201ce5c29840eef3c82617a83e99d50bf3e56c82db018661c7cae832e115bbc3ff7ec9c70e6a9f8f323c5d50b3669204c6d2dae12a0f9d17bb9a8f8e4c3638cd2a16666330c5e12979aa1aebd1a236363200c40ed0260b771454c286b0d2acd14d8ed0c68afb5301d8418eb86ea57debdd3b20f3f3c6c22cebe259139932a863421a1384fb40393d85b27cd7815c57ce51ab911171e9b5402d2a0a4f3b2c21d66b51e19cf5d799c2038d17b6d0e3c69bc26a0942e8d544a50fa0774ae9ffcda57611171bc136128112f178418a931d108c9a64f4f63a96446f31a6f7e7670bf15997486635a13591df0ba73e72aee8046fdb59f55c4a4bb5cb7403d26d1f8793fdad9309c21f2e2122107a3de4994aa7cf2325c5fb26544fe3ab518d30b998f3375536d73b1087e3ae95f3525ccdf4e48043bb27cb33475eaff2424cd9cbc75705a12c780b1e1aeb3a1ac82dd7ec7c8bc28156afcac1d5914710598a98eb8e37dbf9ae714ea475d83ecc31fb45fa20e50d2491deafc3ab006f2e0f4cc82c74c77809fb530973089ee9db71f610d970c8da9d9fbaedf031626dff2ae90a6b7d1dbfa46057b038bbe838d3e3c3cd6493f67162ed1456268c227c5515549b059125d8aa7cd831d07727274e84d823eb796ab2be0641c967bc83bcf11f03716b1d41fe22582c3ad044775a09172e47209a66390a63d90edf153febf1490bdea1c2a55fceee97017459e8bd34701fc79c9e9ce5a3bd5e6f53d4c6b737f14897799da9cbc5b4f1ce83d0eb6df6561862b96ad3a9e70d36706975fcf3ad4f4a884f46b4de1890ac850c3bb282be467e0178a7216a0e2c52978993929c03d75eba5d18395355ea396da5119ab992b1279e25c93734f559e8eece4a3a65373ca47aee9b6f14205cf036b8e31a87622ea0a920bc45d6d80295a1373dc07adc99d33fc85384ae5ddfbe80d380f928b0d0184b44dc603cad7ca98c81e7fa00a3e0f1fd963d247d393d4bfe97e2e859c259e6f6c6094e518bb3cfd94aae180bb300ea34c5d6229a56a6919e9d987d338b1b31b37e3821ea3ea3c719afd4a0bf8b55349967dd1d2a9fb9728814462b4c81b4ea9ded9e851bba25f9e306742137db4c948a3581ac9006a22e00243f6e31cea0999406e9faf1d64ea360d3146b1e0caa24d815bf9cef4c8e94e065cb3d1772eb07318e5d3471344d56744ccb6d0de145bc0f86d98836e646f5dfa07cfc659fa76142c814143e9cae244e671fc48b63cd0c4f9e1091f6941e3005dcdcbffff0948d86d82c3c19eb85a3cb77ad338aefc40207ddc1074e074c9449ce4c344adc7d97d2e22a86ced5fa2bdee8b76c5b2d758bd7a46e41986dfe3bc061bed8694b1e049f57108271fd54a9f93cab5c668abd765c7ee3677a09045fcfe1ec4d657bc2bd56d58f57210ab7ad843113935ceb3e14224287d79ceb9c2612adf2c80eaac7aa4e9e1ce5496c216786e517d31412e0d6df71989438426e771667d332996de0c8f575aec10a3c7fd87cea19fb9dbffd81ad2f4769b0add929138b8a4855ff9665411e9aa54bb2e35f092e0559ff8b6af0f97164b74562a70b4adc79f0d56908da484e2e8ad7f4f824be0bfdfb58c3bf59cdc3008f1f3da9d2f0282064972925cdc88753c66d181670f313010d2f70f05b10f9e14e32bb54f1be31948b36d8197ab77679a4f049d5b5ba3c655ba4adcc97dc7e9086b61f4af7179dba16d731d3b07024b5d39ddfd9ff4684af36ec40b8a3578c626a9250b2595370c627753769453f96a71a81df3c6751ab58fe40b76e563ef9ce46b02418fc5fb9b38c9ff683bec7345575e9ee546e0c7eb47cd742b3b9e0e9400d9e5f5b2b6a870c57c20b82158d5af765628f4d1801d75a3b2c2773eeda3ad33ee115f5d8ab988bee75466b85350317fad46a3967c8a38e5ba75f012368dcb2707ed84de150744bb834431f45588f5b5ebdd0d4eee56221c3587b4bbb105bd196130895ed65062d29f03f6020a24fd22fd4d2286603ffbffb4685bbafae081753d7ca418a1948a5b4502b6bcf0da77ae349a43a5dc1dcf46f6b3a94d51c66f07b1f521eb246e84e16a96fc3cd84c4f1c343f51fdaa2ee30e5a27569eba656ea7b9b3953d993ee8225417e3f155034e48c10a03e4323bbb5fba19ae8e4c927d87394c25b0fa3f502a20be122dcdda9f130a7a96f138ade721867ea4effd3f1d1295647cbc44903fb0a421d7a999c43ffbe64ae34b1fe802f27808600ae98a286cb7f7730c245b287620030b364227ea0bcad94f04904c304de334175b5042d22409976c3eac50f7cfd9d892c84e0685ac59c3b1b108a41eebc70c7fdce849b9dead86d71b769cf63c005cb46da79752364e33178252e88aac497b8c2815c587d9140fa83a1c34e71a4d152e2516c3fc8625918cc74612ae7e3fef958dd9c00a08a93018d8aab8fb4386f2f01be1fc8b062bd3c724e4f869956f9d1b4e716f55bd332e0280e04fb3a1ba0f24e012b986915fdf7f73c3cf9a10f98e027885ebe924f9e38fe51f1679a0df1fe806691083ad4ca2bb4ac6499ecb807dca90f4b4f02d40a7215be005fbe529b747a6c2d107ae887579a1347e6e00e4098f3b93c7e486b0318a45e2114e6f3a4ee2af845ff09a1ee55e8b0d10dff0711a51d285dc45043a7604df7cbad7da3a954c6cca4ec21a466e6b35d8c2ccf188ba3ab36092b7be6b2d01b58ac8ad2fa95191be04712e242f6ecf2d7626e4cc4435be5e38a0be7f12a101a118a4d1d94e673308f643b97e01b49e947f8665fcfb8396f7da90d2ec20f3f6b2b3d209ccd220d796a5a8facc482d2df82ef70cfb457498666c09e3c845d8f7cd4a2beb3f38f20541d5e3cfd8bd5bc961023e1650af815bbc652144200b0265c8abeaed792ad03a75c597493812315926405e77b01e5a0600223ef8bb9e7848ed98ec659d51e16841c1f420dc899c241eed82f180d67b03a0f4110d45f23e669e6007d3116464de0cee42e8fe8e4dca584fb66372f0147b92c2ad4933244726fed075474808c49db2f28c8abd2dbc528024e9f00d5211b4d048b18dada111bd8fb4b49f2562b4e0c7f5d1e7f69cb500d3f76dc5c687def8e1260cee0e68e5e775bfda04d1ac4c24eba67c237fd19400db74aad69610d4681f1249003b322388c023f99f17f1cc35a3b40fbd98eda282c992181756690ac515311aa9ea3d0e2a177e5a8fef9489bfdaacf49f9147d0bc39aed8012cb13617dd88b2fa3e1a0b4d2c45005517a8de7553a3c0012a74662162e587e34921f91642c73aae9e639929bac042181ef8d005d48b986f1aa89d8063e68699d6af3fd2e8090f15eeaf09a8ecbbc18f3fb5c811f1be76e7028bb14eced3b59f008ccddcfa268b43c0d1fa346fa651c1ae8e00e0a2c4d776bda09d8dde86a08bfa2f7548a31616e2056c67b6d9de0a5b5717c42354758b2c03151e68e5514593703c573996ff621f398fd11e825b17d48d6c2cb1c04a098fdfb800d156851c5c3bec1f652badc74f700308a82eb2e1154c6d4300bf9cc11fb780ca4d6d0a00b70142edc8fa928b796f523b515ae54179d2346e7a824ea1f3b315ba9e23800943ba8cc79b4dc7af06539ba6beeac47d52b726e21c002f13e43e572b559ec2a2cf514a89c2b73633f138c6ab911d42c07d02cfc08ba8b75cbf7da59ebea5c8448b3752ffce992bc01c89bc457bfdd1eeb957c421e898e7b55f5df74d2c88fb8bbe563150d8de36b47432a3305b2c8730b97b57bde53a2dfc2fca9bbe2261be2784d6b3b9f64e8b1fbb6e0c26ef209d8f741d5e177f324b9b2aec4ec2e46e9984ef6743e649e9e1150627701a5f032f41aa3319cf107ac65b0cfd3063bb202de278023b17c30bc98d7329117d332c7e607bc92f1a0e9c66261b0956f5e2c7ca5439edbadbe7f879c1d1ba8d7c4b1dad1b5359afb1a3147a1ba47bfcd1cc28aa6dff8d43c86b1b48e1a3930df561859c40d4c07a7aa2105626b4c8034f4225bd094c26f8e9043d3711c5b3e0507e9cc68c266cb0f4e4b60156536546261bb10b021bd28bc9d88812444ae22a6960702bdcd1ededae4eab6c885d5d7ec38ec3f9a7d70af2b760e1207f14b581d56c467fc093e150535dfa4159a27f56ea045917ec1f2c0d4b4a479df9303d3d21f6554fbf65fde5f96782001a271d93a006edc44f9f20661ff608bdcfe46762f245c5b4a3e3a65e33ecd1d0b3616fd4f67d8c0604b6fd0c0381f75cd61a25f1845ea75f4caf5c8363008d57efcf9104d56c7f9e24b26ced03ed236730ab18f3869fec42df12f4595a22759379f8a47e3adea93f3c78a23d61b0d1cb5934bda521344aade17627433efa4fa3bc334f57f2d484bccfa4d8cdd19bc1a0f77867939eeb23248f615fd70c3276fde9fdb5800c6760c18ee7311c422108e5d3315ebf259b2e1b794ce238b06207205ae3257182d03bd580ab875b044d81e649f432db00c76e9790b74d915aac69ccd3977e2b54e7985142c37709506b6c8171bf96a28faba411bae48edc28a24c3a975a84c400ca1c7dc146deb6ef4ed98efd51c36969a2329dfe8036dbb961a817da999a919f9bf113645f33909a9374b01bbe293b86ad4260e22b124cdbd02d814ab6670a65ea8e5f6b33ca53366034665ff1a3ca3012bf30d7706f94200e1d8f2a0be33dbd3337ab514e6f965a10901afa56518ce4554657ef1ed433317dbebf4ef456397e8204cae5ccf4556cd66ac920bb802a20fd382d82cfe6854fcbda30b58a5248aa876c8334af0320a31d82c2e3639a4afa960f654bcf13beda30614ffd0f2ea6ef1346f07717693ddb24f2aea2fa55169d2aba971f73e3b80ccec0678214151a00ccab600f0d4189afbf005b1af2eb19172bf5d072ed365b7ce82162c9c2ef4acc435d1cc93f7ec6d08d0df36bd5fd34d6314ab045518e997ac29342b95e734ff316c151ae54294d76ca0cb37b7d9e6d95db95787677f115b211772455a69fd98c852ef3881e5fc692114a824f0ebd1b6c99dbbf6fb7cd9c6046f576b4749fb2ea8f4d815e5c68368556ff794edfe9f9fea9255f2e950444b4404cde7cbcab0adbe197b73fa0a1ebc335c2d13254e709909aff625c8dbbb182d0a2f030735b62904a7b1595c5b23e93b974b5390fd0d2603af48fc100eea4d468baba986fbcfda471dc8cd0e635cc06893dadb118c94bea81b11fb2ef7615dbe0a802375100878560a4b737d54892c0df7c21a675e093b5c9cac42f15e30a07ee98767a08127a80bb72a36d80187bd58eb776ef01e728064c9acc0db2e1a2d2a061edc34379f36988a5295b641e3e4e6887dfb2fce36e966198d3ccaa6ea99c3b3a28a820b97a49c6cab55ec3d8627ba8b5571bffaa550e276cd5278113d92038fe6a3741aaeff3ec4301114ecc271b170f62a61ecdd14b91954251577de61df7e69f9963068711816c333ec99b437c675c8be54b659a052adba8875b481db9ac1069c2dc05c06b6621ec314e81fe003ea734d9190503256b40fc778e635a0fe1110f05dcbe892cffd48f0c45de5a3be37cfaf9ecb98bf215481cf153584180ba9397a796fbd8c0fadc9b1704b3443803750ddaa6ed3b91db4230caa1dff86f3f48ff0ac746dd539a4175eb92a711dcb1e9bffe2e31fdd83a31b1157b1b11503ace2858f1db2ee0e598cfdc543753158864898cf73ec79fb3c823eef58612c40ecdaf095aed908fb74484e20e02da33481874b7541cfbd64deb5876903f81460c4204572733750b552ed42a2b8f5f13b56ccee2892effeaec9927aeb92d7a0c9f522b3a68417ca00bf7e15a8a95bc79148ca64d575bb8c5d75495ea05597e1bb5bdba41e5f73c430a854e48b47904bb3e145199167d8d619f901ec5d452768fc5f43268ae245a674ae1d8b2ac0cd41370d55ec0c91a2b80b10c7bf8f0bd4ad1c5b2777903af4762526b5fe644df17e4f8fce353d1ef2003efa5fc854348736bb8082fe9f639fd0616f46243b4fa1cad021e46a6b4b648eb906fb08227fe7d285d7add2147ac0632f8982c0ab93a782b0d12bd474f2c01e5e0aaaaa978118939fd7447c47a06a5e095595fff04f88faf73c145b8ff1e04901d537feea4da52762438125b9a971471369766cf7913da5b6892703bd11c04104543b6c3409bee75e69163ea1887bd9d86f298f5402bee0c47867f97da831fd221729210cbd4f6b0b5c01e08e79dfc93dd5dcbfe3d6f8ee18313e24ba8441e47956e9e32c25bfd8f58728c8a97d9f77bcac1f5f2821e64dd7f903818548e3ee4b9c74f2878e8c5d36f01447850c4d369709fa53915d2f4047d82c38718bdc2ec51580987a189fcbf5913115b76599e157d04be178128a5c2b65108b535bd96f9580d23daac2b30c20b0cd891dfe64c2889debe478169f299b5540a503d623ba6548ecd9754c29d1c9b343ba9bffe84e19b9497162593449cfadb56f809398ddca8661d1e20fc627d44ea45ef6973005fd078dc81267981fb145734c35100afe0763bfc0ee4aaefe318d7af1fb4fa4985f85ef02997dd03e5b55310b5428292b0ae085f64dd6f13a149394e000ea27a841b6acdf828bf72c1dc6ff2d79aa15b92a5af89923647dd3d69d55128c2a60b8248647f3a6dc469bedd51fc0ab908cfcd40c661d3717ec784d39a15b108b79890cabfe01158ac013728df5e97197475d1b90bb4bdcad157ca127d7f05054e22a47eff1538f70f4ec7f1d7939ab145de2f8bafedf6c2ca99642ec0cf7f74992b8ddb4dac2281485ed59d2c7e890646fe3c2a3f61c1233c640c95a183c64ea2a12b2a682801ec6e6debbc32e1e6d08e1767f262e519f09ade215b7e6131c34ada390e295e4888a6ed716914862497c7f4beee65346a3c450ed0fff9a84608c9309e82c66f1e3034547f1c5a790821eeaf4938cca36a415d543dcdd625fbea17bc48c4a3a835c7dcd0645205b6dbbddf9ce9e171681499b94f0a4bf19473441e8bb2275e9850a222dcca2ad33c33e2ba251b008a1163b98321ef9e6c3bbd6d98ee2d7360598fa53871dd5a8a38e18b3439e03e0f5b54a14123acd3bd3fb7c5d9c336db1d6462919a496f0cd7aa4be978405437d1c3fdc2f54550729adfcf2c11d4bdc1ca5316172d8ab9d32f8de243e9b45476fac7a4eec0451fa4915a2bdf544247e02b26ec87162284472eeaaea1ced88183fbbd763db009ec1e43a6af6f453beb8e7ebf134f45b179b62aac55917cae63a7858335cf782459b267debc14b881074f3a99e71cdc3874c853e220dfb182fb1e494b8a652cdd629afb2d323cabebd49deb837c41982f2e74ae7141c6fded3d20c13110b7f01caf6cbf854c39889e037665e07981b473917914d862263bfff8c51fed0fe836b7bff1e252e3e42a563e2c59ab59e429a2eb68e46d9a90f38167dc539a0884f7b500be659061ce1ec25184e88a193ac04a5384a7fd3281aa826e8c7ee3b139205c7560ce6cb91e6a038772b4ccbfa77039d6677b5a26387ce73182448be2a91f273d1002694a0ed2bac91d863f2370df287e230d4b98807cb2306d40f562b637a10de6fd403e79d43b3446df705db2a08f0383548ef9f87206b708386297e3751dfa313b69f32854b62f06814fc3308baf6cf77b11aafdc0bc1d8d720d2751e50f0b21686376828070002237179733ec4fdd3efea0ed80c3608d23211f239a9d92660271ae3262ec04d4c04fbd2bb0ee26cf1188698191c6f03eed334fc7370e17d4c6272062575045baa167f4c010a318693ce91d9d8a5906ce0903f05a2eab62df641b4b3dbb13ebda72c0099462a004b2cace768c3a24dbd6f3fd55937204daa98c4da3da061a57e02cbb4e18ebaea837a5570efe4f69cd118f7bb4f0304b4f728d7194efb2546ec91195b2d1e475c2c721d463f4db6896ecc7f8a313d958320e475a01e50322398d191d3de6d0462fe86e538bc79b296f6af8387260424d2cc5fb4371bc6c9352a3d1cf8f7a3e11f46f0943dd3530adb85c53f60d6feb1aaef2cefcc18f94163b641271a36aefaae538a1ab42564db2eea8f09c3682084b8109ebfc17729a32c609f5679896604b17024061c27c77065185fe89696d5df17a9a4051c0a6808d3fdfe317b291a9fa7a545af1ebc3d9f1181f80147f5778bea9bb349f51a4491eaf331530fd479bdfc3c21299be807053c3607a4fabec565813391d7aa20a12a01a64c5b9a049cf5b5653868129ac3ba83a8d6ab5cd611a9e27ff8b7ca5766c451831f437780915fc238c37d90592570af6dd087344b0b0bec0316f190d61b9235d856608b0c79d7518b6e3de38b872215779e2396bcd915e4a311f53d34fb311d37b953d73da9edbb4ca23fdbeca11977bee200d42251b7b0ad2fd60f6273002dd74eb543b3b793fb97effc0b63e9c3c9960dfdd5067b58ad3f635460dd0d84ea8a4e3a66396314e2988994a5ff70e7ab8a090d46fd3092e1812cd003091f091cd0cc1a27f979e9a8b312ed184687d999250ac5d8a98fc079a536f102986ebc8fa7b9ef0a7624a4a17966f3292922b9ea997242dc11db68b086cad7beb01ed56d33c063f2ac72110b1704e7735b700d754555e302cd9186a11d05cc36d823d19c30d9df573c7b52b1564556561b076f41cce721c7847cb5512fad1d2fbc83afda45c24df304f3a5e2e5d7dd8f5417d3b76ee964b4a1ad0f9f788068ae51d1c593baaabf066ac51aaff6d59815c34d42e1e39204dd94a8e7a093c717287728ca111f6c0e11d21998eeae7e221682c16e7de92f3c0098a7ceb2b78ca3b7d48a9ee94e663dfba55c0f2c510f4686b761fe6daac7263ee47e9a20d5a4caed37a4c7cf471e762ef4fc99ea4e49cdb8dbcea77036c5dcf0682d53515ac9febc8b6481bc3195fd34f80316e87c84c771705419ab9021215914672c35cf4fecdd1b4303cdc44f28a30fe1c5fde2867cf400128db4a9722ae0f0e070f4895325cdb796de1f488dbbdcc29eb226a60f135e78f525fbb8c456742359dd28064b8d01dc78adde79a0244c69b0e9fb852567a8ac6351e1730a799bf2142536578dccccf786763dd9361df1ca39e556da80a9d821a3b47b5b5997bd87088294c5459a0e1ceae777aa638fda1d92f8ed3eb9c01eb14e999d62ea1960b4cae7f0fd36dbe9d82919379feb2468f383fd142d3105df2283169cafac7437799c4b0db2d56fffe4bc6767e8153acd620f334f524b609f14587ae649d7821ca1eb0a747206910b65f0760a1d0559c971996109da493b75021913546e6c5dc10d4997fd79ef14efdeb947d825d1fa102252d7073f151b0aa243e7ff955e9ffeae8839e2c5d541b0eba180234b01a318cea3a818f2b00794ae94f01a296f0701de9a370f8bdacf79f9db165e559dfa5df9688afbd0db99bf881dfd82579618fecbd9b1422227f250b700108364a3434c75557b8cde93f5d228ceefc5d391ee229358beae0997bfb2514ddc4dbae8e25967d8a62411427b4bbf014e440ce759936b346f29c5cbf269dd88d389dd3445c1b4867f341aed325fe6695c15877712a9b065f0daccbb41914c55f092a29ab7027c5b9787686809c8cc6b263b852af217bec156615eab95dce59b69a73240487c217db2d8dece45902509c3af95aba959e859bb4c924f06b2cac439a7f0f1895a7d2b0926db84b037159e35a3fa45e9071fa3d5222f50de7132dd12ee9c639c97952f68176379494d5780dbd70e31423e29fd008263dd2e24f7b8477220a608bbf2ca76522ea18394c36a2d204bd53df162bf973d0585b276879f18362370f78a03d63c38db6b63eb5145a0fdbdd4e704a1a1e9c0f82b31552fb1afce3fd4f86bc0a3a5453f629d63d2dc6c4d465f1ce74427231138acae46f83b6e7d9a91bbe9771a42e8ba17628c638eb765195b7899d16567121097c9a33f109f71a706038bac871c4c805dcc6d6b370796bc763a1f7648bc59f2ce577ebe46a60a752ef8dadb140f75257ed712018a7810d297da3cc289bbeb9cb68c9789c1a561295b2f0653f052c937c330e8b1075cebab19a911f87048d001696d9131b35c7eecb06ef4844dbd308775b057c02564c47a2ded80f05785570426ee33a863b516cc90f6ffd73c0e677226205808f2fadcbf218db133a85cdaf35cecc20e4da11c136c4a1a9ccc2312773945118de84dcc9eba76eac2aa0d552ac26f19ec3b0e733c2205f14fa8df0b2840522914e553abc4042d5080432c43e144950cca07aa0b4cca3ae6ba56dbad1d92cf22d8adce3c3fff2891beb261fa47a887a10bee57bf090edb05cb7e64f369097fa7bdbd76cb680b908e43780e71047c7a3b15aef720e891adc8f3d7c94c3971965641fc39fe927366a608aeb1f19c7890f5d4f8d71886c06531455fcdf8fae4099996448189a52879fe4e3958f3ecbfe6bdcc5c4bab9b1ca8ae7f389af9e1a87dc7607fb29cef41383bfdea720804299b0ecee316a1b94679006b7f4e974647d80220b1dcd0af1c775677762f4fc74e34b87397bf36d7448b665216ebd01c5fb04d8f035bb95c4e2895235439f3adff5925f6f3d360bb80a50bd625a5c03a03eef09fe2e79d70f2d6b2f632219c3be13414d4e3c1eb94a3f286f7f4273bdaded298694160ff2f43b46ca4745cf4cee55a755dd81a9cbdfe280f40534297ec41fe38c64d2bcec453d7b8043ce36aa8a77a666f49689868c199132e253d7a90727f178f83082c791a251fcb540c69f2626c0d1aa3b8da1f2dd9b9a6f44d73ea52b48d8689f8db7e531fd8830515b5e60053e0a84b7abc450d191e41d04a2683e0e8c405fe68a4e4b71349a122e7eb3a5ca646e907ded91a24bcfd9418f0cca57d992f8f851a3cf7cafe0ff8122b75d101ba98ae518eb0ff082e6a3cf50d73076f46cb454f46307a42025a6ec15123eef54d213c78cd44fb213bae6ccb6a90233afd5388113bdfca3fa02ba380c84222bb9ba92a9dc534b1b5ecdee4d0dc21ecec1cf8895a95315056a4b187d616fb236fb3b3bc2866eb4d00d9c1f3c8915d4942c7aa3aa6f76b4ced5a8bf4e60455854961c5821fa5dbc96e3e7bde7571406c9197a85394bb92db4014f87bb3440fc2213079467ca7b14a65c543eaf827a81b60f10d016bba3cb0b469d3f54a7e4fd43766d338d909a5cf7f0509995a82657c2e8b3d002ae23ab9a84096839967d61c20fd2a697dcef2ce168f361334864cfaa1b4a7e17b5bae5ea48afc258915986d1f6a7573e0855217d04c503d5cfdf86234bc921ecc4f7d128f9b386ff077f61d0d3c09054ee1191958b1eb413983f8fdf83c2c05f1d61d1f2e2918baddcd908e946718b13551a25e2991c2ced3a828d387d44cb4a912233cf22a60bd5ba265cf4d8b6c5d1a6104284e5fe127cece7dc8cab1daf02c83e623cbd890a95a28898e1b4d0505c81789d2efe97d601c531019e7aa3a9eb4b3fc23e5bdc2bb61c849d9b51ee5e0f3c4dd607d1acb84313a1e37c0a948be5753d87021bf1adc1d2bc0ea2c6c94a3bde2dd68a31c111866e6987ce82bbe16c5d4a3f19f93d89c4ea32176a50b8af5df154e83bd060be8baa29254d340837189be588c9dfdbe8b64591f4eeac849dd1deec91d95d93d1bd7333f00632771aa6312f17711ab2dbea701a21e47f9c8bb9b0eb563d7be7115be7149d849e3cef792835dfe57bb66c9663445680e9bf35df8333c6dc603b630afbca0c35f392dc77ed0a22bf891f4cfe7c393f1f45bec3f32b9e2151a213cb94ca17aafa3292eb418b5bf58c15208067a3db536ffa2a542607c18613f062917f48b9686850db39cbd50a22cf546d94c2632b31601b32c8cbdd97c1a645b4a0bdff56bedf63df63ae47b333ac707b3331cad3c1b240c1a770a57d80612637e13a0053003c4e1faca121a61c2b0b82317bbc1f3339f97c3b28da8aa3870be803b857fdb91d45ccb57778e93ba491e961f069727d9dc6dd6354344954a80e8caf920baacbb2c18cd905195f62490654047b85e4b31d6ea423772f5553c690f587f8823e2270780d307084088154a84dd51a7fc3b5d45d21d565087e911416f7e6bbd28be5d3871c02580a47891d0181c51eb5a696e4f85c3749e389d889be7f11ac7102645b989efd158f1f1cb944b0c9149f04966246011ee056c93e47d8c484a6a95c8441299bd990a10afe1f1c14bdfad2e6f018375e615a34f05aea8a906b0173eed5074b7dbfc0dcce4a07172016b93ee0aec1586f911a9fc509d0fa8f3eda407ebac6b0c46e6828f61557bea1ac50225a1ddb64c00c24a8f74dd4548432a2442bd16e04d90c94c1520345e427fdcc9e8b1270ce8201d50a92a0fce5c115d439fe4ae7e6f82e2361fbcfe27875328d32d3b2d9ee16a1c4a8c08f64b331197bee460f7dd0d741014665ee6165296a152650aa162281524662a44cfca218e53204794415fe7d3ea5dfd618e576010ccde57d9ddb21df85262efdc7fb702d92470a875d49246136c98c35f6ab2bae88c454b7f20dfe692dddfd1d11d69f26582735604e36a6accfe441878a213d133ad11d92c28934690777560588a24bb527313931dc2105b2ae2daf7411cfa8f89932b42ef111b72906a9d0cfca6ba519b2b848427575236128c4dc40c1a4e16ba20111362fd9596e636b68cec2ba3961dfa58c6874004961fae21791af6b715e8f68bb2ffcfabec45c1ebe075bdfed3968ed9d8cc4d1ffac6cacdf12b01c4655bc9eadf8796812bee237f9c34f25bc76eea84cc914d8210fdbdeefe2b9b5f247b8116c7bcfc22af477d2c169b72b4fb1adbb3c25efae5b0f708bd9898a5ffbec7cb28a27f3a7ab2b7319a1f79ece35702ea8b66bf2da93bb9c56244d304a998fb9d4a8b71f4f78ca4678702787b5a18e3c3b74adda3fbafa4881b9e0be6506ddbaa25f7f66e9514f6ec8100205b070f7920d1b972645f414de61b59fa8c79ed127f83e8b300fb9b3ee3575ca53acf29c24a0a2fd6203a38c2862d957e96435037b700b5e713b949c67c26cc23c2774e42e58586b595319000f8fe04d3210d6c3d1c4182fb4f2fec7ccd66b18790a982cd474c09016dfa31e8caeb02166702bd25c8dc051315d64049aebff66ab771a78b2948464d3bf94e03b56e38ca6c26b08948fb30213821d22a7535da7bc7abc217cb65d916b839ad9be206aacd1d2f5f0a81ebbb1e3aa1e84fed7c8faba9a30c0a87cc62bcc64a1427e7a34b9e2f97240ea64bb0f6f66d5661bf9716cd7594aad4a50f171ee1861ca250802b21f9622a1f95533467819af9868c0c8498bb46ae052ca74228d14ae4cb40fc80f88647dd5a8eb989560be0ef76d1214abd6fed532834cd452cdb839d406605a1be89bf2ea87f37a57ad0d25a1e89a64118dcc6904c5f949d771f612f19c800bcbce946886db2c3c789542a10d0807fbaf05788425be9c542fe3012eff038c2a8828fd65070f259d9aa84d64b0d07ed4313a5797c1cd8740e7a8faa8465db1e9354f5edc1b78a51d4054700ab7d48cb4956bf5eae361360c4c3e10ed213c9d69052a8ce044f5ae2fc83ef4e70f14b2f355565d010806c22ceb6583119af9b1c34a3b67c63ccb0de9758bb953f9a1f98f77d5d50d63091b206501a2ee074b92c2c833d63667fe68f78c52e1da9c9ddcf8e0b00e4d4dadfb43458f1618d224b22389740a168f75a82244bc0c7063f35d38ff95bf0372ceb3b9ff81d17c9572849e65afb745281d88c5dec62049edfad652d3a186fbcd8804cdae94c636eceec50233e6bf53c6dce8c44cc06d62cd6b4705096c6883067080ee3567f126c2c4b699a9f191c6930973834680592ba8b5f74059072fd5dbaf832a911f7cd422a0dbbfbaba07a33023418252ff333afd51de5944eda1bea76aa9aa254ab8ea24c98d2b3900b8c3529c425959c862abce2e893e7fbbe8bf7cac699326c6b6a229213220eaf90817e42d6a77078c6ab248fd5254c200dc0c71a97d2295c29132ffac24a8d7eb80bd9316a9491323d5a8d2d49018053ca2c0e4d05ae50d229e323a5ac87092baf47729f95cff2db33414183d01aedf1cd4aae0e8bd50af2e550595dc80058c28612e386865df4ddcd73b813cde04f6ffb8080e26f38df1557e06bb470aa7986ca5888d86233c846b238d7520bf10a65e5ed68b70deea9539e46661aab5c3380a857474ce2ac3c10146fe9206ca9ebad0e0a1d2ee89103b595e46b6d2ec1639cf2c4d4b1477a64d42b1bed598f983c05ee892a53999fa43a46071279c0c53620cd46376e53db313652a34cacb12fa3d7cc68c1b48099a88195b80a1e21e355b82fab30e47c02f4943c99eeccf5e00692830a57ab646d69af5457a24a94f6e94aed8fbb75c8d8c1378b64a5838a64218730aa3b9dbef758ede09c346e3477deec5865a73e1c7f0fca04bb7ff99f865285955cf630adff9e197eb95b00687b271fb96ac6b486a6f51f51add355d3c5c1f581f067366ee4a0ab726e55eca31263401546a33d29a09b46409d89c0e8ebcfd73bf74b5cff0590fa38ee0024bd326ab40b68f8cd460e838cc0112bb9b71feff629acb4577a9113b27a1262a0ccb6a85d4d5ac06457d9c50044a9cda48023ec38b4b331f6ed8802e4e430d75a68035fe020181942a72e5f86dc9b2db9337f4e75a2d22eeeee491e59fcca479eb004db41d7ef844156857cd0be009fdf206cc4e3274e4af5a850e03b900a3c185e1fca5da7d4159ad59082b87aa41c1002b89fd3c4999e96cf21043b1d0856f37ea083c1f8b9d798288589f1c2a00d5a3b171b5d1f375456acd8004ef6725a2c7b278896e68b37a6795eece3580865a90249f077b7015f672784fc42ba8e3983b42195f863afed2fd7a4b6d471eea88954537cd36c800779b050dac7fc6eef68eee783cfcb234b78348026e3e15d5af9e14656827b7010c10fd22482e07dbb924d236b61ba107defd506a04e9de4e837c59f7c56e36547c5c9fc59f6e44223bd639240fbf59ad643bf306e65ded53964343109b9aa66fdcc971186b94550288df7abb6eacfc4e5c965a1984539c403f7bcfbc6a860bdb07070237ed8bbc9b97005bdaf83d6d860d6311cb5def9ab4a04c317094e6d8390c89b87e97524a9511010be719765e1ad64b54b92ce1b364aea4f476b28bde44c0ef0c8a461238b98598f6360dae4eb673feaf1423d5b7d03e8f4d4b0b4e69c4b7516cd764c535fb2a051bd0029e4f8c0a53d721b146e3df64fb78a46d5159d11033c5eb96a982505b29062b47cead343a5cf99fc9c873f597d06440bbb2e244996c24468a015934e6cc0b1cde86eeaee69a192a094d8ae8a5eaf8991fe3ead90ea64000c1fe8a396be5f91251a789eb867ddc87a6903096c1f868f31813a71c0746a020de155ad6b3e3d8125805b637a0f2b98df7783cb0ef66e315eced0e0e3e3b9d900bc746201fc38177837a210fe74999743f1e8a86a4bc65148f9c96fa864a0c39ee0fafe811e2210304dfdeadb2843579baca3e336cda569a628bf2b04f627ded4069141d32bf67ab89b70cea12d58c50d2f622b7fe84878a142b74721f2af13bb0a2a77ca9d8538683a439f43be04521bc9c4b15e400af58c463efee73c129268b8cdb6de2963e54481bb736306fbf4f6751cce7684273434a9536aed38f19aa991397677663cb364ca347c001de6de6f1a961d9f29f57cc7d7ee75ff8eb5505f2994e9da7a935ec73e503d885753d0428aabda9e6fa814e934007879c1084183dad23b6fb1e5495a0c8cc6a2b33013e809d1f98d3e336a1ab39c321025408424fab402462a40fbb207be75ce686a3ed226010b29485d65448a0a773ae8475ec0612738c42858dd79c60f47ec05aa81a2e42eac9b6916573d0972bdf3c4eeb861b3de2ca6eb258225a294b2c917817a304cc6c8593e3a8e33d5e527a4c0d6224318c209147415bc44afc041fa97e6e1fc0a54302ed313a5bf4c710eb346162764f81154566d096aa62122a0ccce15502f3b0ede7b4f1e199fa9e411be1b2c893a8d3f68428b1eb68541ab6fd40492f5a2e1057b8eead61565098e7735048ea783fa43d7743a5cf0fad1c0c4f5be16bd939316f3330cd09f5d3e779cb8ee00b4f5cafe8328b575abcd93523af9d5ed676b0d3234eefc6ef233b4f1a409413aa4244a13ac364bea2b9c709df818ba801db706db50cf1d3267624360bf1453098f4e214643427606e802b02c6bc3b0fc583273d1616a08d7f0cf2624ccfbd1dc181df623cc91dc1b4b9d524d1d865e366f650ea35a030c741d56519e0022528359bc8ee81da48428a424240c01c5df5fec5c4879c34c160f3c68701d8c14a806c7dad22a63eee9d56bc9b69699f674fda1f866927a620d8480fdba05002a17400bf66f4d262844fcb8f5049cf8ae1fdbb527ab4711081823f58d1d23db3b36dd7190e8a2da93348fb753684be28166eed5e4461d142eca27a8c37bc6effd13a09407ee81419972f4707d03e9cc3ae24920098333dc1dbe22800bf2357051ae8ea5dbfbaa80d74a09a7c0de0c168070023a75fca1a4b11481686ef654481dc8baacdddc7166f31e71e69b256ccf7038a959fa474af219503da56e9dd9dc381d4b79e6750bc9e00874d69848b1a5f80102a68f916458afdfeddba6c59f927e35fb2d2fb9c1434aaa52577d8968c0059bfa1a78f95eab7c1e6348076d26d630bec7807a9b36913cd6d3b8719660ae23dc22b67f17cd199dba0e836e992777f5c9d24122dcdf10a318c73971ea9826a24af6e91d14d141cf3ae319b03d1344addac6b9fe8baed4b667e56003228d058bad642f7075e6511d5e48fec8e138360454a6776dbd8fd7e5f0dbd5d7e68ac7d2504369e38dc4ca802db2fc59c4f28a84758c754aea7c020440e295d7487c3647458ffc1cc06082827d2a77fbbfb52d1998bfda8071c9000bc835bb34dfd236991d83c7edb489e876226cd38612b4c5a96c3ed873b4dbafd47556e7e3672896b55bf8d3fbd14af8b966d28e82a0a2c52e0a87e2f6185a1e2ceaee74f76a267bffc2a1bce2ae77a3a4fe5f17dd4fc63e3f71f40ff636548be5062e1c30a99abc91833af43ee511c2b8ea91fbc8fe234b31076106ff4ab4b4ee7cf436ba88a6885b519b1898ae627302280842de8f200daa4cb0c176966277ea367ea9270c0833f56e6df5c6fc7fb38f2f8f5f0514bc7d2890f74eb00f5a17c910d61f7cabb1e56d296bdb939a0dee3d1a0e57fb356bc5b5277953717d7e0f68ea3ac62979e7af29bcb7b30fafd9f7b705935ee39eb6f53a53a564bc1c4f6bcdc28299c5b7af5afbd712b28e87f6e98140ccafa39ba929b84b4e76b75a38d5817cc655b45c9bbf2e2ce11bce658959a5dbe7c52359e33a476e042f115b9c5e03615e5a54b171a681cfc8a4d19f20be9d127a3a25df6c4dc26c3d8470a4ea9d3474c7ac56e38b567bfa6c2f579b88bfcd3fa1e374fadef800596be935021d6c874022afbef17ab7470c5895d5c6e9afed008382343e657ffa6ad6d8ef16f2814bead0b78589952e77962957035cb9465bf6c8d35941d6c772fed9263821b1d6a6c0212d9e67a55c4899910e0a2d425f0fe772c91a4aa475445df135e5a5386edc6dbbc3d7d31dce1a907ce10804edeae34c1b9d98a941e2b607e61f6b83f42b5d4b1a978a804d92b48260ff7af2851635e0b67b676f548603ae2c43a280e9295c55760431a8eb43cba34f8741ffe313c66e63a7f787fe571253ca4aa315540001e4fc2b606437468767bbd51ff8da3db2b890d7fad9284809e2795870a0de291f07412f50c4ab7702c050ae7feee518c1fe17235a2dcfea0b69f92374bc92528de13cf1ff0febe97dd00ec63af178fb35247f8f40eb2053ac89509d939aec539d6588b46372bc25702c055634cb226e15062920f82315b3462133aac930071a607abb222606920c5c6171aa771b45783ba0eb9719c546d4b4a19bc584d9d0cb6bdcda654489bcd14276d9048c2e915da6bc6f1c838ffc24d711c6e0eb6ea74483420d07590027c7f4ae2b637bb02266d704e2016695d7d92ec5c0022bc125325aa579ead2a3e798ffb8266b51b9a38cfa9774e0d445c58106d28617c29287f97077f527c2a592ca295ee74f8d8c2ea5224b6a92df3b4da6abe24509a972d8037a060910bf9e6d80e8ceae90a3f9c86ec8a0a11cbf339da80a01baf1d12c9d1077b8a0e69cef16a46677cb49afc1c411e7d13511f39d685aa7be1c891c7ca67c946bee49f9e6d8dbf7a4003d89aabf25550dbd958d74824953ba61697562cf731c4fee5d96ba53b2114dacde1a38811d6bda45643855309626c7e26c562bff6bd5ae1199e9acabeb824610a8bc04b4df06f0e71a7b68d06d98be4aaa1a48bee380384f8da00d638cb5e4ae6555485ea6212a50d685f0b85866ea9026264385b3c4f311bba56da9e3bcf414c4b5471654b28e83f4354716bd4c2d2f809303249099dd5e1e8bfba9945e93e75f4bb736f859b747d2c629db05cf2df0ab03fb24d3eb175d49d8dd9459b0016b3c3b0978ca7d0c671c10d74602ff848ad3cd2029532e9fe20475fad9d75683cc342ec1c1fe9a0b97290a7141aaf663007c13d54656f25894757cd522e28b1b07198ddb374e19105ffcee91061fafaaccaa8e34dbe9e5a04532fc4e42bdb0f07a5358b5341527887dad811f7ccd0033842b4c1ff60c07433f5e44a5cddadadd1135af107fde45b9861d9f602a00a79ae47c3652e4b3dffd9325fd3adaf63fb03757889bdcf934bf2df7a276167f86b2d2d29371d514a69e756bce4a4e46ebd2ee9f430512cf2c3316dfa9dcee5146328338250f3e35444575ea6285e6afd0f27f1f4c522ebdc8d796300682f9f9e153acc0c9f1b9eaedfa0aeb25cf488a844ad3be010586cefbbf2aa84829bff75d6166c5bf6f6a28234e1253bc047a80d8ad81767de17cb0d5ba3e83c81ac53122a59049abb5b5c24470839a40403d2da3052c3566f91229ef6676db17ccd8934ee4b21199724d50f997f69dc602f413f88492913f75d5fbd614b136010947abf794c7f162eeaaf9e3014d2fa9de40fe0eb5fcad8bd334653a0abdf9bb91ea4ff913de1cc6b891dda532bd637d9cb71ec3d804e8fa1ba9bbe74c4e47f8d48d59603a5e6982d659e38899f6ce1afe4c2e085500afc2bec02f89fd67a286bd2bb004bd2775783846d2e4f0b19d276ac517dfb36d5236cd1c29ce6cc242e8333d33f073c32505b4fd19b02db5ca3feb96447eed86bce0a8d1a76750b4b074154b66deaf9d28321fa1495df8cefa7619de03539960a69f2fb6e236da3b4a59eb7884cd9720476fd7daf219d3c4463c6d6dea52470c26403a171b2ea297319b3654374492fc73bc1ed6db6d1436a375a2d212329d8d9ef62f4b4908faa6f5f81922083ac400996632346d2dc25a7915ce1449e29a6ecc14efb8bc862c815741fd50443c29c39e14dbc49de10d109cf5e13db1e1c46395c885c6e914cf7caceabbdb1bd6bcf73ec1ac9fa642fdfa9225c2c6354ccb99ecb60ce1993b12cd665cd2f467a7353dc084e1d626e83dc3a496aa737b90d233bf46c2b0bc95c73a693c8520f4ce8d7bec4d7cb63e32add2417156c43a0b16e9e34a5f33b966d4e0c497dd10b3c2db382c42f9408b0f468d48597e440b58f592bd4b37b67f83fdf034c7a6f7b2c8ee00112ededc3e1e9d7002ba86601fe5d7ffe57f2b28fbc1f189d082ff9e17416f68b6944d907ae2b24c4d7fb5518db598620ef6799f8c469966c13cb196efa54326d7bf7de71c80af1b00b53ab3224e9cab7593dea895bafa933057505e9f4fb58231d929e6bb795a3aa429e563bea24fd094cd800abc3b1773e0100880ca894a5711bb7bec1487d43ea405c92327023fd63eea0928ced7f34c96a0cadacf6ba0e13c8ec99d1f154434e42881456c1f9d2c5e4f1c09c86fdde1841e403c6c74432901a9d30073ab0464ae17c1d5f153229d03ca60e4e26fc903cf37995c762a25c0b0aa95f8cfc0416937a9a6e8b18bb00f6238c42d533770b014547c38217dc6e0a9d771b6339ca5803d1aca3a1b39fe4217ff92eb4a71bb20c42bcac87c52d169820795a2d58f18a6129450eb6b01c0be21e2f25fb496fac6e28d71a7a227adcf0bbd8a570326692244faae6706132c4b4f6e8156832cee9738a4a8001a1b4d81e98c6fd09ef8572935ccd560c43f0b866d2385db016accc5ab7f59281e95142d79db96a9708de331ee4c82773a880cb598314540c55fa154ace37655bb0e03397985508165d54d43baeb96b116929c46b2a627cae85d4bd68070da33e268d8006809415a07c0dbdcbeacf06d06f37b6e165ae4888456188f7830aea4e3aed395c068a1afcc5f8a67bacaacb43111b9a3b1748855f87b17128773d4c9bc7786b94b632901a89cc9337b89e2e11229bc6cf60db5577d26841d0c1c310e9a1a2f9075833a8098e076027e4928d5500334bdbf66e6a613779e87a9414f5ec889036dcbf0a392f34890a02506a3776cb05f27ec84c9882f25f309acb100e8972f8998079cc54725e55f66b5d616b5f3cb88aaa7d577dcbbdb435321a12ede0e3a579bfd4cab812d7e1d30de38a1423f788b7ac754e7ec3802e349f0eeb94bcf7c59c9c4f4cd16de693d96d08c038f250ba9dc1089a0fe1de52991cb50b51cb98dbaa569737519057b1f780cf40718971bd139a910bbffacc7ce2c362f901b98fef81242468797c7a6285c6d9163bbfd66499b84fae8b9a126f309b294536fe5bf7e58fe23cb3d2a8af13c242cdb90ac6469445b667e0a3afd43f1954a16156bf1208e1976cc76c97f96081ef2511a9a29c991f8e4a8a76932a31d7b1f36422a16637cafe0ecec9c028dd80e95c3521d78a519956fe06a45a4e16758c4cad813fb5c1e42cd7aa6a7951a8d6e127e04ee5edf016b244c75da8b1bd6f6bcb6728abd89c68b80d08cc59372e422a4e24ad687130c1c4d208bf00214308c461b844268c979a4c6f6246a5f95d0771fc8d9a47236f714adbbb236aa97de27452feb7b262e92e8d7a78fa38d0f47d427ca8566784c2b5b8c6008fee490be81a4282d9106f60740b63fd74354e75a4f1d8ce476b771e20b18b04d70d0b12a6a6014987a892b919abc430609359f9189ebb3d0ab2d8df340eac9c93c5cf7449ec7e90ece67564c153c25763151d22aefcb95e3cf04cbb50e6f295a858176c919d418267ce494daeb9a48b976e47fa2d5f60b240e28c9d22716c7e5955824c432beb1ccf029a6e36fc5c7738edd1c8c1aeb372ed368a804172a0c2d0347616e57a6a56704147ced17c7f458d3aaa3b3e5ea0ae84706919e39961d14b69568d2e0fbf0da657a2a7fa19348530a80a0e3eed60f7bf95dcf8bf29ae104f69842e5044efdb0b2e6f41021b31813a6ed4558f2a280549b827bbd9f7ff769d1f7c1ccb6549e6bfc93e2599fd71fb834f91493dd376d661711cd98a152f2f4fc1ac628e7d2e09712e1314ca88cbfc9796dae4f09c2fb8ba3e77babe2aa4b36a160fb18c3982f39b91a676fe33d51a51141905d4acbfeae11c2358fea44257ee5aba0506a5b46a6e8721f333437827b88df3690391fe4c461661a145672fe07724567209e74fd16434a937fb0b642a17e113a44cfc86baf1aade8139c32d573658b28505a8e62be310698508d5443fad1d148413d75950a02d02950d95002ec3a3e839235453e2fe4feee4697c08a11af6d700909c782a43df8dde19dbcaa075ebf711c6fd79c5c3693990c14ba072563f383e6f7a6580df00d6c050581da43bc2f1aef28b26a4ae90f09ce3e264b939c444e27c1454c0ab4472e8f7fdf527f77946e135d95a41d4ab8a6535a8bc1348359901a15c4543b04c0313e63157b9f9b0d6aed123a9abdf519ede69785a2be1735f7ce4a1492f4744e3d99dc57c33b08dc9df4a5fa0e358f64776be537f926c58462462d531d3636f612cd3ff111a8ad72b2461c35288af712d3fb342e07348ef325fa00399cf29c5557b995357ed80a573b2333dd54bd338ab87b0ff19f4d9b72ebfd5e196795d3438447adcd62b5e8855e34131153861c83265103bd3c44f3871cf3287d93dc5bf8d1078c21d5c68c30a3581689ef3c1712605ced78fd387f8fb3f14fd3098705c05f26ee834d15a310fb9709c073f7329b4d2766cd73af85d516402710065ae8d690d936ed2e853a6c8018eb59ff091a12cea14e2b5fe747918389401b30c334cbcebbc5790b044e429d9ec262b7868b2ca747d6d66e16dada0160dc9b029111c5a196af1985336e902cad3e10171c55dc07d6f36caac74de807e3cb58d7db3285783365d4106f1e376dd0c05eb13987a3fff9ef1f7fd11fb2ecb1f6c8dd590aa3827e26f00c1b2c8a60fed8f1b33c2a36d6ef0687624b6bbf6951c1fb08231880da867b2eaac5f74e499455460821cf9adc2264843298d1ca3cff70f09d44a902d3dcace777e8e13b8ad3cd18c5c6cfab89e792b89d48462c5ab4facccb615f095ee62cfa69bcd8a022d3af2984aeb3121c5754ff5cc5a617a117f5c96809a0ef1c2c297d43ea2b3d3b448e1732b281e1868f795e93b04dbe8dcb2bfaeeb2808d78a14992da1e75ea9272e1d6e9b59a79f59d16bb0396a0d748f476a8c9191f12cf231f38386c39bd32107f2500413405ed447790ea20b6c19ff92e72575932469d321083fc322d742bca09e213e4eaaeb81ec0e901a48204990931778c5321b37c6ef0052d1784fc5cfaf57b9086240a6e81e8bff7ab4f3c9ced91af82de8fbb1ba54ca49113a94ef539e5e2cd6855da6cbdab69797a7e78bcf73b44c8f747210807c06a84953c9d8dae1a766e01c05fe5809f2e8e14736f3f2af965db60f47fe71866ea6caadcff9dd0c87018803f7dc13dd8e864f9152e65f66face7527de0ae229282c26a56e5147ef3e042d57cc546d96d7310abb457aac5882ae9e5a8ca691a9d2413e1ac8e736301b1b470fa2f0b8507f47e85079a8d0e4eb69804b6226ecb37339af987f3193e16d6c03b623a4b1834249f146d090fc11dfde410a4208e43704a7d6e3986b57809415347a6c8e01937c1e1a49e14457a17268b481200ff8d1aeecd822c6df1ca7df519147c93b86a5d4774a3fa7a4ff19e55b3b725168339f16a7b24829e9784a99b9c6ffd084ebe75e9fafb6f2208022516a224a10ac492815de75b01021f644268ad2a0a0d0dc80d73e42786a6aa8f31f65129fb8965d9e9db49d3f2abea46aa3cbdd409e190c6ff9a47a8209308d405c00d28bddc0259dac7eb04fa2e547355ca5b94793b72c3b0d99d1e376f34f62d0cd0d8e9f7efb2abd66672b74958db6979af00dc8aa99ea685fea7b1075449aeab7382ee6be3dd5eed9011f40ab93aa6c4e81c52f1bc8fe3557b3ca07903d51375ea1fa9b13b1e7edcf39a9998d6987bab7246c47fc7843d20e942c12d5622703ced12c1abe923e3e95d611420fbe8540099398e2f342e089b5423548ccbf35fdeda066d315b8adb74a5b5e46f8cacc7f73c55b119c165968b2c194dcf6ea256abb409d1a41a5a7fa8d2ea0daa12af35795e54b5f5fecd7c0a5331cacfed7f8ac648f116cf857bba389f533f37b6acf995b68c452ad82f982bef56c6ff4bb70fae4b46d6e225ef9ed77d4daa6c315e2549e751891f8e67ce02f64b18879058965f08beb6646c329a321a10a29aeb4b95c9048be3e345a6c13b750ac74b9cde9278b56c2c516ed1fa92c175f35c8d70d6ae9e4369297d8dae7d37c2c6487a2ec99153aaacc46692aa50fa2aa319f96b63656c07e537b8cb09d45da3201e22ce04afd10dfaeea22000f4a64d93d0c8c8939dbfb0114c3b27a928800047b4bf22f25bdc192a23c76c567ee8002059f45fdb6be1fb45ed0e91349be5fbc75673cb5368ab74d92be8497dc722de3045a4cd7d40aa034852c8d738fbeccf7a36a9f6c12eb501346d6d78038654af7671c570a1cf1684d4574b8913d510a6eb444c38d0eb779f139679a18ab85e384f0a677953c0978a1fd1abb084db41f7182f0cb8a5ddea5b1dd82088f52633b1ddfa47273ce49b90dfda66e2a5d115719c0e86efc9b3dfe89e83902893f0b182d959721b1523417fe7a313f509b935b90569359d320ce37337efb9b65002ce3fad3d51ce45f1587a36bc2ff6b0a0490422987c310d9b5efc4c8f13058fdc5274e9e1e5c95802ef79750448cfa0dac4cef073628e1189a40c8b60637f9cdc6b199ce19f6f45cd1b36ff04b7472bed062f4bc3281e409baf0fc28a2cbd6e34876be24e363c21d7aeb67517937d3cf59b6b49de25900bb00851270067db16c0119294ce25ce838db3f9639b870ec9f0c5c13e5707dd56546bdfc81c6a9ed32355272466ad92aa3f4677da77d896ea95a49e2a5844eb7878158ce5090783ae1894bb91358da404622e6840a2dcc797e0dc453ce31bd8200fb2bcaf6475d3ea78a6b00e4d2c112d87a1a7414b487578130789be2d84b77de166edd36966df3abdcdc8f4ffa9991b69472581c09fcd3704e7dcb6fe485dbfbcd714238555ecbb4d221214df09de4354ecaae3fa4f3943b998271ac1d9ebcc090ca24296c6d79c880e6a3f45e5eec72603f4738312d95b245c0162c22c93fed1d0a70c871f1a2479db3a0bad77fa49839887ee034356f23054aa7c090da9147c2c7434908d78e59a2fac6e45abe6ef49302ff19ae91eab2ef6d1a7d139df6893c76b18257b88a35c900c8d0a5d41c49d166b881bb5f242f8a71fece2b533d7a2d30cbf43f3426f1c7cfc049f2d2403f93280cefa2c2de218fc6e2b4abfe645d48f99f4e8bcd1ac0abde0af99de8041de3d8486e0bfa0516fdc20f5ff90c24cf07aadcc98bf4d625b2899f32f57d64dd67a98cccf32d63e18e0c295d2fb33c9c64737902bfa510da4a72745b8e69e25176e104efe19d06533a157a0ab7c67721fa3f8782b4b4e000a3adc2bf007d8c779cb685faa14dd34649d4bbac0aabb5f3492094a36c456ae489cfcced78f5f62b52fbd60e5b2eb8e581c3fa5e88e7bf32be8ac20e99264b5b3521f86a1a349f692873255210b2f98d0992fcfc32f9b6a00b2a4b54103cb39abfe45d94de9b182e1082a8acbf903cc185ddf39a79e2e6456d746288378b98b2f672da52382da7cec383e928945728a4a9bd2d71ff178ddf3d14cd97b2389f7636c4812e834ee67f899d0d3aca3be4c59f456b5ffa2a60632480dd0b751f496aaefcd6f75bc909c4c98fae8354168acbaca35a175c31b4ea197d91b3903a07a441789575dcee5830c0b1de65bf9a2513533efcb5a7c45f07e2c43e10f18b49bf59e88bb67a90c7f1ca37783ee44c0f77fb7a65fd9cc100df7d2a9bced9f64ee7da21c91e3e2a61ffc6204634135b4cd240a8c558b3428d0182ee48c5c8dc6e56e7f4c5cb73ab0a7882368357547c1ce527272a60208663c8cc913d96ffbbef0285e4474d3cbedc87e72087ab051e6619976ac3f3febda53bf4573601dca89a16a85cb070237ce62c2e53bdcab055a7bcf9ffa2840ce2359dc456d24f680ea4be8005a1bf83f652e87cc18442117cce3c9331ea3d92f6a6f35b6962107b092191d1e91c2babdb260197435e19def57818ca46515562cb800cda9c7836af44e4d0562356681a82210fce921f5da3cbeef1f384c06a803f395009a7a06aca35220cb9674bb728f6aff94d83ee4442e712b21ca2b843e6e7f052ddd861032a11f6ca4714b6979d66ee3af3a531bdfdfb51980215857435e7fd4d2c44599b4db23dfb7639d3dbbfae8f7e03ebe417dfde7e72f361fa60e8ed1e924b1d7dd95639937f9b8ef2104d34fdc45ace9c83fec1c6632a4953732b14f1662b17f6b5afb24e958ba0c2f45eb8f9adfdf82a356d9c0b8e09f39a82f1d3180e4773037560d73784223bfc2685e36503412abb26b9c2dc87374f9c45b807308ff69e2ced1fa43fa7736cf35bdff22871bd5849fff86ff542f96e9b960cef4cc532eac2f4a2ce0908baf8bef415692ff0c64a0de545a69274808b45958199892ff8a91c23501219fba7334626cb6665dfcc5f41a5320cf9c2b14b1adb943b99a83626ed8505a0ec2d7330e74985bcb24fcc8f4e471ae658fa455d1318a29c4d1daa7baf1a1b409170ea5cb5aac12299f2982cf4256453593d9efa7dfab54cd448b3a51d539c751c22d3d3dcad3361e699a10a533af6354b6c839ed2a1fdd5269657a7c943207ef0f2f5b49f87d6a6f6efc1950bfecb37c2187eecd701e5af4df3f8b78b9fefaecef718e1ec51300831150e107c13f3c349b2192890e5bfe974612aa89f0e8a3ca482cb244279e8efdbe441895d6940867b2c29916c1cb436be1991246548fbaf07381a616bc99fa1c1ce704ebd8fc1dbb77b521dcf4dff01ad22c4b9ad48de2dcb6a62a97037113dda2e0c303b0d89f6bff9c5b6d1c65c4b186c65ed16fd5722add58f0232b2ada62a26de3cf0d8f619efc3373f87fc32f6554917a5f312f7d1722377e6f5266b6bd6cda49563012f62d7c535f0537116fea8c3d6d0e9bd8e35ca954af81e4ba2a178db90277c79f6ce6be1135eb52da6462148cd645ad09c0d225e48e27f0450b50a95cb2c523fec4ba7f4088dfe40e522b0e7a6a531e5729923f880bea3163f539663e9efb11c832998e415a217a8d40233cbb785ddccd2a324ae918fff16d720ac19319e75b99a0df7096019c985e2f889675705dbf18a4bdc981e5c061e6b296165b22825f6b4e103a3144e8f5f1beb8cc1386ed6200c0a2fdfd863a2315e4e21e26e46d44f6b10fd426078f827e1ddcaedf04c24c7114db06b91f562ba92e2752cabd1b00dfec07b0f8e980c1f34332ac4b575d067c9c2fd4f3ae434f5bc794478ba5e3137dd5304d214b990ee4f0ec35c4cdc953a2ec0a3c922de5229a00039c436c2e79361f71ac384b9f3a88427bd3989915fc2f62e250def9caa34216150895359a9ab0bc64e4886a2951ea9b309f14f4ab091842d1fb1b3465d7de69358b0b7277f870f68c20b31e9f945db09ee83b74c7877804f056f202b9d042b22208e18f1cc6a5f702f1dfe377d1c379183d6bf44509217f9e56deff00f428d9a73d6a79304fd57018f93a02f242f3bae53943b609d51b8d8d24438387c4cd2fcb8aa8249d1a1235d0d84ab4236bae53c135ad528a533c9123c3d1db77f9631242dc32acdc7c23cd1aa163dcab012dc65c8dc4d216d24308a3feb65b721ae08e6e5dbf260bf4beec4d8d46aac1493b37f65198db3bc3301ff222d76faf36fb0b035c5b782be95e8ae4f26ed9e273c4068804d6f28cb29a03121013004c38a0076280a02576c81f98b1bccdbeafd05aa3d9efd48b8f63bb992647802447196f03f4d8bebb6c8c186050108bb0ada219c658cab68c84b34098e561bdea7da9ecc9d7e64f1a28a4ded857ac2ca333676cea60de2becbcc1a757e4007cb5b49c7dafb85f43b28b7119d296a8f718ee449a92298b4a7b5dc0d7ffdf867669ae3145b297909a6ebe56fb39f6e4455f315f6d0d930a27071d1947d0725accaa33dcadeae858532d32e697ca419abb1ec59e42791492464ad30904edbd84035c722b34b4b7c5f7efb541eb3635a2b06e7c058512e3583a2e2b2bbfc6661b354ac9ea06db67a40524471ff82c0ad5863bf6882b49fbad07b457848ec0f8fc1ace2c22a95611068fe3108d99e23408f3cfd8df933047bb7cd1c565d570988ed35cb3b6fc154fdb9ca2cee7cf006ab442132e8aeb6627dee4e98deab75bb8d363274e7bbac57433d0cf6eaea70bfd742d98ea50e46930c8e99a320dcc08b35c9bb8dac4dfad75f8db0217c144bfcae2a1d71e002fe1ae0a44d629ef8dc61d54b3930ff5cbf916b6284347b69f90c1a6453be3fde36100fce8a74134f226a3301fa6bec134978dbeb242287dcb9af3390dece28bda5251cb905f52a784d9bbedcbf05d93c95126569af07c7ca444c4a44022c066a45b8c341d7e763ef03bf01b462ba3fb630a6390c54c0ebe79f801b3d977870acb1841dd4ae11d2df56878b924bbe6a5e7a9701cd5ff4e4a3b2f4e48217dcbfff580ddab6d2ea1d4a454646f84cdcbe09ac9ed9a83b9eda61fae83069efdc05c16ba296690d5713ec4efc85e8bd457542f333771969fb20d1f8ff50cd43b235d8974c6030235157f99408d228e3632a60289e0d6ddc6b9c644f41d3d49f6028dc43f4bef5b66f707bdf48e534964405ebc099cc999d477436f8e60b77379c79aa74279872610b62f7cebc67bd7e37bd90999816a719adcac5d34f2b41d3408dbb2cec026c7628cb58aa9803a1e989a65ae22123f45e4db9357e39649a6bbdb05431164c8620185cf021cd6c32b74362263d3722f2cbc6aa5328ccda4dc7a1dad53ad8758e0955d595c1d558beaea367e2cccec1815866162a31b8386e10178f93ec7cec0a9f388c0203b7899db000f9e4fe2a163273673a14aa16a18212cbb7616ab2039bbb7ce228a151d05fe7b1e0aa62c20afd75597604398b43c996e65d8d8635d3466732d8fcb32834a695b0622c3705e20e8ac255274318b71a08c862031fadba8bd07351e34a8983fb2afa1a0c4fa348f8c89861a03164817e705c6da03403f0ba1a43d5af58801191ac9b6bad307e6547ae676769f29620e19727f7607c6201f3319c0018e978be49c11bbefa398bff8f75ad5ac79438026afab69114a099e3c759cba986580bea2504220c9b21b9b82ce376fea32ba0782033b128f3029b6fb6812bb0dc439f842f8ece19e959bf07a1742faa0157c350f43361779470352fbfdc2db57f13f38d9e3b523a762d74d3eba9964a619d79e37e7065e10db137a2279ccfcdfd3003da0b7b66ee915b3cd1850c2b7202e255e9c4c5d4db5d3d4adbb21c15b55a288875baa05f5968f89929da49fcae979a008199e986e12c0924e3cad2d1b7f51e640796ff0232513270bedcd53442190dbdd11118247904eddc7683758d72ab359061f61e0e88ae5f3be7aa4607ccc574f8e434686a30d784b1d7c44b70b2b5fa060a8a71ac1a9b48f22549dfd3593b4b7edaf4be3581d2037a864a705a8171d6b71a611d2262ebdb7bd8cdfc66915c215e385b2ee4be8298eef17060114973b7684217dd027def69786607bcaca381bb72eeec0a6e57e9a9a962e61d0c054d02d5a407401f1dca4a449b68059896c8480f5b5939dee4b2324bc85fc5d2ac0475bfa1d94afa77ce5a9ece1e872a88afd5ed5bf9f28dfb865ea3faadf3697718bd221eaab9d7c358bc3eb106376f2f19b18ab2a68c352bbc564a5aec3d40b73869ebba766b3180fcb614e5147567f23a7aca6997010412a85d7d361aa3d0773f236ffd4bdaa82e0bb9a1f7bfd266cc11719e3cd075625439d0984edb797f42edfef97a1383a75770d577c39956986a9f02267e7da755fb5ae7a557194d20f8a8e90eb724218a9b45636fb2921d08291c7c63102b33d0b554d8562a068b1b8b2de6468742b3cb6d370b4a5335e66ba2c6defa0b8290173d8deaaa3962ae4e6925d50081ab1f793caf4d6bd93b35bb831d1146a32490a9c39d07570f9c44e489fb93ea20a01eee8c60d75963c1273da0c5ca4e7d717809a5338114e99a6ed867b7b5a5e113b970b85f028b7904dd84a7026a02a73116c294b5657cc83797133fa2f6af60e78ac410f7d1f67df2310a2df414a0cb7a9a40c1e48ca90f16bf19e3f3381e8fc2c5368381786452bb946cc9fe824cd4ba082817e122d0fa7061ff3cc36f567710b6267b5391d540d0327a55e38d59c834dc00df435cc18706bd54f8beb069448165c5eee989c145e0b75c259beff67231dd7169c0a076c82c3b9d5fb29edff0d573a7b47ef41683650127008d00d64b71ae314186e76956bc5af6ef4b8d25ea77a2b08f9a07ab558884abeafbbe41d455f57925fe4d35e78f9f75c966bd7474e7c1873a80e2fc57a77220caac4d13bc449e3b7213e22117795bbe024b33444d7e1ed7a4b519a246ecadfaccf9ae2f9621b1db5f7b079731ddfcc5fe93a69082f96ae2d68c3d1fd42b6432ea33e3bdb6206e461e01420d6867de287a7792d3be54f36507559a98aa6af1cd0f4627c32f0d916cc27c193e23fcb560117640e740a9f7de9a531d393e558f32eb09feff5ff7cc17fe24884ff83e4c43571a3c6e739e18801e647b93710ccc14522f6cc64bc580278e5a4f3a290a0f16a34c7ec0681ce8574cf0ac000f5008cfd4c4003d368c96cb85384469cd0e9b4b4348d74903e6e7e0ff9724c6bcc40d4b74cd9ddc8a306dedc033cfc2be438f6940b86e335092bea7e5e9fe96650d9547963bd9b501ba74e91e6e948340ff8bb3808a42fe28b653f31e65d43ff99bbdb446b5c2d41a9ba17f7162261fd5ebc1698e69fe713103eb3457098bdbd29ccda1b132580c13c7ff30b427f7b91c3ce8f2385365666b6018e2eac0f4c07ce4ca3105c2c7743b39d72b2c3cde3179607ffe86c2dcab594e4540641ef094f3df6c320911ade73d7761198df9dae5a3c0d560265c8df87d4d5c405f27f206759b1afbc5b21a53a2c7cf872e5ee653db99fa347f407241fffafe16584a4fc9132878058ab0fa97cdacd46ea94d4161c3e14676a9ef4df87d3e263a7eab09c2c90278204dc3d9e7502ea5b4df549fe968b5cbb3b4732364cb5eafa318732a05361232bdb98ee8097805e9d4cbe2fa2c292c946b759a22b2c0e2d7d68f6e722334cdd576e9daac535d7ce1ee0cb512b68bc1edc3b5142d1de2ee6d3ac4b4f23517223169f0636ca0ce63a203ea3203a243c35855bef3f6477f2d301b077d2d20093afc7155258ad562a9defa9d43bdf249451d54450f3d3cfb038902800ee4e23b4e831488903b02ae208fc7698431ba73b351fb90f7c164f4960a54b7edc1bd4c7e366503233791d18ea7d572da062381d950ba227e19a4acac294579c0ae52c2930f00717fb56c11b4d2a81068b5c28ce12b2a4e5e9d424131cbebc22d430840e2aa0947ea8e1a3b5548317e8529fc43c00ba1f8ed24cf4f7aa001d9d6a15f32a6a4e1e8e035016b8c624630ffae085475cacd314f7b7daa0fa1427b0389c0f4e73752e5aa11cd9bd286fbe3aa88776df800be7eb7662d4d24807714f6afcb9edfaa56c4a84bd1875665672714b9fa87a0837486093926e724cc4306713f0024901d4e6c608fec292594cd80b1b129ec5dafc79ff0d8d4788c68140421912d472b574bcc469f160015bf91ef8a2fcf0f364d09e231e146e36a5b223668402197be3b93615db77bd91d4271539fee11a5b22982d495a4c2d7321baa4da2b77f4293cbd7be67791db71be92aa8f4b01397bdb20d4fed9c8e692f4b277cf81676a6869c2e53a50ff57c49178053f4c57e0c90bd76dab4ac856de6c43f445831c0f0fb40387ed2cd6bb28e5b1c6644f75f0c784ee400e13a0f2b32d25f317fc910a32a7593b62729d3ab5bed7aea13a7c56f10c00a9c46bfd163f7f2bc037d8bf4fa6cad98b7420abce16137f315e3831bbcf195fbb3df6192022ca8cb78a92e921ced28d88929093882884e8713c9f52e678bda4518de54587f40944aa5a3f91c0c717b9faeea89f9e5d73b85e4836127bbdd2e5f8c02f9a162b202fd68b1228519eb8a8247b6bfe5269c33b4b2c7d1b327a22046f3b5da68d9cdf8f9cce6820d5033129d61731972756ce6037af66a3bd18a94f2819b8f4cf152bc34309a0f78d47b6b40f4590bf8f08e9f0ba908764ec120ef82b67ba8459a7a9fe0ecc683f78f6d57a6d3a1f92e47cf8e3a960599d193dd11a7d6289e30d1f823206ef415bf110f24cd96a89ddb86fcf08ef6e692d1f83cd1fd7085bee05605654c60700cb9d678a0e2613cc2ad738a7a0d75d1793e09e8f65ec66999024b3c2d4db458cfa62404c5fc6c178cc8891b09a3a3bfca540184e8c8818961454612bb5a964bf407238f255f1353a7409ef3273b58a715ef34571213a00b9771c603c4419e0a2a48dd7175bacbd2b0c53513cc264bb0303066ebec35cac12486315060a1b8810e63c4a3b55bb5a54ae4b31267d4a0bc4325dd91e3a3f817cd9b0ae2cc65154cff6b40396d8ad38bf503344fe0c13a7eaae86ab6356482460bff3731b94bdb263d3f65aaedc81f19e37ed8bafab0ddc5cbeb5b500f3938270bdd2c313d14ea2e77f373377f293acead317283af3aff87dce86190fe8f654aef43fedd43bf6dbb4c2f7346f974af07124c67e048e04aec784ce5a66a937b554b752ad2143d5cd1abe57cb635c6696927e76eb5231e36def4ec68bbabd7b9ae3dc3bf701badf57bf3f3e399f8158df630468e25b242f44ebcfa260c455928c98b4cf1f98bcfd6efb9a72dde4680d76e042c217ef8d546e5e799a04b83fff5efd478fa2ce26cb432c41a0f92443a3b38557e07bdd032753b85e3bd2acba24ff79970c052f3302b8fb05069521588035f01bd3e1ac2e49f1a9950675a4fa7d7689cb1d5cf1c93660039b6466e037a00544cb74be878e209a6ce0ab90028fa0fb82b2d027338cbfc86d2bf29a282e1253e2554d39c9453294e1970ae1d2f625144324ce2ea255ddfff524c75210368353bf146c44af2a399e9d754aadae8d357667936a0454361751a61a83c08a67dddc05bcbb12d2e2e2f19a0bced9549086f459daf2160f1973b875a33389329939d81a9e472c107fa1b8e5bb56e85ff4e83f78a551fbec94ed1fbead0a737a6dddd9f7614f87132cb7293a644e230267950b33be78f483b5d53e84c571575a6e4a07eabf7358d5c6826858b2188086828f662f9f90616de17b2467e3830592797ef9b33e1c91e41d3e09e989bfdae4f02f9d479bdc8db3711d17fd440d7453512faf0d53b2f786b84f4fd5d2e9f1e24342c4bd7b41cfb6687bfa6246f89f078dd30b47fce75a254adea9f0844dd222da89bcd57c95ed43d132e36e733160cda32525a37f282807507334cb70e0033847c49d73c2af818f9ff3e47dd51a4833c3aef6a0993e7ecff4238aa3ef0d877fcd8d168d64aea848fffab94b065b86acb4af46126190dae00bf280442e63d327f50039c353b6ea9405f212116b9bb1c35b39945f22d190c175c1a970385f50356c018aca2fbf995c488068e24c9b280080df839e535c607f3c54be46fc48673593288a4ac3d313e9dbd057f8f0b9d27017825692adc0ff0f6c67d2c447724c173819c31d0bc66923001b2c37f7e0a1a841de51e10c3fce9aab30a82173ac32025b8b644712111fd7398b27fee4048a2038ddb5438c7d766a72f6b365beac49c3ec0aefe0621e1c7c0c0e7673760eb2a7653f1adf0a09f803a27c0ebaef2b54be43de2d1dad6684841bc414d998fe9e5ab46785a23f33dfbba35fb81a0cf50731041b82c62b8bea868c60635cdf70c75700970f260cec3727b0d82bc40df7911240b1fc2348408103277e23704cad9985c3a08d51455d82799ad322801ccc91590220c03843a5ee354455b9a6bea533192781a0509d97ca850fca7af7dce2b26694360808ce364b2f8e9bab545e62a931f1050d755ac4c3ee9b89fabb1b5afaf43f406a55f4746f6ca1d03aed5b7937de2709a0dbba5f56d388025a9f681bb6986f8e644fe19dfc01c95d53221c6a9aad05d19298bfcedde5385f3979719a29cdf39b4a8d40e71ae120b3d9f9d574101e35c6353f25fb2a7bad6cf915aed5821c7610808bb88f50259abe1fbdf8f126feca9abc82da91a06db2aae3b82bbc522d5f3271006fde2cd671783e1d09be14dfa8d02163d6a2cba5cc9365132e7da54be26876a262c870106485c2dce3bed807d5afc2d05802afc31d1828c9d112d2703d5fb7b6c9e7bc644b4dfb3dca5088fdf07228286161d746d8d754ec404d5fdc364b3c3addab7812681dae43b7f178567c1555511df3767eb9572aa36c0a4e2794943e07f57b228af82aeb64950860fbc056f6301e4be9b23372f9607fc77d1080d2bed65a30240ba15f79722289db795eec08722534172b845313c02c39d807605864d592e51a6be3827e458c89d25f1002f9e191da312a4dd2f3e80fa4776fb77f4c217777a7ba14be60e8a315f2001bb30bea55f0fd3fe9485d069152a87b8479ebe25421821a7675929b3253a5407835201d4704bcaf1879563541cea07b12bc39429d766bcad07a727b5c37390edb8dda46d4961d833eab7ebadc28cda0de94eda459d60aae1a792be14d8fa819a0b72dfb707304ccee2e95437334d835dc33ed2a1fbbc9a8fcfba7f327b44e89516244f8ac47381ccf0d636705fd522c410bdf20df8d0421596093f37003494c7fdfb0235a5172b61eff5c494a3e1159e8583f9e1eef2967af95c658e9e6b9e58a1e75625aeca5a6266a2ad61560deb38fbb89fe6c23342b7b6449190c54cc6ae3b793e3a517687625ff0772adab5649b48ecafcb3b55bd8099884ec82b1bd3ddd8c4abadfbd71f5fe34e2147ac7f827e03944a9c9d5e17f90777919dc7e46cc34091aae8175cc2612c300c622bbe1c7da39de7c0a79cf9379981f52c787b4420117e4867c350c0a01bf2ef8aea25e19a50fa671d9faa7cf516f9cc4a87fa70526f2e008dd77aef5b7af86dcd2d0c542a0ed50a1ebccc3fefd0c3116089932372bd93753f6bff5bd469c1c4f0d27d2f6f41f526500453c60016a80fd1c206b0ca85458db85b9360b0b01d240dc6e436a0cf89ebabac8f04d32d0e27031384da737ff7a3ba9af73f778ea9cff5ef523fdbd812f1cf6808ae1626dd270375aea3b9ffb1909d6aab8c4f2af3a53a43adb9cc9b472998cecd750e28e7b9d41ee6fde2c4f5120671a08bd509b127c61158120d67561194b821eca3674080bfbc3b22b6d0012f3dbd902abeb12e79cc7a23d880bca8433cfc15d118514e2f7f4a5d5b56f2b27763998b937f3846e4e38addd4991531a935f27bc8e45bb1b331f1eb5d0cfbc065b55e093018a54d7acc533932b34438fa3ca83f1068b4f1b6957fc1960d5b4555f1aa56dc2f57147e0f26609e924336cff24d8e9b5190504897ee68d136f3290cff611a83d85b54f683ac897388bb3516abb8e6470a5abbb82829dca3964e5c3c908eaf888e14ea30d71db3e5bb1e3758d357982b45bc1ca03a1a7a04587cd06d3cbb237894e9646e75d3a7543a53ef5b11d20822ed7b2f143d70c516d914c4d35f045d4ec54e6d03a4d20fa6e7e334e55872cc1d75795859c0d33d3827f7091fefbd4ad4bb8cc9088140517792bd5b51043a04252113eefb65e49865f55f4b21eaa39aecf69309f25069c444cd207a6f735a1fbde073f376f1353e25c3cb6a3909bec762cfe8874dcf3684e1827cbbab1bee0847a6fd940a9068d655ae2eb95d19eb1547b6bf10797393479b275825de20220b11e021c24a0f3a90c352746692fde5afe97ff40355cb4dbcc55a8fdce81ce0f647bf6ac8b28c35cb5d7cdbb68a3d51126bf4472b5b190e002c99f47dd7829f3c14be77f6db661c9c3bdc1b910e6e0d2114fc24bfc468487bd02214de2cd97b612b57fe854e01692b8c5117279c5fd30734db91d460b26980466a5cf1fbacf677dbe1e16bd9bdadbadd119681c5a50efcb0301e6308687abcdb7bc74cbab070f9c4a4a3966c50b891f1d2d44ca0e7ee393f224f6c1754f6258932fdd4846321766694ad93341bd40c9b31786050d3176134d0e49d2e92a6c9e04f9784f5d9d67f1c88df2c35b14aa42268d11a60db305cbdaac38959ee8185278baa2a29f5c22d29d2cf4b924462b344661b32e8fd617bacc277ecd0f70e80c9a0ee95778ea62e390a9481af8374a6d2b1109fe9d20db2e78a24502b06fd70dfc24c855a0069e632bbdf6a7976386d7e189e27e6cd76d3ddf3b353a1bcfb0676a23737035be105301f1f13a0c110b9d7ad8e4924da8390b3936d470582516b7aa436f449697b9995bf91ae27383643eb456b9d7b1141e576e4f4079fe628424f461cddaed132edaa702ad1e7e7d77e2bcc6ecb12c279fe64067289f86b805afe71ce1321cb715c05a3acb4f0b42b4bc34a4b6ff5005f6443d5db3c14a189688af887df9f11816fd543386dec087b0633368d8321ba3780041b04b3971e165139392a6e1d992ed68977cd48d64d8322444276abf14bd0020c5d734112cd70133f91eb610f87288a31ed82833c167446afe2ad239676369c3d452d8904028227f1eb392609dfc6732f29c81f8da83ab1157796eb51aa17d666f0e5be553923ae90216a78b1c9a1ffa80397015ff9581e8f93e4331a00dbbedcb25aa33f6d24f92a927968f0c4ea6035fefb05edb1fe2835554334694b3e85532ff769b67b8e17c6cd42d1eee928aeb8c6c32df784afa59b0ddf1d508e2849bc5ce4555acd62d723e67bcc688bfd62cbeda6febe1bc80e3fe4ada81e04adc26e0b744ad0d3c0fc8f6b37e0c2bae2278c310431cf9e5517fbb21629dfa836d97e886cebe761d8710ea73e6760b06308c2eb3cf246a088e0db367a8999c6472fe8677c0f035e3fd02b1171392e9eaf8c61cfe88ef0a6392599f4e3d78c0dac7880d698a76943e731320a351805fcd9a804ea71043033806160987dc615d167a2807dc0b11bf542f8e39cc0b3a21b4c36013e6e46f806575377fd5f9589052d35b2618eb0c30adfdebe5f4b26c9b5d7aed0513bfe8e136d82d564171ae33f6eb18709454fc6ecdb644beb7f625c1f7ab319fb1fd00edca0a30f0f0cdf538c027ccec7856ef8c541b88d6013e9bb47b3b034806ae33797162639ac73dfb173ef71615d4809362353933f5fcf976c19cf0613e7ae759abfa42b6d4aa257b5da9a23ac96a2050efbc4ed7ee706a4de2ff2f62d1024be5b9776a5d4fc02fd9dcdde63306f187ed7247f76b5c497d0e4e2c6f336182282bafdfeeec4aadbd341ea848c260e7249606fd0c73535da04b18f3c789712a5aefea5c3c33ce2af95e79e09bf8749d3eba3cb0bd91b42e047421c30738c1e009380d39b2690973791b288f5bf9bce8e82afe0644c617b6d2a563e1018d0a320112edbd689febadd88ccbebd2bd84e468a0b727f97855a48af2c84d02ab9f9f587c4faf3747143629b42c9aa025bbb8b299df00de33b586710ec8a268973e2631a72463d410f160a130450c51b487022db2697c2bd333e12d60eedf3ea54f8801afd2b5f77f140bc96885246cf05c75d37ae4f33fae716a9552ec25e0bcc523ca772b50dc446647e1163e9674223cdaa4c6aa87e337fc6cc91b5c9116e3b8784dd4d5571c4501c6e90587f4d144f1d97a6df81b6ee9fb326df3388c07586fcc1122a696016217381b4e1677a0faa4df88543a065f2fbedfc084b19cdec0d20500b5dc4e509e2d53db91a9d159e0e2af9c6c56340fab6eec6a6819ba47ebcc6f357dabb2da205cc2308b87efc11b26736d13e7149117350539d41cdf9f632c502c3f21d954ba25a58970a2d721f1763f0b1c2574b7429cb709abe3e3d4e13dc43325ed341de899ced33e952f1e6720831592f033b8b88749b5a6d3879e3cbb3b0227acde971f252829b8a3907d6f94c5265fc4a59715aec32d82974b364814d7ba2e43c59a75eec6e51d4627e6c9d1e633e3825e11bc887bb3e6c3633ad4e1667b76ef47b7d6935a88e31616862ab9a490ede5ae2fac4d898cf7b937c554d5703fb65eec142716f158c53b2f68628b33aeaac4c29fcdf5bbd4d3a07a903eba15a5c3cf1de114b2c151f4020a124be116e1ae7b93e9f05f6bd6c2fb15d3d23f8817bd813c59fdf963dcb446d40a9e2559751c32b8a8d7acbd7f06ba9b16276758b21c1ff88bb366a21388c300b2cbb88f93ef8503f5cafa6f513e6b760894132e5c07e99aa25636d4da586717ed3b920eca47059c52090e27aff27901f300f966bf25247f1e204caf8ef74c467fe7831317ad5808a5efee8e11526119b68310c73100cf67b32ae824cafa7a041cb49cb49645bdead9e059f399df58204442ca4016a9d17dac80ba9e31e3816fd4e408a7d92338085d7ebd489d319634a71d9d4050a4695a1ba5c6185dbc7cec0892f69ab4521522084842d00213a58a3ca3edad9220d38d3b6b9b79609721630194a03c62e59c6e2ae5375733c387b828e486cb4ad79ac291317e96a9bdc956c6dfba51582c12b1bd25bb757f64e01b5d52241db17276477cc69c984a70723fac758ac076897f95290f3798f3afa4ab65bde8c480c2839f55329f02200b0f0515a9302bd09cb190187ac26753a5783b3b1844c641b7edc0c44a4f15b73fafff80ae12dbb9ed0118ca28710d3743fad3c6586bc71c82cba1c7c2d7588ac5933915e22c4935c4fb347201870023be4f6dfeaa73f758a9d59523ab16f71b88700fbad1b2a6e3aea881295c339c6e760b0cedbd6b228f6cee90bdff504cc95510911baa905144bd6af3b621dbad29042908389186724cbf2e4fb0495df90192c8372b3ca04df068675e018bddf6989751927595a11d74ec636732c17084c28161f7f910417329475f144349473a192f998ba88b3a6aca1db13b0e1a88ec41087c92367a21c7c2e4bc7bb1eeaf1ca9e7fd648efd003a6e691aad98b8e4f2f274a27921a35b53d461536e47b2b06f9c2a7e5375c604911bace1313e71520fec4e7487d54dfccb9cfdab9d915ad4a6bed1321869ade868b19974dd0563dcddcb7da0100ba7aaf05b45eb013720f17b98143247f5b2d656e2f88039782e82fa09a23de684e0fa4fec02705badd738a02aa5cb42853c71268b1b043d28ba8a3c9543e9d10590fa3f150dd2e3d15377bf43436bde007a56030e32788cab8211398077362aba36377d7d8db3b530aa405df24228def54907e9d4bd637e52e5a51e9d5f3a48be721319fe4061dbf9f8b2faeafeaa7949cbf2c42c5c8ec20856262c2f0a94680113d759e0bdcd92bf6eab3a1fa3b0ff35f85386a7732184496097f6f94ad62f9d0e9462d4c5aebb3032140ada674c7293d504a546d6cf6d610fea8a68c91267802c346d8612136f2d5ba5168ed651da255878b931d661766be93fe73ed8100bdd0219e758d2abe9d1090ba87c6f15700d96ca8626bcfa3e1e3bcf88c2dda305d8f02f433a7575d3f314206bae518a0d147a6bf77571075cf521109186e2ee1fb7f147bbbbaea7dc15f3b715432918754127995a8e9cf9e640a6d832b3ece48f91beaac68f463c75beb55fb5d9d89a10502c7fd49c2b23f6a6cc51a63fe2360c8aaf7f005d6ff0703b559ad3aae35959db1e345513b054c3167c30a41eb3ed48210290d978e2e0f9ff4fb01a98c25a09989cff3d88ac9dae8435ecc418c908a0b8b0ed76324ed9d5886080d35069bc868ea424acd3cb498fdb95ecf319b6b62fafb24560c9e29e6e7462c327cafc61d662f5c9668c5e8091b62e2a249374d58c7365f708df1f6e8e54db00f06010c4fd772f6a416ed6e402cde2cfb749d8eec931e184982cb173b9f1f797f901193af199eb76a87d2fee875ec26a7211968c0df7b7ff9f2df8d109aafe23d6d34cea62d39fa347ccf9ec7868248b02bc704eae184f1fe3683a158588482a1bfc9097eeff6bacba2103eab4e552a55c72263ddc80d8d4f3dcc4e0895201e33127b5ffc07c9526d7b82b31daaaf83845d21f3e6bfe5030b7f4b5df779aa8e490190af3f4d7c2c57988bbf6ee5965a645c21dcca89b77e621222347dbfd952dc88d463f6d6abee90b1fb45d100bf359e096022e9bfb5dd9d0abfa849398b9f4a2cb967a4c07ffa7149652c977cb88c5dcafdaea954a879cc7b22b8894477b80bffe27008642a6ac188124e7b5aaa3d65f808089d16dc91a65fb53fead32d1ad5bbd0cf93d40705fd85685c2a210df72f45f2d41543c88ee9ac4d9870b78ff835cb6b9bc92560165785de0fbb1eb2fa3d6bf6ba3b744e2e3570997b0ae5c86f65e92bf0a7370ad06716caec705dc21bede48d3e54d52cabebd0c997ac6ffd03ef7e3d97ed9a57f581f58343da95be0983f2f1ff00f86330b0933bd5c8bc8644fd6ec781c89a65098c67f0f661ee4f52b39298b6655f53e9b40c92826c70eb6786edd6314cb705638dba16c01b8a9d87c076f75a8d02a829abc25f375c58d02d2cdb90f1f0dd9634db54aa69a46c5ce45a91ecaa204c0f92e9540ca26f186c963426ee50ca904f240455972ca806bc9cf3fe8e2669cc19e3fc0111305ce57b7979c89796010f28e7fe5388846ed3e2310c3c888ad13c8233bd41c6899cdd9b8f40772b32fc34d0b3b889b71bcf150dcb84eb7b0fa22d6ef0dc9f692a2bb78958cc30680a299e3f81840580f6ad7819314919190d9527357baab8020e4ccdf3c8e409251e8f6f35d6a540732ee0a015146896cdeafc4750652f9200ef511d0ce7ab9817f9882a95ec6e798155aad9d764738b3fefb30f948ceb67cc90fd7a9085fef8fca47d85ac2b64250d31e9c11cd5a75a61d52b97b7861953fb7e97450428f69ff745913825ddd8be9257257b2ae03bffa506d4c7464e51082c621691ae490843162eed20e73a0110e645bac57cf2418f61930616311d05580ac16039440cb5057aea5ad11dea2e09fb0e25baf3c64ebabcf1605afc5d4494b706414c034087dadac1617106a267de4fdf127b932221422742d8ec92e1b9ff8591692b2a62bb2cd09963954964fb8fc34c1308b3d826dc16ab5e42bfb25ca92dca6287cf14bef996b32fa82b89a61393dffc9766907150867f50a370b6053fc0d65c6f105f51b167b19467c7c7833b89c20060eb4b25ea9782b76ca9978fc92db1624b84af15ae70c8c42dfe2756f0290ab25cb01a82a1ef0b7e9b54dfedac8433fc278df274f3f77ae1155150d4389fb510f019fac4e7d0e668da9e2d76078a607778fbded5f449fd7ad204a22c2b9dbb122d76b6fcf58a4fd87fa1f13b7737989266bd0ce147691cf7c5b45a2718f2aa67576afe49a8374d506e8c2fd119aa6bb2a075d7e6fed8b67f18a2601cb1a2662b6c03234f81426877da9ba5e51bbbb1b23f2f4c1f283a199df2ccb225a0f356a5d7064eb336309538ca02cced73d09eecfd82c82bb17f2290e360b4c7d8216b87ab2d03358b5bd1a26d96136ab276f5a3c8e4eef642295762856b779f9244474cfb3de81c243bc7eea463b9042c553faa369f9b12877a49b7145f9753ff33074bc33201820f890cfd0f545389ce1d2d1ca73deedcc937a595673aa0042ac797b7c3a924c24a1cc8ee8d8dee3aaddec20d88e4a203baf58b61e1680baf289f6e20f244a65b62c4d5ee963f519921351c702a0fc4b60b2af72fa0eb4505fd19926ef71b217feb35799c67e7da3765522e627a6c50201107febbbafb2df7165f7b62aaf3245adb41e2bdca8e99becc27634982733d56bdfd7551d7f6d6dd392566b225e1bae28533f05303881cdb8792b851996c1fb663d5b4004ab2a40f9fc400e9bea89c591b2535dc6e10e59aff8c93c59a9ca2d5fbd6453b7664d57a71e9f1b81383499678d4fc4682a9eb4040db04ff5f266f8bd35b8cc5fda4ac20969f5f5acb412aee8ff0aeb5cad1a150772fafc6f6b0a7129d3e63f7579052f862800fe2d40bd06d69da0d1e0483c6f51415c06a9e4bed509ee48d8c214bfbfefd25cc39bc0f87f7c05ead53b64112d7e59377c5ec1f68b55d92b3abff837839e7b8a8ce91a2996931e609c31438768268d11c6ecd1bdd28950a8d210b235f20d941a56954484e3a91e5ab4f2bb90be69223d88c961a6283d42f4ef0d12307f514d709b80f2f3efbee24fe328875eae1faca14950fbf9f6694f67bc57e4b011819a63f4c4d4d4160436aaefb232e96ae69eed5def2b7495da2273ff8597c55f3ab2b96ca972cedade9230b155b20cae9c7a60939da920df0e59c602043b3c61302baea2ff227694867b748636b5d56ae694b92be6e7eea451cae233b37ab302a0a8ea2652898a1f7f1268721e7201a46b74fd3a74293285326ca1c9fa77608e9be20ad62d236800d188be4f853d151af9979ebb343d8ac77c10d9df8c8d61e61f7249f925aab65bff3b8a3d8720e72f09282fcf360dfd3061143a227f6dbb9316a046708051be76ecb2d0e96725759057b1f7bb02be5a8ea586a89a64d4cbfe36ccb257674633a8533e3e2563d312eabd339f13acb6c365ab5382540463819cb01e9fbcd59d84fa0adf3dde82f9136f2571f2bf9d7e0217ef160bf5a61ec9cdf9a05d739ab5a6ec31fc11028fed68b4a25c6c11562a8e3fe2a70be81eebb8cb8f0e2496dc3c6540ca4e0a9a45e02c84c862c887c6e6720af6a2dc34a5cf0e048044f6290abacdb667d81ee39b5e5fa61d2a326f4b7bdf3a2b5ead67db40c7a82e19a8bf4e988521a1f6c386c389db7a6479cacede3e42a311190d3ade59edcd8997a9490d5a7b2514d1c76742979d99b0c94446cd10d300fc21bacb7e1e4e2e538a608aaad9b246722b74776cd2d21085e397cfc0a0e94036d5d6b5167b97ce705ad833f5018b7d5b77ec15936f9f578caf4c4176da016efbdc05b696fced0b70ce0a2289cc88d54568c30bab0e2bd19a1539e092601c7dc660e2d2cfb08c6d5ae00f455c7ebcd5bcf496eab36d431ff549f7450f8395c89cde0742709e6b18aa5bda4dbdfee83aa85e93ec4daa78c505998da13b76a5d513e6b076437f7d4264ebc58a1bfe19d24ab356bbb91529b361f4e7c9b33f0480c104c875d3ed3c6a41ecde0e61365c0642db611b74bb2feb979bd03ee6390db5422d420eefe272937b9a356c8b02fb1e2873bfb480779a9e59e01570c01264d04ee2811b28bda853f0a04331386f826d7e5a49539ca078697577bd9a5a92fb0f52471f99324ee60a4555f1bf9fb9d9de30f620f384d881022b4c54a697d8a5686c3091d153e6992fc029829682a79ad81a06448924c2d11df49a9d77b64012532633ea2ee35c2e85b580904b05947512f6ad765322e86e6a41bdabcae1514a1984ac44a58c12f734b9a6f3248330643bcdf06cc8d469b1fc55b8d922557363e754f221f1c60cfaf97fee1ae5295e20b15a21e47f385cad0ee25ff4424fbd842daea575abf366d7b4e3393d149602ca7955fe1ca1c087e7960cca5501d0b58f0f260d7daef02a91f13ce6296ad1f397ce0b84683dde7752135bd08509711e654fc00d02106301d84113870b7c34e865031a313551f5737c945baf46e12467828f772c89d35b9bc2794b301bd7aa764ace90a7f9efadcac69d0691f0eda760069d6f0b12f05a7ce1b1b924ad1845d511427e33699ff33680ded6b585a83208fb61a3f7ce88daaec3a9bfa7ad50b10727c7ee04d0a9e0290bab8913ce1a0b648aec996cf3ab0488463cc57e9b1b4a195cb81ca5721ee20267b3a8a8faf919e94b22aab03ba506272a9995a346089601eabbd627d1d37ae3ea2881b876c5595e4f17623153360d6f334507dd638e68817a0f237cc8cd892e5d4730fe9376e1db6e56bb62b66f30634b629a82c8b72870b79bebfba919b4f5258d6529b4d7136d206a133c6533137133f36796e8dea01aaeef364a22e1809070bcc46ba921d611e2106c77310717bedd798e5d74a53d8a22c611def8d50c4a28f599152d5ddcf2e62737b0bfd2f635a9688af8e73098004283e8e8fdb9b752b74eb4efd1a3e8f6c6f33200575bd28b0b4a0391d2ea668bcc5fabac099bbd1ea8de568ccb7a6ce6d637ec33939e66437abfac1cdbf967c9d7cee920ce9997ffa22a2ac7e8e40299518e9241feb42862110a92acb02b832fdbef9fd4fbaf74be89ca932d52bfeed542851cccddef7d1a6daad3414bb36ec75e77617737cdc5f5e768213f3b519a597f6fefe32e81e4b582ea54c9327d97f78419cbeb746a5c312125e66a40daeadcbac45d6f53eb24aceaa35b6c7dfd64dc03c11ccd9bac405e4a3b071d18bde80d743223681ae96ed02c2aebad8cb3c398ccee88d47e4cc0048e951404f8aa58d17028a7b3b54437f812a076cb3a1499bde0ea5a50df4c03e45bc47f77bfcbf37764d47df6fe3f33fc28c7bed507b50350b05120c56866fd07375cc140b3b4e38266aa83dfd0a53a7f5dd221694613675ff1237ca02a347b001bc21c6da750002a2ee522b672cc81ce0d95f0c216fc7bfb87355d00b63d7b1e01be4d1421f5c259fb6afaeb1b55ad7d25043541c663ebfc1c5b530df4efd06e6a722e3a59918215b1768a33ece89b088a467efa6e7c4892b66125f5ee481cdb2fb7c439d2e40e2a310143b33fb5e7a1e46b44d2bb5f11fbcee03fdb1635005e186332793f34df49bdbbbccddb523c6647269802161a50d9d9fccb71d27d273591092f404aeb20bd5ee2529fdc43e730d5564f244cc05e9990f2e77db25adaef3a6751e54120d824a2762572fa3fb06c4030524aee92b097275eeab91a80d2e7383c1b796e2b22e98b5694e5767b30bd31177c26cd5e8d8a0cc1a4ac928924cca032841c63ad11d8689339aef0d17f6a9d22896a652112d023201cc2928468e50a222b50917ccf30f0b93e6b99e7b65184ee5ce5b09545553d9bcff5ed7c83b56e246e58267130ea2cd13694474869c551f723a1636b4c5aa5f45decc9959acfca4b747879b957f7d87f5af54e2a04f2d6405d96cd321c6113d9b65aee1e5214d83e5c17dae9bc6377f4b7a385cb93d8ba2aab75a66e2ecd729178679ba88a4b22dad2fc47c2cc39f6ebe7c9dd6ffc117604b0ce2604b584059463e18cd2bcbe85180d46199297227b41a6413ff226cc52f0bf87abb56bf13730c26f5f0a287ec45a701d0a507013b6553a8538f96f344eb5cb9f8a21fe4dfe1bbe18afcdc31eea68b0c2447d3223ef2d827e7a11bf212e6a342d6f686fa5c82193d5a85c5ab6e1a2c6312ccf1d766c26acee3a95a6149ed69a9c0d300964b8b82995ea09db26c98a514c1628efd7710bb33cc742dab69bcaae05ef480d847d6fbb852926b66c55f88c32568e379ee694d1fa0f65cb22871a9b14486176f2035f60f0b19d09772d3caa932d29f16b624e97aba11ff473a0b6c2ce2ad636745654a0428518034e6c290d2c8b5509c36ea24b442cdc8bf2084482e5e5ac82ebeea16df1aaa6aa96016c6cbacf367438a2a6905b1cee2e35235a7671e3c4e8dbf33d74e7f146ce4e983ca89a0cfcc9e9419781fa79fce4f3cdf1fb819028b90c025c26458a0e5a331562edeaa0bb5890c0c7cf3a0bcb855edaa2a9ab8fa02b4c775dcc9ea0e10eba6f674ec8bb6203714f2aeb23d2408da38139c5029844d265133eeb7aa4578ff2f275a6bde79391984458fb53c03e24f5aee71feb6bbe6cb23cf45ec6cd93fcf5179e4acf9255111bd4bd91bab87cd443f709bf9aaea135fe61154568b234a95c0673c25099754dc8131df3c083506f36f60862c72af6ee014757a41dd260e16924a6929f8dd37e6dde0f713702b79d21076f5c39c05353d6dc78bc530d60100672e9476d0e8f0044bac70fae4fd5fdb858d127f64803f9a1e08594ef708b805990eec161764c3e0c0159e5dc67092cf082d807c8a64f5c71ea35f5e607ffada6e00a6d160ff5c9dce8e3006b6e957b61976f2c34ff2c9c786180af017cb50a8c8276e3bc41ce0527f8be7674d43714ff6cb8490701617f53915e2fc43c8ef72d443499d1f90df227c6c471afdf5c9e51cece7e4773cea4abe2d137f97b33027710dfbc6469989e6d2d33e4e75e24eca8476eb954cc20edaf3a8f3e1783e1a2a5059717da9d42480f2a376e63ab66234b03645d0b69c55051dd440d62e2f91c5b22334eede34edf6bc8692241c05cabd49b9517326082f182d17b100dcaac5e24cefe434d6977901d36dd2a566455efcc41708e4b8efa4901b8c447bc7ec3af3f470c92299ecb85b5b6fe8603847a45fdafaac48d01c1f410b8257fd0ca52acaca462e8586c78628a88e01aa9f2f66e95d960a41f968c82c72a8b59e053340adf653e841441ff2c460401162eb0687422023a5bc5b99731ffd2eec788033e84dde931a927e5eed3b720ba1305a5f833495ed71b9c29583641fc8e90d15fc4e798f0f0f4db2db3e3f553619797f1d9be350872105c446bd55db7703d16bbdf75415030f3fae75562dadc38d077da18eb90a3fc1423bca6f6f84e15fd58e38a390465cbce3b521f5fcf1a25062c313809590498162bb8d0a48727a328d3b71463dca9d7063d76a291860a49324efa8904b0822467fa08f3cb2c018eecb90db25e0c28d9f37832f6ffd470f85a2a9a3b76734518b3ff1dd3f2e9cac0a9b6782ce8349076d43a997dd57b1b505c9216f02b73ae29352c539e078a59416a719e86007fecd50c68c29f1ce12720dd4787e5b015bd9647dbf1b139319fd61520f5512dabbde09de340bf4a2125863bbdfa864eff58f374156f0ef359082fb9b61853e1cc62ce79b8914be42736d7770fc383ec9aa0749207689b42cc373c8312179fc692084d487282c9c6f5485f88ed7f8b2a496bfa1066326f0c501ac9f0f5da8349096af025c8958315cea4bcc12325535ddfd58a518bd08b7110d5f4110052b4eaf76053febf2e043df487d8ff547430aa911c138b2dc6617eb2b6658f72b6268d3f1a6d6a88b76db64eb6e849045ca6e0aff4fdbf1e6ddd3ea0abb486df4821e3af6e629b0f6d3ce0115744a31c0ef1617587abb9dbadb02a420ba43b7b223bb9f6b3bf53743af331118f4c0b8f8a91d709a0f0f7974c954cc3aaa6dc12165dfc50bdd7d6b44e824e5533b4d0af126f02e37606056b163411b843dd4e0e9349aab2bbd19a79b8aff91ad9fafe68781b4e41e93ae1d5ef58280c67e64b5df8c5191b6c1ab69ba56963991512351befca1e8efe18ed33b622b8b6e4dd15dd5e944849f458bed07875269d693e8f30a32f7b13063488e760364d61bc3aa032d1474147f68dca21cf54897073e22422e13a358f18ceeb3d63a1b132d900a383e5b69086f0bb8192d03899c11feafc5bbda31f0d2d4e31495d316e5f1713cb653e1b4034792f448788057ff3d92e14a4731479abee03f710d03bd8005efd1ce424a14438ae5e3f777d0c08fc9b440aa8b6b0a6a3648b3b18ad08139e2be1c5fd0b8c01959c3e81b5680be6ea16f4ff9cc42353c6abae06e1f6cf238124229f5c8a1dc8302baf68d89448e76206adcab1d9909bfd4ae17ad92b90369d165af6e3bd87587dc8af88f4f92aeb18be5866d8d6b58723b287bee2b3054d85964d3cc9f381954bca2bc7730b79e79a6820ccb2e905d430562e00d85f1eeebf55ae357d0e2ac7a35775fb85fd9fe4bc6c58aed3ab1af84dd02277b4fcb5158f29a24bc9a8103f1c255e3065deee637c1ebf8a258bb062326c1551428da72ccda2ffb467688197d7e8cb535325784320c00b73e4abd2ca8854b27fec39542ca49e2833bcc112e04f904f260ff924cbc8993a09b3b136b962012e0055075f1695ff3d798c337fcc1860a86c5ae956c9526128123fcfd554f32daa210f0cc0f56eeab4d68f6912a996fee26ed3697dcfbbb7e403abccabb84c9322a314a22b481861de85899a541f024c946ede8e352c96532a8f41562583cb027393184c743144996fa1ae5dbeb4f41c39a0f051e100aec8b114b7c37706ec444e55f269332661fac9cb1fa9f384cc164c37c5bfedf25ac0ec059384c2108acee3a12d243fafdd5706779003f9602bfcb339769e929053697f6dafc1ef18171ce669ab215f7a6a923c3c3ae3603b7d987b5c77fd0d25ed7c8b7f3554794fba76484466c185676ba855e45611046d5f8942e94a652e06e8108f1fed0eceeaea794cf9f1e1cd9fc02a19f246c73be25de7f6ac3e667e8fcdea73dbc6785d7fcf6398100d4226e9e59b05ef2d6f467cc372d54cdbac95f6facfd572debdc9c0d9c50c4b53a972a39846414d3b82cd29ecaab6f52e409a48858c33f7a27eaa0c32873c7c317d305f0d9fa433440befc139ed6835ba2066687cbc1e8869bc1ab1c00d61adc40a51017f5e0f10fd08162eb2870c3b6ad33b0e2c4b5192506853f1df37f43a71155243f20119649e03ba557f7b0a4a7311c044449ac8a3114c3b9d6fe58d849fd6438210b69b3ce448b476b4b80ed985cc722044224eb272ef23663331759b4e809a48d9c50dacb733ebf04e94846beb17c6da10ed58ce5d91037b21df9c15abdb51c362293100ac08d081894a89da94a6fbf6d07bd458299b53590b6e0c3b611e7d862492a28881001ba82f5c85b6b647a32fbdf5d52ebfba315e5f3bc06a1bedd71609acc6e0a93f0a0fa5babebfdedb0be5e1516b367a5526a01de33855fc2a39e2eb36fbcff22b1e218bea35d24f403a7acf12e8295fba5e1fe6bc81060b265334f4ecfc214e5f53b66ff3ab174a816e879753a58d661940528e16fdfbab2b0162cf1caa1f534c7b8add981468764b55cd86a2525baa7083fcffba533be8589c111231053bd23b5658a9bdefcf9ea844b42db257a6ae1be0d5f5a19b363198932bb1a9859ca493a522477215c8789740f3c343f53ad38fc0802f6cbe9da76907a5f2b9821f0750c3d78ff5833e185d2caca56678ed70e830f768025d989323bff4e15b3612f4d2f94c9893eada4c1b33432931ab872814d64996875ce2a6cb880adf30d805b23db3a51d65906cb584d702744ab8f1b383608b0b0f6803f73d8ac3b342f11e7f93a078f6a8f3b433a32c04908be6e566767783e7ebc9acfc5f4b770e6ead67522271e1c77466c0fe9dd778f4d07d64d71a03ea40d437d086639f202ae130118a26ef17ea6f2653192fabdd1ecb82e7cfb350f905415a01d4c58e9c861551f2ef6a0a143bd9efa6297b4416d3338edbb0de572cb85b454d05c7cf8724d4514ea79219774adda49b1084088472c55307157ac40536b103ca1cdd1b12e920ffb09c29ccb0d4b294d12fbdcca4239faf1ce57f65a7366a5cd056e41f87d6a33c5aa3d0985a5345faa323701faaa8da03a4151bdc500a33b8246c96677d9df36afc975ec41ccb534381040969a96d8583b8df567ccaed6ff4a15ea38d1a06715428073c75494c9008f8ff372da38c829cf4dfc437fe8181d2ec57b00a8376055d065dc6ee13bf8b2860a1ea774c1704fbf611dafe52deb1c31bf9a190edbd97b554bdbc00c97691d7d3b9d9be45ce94f7f7fbf2e177931f4de107ed933c7346d68d00f502b5599ba78506a7650aeb0912eee67ba7f90a8a7a6f9a69d701d55b1cfd69774eae070bab4069135e15ef5023d076bc7b60f70f8939264d2d6945517029d936b3c4af60d079049e4bd12f89d9db62c1a5cfaa06ba2e0bf9e63632a6345eef9776e11a8c234bdbcdaa5008b81d354e54a5752713b70134d491a143a14fdba365e2c0206bdc0f85e06a3e233ea81bd7a1fd2bbfd97412e497eeb4a74162a06732b558c076dd5d6461ccd07ef979d12546b67d022a86e55597bc73d304d8fcd2b069e1f58920e452dd889aa4ef4ff28dfd90ebf283dc54460b9bc5b29ee0e1df2ceb3f273fa067492f2357d421c988b3d40221f305e937ed0c35f7464d26b81f8c007cd75a5943998bc9c9443a01f42a892b9eddc5302a3d5d3953630bfd4b92155ed23a867c2371f01141bfe0e865224a6a8528c060fbfad6dd9099afd87837a489a92b42df4bc4c089ae6e283352076ef362e935e652733406b6cd9f8d178ad558ea1867b2224a2128cb9bc0a70d9ac12912662184559e059cd75325f2327107ecf964d42136ef9c51f7093814baa0d91d6dcff36927ea7b61cab51806756020e60f0e3694c7d2e119d232c2007034e5c6dafa38e74c2880734e1a684289da0d5796ac10c01ac2a250b1cda16a4945993d4450fba224937b9d9a726a66e8f3bef44e63b2e2eb1ac7b51fe9aa20c72630ad1de43eec6e78947ed99c3b0b8e29c0e0cdfecff26cb7f32bb85e0ab1d37cb38fc3f90d8c9636c0c00e76d97fc520cb59ec20734695e9e7e6281c2d59fae95015ed780009e777ce920c630ef20b1707e2442beb6a7136c431c52b71b2aa60386807b12b0870f77d392dde0026aa82386ad53c9aa3ed4b21348460e271c65d4d8ccf0f1b4c525d7ed2ef6f29972ff2df9a5a37c0c8876179938d1a3bf73a5503ff4f28d6a3da647f3e059e2a442e0c01df41089d3c6d0f010f1f3cdf578240f2da4f6e63feb61dc29ac5ca9262ab9b54389ccddc242cccf41d689bfd4887810413b5c3e95d8b12d8351164525759f8fe72d76827c50f60b3053c9ac4c757f6f2ee2df3d5da9e5176e32a99e2cdce2d51798f5276f09bf530ea1b6a5890083754a9516414233434b1f5bc2469b5efe7863875e600b3b6d18292dfaabfb9176ca42802c82b7787e35d47315c58b10bf6e0a224b9591b3a2f548104367bfbe3151d3451af78430b95d7a5e2cd912d893e4b1fcc17dadabcdab63915c5ee4dde2e5b2db487ae4cefeea7f53ae84b154cf1836d37de4ac813f579331290f747cea98f8f761ecb69340df778facdf1dfabaf79bac0dcc9739c4785651c53a97781f6b5b3bf1ea313d688d1e2ce69c5da4787ed1c5260fb7840d432264e3a943f1dc3de75c76527ae1175e739ce53b1436e95dac491499de22c9a3d33919500dca96b6521073097ca9fb98327fe1d974b745fc15d1712994be35ceb7ee630297324c77e2ada60fa487fad2d04280868fac6f577330d1ce7c151d050b593a9ffdec369b4d6b671e44d7eb4303d3ce9c18ff0f8e0c019e08c84048aaf342709343f44c5e2ae3b7b1ba418a1466d2b75166f30bb8be1d7989479e93f386050d880b142aed549a15bf6fab40ceeb21e45993a6cc0d9c269cc91af681df253f4a50a41d95046b07aea73cce287de0dbd6240a512dfeb8f2e01a12856af29586718f36f27fd6aa18374ec1367182d91e230a17a321be6d2072888e6764c46eaef455054d127e4f8e91f7d8d66521de10ef021ed08be1a7e137a9533c080731424ce4ce73b656b402b11fcc8e39bb1e0a8bb3cd2c97ca15e6bbd73b65b28532100f33072e99190ca4a723b477b6c2e0e19e681d8efccf329ce64faa048da6ff3d7714d661d74c02fd3daba6f0a6cdb22fb68822572da5cf960b7a87a6c6c10ecc7ef37788be37cb1b7061d3b5e2325ee84dd57887e0b546b38fb4e8c10b126a2bc0a70488c7bfb54edda0620a3b2479205c8463dc7a3e0bfa75938e8371f6bde25ec043586ff188d70c52f836c52376b136b6834c8f6f47598dac146d1ebb4feb6ca4d91985c059211214e0033ad0694d86174a46f88d14c3df0fc9491960194ea763ce39c54ff294e8e4eada41ac4cc462561d111af0f8c648ff96f4615a474273530d804b0872432750e2f0f177ef30dc15522c9fb734ccc953cf0609832158432f6b8da2a2e991b76ac6d440bea15b512c44341604d352dd5a842809efe3a901c9d0102fd865cd9401e22c9461215a1bf54f04e3af3eb106dcb27e66c55165ff804b31158cb05a9bfe84fafc1957310b78cf2e986f025d6d5101c6a5ac035c734d99f873c0fee06c96a85e874be33ec5dbbe6bdff0c7c17ba2c7d7431bc4e24f921b5ffea151a051ba6fc4562798aebe711e8bb2a9dc3068a268068efe9b92fdf0ca1268b7f0417df4db31f89e0574000f675f931ca0eb91b16ea022c47eba6c2394ddb8c3092acd8d9ec47f63f20c99dc4f601f97cf4f421fc75df860fa85a6128e02650f70ad1cea6821aeb272195915431469fd27c4f2905a7de71e919ba400290e4d6917eaf1019663a4bcb10c408d84da24a437b0fd7a8b7c89037398078d5796852a983abef8b4fa2e20e2b22a8e39b871417b048b8bbccc696b2070ae80938f2ed1a11967e26d748fd1a2423ade782e278b266ae21195c77333351e7af03305d0d73cfa24f173a3b70f725a0e4f620788abb9af21bf5c1df317bd605abdef1c94c3b9ccc60e7186b4b56a33b79b464a0f59df10a96dd16a982b376b4e2d5723a633ac9fc9dfd7d1762c04e6939c765552381e435e3304a8a7168bd7dd4595a0c24081c1b1b5d937d7a86276f497c510f09a1f67b92713809ad7329da22adb1c6596c8a63e99752656ef0d49d8ebb4ea1cd4157539d3ab4c68d625e2fce9f7507137ac05d0d5f5677f260b5caf88316dcd64b8d7dc80def942dcbe82ad411f756df849c03c1490569f8dea894fb52fded2cf166098a9a41d7dca4bbc92011810d83e44998ab12ec8f880a850289aec668101a8fb44d899a54aa697cd487f7d5975471f687f54cea5e4530629cced38b83f8ff41f387e3b9b4a01c884f65db091d7b25372cf4f980b6d2d30442b70899e3f07691a23b1f529b9fbb87213c8f1e92977c703e10711ca9dbc09eee27c0bc0abecadb281ca65264e882273ad3d05482ff45150f3fb5261ecafcd62058190a4f2895cb298df662f06fb08e01372c343ac6410b2610b8fdc19a24b87846a43095e0b4f9d4335202c392ab0969f915a9c4ff34f9f7acc982626a96dae2ae419b1e2540495de87df43d07151004962b75afa17f95b80c03763b722b7684fe5d5cbf3981d5ea23a585061580d59d631c72920d1e44c84daf18f0db28a92a19fb601bf0bed52565cdd016f6a146e0060c6c76c3adcb881ca1a4e6c62acdc8ecb32e2f68b6aa2ae9f9b668b97e05247e633d7c1147e78914197aace2d2e0d2fbbc30ba609b3acf557276146888b6978d5a27437c8c781631cdee714983eb1377836d1e718399ad93f02665ba6856285bf5e7d02fe2b47d8489ac8483a201af732397b3e311b2f7093d1ccd29d301c1dca1177ccaf9267cef64d4f207e9ad072a2d7354d980eb2e3a3488aed7bbacc76aa36b6e874bdd34c46a7ae36ee41d32ad6547f574eff8374839cf88b38a27d12cb744543860028c2431b660b2ebeba6d6922fe5b555abcdc7067fb23fd412e62bb8e3e1b8a46f609982cfcdb0a7211ac95cc2c960613eb3cb5ebbf994bd8f5c7abdc1b4eaf644fa4c14a2c27aa9e62e5e5c1fe1fbb67d40d16f4ae1e55b4a80b5d3463bda1a5048a29afc3e116d2886572fa5bc5bbc97c359c85aec2b08837d21d90b5032cf3111682122d38410e35aaf6844280e6207833c77fb1d260f8f44227117909bde1840950409f7df5524c7787978f588337a0485ea8af47f4e69f2f5e00c2fd7be3157c104dd940e13b35aa015608234bf049206526556fa101f35702a45cef32d43c5f645f44ceefca311b43bba486005718348fa51a8c486988b3283768f00450c3aab5e03365993c9c3647cfe5913fad441c5aecafd35226fd3aadef88292069874a0f56ce5c03ea88dd7b9f3c72c94a1fe507d4842392e06e051e040574319ee095c86c43c62a770079c94d00be6c0954d0249f6eec8f185bf7f6297459ac6c5dd2794fc348399760ecc416a795d65598c6f511aa9d21963830bdf012622fd55a84225045c1be73358b84bcbb19b9070919575bb2f3f8cffdc5c675cc0bb4df2f2e5195db25f99e70d86eab3040d6ba664f0d6d513e3cadc5afe689779dcb6b8eb084340f9d1932d1c0521c15d602a53540ae3d6553a3ab6af794085566bdc6ad5fe59177be533eac78a49935b5fd5ec50aef16a5bdbdf77fb215daf974bab2c7e7f59b72d09ed539f02da9e408d3bc19b0884d7d3f9c56060357b220407361fac9004593db9ef06103a3d821c4142f36c938f7e2aac7f09dbbe852c7d0a6ce7d18df0e8cc38c4d70e2462ff3c16b86cf0467f16a372182a9ea39a808eba3e358b4b0ad594855fbc993675993e602702f5086809a06fad2feeafe51ada72f5329e52533c72c9f1eec62d71318e99fe6868d8aa31aa8d4150b02192fb1f3cdf395a16d5e96e089a0e1213fad72b02785448a2dad5fc37b84ac0e8c0e46b6b2994bcd306e5ae2c5a3852dcc6ae8005a3c33611f31ec628dba0f113d1196f91f3d310aa092a14cd45edbdb53ccf226620b2f7153201ccad0d3a4928eefc1838daba4a5cda1875f34a918d2f6a01cc8e6e5992d10e648ce40e3131975bb0e60120133651be9916261c4c13d6d1ba70b9d70e1ef28aea42e39e98ed1289aad8fc941ea09ef21e7adcdd970cd2e45bec5b4c166668ac2161645298948dd07aaeec22c824c37aef36f418e59797d5e16e93c610df54e8bde6d1013770fc4f8b70c11003197c58ad602a9b9a905635b5899fb8ed7fe2763ee8742f8c599011b3ae2c393f3d3ccbff8a7c40c4852b601b02e21361416ac1ceb2993bcc48ebd226ee610f72a99f5cb4b1672b866d54d3d348b81d42379b57feb42d1c745e0a1ab202c4540cf8eef52ce42cf0e9e7c92d7b4e73640553046d262d28e3ec35a28599f41097d47c834a00a225f5cc3b27e8269416fe856bb02dd27db2dcfc9c96feae1120df624a787e7e46a2216ac6c449d6aa2fb82eb25f120799e9c9c6bae23af63e4ad3d42bb903844ff401a2d0b16cee32d0cfc6197d9dba30e378d2e762d9621b7c2fe0f506407d930384d0d119d29ea3f7f3e1b17df1c6e0d69952bf47707b17074dc905f309e2c04e64776665c105dd7f4bcbda726d4534ae7ae2d3c9fd8b3ff1ab3ab7b0ec9885542ca977e56c1b8cb6ca861bd76a4f99e28978f328c0ad8bf579ab6fd1e973fbde64dd756ee9a11639d592b3bc9bee3264c7b6f486e589e8d766769430211f3bfdbc89f7b7b9f115c541b4cd4c8c7c253301eb010e23fa1afbda863c512e91907aecb9a4dac04fc73592bcbbcf28aeb6dd29fd3104ed5048acb848714a7351f51ae308b12dee285a3337b249d450fa47e8e4e7355129f0eccfe5d5b2d809b90a2e26d76d70bf59bbc07f9d64b073674ccdbdfcaf721d2109807dbd12aab163513e36741c48630bdf242b606db1b599e9cc868bddd54c112d70d7d1805e315d3b64739eaa19a5bac6443daf9ff28ecc753dd52bb1b661df462947f8f7c43bd2d321975e87cc05b9171eee07c748d36405fdb7da466d0dc1bfc5ce4d1558ffb6ba1d7f4ad401ea6967461dafb91b775ca582f553646b5a7280554d1dd86021c4640f8b65c37c18d6a5bb243d42021eb95512ee0af1d3869fd4ce2fcf3f615efaeb0942ccdf532695ae7746f352eebe872a65c8a33f2a88dec0749b45f36688c20833ad07040d12cde0ddd202a79e774b97c35ca3d0db4bd76ecc98ba3be2caa4fdce5d39ca2047292b4c72cdc627b002af88e44f51b96683a472aa42697f35da248b8284164c02d66f8f380bd6f2713228a8faa99e433d5fdde12f00895a9a2a75d07ee1f1cf84f89a83829e12893bc70e7ee5a771b41a9e69c2b64e5d1406826ca768fbd06fc7d78159de032ec386dd3a042ab6e63bb2ad65ab93fa8dab33ddf50345255fcbbc7836f0f5cfad27679edfdd56bafb8a55fda6ce49fe561f5cbae53a24fe6bc4f52709dc560b5f294bf426cd21f72ae12bcbb5f78c6b42ef81a1e4f309c56686b4d5b65420f82f6bc818e1d843dada64368892b3f9fe49513cd156547bd09746925b50490616a6b3868ffe571c466185df8ae24a0e002a878c2a0706dfe3a2c66ea7523345259ce07bd0529c4ede1ae5ed1db18b7fb83bdf9f54a3ca5e6b58d7007422fa8fd370ada7a5364703629526175c0ea114f087803d12c79c8269523a470e82877c5bebb53de2551b24ded2dbd2d3dd2d418ef19424e416e82a60f042cccb45291129031840efeac460f411b7dca6c6b9efc6f7ea47ec24376516708019b2c8e3bd7185cb97627c17ca18183f27455cfb48771d20c0af818778aea295225c12d4d729eb9d0a1ceb557962ed6b761df41b821b7ecc1f6312a054dd33cdac1d5a488f11cee4c056fedbbba47f86b99cecec7b158e9d8d9f57d08a738846bdded8094c9003640d8eb7a3c851650492245e0ee63c8a354a11a9aee6508339225d66fc5273a2fdb52b2194818ee79632f3897040079b1a351c58b129333ca69c0f2ff92566cf096f83031695464c8fe45d639bf8632894cd72f5a313ebcda8bb4fe5bc17f3ab898e11b0c5f78419d39a3917a32ef45b082c10ac1a98a0b4c585ab7ada1ea018f543226aea212e1ddffa4483fc3b5fe1c67269598975f39723cea419aaee664a858f95af0580279409abc83ca86ca8bdf5e5b77504bbd498943d0cf5080ccce39e6b69ae451bfeaa5f97e61fbf5b8a62532463eb036c6ea11093428f43755c5905d266ee1b66aee44a2586a2ae6bfb682dbf6d27a02ca89f5280729310192d32e154eab2e6c93932ccaae8c25132ece9a2e5fe82f836db9601a8de863c8bce2c978ecae630e3d382111e502f7ba789806cade3637f72086e6fd2e6fa6da5af7b7d8aa202c5bd48e8fce6b74074032c90a339bc1ee0613edd27c0706bee4317665a86acd971abe607856375ba197c795edf581249a060f3e9f9d13513d52d89f3e09bdbeb78b38f9054684dc00ff3151c44e94aaca27c4d4ff6bf00debe4451d20eaf849eaca4d0deba16bab4ba58d81ad57bfe366253a088fe00990cf1062c041fa37cf8b34299d0abab074ac111e7a166dcea79c173bf34cd34411f4581a9f4cf03cdfbbbe7a8cfd3d38083555a09b509671ced685343e42412f3b3ef845db7c666b2926027ef184489086b8f97db90411c59a62ef71c25d6da6ea786431791ac2dbff7fb051f5eb7b4b97c3da29fcb9105199e67ce686a78ab4f99676b6c9cd7060886a0051e46cb677e5b6782be260804120744fc03912058ae1845a78288b800155f7ac4d5bbaa1377e993ed6f1ff61103a28dfff375d078c999b9df0674573d408ff2fb331dde64732a4ed11bae8d2cb9a1472607b27322d0131c6ce1541bc558a11a0fb43e0831ca910088078b136900e59d77fdd870c58317ceef3bb20b3092eb39c3c69a660926e5b084377d733dc7f06490b98719be261ed11e8fb68b3dba22df77bbcbb1734041f10f685c22dfd6f1fe612675a2383bce0a935b7ba0d2d6cb43fb42b1fa21d178cd6b657b8e4ff1f647c9c760f9155191f3d85e5980c9db869017f83668b2529ac0cd24c3faff9cb33dda902c007a1cf4ec3e83790206aad085eb6753941204a22c17ef66d5738e216dcc3b57d264c6304a0cd7efded8e67425e8c70f2c7ae2710ec4bef5babc32fe648563c335a487d28b465b807bed73c50867cf80d2ed33dc0586fcb86da3c3c94c66be94c51f6900d4234ea4a43d12b28c180e1dd5aeb8b610f819ad6a54156ed53cde8f4f25ce1964c0380ab8df789e39100c8a53eaa11edd56b92dc26c6b1130f836d26ed12531f1f2460a3d4c18359353efcd7d8cf1ddc4f092b7afa31a1988e7724383ae39bcf16ab811af151b9e7fd87268a3c28889f7d76ee538fba465066408adfd34782ca36af187cb84d22890d8220484d02fa13dd1033f8d9f565914185c0fe625646cf9e5f58764a11ae8882f12da373556dcf911660a402bbdca1b8c514d7ce396c00e207dc43e6fb2ac1e17b3b1200bcd787adb0b722ca3ff70dcff7b6bdfaeb92aa1c6892e696159e134db8d50bb6d85f4bb0388a6709dd1550a891799ab1f783910f5520ae4053a1b036cc36cb77f081394b392cd98196c38f8aefa1531a036c2063faf8d3071d62d8e99f310334a37a0f63f4cb0d5c3f6ff906ced7bf1782e143b181b4de7a4aa7fa61c2eca7f4a277c83d9688f4ac45fad46fb19365eca92958510277060354a202c2c71020042c96334345c99767b55444822e2501b2ec5417930b7988ba2cc7ee370af18d45e6fdf5c3a44c31086dd4790af0aec8dd76e2157bf6be53419a733b89d2fd5b018b85217666c01623c5700253bdeb7d2697b625878938cfbea24cc3666cb72f3587ed68be459bf3fe468548673d7ee277f67a01ff6fa77b60b2c418a8236226ff919eab455008a63bd4aef8d267c048d0974f27bf4397cb647baae49ea77f2715ad94dd7be48d04dc0c587d1e900337af65abcc692b8861380315d1e5f071a395c2559fe2525c123f535e1a8672d2e835ec88cbb7b3351911ea9e257bc5f6b11e75b46329011f860f58685d4a4092c159daf5d57952d4bfb189b58f6abd081ab8c7166873996c790780da967531f0ee249d20036064e56da1ad4e7a43c7dd9808c87ae6760d95acaa9621b62fa5f11c95f89c4886c6d4779704470ea23936210191e0639a45712fe690e3b20fae5652defa6e7edffa63870c4acc6310f5168afdb675a0264f52f4502c76d369b68e8b99a8dd07dd9c1fcbde6117ecb28ceb3d363883fbdd8491e8b07951c8502d7e7424539a21861133fba151715d5857ab1910e86ecbcb771b5b2171308f1094452aa32491ec57a097efac6547ec96b1e9bd87e7a3366103209423dae78f011ba1c8badec7a1b9573fe662a2864f0d41b25e18186f25f1e1713681001faecd8bca139e1e87a2fc800a52a7729f1b52cbc75fac04c0df47d2e0fbafcfe8ff9194827fda7c6a121994e9b6bf212e027e1512efab5f27f2b298d347c3f2347e309437428ae9df186ef0e15fcd4f55a41c47e869fc9b67cb5f4f4b6beca9c26c2270c8cb9fb0e846296faac6a519bf240b43a9ba51131139912312fbfbe64b1c23c8b47c83d51f18b27593f5cc034708a712d7e75f1072165cc1f6126ed1f82f38cca2276a06ee9682861d875b8b120a0878b6805dfe11d7f8ffbb07264c6dcbee91cd482c0891ca139e1df54908043e7955af427a49d5132e3da3c7438c6a18e78f44792a7e6f0433ffd790d4698f5572896ce42cfc466137a1457cf02f1415fdd248fc5ae7abffd4491ff60348efd1265e6931bd04d59bd8cfb8e00835350806c9c4abada1c43eaefe29d894d4910b6ddb99f36f61b4bf58cbb20b798550880989a6a4708095fb20499a81ef82f93631e286283442ad911ad8cd1cd9d0b1c84359a57df8bec1f0256ef43df991fa58f98ee711221801137c629a4ea4f2e97b98675827fdc024bbf8daabea5bd561a8f0b507ed0959abda4a18f4d49303782537df7d7585530293f0680763cad2e2570c7d87c82131e03f149b7139dc1cc220c9297b8183bbb2758206e777b627c2143fde2c427d94a0d81bd09219d3a0b0671b96c8dd0143249aa79a687e0aefd248c5f1a001098cbad7df741fb541e04a113ab49bf696a1fa8b1586578e0a0de0f24f725a5f06767326754bb34b12b5d246d95e14ce5b0b3b0c45a31b070338339a05203699d0f51996818094bc97a2e207321d8a6500bda6377ea782a4cb9f66b7e4d57c903b93513c0a11a4d71091dfff5179bc050c7d6b387b1f2917a0973b76363c72b8bac68c089d8b28bcee1bdbafaceff1cb000b9eb11af5bc94bf68fdee9094236e13e1faf56937c8179ca1c7087b19c46b5ce3b580aae6151918c5fd95b4b5eeeb36b7ffc73d6f293988cdd743aa2574123a401faab8ee5dc68efff7bd674ea5f3296f181318db50504241828ec2d2eba02e63ef2fe14a15e615e491c156b7f83560ea6d6b802772b0627b7abae45f151b4ed8f8e06a4c3c1353a43e189227a192b99509245f1f0a310da0aba5e6c2bdb19ad75e7a3c1a7ed06b0c67e1f3e4285a0440ff42c7961d4ef3e28d06b3169cb1c53475a2d11fffaa2fc0fb3f37e690c44b211112d04a4ec1757033b31c8fefaf70bbea73e7dc9bb52754444bf40a5487b595a5aba40cc9727a94717dfc2ce264a6852d2b10904c8cd1950896e9cddfd00774c1181c52b412ae0c1eb9a460ec39a474c78c6386f1dee78b2bc04ccf2347542b4ef0b323dce4adced0a02a99a8fbcfc6f9e2669e1afccbdcca4373f3bb9409e615f3c3641345c14ac94b422e3af9b252fb854d2cf06d02f028ad60f0784ff694d24f42ca78706ac306b398a5f34be11f07b27e0bc7b20c769a8a753e9efe72f594deee7f836b699105cbee5b9b156cb4f8cb374eb633c055288fb5154a50732a769a8588d6e4a66506f0a77d1f7cf91dd0fb1072bfcf1adfadce2e2508e73b0676f748068ea3bef585afd1d2f825df17f68549ed46c057b02544f49c689b85710f9afea200b79d670918eaa7138c6226afd26e958180db383d156122029a7f394d71ccd57f628b66bb8fd7d1d3ba62849e2d8368052900f344c15b3d0aaf72f8cf16275308039b7ae46626851878f221d7135fabe9dc5ac01a25245b46c7d3e9e4fd6b3528c7a61521f3a99d191581f646151adc9e2f33406610f09fc13c73a0c4b57306a23bdbee3af7b2f5dad2e0f1483ae46c7ba77a5186eb46dce4c0210a21691ffbea3b5623e9d18dc5664b94db8f7560cff8ccfb7dc79ca7cbe7ed7ee630c60140ea46edfb4dc6c91e17fbf62b5604275d524f811d0feecbdf8c565eda3198b89704a362ae3868c788e8ba01da3a9c92a114934326df6495467e58181eb5be6bfda751754a5fa0eee3cbadfe4f48b779aaaff89e53b5419863ddbdb07c23df4e697f62ecdef0f617b83dcacbb9b635c139ea3e4e58c7e4efeff637309764e5d0e1feb402ca047e112ca6ecae4eb50aa224420db2003e7b9ebf9ff79fa69b638583e8ff7ad9b305ffa42ce49bd5b0fe7204be2c56cbb2f65e4a5796e3325880545be6dc019befa78eb9f79675f6717ec25283b3efd6fa65250c6356c873817c68f68d3d5fb6c9e049a7435c5f10a85d25a989d99cf5660da9f6e74aea8a364ba84aeb81608a25bfaf09941000242cb5dc5c1b79a5ae2314ff401299e606d92aa64632b0bf61bd07965d400e721bfe1d985799fa43bdaf919900c03f42081d53efa2fd16621c5f3161e35b35879e0c28f0186c269f970fe6cae7934a886f85dccfd989f7ca2efd82156bf46d99d2b427ab5025fe200a5cce707de51c4f5fb9d71c0ac83c80b40ec17f066afd76671bfce266de0d57ae8147f06dad7cd0c2a4a581e7ab1c6bafeca0bc9d86848b17df351b0abef2bfaa0b2a94028acf24454e239d3bc6a01dc7e498d731e76bd405b7a4ccd287ff3be5fe8509cf721bee82e5b00edfa97d6f4f303293691feeb48e3644f4daff0ee846ba14b66093ec23b0fa3f6bb13a5ead2f080c99e7f5530fb74121fad2287df169a977b46fd218434fb4f1c3fd09b36b702b3b5366c3b28d6bdef5293f6e7a1f64311e49ce5a6eb45dbc87dc0ec829e2437f0a7f736a3b445da62b1eb4f2297b5bc4b31d874e55e3d3896e60dcc52c5cbd51530bcd14695ad7d338314172d64582064ef9fff8a0ee3b9b0685005f2a38484364dfa01fffdd34bbc41afead6a1ead059e3270adac34823b72bbf2364dc5e58c99e50cea9c3ea991129a5a4cdcba3948813d8159a49ab8161e17f0d2d9ffe83ce4fb15ffbe03af0556423e41e6a0bc3dcaa053e6f469fe2fc3406e53cb89826de740edc0874867b441b0c2474d1db1d71b7c7d42947b04df8baa0da7f0e0efc9b83b9834e18bf11f1e61ac70a0d21c1f41f786529cce6eaca7d81651ac0d20c4ecf1fed36ce10c67b6589b9a80715ca41991388e3f3e7e5b77a2e4ac86e47362f2372119e58dec121cf8404f81ddb5c9c46a8fc33cb8e2a7f3bf98704f80d49f91e90557444b84039a6f59e57991f9090faa073ad083f7f59df4646fb8c1f4abadf58a8c7c57cd1adfeaed098d0d68b87a597353b94c1ed05b540a238a39f28399f60abb68d9466e2f3ade3485ed16ecfe43b8513383b671cd986d615a3d81094b92d1daf1d52f2a3112ad957cc7d8bb910c9eb36efd9908108942dd36c4073c60b916c31b5bb2b1a8ba2eb1d0ebdfb733ad931e45d463b859732ad5d628fe8c0b5ca39b8dce5167abe224bf262417c36a501e50cae95dd5c7d4bb45419d81cdbe8bb6014e7e1521b061bd39c58bda1b286914753ea25abb904578a29df553a6e733795748b2421af93e56da6e5f9848a23e01734be9dfba0a0bd572b8b4864bc1d81b42ecacfac7c8258a9c7ba6a967df2b8b6e58929c51baeb0626815d84dc9d1ce524aa41872bac4ccaf62daae587e1e7d2c189e7bb87fe56e09601de6e26da17d373bc8e9948b8a2065f81239d4131e1a2a7e5a32f02843e46720b3362e58aa74f8ec0b3f25c79abce6d60484b00c412926da8717f74bff3be102a066a3aa6a589cd26c5e0c86b90eafd5483d4a6622a709961275ba195442996b9aa8d2fe97279df22a2f66cc83d1ea2f6b293e2bdc99916c6c94b04df8784be6198a45d3ce435d9adecd89239efd8caf911cfe3f4f956c7c64360ae38d0bdd2fd9f4ef296f2605b86dffba9253f1200e5a172ad4fb5acb594a4bf82ca8b2fb22686c36f72c9a05c007954fc14819646acd1bf14832d08bf22c3bce787dca2da95fd158bb4c0daa08f741ada2a574ec4a4a3e0962d65580ad408f34ed5bbd0730fc8341e560c52ac0fbaa5a26ab769fe4834fd9068e2c718353130f5ec2ae3fb2d0d34c60b0affcc521bdc016c8c8ac3f0bbe420e55786d670a62a9fb1c71c9cce2b8c2b142ba8bba15d55950806d05754c9a981c1c214790f5a6c776d45efc1a067a24b0507fd6bfd2e6a99f9422e02cbb41e744d3956cb8e37f29feff9587e8d48c4a9ab318beb900dc190bbbf771d6d157478e5a29acc50e54b02838e7a1840c4f0c1d71f251e72204a37aa8dcf70f38998f0d95de590c73fe5b20a185aa5db97f7f8a2978396b6526b9d51f7c3210c01e593b6a4bf0e67c18fb2337bc7976e56ad5bc8fe6edf0ff8f81979fd209637a065e3cffd326afb24679ce811f7fcdcb5e1e6f627896b1357a44afa4e3eac1e25682e9277030b01cd72230349d48fc3e40cff6809e0ee4310997e02373471edc085e0842912569d8c197fc18b58a5b8d04673c41b05b6b4f46b5d570892e5ceab8eafe483eff326d59b450f67add629d0fe5b0523a3d293767269fb53578a5a0db65675ca48bcf6723cb349c1972520d54726e1f6e112924c897c6c12431900cb351aab12a44c7855c0f8b426bca67aa6a7596a581966266099c0d646cdcadde4521cab4cefa524b3682eaa0213e693b87861c3817d9651d33ecb6ab3a53c1fb8ef9d160c142f4da2b258f6a9c6ab57f6c1d36ff6547948a2f32277870d04ece164bfd86a784d00982d7571cd173daec485a860f0e897de9296bc774eb0bbf37a17b1e84046742a9ebd19a0030638b532f0c91ed7067c7952ca4d9c184e703169a7297c54dcca8039311ad3fa9b189d694b830dabd979302da36c38aeb43dd5c595e0c9a7da093adf151050f27c4eb98e00620ea156f564f9830abfb3dd3b4a0db3b6fdb94d7736c429190fe0d47b9e84ae1a4183f3e32176eda7f38470aba866781030350088caea40b79beaee7928f158192a4b01a50df785758a040adc71b096106d9ee874aeb4ed3c8495ef1ec0dd680fd9aa7bfbb9f950a0e7074c1cd903be6662025df22c519209faf95f4342b28869493745815bf39a829d8efb0e8138b48ae3285e275ceb9ecc76d9601d146f5e55014be8607bf4d4136f416b9c3814361bdfcbd80b0b5018d740b78117623e7a78387a76225627541edc63c133e66891a21453823f000d0c92ec2d7fc43f3abb8cbe5e3e321569127c4d17286fdb5d7fca3f56e972e243a2d6414840123493e5aacb00a75fe07ca2c88ee89abae1a5c7d5c34a277ab1d9a3070d215e08b0f78dee9c343fa0e02cbf37d24672e0c122616baf3f45a70ebedeb6883044f22f6842bc815c7309cb70b2f4d68af421222cd5a67e7e3b86f47f1079543c3fdfda7567e1a15b67453a6af37aaa92df99127e5c57dc6ccc0150a628fa84148061415f74bcffa115f8227d671ec87f21f8a06dd45171e29e719a01be557cfa8a28708785a33fc2d45145b5ea557bf1d4151c642669a7d182c68e9bb9ade099b827d445ef051b9d0448717c7b7c40dd1bad0ec815dc93adc10c5ae46db1d77c628cd03b18342a23046bb5959a6c87df221f05d15e735641019eb4dc22c36ea1c7416a7fffd65b8d619005c300557e5e16a179abce8c3f601987c54902368768b2394dedcc5b86cfa34cedb3f1386f875e8818cdf3eaf9040f4a06a48704a8084028da760f335411193c5e5f27f2351b2c13641ea71cfc806419947b6d64b4679dadfd31b95d17663a2b7110121ef4e7108a9ac88a06f4c6e3b4769c27fb4f578e4ac2b8f6920f185c10abb7007316b4e772d4dd1694067e0fd63f4da9abdebd842a1b8c01521090fdb38731b71468316c63446b87ba7280c489f540760f442fb9b31285e2c336b282b2b06cd849e472735c4e230a431f88c525db94b0b0952bb208e36a3b49ab8a7a6b7253e50e8b86bf63e40d162b8b8478555b5feb48d1e86e95944edd93d7a5fd033b4531777271ca0b4b705d770e6a6be3e9111cb093745d8e7a8a34b806332c70b749649ea603f8b55cff96d0d6ccc963b980925a8af49c3a449e4ef45eb0d9a690597f1df86cfc8c913b76d4d36f94b64d07d70845fdf4c5f5d7058ebc568f2f322d6a825785fe06c61110a436085191ae1581177f6f97b0b74013219ddd4a72a3bda6f08832942d477a15e28bf6f594edf1a3df9736cdced2c18ef70ec177a2760e15fa973d5533d0af85405998facef1852898b8690be244e3d5f2fb203a588fe6b71a5948a0b91a110d1623a544152c96c537f59886427d30dac8477f4bb04d73548701d3f80f4ee2175efac38c8fa2604b454ba01dc977097d19eb922a70b7cf70a46e6be45292b28a18046d93dafbcad5754eeec7d754682738c96e86f1170d97f03cdf5dffe5b8bc4a4ab57a482c76b34bf76d7d9e3f5d355eb2d1ba9c2aa8504cf7cb8489e560102a9d3e65fc11f752890ddad204f48978ef40f8ed42e9274f747471cd0e4d9c9577ff4416a56b551dcc8566740f405fe43e92003834d0cf4dc2e72202612d8f41a075e63e90f970499f44c05d5a2f1d7b6e56928e73ecd3c6478113d8d8151ac77bc214cf5f84b182c8048ef8e2dbfd3369f633dd4e291892f09bff56200d8bd314ef05480a5b9f8e3f46469347c500c51d1044e59df49850a169961a1af56282d502f3b7faf761f78f84b0934c18e1aec1d3188469522d26e02a8b2f593f23346e9858fec98d41df542456affb7923b6bec08505c52f760278adbb6b8a21ef4eb0f91ada7b720acbd4d354e36f355b9310501471b31b04e33c4a45bbdce669106ff5f9abc21bd5d216cb8b2f89a720656e9c0383a5b684d5e1d0ff4b0d6088e0aecb2a73b7847ce36d5d78d638967953038f3784aae3e720c7456f804ad6e6404124092059c82e095a2bc557393968a3afe35235997331cbf7fd92616db020576f6e36615b98832f3410520cacc955ee51378c9262e96444b1481b75c13a19025bf4609cfcc241375ffdaed41ce7926dff56dedf9df9537cd722a1dcc0cbf2f9040408d7d0bf41be228793e1cfd46d9f2809141ce3e3f7501d4c9200b0aef4296ddd547c3248f2cb8faf37198a753c52ad40c88e5cccf308f53781146e056b8451c0e85713450661b3d4f15cdcfe6051abecbbec5b2e60b6680edf5ae04a9a8514a7d410d29c9d4a4fd38d4af4eca16abfcb12ba7257da73fffb68bde76100cf1e3e01675a5ea2f069f68281c0fa7ca7815ec8f2dd71f51277e1b241f6bcdfb7b026f8c8ee3cbf352113c5df5f1e874bc7166e1546f1dde139f74c866d70df919a2eee15a16f61c1b12bf36835fd7856373f28e9fc4010e70bd7a50b41da78b8beb310f17f434daa28aa1620cf4e2c5664edd881fcded0c92480e4933e3b3b74d1aff7b8d81c7633eadbdc2cc04bbeee9a7bdc571566737279ad972977f0ebb5199febce8056fa39139970746699bf3236c15b95fa0febdbf207a505b9b3c2f217c33998421e1d9e8101708cfa7b50ba46988b5a13d9e31330c478390f043ed396e4295e25bc80450148bd15de3a0cef6e069ac93aa812434208026201fc1f53fbbde76af49c43a37decd2f8d24a0458866ab37ea2dbf7cf762761700b3e130bccfa0e287d32ed9e13d0a1ea4457da71a5c41d70332ea33f760bc3c2a2f3947ad39a0287118f96a7fbc8b30811f95f32e9e00e9884dc524136fc2e06f0c868bc664957684521ae09baa5d3ff70436dee7d5645cde10e926ae2b83d7c650a1e4a1b93fcbc5943b813387b2e5d0790d8de30ad88741c44ff2f78c19fc50ac4c6e91b8b6252df4c48ab3ff933986bfa48ddc6e0dc9af464c65f3ed7cf9cd005380abc04d8d7674b646042996b92376aaf537682ae3cda4b4ef71a68a45d1cf780b2d493f7a22e2f99db310e01eae87ef1330dc9e11cd58c6ca84ece6af475707ff95edc25e522c38529c1a09e36d8468a3fece31eed34a118bc3afa893d8702e3153d5a06c96856900e6fce89e0be3eab4df733589758758031af9da182263ee5f09043a8fe74aa797afbe9c90b62ce85c17fe53999e0c003abc282566dd99531529539fff0e78f2b670dcedad609261a17d44a4f03bce4e8620c536ec52c84e62e713a873de489f0ae3b65a7d2ad5f64e7cd8655991637af0b2ccb26aee0564862779139178f0efd4edd200378766652330b1526ae28c56d4932996277fd414f84c888924494a6b032722b8062c34ad22eddc1df326dee403e561083c9f7b273cd20a7df58e0ced73e23864a535d442dbd2ebf764b852fd6b5ece3ca563ff011b3609030a730159c3363d0e7fd3d2386a60a6cf9ba9a98561b51c40e4ed9b8a52f412e57ff4952bf3b7ae82b5be5c3a94cefd36a2868390c4cf58fda4b71e70a0bda1cd11899dfcbf375d7ff91ea40a6f67a6496967868d186c67d671504650f6170b34d972174e88d03321d7a96759347cb62433afc2b6b6b6e9855234e6783232792af5da1d1c9b3d23160df0ab6d3f2f4c47138cd61113650df1d5837e9d16f9492c7d916c9c9ec9dd9aef123f704988cd5e2ac83fa8a745f0412dfc76c6ffc0d53409ad5c012b25808822cde2ee816246ab78312fd6644b4ea8b0bad195b7e5112008aeeea8b160e5a787c5e5ecc97793b85b69ef581ba1ac2cf49acbb2922a0876bcb6e41ec217154ade21162dc2ddfa6b26dcba96d35db0c7a8b527c959140fc7b6c82d1070924056ba4b4e440db80939c71e002a98403d24f9b2e035142f9f4cf53d75daae5f19c1d0dcca99b905604dcb883a6fb3c4fdbde5a40e14ee07f88b5dacb4c9a8ea669bae365da24e2c00c3c9057d802a48caf474fc4fd5777f7e1da2f4c17be22e4623f93f4c1ef3b0b45245141961ac2845752d72815e24abe219a2ebd6ad9f517b44580f1e794f236b04aa8645dd1233a9d69658aed8333d1c08e680a5f4f1dbc61fff695c3d62d0cd62c33a7b8c7de2cb384417ee97f590f0541ca05ded3c493b50e4fdef9c2ed3122730100759736b09739ccf50581ef41632c62c111e70f0fdce7e658b211944097bd45058bef2c766f87d59809d9354613903630857bb7cb7b2781deada26aac2bbf9869ec796d38a3da42d935e212e97882546012e8da8d1a458fde4e84c80dd0445d7b0a3d61a14cb68560ecde94d699012a4e7b9ae27d6a2542aed5d0b43eba281b4cadf8518804002639953cb425ddd19d4353f3524776b3cf1f7bbb10cc62b75f260f48bae4829a737a0988eff3e6a5b440383f2dfceeb9ccc973d8e1ec5beb36919d8b05d569b3bf97128f5779807f6fba227d93bc35c2eb864be6292912aa529e1f1157d74e8e44b81182e553c2cad6f1e8d89a08fcc62c537fc75a2a5953cebb6c9d1096f749bcae30960f80347e507312761672e272a16a35d1da752295738b9bb16c68be154d08724f119602898af160062979ab79c4423a927f282d786dd5afe71480861753aa208ef29c77b971b45e18626ef1af9a7840a6a35e78cda77e53c7adae74a45fe1fc7b6d5c71f3974614992c0ed15039239b1ccb6cb261a600f3ec3cc0126f049e5c4e20ff027b5a8b4c6f1fafe0bac1aefb2ec69f0cb105e3e6a68cc4b162be7df7784eb7d1ef51740f6e147e778a988fd8aaaecbd311f69b270972aff75261a12dfbb375920cef06c0a69d136275058ce6f448349b2851ea3ad9d2df801fb65ec138327b602744335a0c5f490b5910da441214ea3e06612d602d32d9ac8251d198b03ddabd448c4fc4f0b4152f1afdd45f28e44aa2618b28850ee1d3e33db9ee2ed26de9a46eb697074621d9d90b00b887f02644bd74385960785f38672aed13845e2a26d6c1709d46fe2eda4da78074d7dbba6c0d97c79290452f0e235ced07fb063418d37b599d5dd7214b9ae1a406c6728919eacb5399eaac633fa6d71f193355c5e86f5ec9defff282d5bfa63b876371d5f7a4499d353b74edd00d2df6ac68d96a35d89bfc1c4a087cd071f06a6a03704bd4e07856c509cd219b20ff79764afb75bc791fb8befcee667d7c12cb9970f86e63557813bee7bb5bede99b869bac589533e9c698c7b46e3e3a5e51f79f540fde0a0a65f18ae62b7f3e8ee53136afdf561f99915ef4bd2d653e4ec5aaae0645fcde1408d9d5b87f04b7d3e1349a06e18ab313af3457fe5c52e4492a666e9824583172d6f17c7a0a785e22ec7604f3ba1a6725d11400f0fce689462a316199cca5813d3529912885839ca4a50c153d5cbc67e3b18eca9e0193e97894e1e1dc0449debde2d8c9f1cb031d08c7986f2e874838681b1e8be6507b899e5a04ec9998d5d7172ec378b0933ee73a7071e6e5c407fb1031f9d2dcf96967250163fe33e89c92d74fe92bca92601b77231dc49190bb5d636b34542d3609165bb260de9afc746cc8b4c22d928dcba83c83cfb7ec5d32bb409418123f1c4304c7988627b8e0fe00280b556a1e778a272f4d7fc0e9c3516d1f0d854d32e05d7658bd66c78d422fee9df43b656df881ab0d94773414b52ef2781fd959e5917f96d9bc1de25319557191e3865665916bb9cc236fa27226e44ac76f67ad64c077d3c1d4b669ccf1b574a76deab2da2abfbc1c12217e338b6ba0df5ac16ca2cfca6d55ae991bfc625db384f831f3768a558115eac14719d4d4ee462f3e30568b1b42754c2e2b600019026752c38e69a5cfa35a8bf310bdb2917ee96024909a924d441b35c3d77122ea445272a5feace17035a6c7eb375d6c0838943e163d6d17e0f0e8095faa1b54d964896b37292d0b018dd8955c0dc5d7e6db045d9e781420c8b51553ef4eeee19c56d5c59a77669d2679639695b9136672b2974afe9697eea78fbc3f876801c379d797d6b7c54955c5c6dccb73e276bc8e56cdf8a22547fdd0e0cff5aa60d66c02ae7bd9f300205299a77e2dd124d195ca2c74481ab4cf0dad11959498ed4ad4f6e32dc0487bacd8171a03010e3c61b95c3e3b112561655613c3ceefb7c8658cc97a0a8b7e13fbf4fa69d0d6a9fc4563d7d215acbd9ea4b1a8752ad4c5f44a4d61892f63380111bf0e2ceb52d4e93048da79484c7927203f9fb405be157713d50aefec5b07092288ee96a806642862c18d98624bb2701563b8c5731b271308a36af4f184a3d368520f46ba28d6753e39dcd547effd70311d3b56a5d25a4d05a2449405b08b68813bef39b4b74631f933836407e0d059f4898974702ff1e7159dbd7ee915c47eb3d21c4240b4e2540a7e7041a1834fb7c0b7f02c1bd42bb37c1cf35861762204567bcafdf24e4cde2c0870caf5be5890ad3d088eb1a5ebd99fb0a1f75c72a700c04c57f9a61af4a1c5f5ab45b6ab29838bfb5693456880b724bb40feb99611227f50dd9a6eacff81ddff316d5b49962536fb570f7bdad72ff1e137371b85b8994ac46cba35019b26e91b3aec87aea68c645d5d844f465a9c699850451490da87f7dacc46f885f3c354496173396d340e789e01d7c1b4480572080fc780f6edbae1f70aa7bf539a393def716c60bc1b847993ddd16a5c68a249353f2a0a7bfa5f37f1e8c64a09876eccf6197b58987a412354b1693c80d45ca859c7df75dc2bf60a11a06f8cd0623c87596e99de5b2c234bf2e3b88ab51a8237377fe5db4796e2532bb25ad28a85019bb4892946b9ab8fcacbbdab097723c792bcba9b1464ac17556cc79d5b1daa6ef834937ad9614c3ebfc2418cc375b7af069b2bbe03fae196d0a2bb654f4dd1a6798c1e8aa950aee9285f6063bfcda6b8d65a6ec66a2ed1464e2b3edbe653d8bb23a0aca0feb074649f3589bec8e746867bfe83519941e5df62bf1003059c729ca1900848aed392eaabd37ffd251822da959f0b96d87f688730c7376e45f509976d76102a1bf1073f792f93eff1f369060b1f895a911c20adf5761e03d897a872f37d51b7d834753ebc565cbff4883727a7ed4b70896d3ed524111c8990d4196f207fc3c2448a5f7926ee08d337fcfe42e8093f82c07a9e73176bca98c8ba3c5f3f9b59730ebdccedde60adb5e15f7b93f9a007bf1b2eec81fb26357a03350c9a39e081979bdfc717acde22e18f1e7d814723364b2de48d81382dac30031923b83fe7ceb7f83c8bc3432977b8153fa9b075f1981066c5d15a0185324c86bfd5eca82e399ccaf0ed918877086da6a355923cb68782cf409fc613fe3a3a922d20a6246ba8e6db4946298ef8076ee4a99b687e3078c2076db89c9a42b5c0c40f649d0be494c4299dd78ce1e614b7f09bd619c77810f9ae87991f6874bc6a683bdd9b5ac37e7eb7114bf65540f9b34ae62523a12b2195573569b62583a35e3e715dec781e8dd4735cbb6a0ef3d2f1de2762f10a3b219a1de2e6b5d38543ad79ee6116b25a24b0fd5fab638f5c88740db26a0c5cd5e8d5dbb3a3c03d12ed97337bed16254f40780f828ac7b59b4b9606cd160b778e366a4d6e72f9fae1571160661ddf58e3b67487c00a64587b5355b67aed2742dbe1fe1a625cfa4279263785339d47e2c02306b65c7be6c7c8c9943911939fb17d21a1e2d1822b718008cb6410e42512c62c0e154bc592d82e6d296758f6e840f2ff236bc6a77249da1514f6e5a50b1388ece9edace93e744a278b9a80aea5b72e5a53579093b2660d9f35dd4b670e006f7e497f0d9877af5fefca76784fef999e2298a397ee572808ed9f8f102909d62628650d3d21751363e3111f0cebde18836cf0bea2da57226dc1cc981198e6c2dd77c0e477d8b2a9a7b5431b6283d1ffcd72632a3140add059691d09adfd56d9d3f44b131f0ef7bbd79bc18d2f1badae0887da2fcfdb4e884efd34c9a2388074fb02d62252d5aa3073f1a225101bc5db4037eeebec1911bc40e3bc41c8bd1f118087b72cfe68264a0280bac6db4900a40db9edbe2ca71c6b0475d42b77a81d1b8421719be2feb89c81c768c21205e0822073ec93f518dd9a4c65fef060d29292d8f75581ed369418778fe50701c8fea2616cfc31dc1345e5fc4f46079fabdea9c55cae2726e63de533b0ac66fabc2cb750ba694bc2c9b3d397ddeb895f3fabd6618e91fce72259a0983519acd59d7517be9859c58feea4b1290cc86cac2aab9b2600241369c827a15116a98203b668781e7e854903b523ea39b4d795ebd8bbb97017209d6851ae89dec2f891037bd62d98ed16cdc49fcdda0741bad0ac2543e031027f0c3711a5ffccf707ae44f046f66df57df3ba8a99e21f674593681e4014e3a09b1cccbb11a74512ed0f7f48ca548168a688f28a5bb0c8bb2d777aa67d06160527e1e223daf4f273858e1cbdd9fcf555f7c9ea505e25ca91a9c9a1991683b9003c7184574ce6cd059414b424305ae1bfb8773c5881aa0a3c7a9db0cb5c57e1c8a20ba580c452bfbef5560a16d548e3e0fe439e0f2cbdada75fd0d18ad735ed4c2d75fbf1be9453db506401ab512110ebac4c2ce92c9d96748512d87322840a7d433e3ce31a2218ac0f3185519c20e94c9692a16ef16ba18baccde525e8cf8b194968bba6018ab4f8307b40e9a67ecb4fc11ff05426d2b0c81ba16afb357a6676d382e91344d7f2f8c842cf3e5c4b0986dbfabf4017076d6477c8392ff51132a3a67cd3a320a15ff7e14b0cbca16aee8a52d85f4457bc35f5b07c739ce9135c152cdfbe29db7782db622e281ef12f88fd8b8e7ad7ac7e0afd1f05f35e00ee69d5c2d47c401fbbdd43893e5a19393f50856fbabf08a9ac69e15fdcf952eebade766f1f45d66fcb27abf69177fb669ac1cbceb474165f953c968effe2b252806b92bbe248b268750cba5b3e78f90ff1944896fef5412b75cfad029d312165830ff31b1a4b658f2dc6594d76c7aec060621bfd90a4828febd8b8eea3f1a534a0d6ec889a2b39299ca53f549ae040f5d9005cdb69c8ab05e7737dd6bd493495a02888c591050143fbd546bd497475d68763468db8daa869a176e0cb543c4e0f85d0dfdca65a653f5b8dae0e572a47941eda39ef39703c27a3294e3a427913da2b22bcc6958a15b889ded5714cffaae67752263e484243013f1bec1f4b91aa5469f86fb289d45e86650c5afc05771b2746972164b6f2af871fef22cc72dc85fbba9f34309e2afcac12e73efd9c0e2748a84a822d675a1456baa880edfb831a758590395b03863e16d7062d73f260c459a6518038671cb14d400d7203ac6506dd1967f32548f14079e5f42a560572fb8a55d3f702f84e415afb9871571941e21c6acc1db093c2a6f82c8fd6814f75a979c1dba50336646d0e6bffcb3403827b2762f4f5732ba8ec58adc99eeb9d441e1102b157e56b44b8ac724c7ec0e57a2cf6b9a41b93f94f29e08d54408055dcf3187f1d0163de6c1b427783a7eeabce27906f0dd35c4704446e0075445fe5744719f308f81628d3362aa9dbc54e776d2059e2a5976b014b8e3b8d0bdf2f9421a989cb444ab8522a9d723c65e122d0e53ab7a16238b05f319da9db6cb55ac4ab36c391b2f5d99e11249bee83d2d17fc157d40abd1cb6dc8a4610282492f77c532667b3a93648813521fd196340e254975176c152d640e284fd1884c7e81753944cd7773d32f2edcdc03a4bb72df8fbed9fe1e8b459bd814262701be9f8e9eab87811e7029799930f7a55cb039741fbbec910d6123474afa30bd203ae95c9f41a7cd4a43b738ffa85bc20c6559145c4dc4dde58de56870bcdd6aac2ca2007c3f74e7f3fe8950e09fc0c0e75ba91dfd6e44bb9160ffaf6a5127fda4dd75efd35b48acb1088f97723b9ecbfe59a9eaf7e5da0b84d6ad0b3e300062f17cefc06e27f19b04cf56c68a2d35ef6fdfc7b97f15ac81334009d3a9df4b5bdea30a9e07d5c572f5072b47f3be65b9feeadc3de5a6d232f2150aa0f54015826bd5c2b94ee3d93539b6de76500966c05072e33e4535b93f00ab3267ab000ad465658ff67c9a525fbcb630e6883e44a101250e24537554432f4d75bf2ebf038256826aff017dc3012012981c45c3cc84bf023bb04392c3a5bf06430ad179e40d6876cf377672aea58e4e9bb78ac773c79a65146b9bdc47b19b3a173264d04eba6984f1f15a585c383d4fe5e110da3e0d7bf0ab6c0913182bd84ed9dc12d65223961a1d9885172d63db84851c0a49a1b0aa1a129919e1cdb198074f57e76f3665597d18ed537926f872f0881f715537cbb706b1352e24479ca891795ca1e39f63cf3871dbef0673acba281479f123f46b8d2bcbf42a11b73496f553d81ec017e60a52bafda24b4287419b729dddf80d3370a6f7f74748c92649db5d707b00da4ae76507c26fe24604be33433916f1b7eb2dd12ff0811587eda24fe0dab0850d8b34badd5276b64c99f20513fbc996f425918b0d99596680a1d095babf57ee6942697648c06b74a8f297f99f5b2bcf8099b3075d5baf58af7d61189fca47be6715270bf6ac40e7bcc01669972327e94494affe8abaa4d76d6b7a35ee2a48d455b6e9192faa5e8f8c5dedc791af46661122bb56a9fe2643351efd7a433e1e6f3dbe5d1f05b70a7e0a7ebc7ca2010555e10c391b9721a6587e30ce836dcced3caf17f7339e61342e070eec94ca5c58d6f9cc29314d26fe2cd71c99ee28cb3e63413bbeb8e4f51cc2cdee7cbe1c71667bfb6f732cae53d1706e934854587ade228224c6316352ddb42bf96bf08fee47b1446ee4ea183c0f9e3eecc485463b13563f9702143efa7fdaa4cbc8e65fd47b572394bc4d04f9bd02b705e6c3dc5b6b2cb3204dcc58730321f579fa5421ada7bf14dc1db8d698db6efee046ad0a1ac6ff2f961999729f2c6c89d09050ae56d09e2071c13973d55e9e102f7f5d2a0bdf2c3269e520368d241bf548064e683db85788e9a0dd2a5398c34f48265f3129e41a28488cea93d0c2eb9a8b9e6b0c29e10ff1b0f89272e934937418e6b91ebce49db21a0be44418ee44a94bdac1928297cc1f4460b9cc9f60a6ca35b5c74183a296130b80b2758076def1ed6c3f2bb1258d8b346c7af5b40ff983c483f78ff658d71612755c4f68f61959456d142d9ed23bf7cf36f371c902407ae7c6e97c1c3189d1f9b58acf5c2bed34dca3c691da2ffa6702f1303e741375e6f90ac077cd8d14d01c73b44dcddbe6299a182bd72533a3aad13184f6fa4eb97769ed2870f35dc579a4680f5d6f3c9ce933cacf9fc843e71c7e2b19feb29a2b611b0bd8a3139eb95499e30edf497894414541cfbcbb48491404c39337a84daadbb7323b67926b002474445ca92ca59940455a2e9d58f975079d84fdfdf84d24ae91c5a8e712416dad7840217694b9a5709c1de4f28343e3b34d41b1f728d71b9c4da390a5a891d4235e9420f669f0f69d6be18e02ade37603013ab16255edefdb0dd874ebe9fc509dfddf03d8a01fb72683d864ef91ca2b72e0620f998f4f4eaf59ab17a215c965449a149287b25a163e6477a69d9a6f1f9f6e1297ff29ae9c6c85ce0f1299f067ce13fbc68b4d641af2112994cf33be9e54cfb3b5f995eaf083622f687e1cf58f18476083d029136b92c5cf0d5d228b30ded91477d7a02b21054f9c7e13c9ddb4aa2cb7a9fa7613d67b20587920dc2211ec3fc7c7b570906390101169163d0f736134e168003030eabb56f79b7a9cdf718957724b6172d0903444fbff983598a52f08fe9052ac00a37158e874c7669c9f860668932560898619363fbd8d098c8b64f4e46498ca397e10ab183f3d04adb1bf74f52a05275b4c9294553c8967c12a6b8110bcdf463e8f83275b1221a6468b204c949188a0ccc342b00e1ca6b65ea221bf62ad74a3cd6e35057d437e1419c2643a2b6dc3a255015f1c7561d6b80752b09dc58fea15b710b96c0a62207aa954ca28c3bce02dbeb8d1dca6e7d7d7c99821bae20382ec22a6e5986d273f3cffd4a0e0d9eb581f0ad53ed1c13d99cc2fd771984c5371bf427fcbf37d5889c7490dd41606d8be13c47d47e97b6d0bde0886f8b7a1292fd3aa106550d780c01c252a4b2acb4698220b49bc43784541ec49fe4b0caf54d95e1f853c516cbb9f1d61c4b133b78a18cc1d5e56d50fa1376308a4bbc70786d9bfd47586c1318f3b88b42d1f202a14d2dd53d457e1d4116dacf8275eaea985db741159e0974380720f02394f547e4e2f66b9817de7ab1e89644234de1c76cb49a8bda0e6a0fcd6b9a9422d717e4564bb3868c0b0cc3db8ac6ac012219a37aeee46e9bdf38de24aa996e3489ff27ef6becd100256b0b4a7bc26ceb31e3565465384a6440049a531a6137632b5df7c423241b0884be76bcbe71a1acfa0c382da37f0b39832580a3e32323a1067e0cebae31ddc56a21df7b6d83889cadba580547df8b4d5e86eb2e6c4b24a848813781cc3945f7dfce4631d6cebcf67c68997c6bc5888d76dc753faf89b8477e9c36c15d14a5f9748f3819183289fb45718c9e7566ab6aa7469a2cd0343c7a5d33fd2283fc0cd564bb286285cfba74f8854e953878b2f945743a4eb8bd9976d083a06fa69255f1d0a85869928fc713ecc072fa21e9419a6e1a38c7ac3caca70e1b712d9f82a0934326973ee440a8d4f53ebd03e01fae4c34868686874743073e365584936a5728b76010436537e93f70dcd6549f3ed72f866945cccae7e113954724c5ebf7ee3693783ab72b811ff6af03b79d8248ca2b1d25fba21ac19d25ea3f556fb0c799ec66882e8128354dadfc6528b9dca3f4f92629667c1982ebdb556c206194c0e3293932363d65d03960462b6a5614cc3d45cf7a8a5eecd872af457d4a77f38201de6a077599d77128e04b453c8eadd0c66dac813cc13cf5c3ce1d6f958137e31723c8003b7d7db3f6376a4b78ed89b7027cb7ef6834a762ec30a480bc57844975e46f317710a1f72b6bba709b1428fd100d23dfacd829201c2dc10f5b1ef155e41b6fb1ab11790379a1f0c06743a6884244dbe378ba04c7ea1efb973d0aacc4fbb4bacfac9a7eb3b5cc68112b4a3a777e7804dc3265ef7303bc6a7434eac083ae69c396b5791aedfeaf3d1befc1b7890f59e20680b21c7e25a792a80ad3e87610615b6d4f44021a612ac8cea3520217c2e8dab4a753d96224ed9bf38128b3290b528c579138e73dc97eec0221c3a8de5a326f21d5b8c7378d40af6c39bd9496a9e5251e9774cc5f94c9306372f08919439c3c0443f30d7f6a1aa73170d113ea50cd433b3ad6a1a5e0311bac8bca85d113ef95c45da0dc0f1111dda87370df13f6f8f719f6d07ae1eb0789d853a48f41ecaf21d734d685c75a3325d1f8b2d7ae55f643a5a7dc5786bd4613c8ae1e129a20afb3193dda35e20e697c0086c4e21d4f5b8e75c4bce0ea7c3d32184864da76df2b3d2ee86d46c5aa8c658144d35ab00b4c71b0033a73908eddd3c6ee32e799a212452e20765dbc7c58e073cb883532029f37deac54bfb22b4c5ddfc6221cfc413796b797882f9ae65964fbf2e7970353b8339187a3229bfba2289a8be94e3dbda92eb7b20d5f7c9fe066f44c5761cf0785222bb3a688189a41b69fe5b3af97fd9c263aca4e02868283debfecfea018dd9e8bb2ea6942ca05989b46affc3f6cf1f342eeb427096776d48a3722c9b6d3307c40afc436e5573ac70cc1a12d1396257acc06099cf04a83bf0e9d42dedf04cebb3e48205c2a07fecb19b1d4a18107503e356b7fad9eb34c342f81b3d5de534f7ec0418c95fe5407fac99817f80d6d66ce4acbe563106932233c50a8fe68c469062ec9aaca997373614cace247034eb41afafa56b12261b3d6f5fd7e50ef0d39d027207f3f12b7edadaa5dcbaab5dc9a19b3a2d8cc2f9655efcf99781bac2e98a6ee05fadd7c7bca5d9c70644a3de51b09d62999cae7622e5ceea16f48bcc6ea9f778e03b5724d2ab54fee08902dfbbab0deef2c0956c8dbf9c19f2f268e9ebf92c44cbf60e52431c3434c8a2f3b4be8b30d390efe63cbac504b34e1743f41c2bcc2a8c32a41477713c3bde129714f8e0a8134ddd8b794e04aa96bd8197cf6375e440ceddd818520fc231e60f65aa3c5b51bcd9572335ee9e3a5add5c3d8dada5ec4a7437c723775132fc053bdec2bf14c183e7df8fea77b746c786f94a3251eddbb5438d1863535fc64702cdd55e85332e5673c95c046c95c7c5279fab1a28189f78e53a186a99be1abf1a9f78a66d1cd1ae7d86fc5c4285d4b557deb64150dba0b4015721e437085451e18e72e43b170babb7db56d725e4e5adab9fe3437361b51a0e2c92f970e416e960f3fa77995d8a4dd7417e76bcb72562e150d6644b2f6824fa8cf8bc605187df464280f718d226ed05f8f733f3706730e70288b12994469060334a17046d95158c3b55535806983dff2323e916f9773835ea5fbfff0dd0c93b731191e999e8256ccfe6a2c2b8ba987a44488a653cb83feadf870db86e6552a391e3e1c98277372b54b0a05baf2db572879ea01576f3858ed7af404db5809e7497b282da5a51dcd502f87838f7c867038edfe3b12d703e7ea2283b2819ef4d83b5c928ac0f20fe88f5bb715d081c8787b40ea41e3371a2c2f8a7a732562fe112d4785eacf190681735ab2894e097dd8c722bea8e17094b4ab3cbe20790f364f7f4c6a2afd81f3dcdf5f25aef7a2e9a9ebc11a97a5a6d146c9790d63779ac87477f6fe1b00b46bdcda33dc4661af5a645d7bd7869646e33648d12e6052a299a3e147d4fea24875db586eb000565e0fab66d07c578db3d21e53aa65a67275afb1e800ba0e87d6b315d786a19b4d7a91d4d9f8ae66cfeceba4576d20e7cf382d4f068414cb91b377a378e1e3ce845167a957c723fb827554a8cec21f58b0061b8826e6942b226bb5ff2d31159ae00944e9a2f4c6de41fec5daba759e3bb5519abf91dccbf8948571ede8cac231003c657db2d3b4961b983458fe748856a16d8c095272b8d33c7dd691ccdae153470820179f8e067a743542e089b2f9c45f59597a2fbd3b8ba5565300dde0746c585ba26545e6e0db4e81cf5b4b2ddc27e575f57978c2fc2e733cf15fbf4881a4c56b4cb6a2c747950fcb1a902c11b1843bf4bf1d7a0b4b69b0a8ddd2809ead1a80adb7ed2384f36e74596fb7c5e7a69e9284a9372c98c77069728c3e22ab1ee5674b2cb69e5bb39a47dcfd1d56f11d09dd8078db3af87dc4242f3afa7fab3827c02d43a5bef5b2353990433e9b15b29fdf66c836b0a8a1663c743452cc2b0e86a8a3226f0da559dd735d13a418ddd3c95bffddd5b5e2eb9d57f51af7663bed72924dc0fa17f6eb42a54e906507c2e0d79281e93e6307ae0772c05e3e43ff4110d366f0f515dab479a7dd1afa1e700b4b2827644e16e6d5762fc59b156fb15bd9514ac08985126bb2a3f53ad7619fb177dda6eefd72fd4db3a5a3c4252938df8aee6d00806e861502b163970a2572c683a8810d8dd91a948ee6af603715b7ac935d9a5998a7ae8ff1a0b357c5293e64dcd7161653689f5e1ba7c5695b35db0ad098cf14b0fb1dfa028203034ae30e17bb3dabf21bf55af70042819dc30a110cd8fe9cb0d835d8454a067c72ac6470843d392f801b37f1ef4687df846b7c2ae19bdb3e9dcd17438b53c6002c2fc6bb5bf8756681286a60f178f6ce12925f103461397d1b7b427d01ee7013419a921d5e3869d577ca67358fcfafa7686767b9e6274476488097354046f14ace0fd990bb0a1ae755b6eebb9a064517da2d4d97a15e37e370aed9336abc03bedb228adea056a61365265f1ca6257ba7f0d9214a7523f3cfcec9bf09f56f4a5b4094e9d85aa520622beb9e1308481ccd952012402270fdf8b5a64f13d67d95529f2193cd1e714b11d69eef75e9c3daae9ccfc5c6535794250d801bf13c0fc920869c1519b2a8c32869d61f9b265e735da95bf02eac648a52d63da8a55bf0d24191bfe4bac8b271c6f5d255eb135f567eecf140440f40c879edf133031ad44d19cbdc51df5a922378f197458b78c359ac8edc59a7b1135471b48edcf193d71f43fce7ccdcca4791afb158a0c03dba86f72f8c88c682b4e13e33ef0736daf73ed7c98044055fc8ad17b82b934f130c8daa77cfc6e76e72410e5a57f06ebded48cfba5507d7918407c75f88eb658e541283f2aa7d499f6b75f93e652bdec68a1c1a90f6a496ea0c9aa75d75e783f4f72ecd54a8041d88b93ac85b3ae8c2a082345ebca0e69ec176125bf7c374506dc54800d732772800d132812f273922f5617096142793e8e5d30ba7db7bf5d944102690319fb3d006da479e4200516c7637f76200b1cec8eec0fc0cf83c1a1fe087441f76e546fd94c0370c7524bb6380c5e745d6929c782eb109b3c418d3d1c9bbc63e1456a0df83ed9868f209dfaf9eeccb36a4a38a6a0062c44bae5556b3361a4332e9da58b3a7494acc4020ea3ad1093eb3bc179c6540fc9794c42a21f9dfa44f8983742dea6b2da8235e64355cc49bf66e8298f861efb9819bab7efd441f1a587aef6d33b8b6be68ddd56bd7fc86f113a342e9a26267efa459231bc71949f41229df3c2879fb8d2100333cbc4ac1674947eca7e6775cc896587b081461451b15c54aaf46b502e40c272f78a0a7d96532a206a893b04522ec70689d5895b6457fcd76d557b82dceba51a0fd82ca83bfc69698efacf52837598cc66108ba7431a703cf2cb0700aa7055d9c14699eb4a7ff3311189847a8e86908659a1c62e3aaecbabd3ddafe6d774ba2ce96c122c9f6573b8b3479447f9ced5061f4c6f65c02e134cef600332219779761553ea44626709c27d02b49d672f9691ecb48f5274d32fce2df857d0074f0556990b4ed0566b9a54db650fe607b27405b4233f097e6fb8213212edc41f0f6b953cb1d221269882ebafd23af9c0220e33464c2a68593f8d3fcc243284e394060fd03312deb9ccbc510d2a27f724795d66e83ac84c2fee5ca5ad8ecabfd1e58e14cfd5864506df80dab19ad222425f742f62565f5bb9bfe7d89ed23e40b9903c4487d8f3f116b99fa37df6b265e1cea07465f6f939ce9c226302307d2749a7d45594f46b3559b4104a80bcbac38efde01f85bb37c4f9ceac47aca2808f3288236c51e90af66197ac7fbe2e8c1952ebeadb27c65881f2a1f4caa4eda29d8330194d0549d4c88bfc78cb49494b6ffcea16b2d145381a9022ba0efa0f000bc148632b74b9db9f4e8806522babd86eea81f76ea58f57ef4168d8dc4be27aa6b921872281e019650bde24deb09ed55e667cab082a8f1d9122c3fdd3356d996d06e502943db306461a95b418be73d8517813a122f44572cb6d83483da32fcd1fd4a06c1ba55f417b3c92bbefd6d3d3c943b0000fd5f93db957cdc42a3907d57302cee7371752ad09eae7a1517263f44971734c22b392497ecf459cd0cc56644c903c088b0f1f896d2d1d8fc8089f639f8fad23e3a87d20a89887bb07430f5eff478a205faad0e879e72ba1adb51d915a85c02948b5f6d0b9a324ac7eac4e9abb41af8a37910abed0d37c71ddc61cd366e059387904445076e3326f48d5fd70af713b1c4adf725e1b83784d5eee0d59b113cc54107fc70505416673314716e1ce5f6a4e9ffa3a527232b293cff90bfbbc252e4d7d4a691f9ad09103b29b629b18d10e2550f7ae8b4262dadbe5ae7e34e70eb6ffbae66fdc915b7d601ca9ca368a23fa3ab58f604c92de40b5a133581e1d9773d3fd2514137ddee449f3aff5aea93fd7a99029f618bbf589180b4f1256717e08f0870ba0a08ba46966e63ea08e9fef2699086bbe9c7d45df35846e3b9ccb8cd668958e459d8a19eb74b7df0442528b2275e3e81d15e0674d2d8895fed990b16f76eea3454c308c90efa6a67e91b11d027d3d4823eb090fec093cd5a2fda81ce1511ff6caa750f993a1235db588bc278f7f3da3d7b5a29a63afbc8d5cfe77207e1fced57f8d0a3d58d4e650b68f7b301198a05c5c7a77e90efa0bbdd4d8062dd3520af38043959090a62068661cbc420873dd861b311b60371091ea068635e2dbdd8cf77c195e5eba3c3609743d7b2176801bd625363ceaebc9f8f33bd0ab615b504bebc289dad187464e66fbc159fe59c94cd141101046e460a4f0cfe14543ce60fea48a0c56ea3c5f9c6001bca69be9df0ce3fa760652755fa8983688aaa03dbba6d2512f8afa578abf4b5bdef7fd7c1996f031622b4de951b8b383f978bfd15a00a483ad54332f5a6484b3b147f80ccd5e250bc236de22176d93e3c5dcf6ed764643904c01bf1a36d1074c7a65309a27c0942abc17863ad2a98f7a57a495a7a5154a70afa7118d60c03104a2a4b9c1303126e1d34bf5d1c4e0f221a93f70a4a56ebf67a7d6f91332c618dcabf7193c6704bdbe1c5920c79334fd4ac2e98c032423c421a6c2df128472d92984f1c4accd76049d3317c6e7fabd386085676c6224e221842e4b9e8d7d1188ec328ca1ad2782ab39052d9713da840ab30c977d8afb97b0c073d33e3bc11c1292806d4cf45a42539db11815c906be5715e75d5d8f9c5f9fec0b127931cd6bc20aabce81c6ed17c1d6da9238a17d948f739c1b8df00de1cd0696e7376a86397e
  
    
      
      
        您好, 这里需要密码.
      
    
  

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>P3441——MET_Subway题解</title>
    <url>/posts/17e083a8/</url>
    <content><![CDATA[形式化题面如下：

给定一棵有 nnn 个节点的无向树和一个整数 kkk，选出最多 kkk 条不分叉的路径（即简单链），使得这些路径覆盖的不同节点数尽可能多。输出最多能覆盖的节点数。

DP 显然不太好，考虑贪心，那么贪心尽量让链长。考虑直径一定作为答案的一部分出现，而剩下的就是直径上的分支，分支跨直径配对成路径。考虑这个如何配对，其实就是不同链的叶子两两配对，考虑以直径一端点为根，长链剖分加排序（链长大到小）取 2L−12L-12L−1 个叶子即可。
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+1520;int n,L,rt,ftot,ans;pir lvf[MN];bool vis[MN];int hd[MN],nxt[MN&lt;&lt;1],to[MN&lt;&lt;1],tot;void add(int u,int v)&#123;to[++tot]=v,nxt[tot]=hd[u],hd[u]=tot;&#125;namespace ZJTree&#123;    struct Node&#123;int u,fa,len;&#125;;    int bfs(int st)&#123;        queue&lt;Node&gt; q;        int ans1=-1e9,ans2=1;        q.push(&#123;st,0,0&#125;);        while(!q.empty())&#123;            auto [u,fa,w]=q.front();q.pop();            if(w&gt;ans1) ans1=w,ans2=u;            for(int i=hd[u];i;i=nxt[i])&#123;                int v=to[i];                if(v==fa) continue;                q.push(&#123;v,u,w+1&#125;);            &#125;        &#125;        return ans2;    &#125;&#125;namespace Tree&#123;    int dep[MN],fa[MN],mxdep[MN],htop[MN],len[MN],hson[MN];    void dfs1(int u,int pre)&#123;        fa[u]=pre;        dep[u]=mxdep[u]=dep[pre]+1;        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==pre) continue;            dfs1(v,u);            if(mxdep[u]&lt;mxdep[v]) mxdep[u]=mxdep[v],hson[u]=v;        &#125;        len[u]=mxdep[u]-dep[u]+1;    &#125;    void dfs2(int u,int ltop)&#123;        htop[u]=ltop;        if(!hson[u])&#123;lvf[++ftot]=pir(len[htop[u]],u);return;&#125;        dfs2(hson[u],ltop);        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;&#125;using namespace Tree;bool cmp(pir x,pir y)&#123;return x.first&gt;y.first;&#125;int main()&#123;    read(n,L);    for(int i=1,u,v;i&lt;n;i++) read(u,v),add(u,v),add(v,u);    rt=ZJTree::bfs(1);    dfs1(rt,0);    dfs2(rt,rt);    sort(lvf+1,lvf+1+ftot,cmp);    for(int i=1;i&lt;=(L&lt;&lt;1)-1;i++)&#123;        if(i==1) vis[rt]=1,ans+=len[rt];        else&#123;            int p=lvf[i].second;            while(!vis[htop[p]]) vis[htop[p]]=1,ans+=len[htop[p]],p=fa[htop[p]];        &#125;    &#125;    put(ans);    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P3783_天才黑客题解</title>
    <url>/posts/905428b3/</url>
    <content><![CDATA[我不是来刷字符串的吗怎么给我干到这里来了
Trie 树神仙题。
形式化题意可以看其他题解的。
首先这个字典树的边权没有任何卵用，因为题目中已经给出边上的 did_{i}di​ 了。
其次这个题一眼最短时间，说人话就是最短路，考虑 Dijkstra 求最短路，因为这里 SPFA 显然已死（你真的要卡 O(nm)O(nm)O(nm)？）。问题转化为如何取去建图，根据题意，通过一条边的边权是如下构成的：
w(u,v)=c(u,v)+LCP⁡(dnow,di)w_{(u,v)} = c_{(u,v)} + \operatorname{LCP}(d_{now}, d_{i})
w(u,v)​=c(u,v)​+LCP(dnow​,di​)
不难注意到题目中慷慨的给我们了字典树，根据字典树上的性质，任意两个点之间的 LCA 节点的深度大小就是这两点的所构成字符串的最长公共前缀长度，那么边权转化为：
w(u,v)=c(u,v)+dep{LCA⁡(dnow,di}w_{(u,v)} = c_{(u,v)} + dep\left\{\operatorname{LCA}(d_{now}, d_{i}\right\}
w(u,v)​=c(u,v)​+dep{LCA(dnow​,di​}
但是这里面有一个棘手的地方就是这个 dnowd_{now}dnow​，因为如果我们真的要在 Dijkstra 上跑的话这个 dnowd_nowdn​ow 是不太好处理的。考虑题目的性质，注意到题目中的点几乎没有任何卵用，因为所有信息都在有向图的边上，那么我们考虑怎么从边上下手。考虑点边互换，将边拆成入点和出点，连边 in→outin \to outin→out，边权为 cec_{e}ce​。让后考虑这个 LCA 怎么处理，其实很简单，我们对于第一个边的出点，我们向第二个边的入点连上边权为两个边上的 LCA 权，即 dep{LCA⁡(d(u,v),d(v,t))}dep\left\{ \operatorname{LCA}(d_{(u,v)},d_{(v,t)}) \right\}dep{LCA(d(u,v)​,d(v,t)​)}。
注意到节点 111 向哪里走都是无代价的，所以对于所有 1→a1 \to a1→a 的边，我们建超级源点 SSS，让 S→aS \to aS→a，边权为 000 即可。
让后输出最短路长度的时候，答案即为 min⁡be=idisout\min\limits_{b_{e}=i} dis_{out}be​=imin​disout​，正确性是显然的。
写完交上去，恭喜你 MLE+TLE。为什么？因为边数最高可到达 O(m2)O(m^2)O(m2) 啊，这个时候又要开始优化建图了（悲）。
首先原来的 in→outin \to outin→out 显然是不能动的，我们考虑对 LCA⁡\operatorname{LCA}LCA 上下手，注意到我们对于 LCA⁡\operatorname{LCA}LCA 上都是一个一个连边的，而 LCA⁡\operatorname{LCA}LCA 对于大多数对节点是相同的，这是什么，虚树啊！我们考虑虚树的大小能否支持我们操作，不妨设 S={di∣bi=u,ai=u}S=\left\{ d_{i}| b_{i}=u,a_{i}=u \right\}S={di​∣bi​=u,ai​=u}，那么这些边的边权只能是 SSS 中任意两点 LCA 的深度，根据虚树特性理论，SSS，中任意两点的 LCA 总共只有 O(∣S∣)O(|S|)O(∣S∣) 个，对于所有点，∑u∣Su∣=m\sum\limits_{u} |S_u|=mu∑​∣Su​∣=m，边复杂度 O(m)O(m)O(m)，可以接受。
我们考虑把 LCA 这个点拿出来建虚点，在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，让后在利用虚树进行建边，但是这样边数是 O(n)O(n)O(n) 的，总边数还是 O(n2)O(n^2)O(n2) 的，还是会被卡，考虑怎么优化。
注意到，我们实际上连边都是在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，考虑这个怎么优化。子树的性质，DFN连续。那么，问题转化为 DFS 序上的区间向点连边，点向另外一个连续区间连边，这是什么，线段树优化建图啊！让后就做完了，时间复杂度因为连边是 O(log⁡n)O(\log n)O(logn) 的，所以总复杂度是 O(nlog⁡2m)O(n \log^2 m)O(nlog2m)。
能不能再给力一点啊？
上述过程我们是在暴力枚举 LCA 的，事实上，如果两点间连了一堆的边，但是只有代价最小的边是有用的，剩下都是没太大啥用的，连了也不影响。
我们先把 SSS 集合求出来，连边的话我们从 [1,i][1,i][1,i] 的出点向 [i+1,t][i+1,t][i+1,t] 入点，[i+1,t][i+1,t][i+1,t] 出点向 [1,i][1,i][1,i] 入点连边，其中 t=∣S∣t=|S|t=∣S∣，这个可以用线段树也可以用神秘的前缀后缀优化建图来做。让后根据上面所说的，只有代价最小的边有用，也就是说对于一个子树区间，只有 min⁡x,ydep[lca⁡(x,y)]\min_{x,y} dep[ \operatorname{lca}(x,y)]minx,y​dep[lca(x,y)] 才有用，我们考虑这个代价最小的边怎么连，注意到每次都是某个前缀向后缀连边，或者后缀向前缀连边，为什么，你思考上面线段树的做法。那么，我们建立四个数组：前缀入点、前缀出点、后缀入点、后缀出点。这样的建边是 O(1)O(1)O(1) 的，时间复杂度是 O(nlog⁡m)O(n \log m)O(nlogm)。
代码为了易懂（同时也是我自己码风 www），一些代码是封装的好进行辨认。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+15,MLOG=20;struct Edge&#123;    int v,w;&#125;;struct EDGE&#123;    int a,b,c,d;&#125;e[MN];int n,m,K,S,ans[MN],hlca[MN],ntot,prein[MN],preout[MN],sufin[MN],sufout[MN];vector&lt;int&gt; out[MN],in[MN];vector&lt;Edge&gt; adj[MN];vector&lt;pir&gt; vt; // 这是集合 Snamespace Trie&#123;    vector&lt;int&gt; g[MN];    int fa[MN][30],dep[MN],dfn[MN],dfntot;    void triedfs(int u,int pre)&#123;        dfn[u]=++dfntot;        fa[u][0]=pre;        dep[u]=dep[pre]+1;        for(int i=1;i&lt;=MLOG;i++)&#123;            fa[u][i]=fa[fa[u][i-1]][i-1];        &#125;        for(auto v:g[u])&#123;            triedfs(v,u);        &#125;    &#125;    int lca(int x,int y)&#123;        if(dep[x]&gt;dep[y]) swap(x,y);        for(int i=MLOG;i&gt;=0;i--)&#123;            if(dep[fa[y][i]]&gt;=dep[x]) y=fa[y][i];        &#125;        if(x==y) return x;        for(int k=MLOG;k&gt;=0;k--)&#123;            if(fa[x][k]!=fa[y][k])&#123;                x=fa[x][k],y=fa[y][k];            &#125;        &#125;        return fa[x][0];    &#125;&#125;using namespace Trie;namespace Dijkstra&#123;    int dis[MN];    bool vis[MN];    void dijk(int st)&#123;        memset(dis,0x3f,sizeof(dis));        memset(vis,0,sizeof(vis));        priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;        dis[st]=0;        q.push(pir(0,st));        while(!q.empty())&#123;            int u=q.top().second;            q.pop();            if(vis[u]) continue;            vis[u]=1;            for(auto e:adj[u])&#123;                int v=e.v;                if(dis[v]&gt;dis[u]+e.w)&#123;                    dis[v]=dis[u]+e.w;                    q.push(pir(dis[v],v));                &#125;            &#125;        &#125;    &#125;&#125;using namespace Dijkstra;bool cmp(pir x,pir y)&#123;    return dfn[x.first]&lt;dfn[y.first];&#125;void clear()&#123;    S=MN-3;    ntot=dfntot=0;    memset(dfn,0,sizeof(dfn));    memset(dep,0,sizeof(dep));    memset(fa,0,sizeof(fa));    for(int i=0;i&lt;MN;i++)&#123;        in[i].clear();        out[i].clear();        g[i].clear();        adj[i].clear();    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;K;    clear();    ntot=m&lt;&lt;1;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;e[i].a&gt;&gt;e[i].b&gt;&gt;e[i].c&gt;&gt;e[i].d;        out[e[i].a].push_back(i);        in[e[i].b].push_back(i);    &#125;    for(int i=1;i&lt;K;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        g[u].push_back(v);    &#125;    triedfs(1,0);    for(int i=1;i&lt;=m;i++)&#123;        adj[i].push_back(&#123;i+m,e[i].c&#125;);        if(e[i].a==1) adj[S].push_back(&#123;i,0&#125;);    &#125;        // 以上都是常规建边    for(int i=1;i&lt;=n;i++)&#123;        vt.clear();        for(auto p:in[i]) vt.push_back(pir(e[p].d,p+m));        for(auto p:out[i]) vt.push_back(pir(e[p].d,p));        sort(vt.begin(),vt.end(),cmp);        for(int j=0;j&lt;vt.size();j++)&#123; //新建前缀后缀节点            prein[j]=++ntot;            preout[j]=++ntot;            sufin[j]=++ntot;            sufout[j]=++ntot;        &#125;        for(int j=0;j+1&lt;vt.size();j++)&#123;            hlca[j]=lca(vt[j].first,vt[j+1].first); // 求出 dfn 排序后的任意两个节点的LCA            adj[prein[j+1]].push_back(&#123;prein[j],0&#125;); // 前缀后缀初始化建图            adj[preout[j]].push_back(&#123;preout[j+1],0&#125;);            adj[sufin[j]].push_back(&#123;sufin[j+1],0&#125;);            adj[sufout[j+1]].push_back(&#123;sufout[j],0&#125;);        &#125;        for(int j=0;j&lt;vt.size();j++)&#123;            // 前缀建图要分类，别建炸缸了            if(vt[j].second&lt;=m)&#123;                adj[sufin[j]].push_back(&#123;vt[j].second,0&#125;);                adj[prein[j]].push_back(&#123;vt[j].second,0&#125;);            &#125;            else&#123;                adj[vt[j].second].push_back(&#123;sufout[j],0&#125;);                adj[vt[j].second].push_back(&#123;preout[j],0&#125;);            &#125;        &#125;        for(int j=0;j+1&lt;vt.size();j++)&#123;            // 连边，这里dep-1是因为根节点dep=1，而lcp是根节点到            // 当前节点的距离，dep[rt]=1，所以要-1            adj[sufout[j+1]].push_back(&#123;prein[j], dep[hlca[j]]-1&#125;);            adj[preout[j]].push_back(&#123;sufin[j+1], dep[hlca[j]]-1&#125;);        &#125;    &#125;    dijk(S);    memset(ans,0x3f,sizeof(ans));    for(int i=1;i&lt;=m;i++)&#123;        // 暴力枚举        ans[e[i].b]=min(ans[e[i].b],dis[i+m]);    &#125;    for(int i=2;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P5289皮配题解</title>
    <url>/posts/ea6060be/</url>
    <content><![CDATA[题面过于复杂，有一个显然的想法就是让导师们去找学生，设 f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) 表示四个导师选的人数状态下的方案数，转移判断满不满足题目中所给的派系和阵营限制即可，时间复杂度 O(nm4)O(nm^4)O(nm4)，不难发现只需要确定三个即可，时间复杂度 O(nm3)O(nm^3)O(nm3)。然后就不会了。
观察这个 DP 及其难以优化，因为如果我们缺任何一个信息都无法描述完整的子问题，而且复杂度要求的可是 O(nm)O(nm)O(nm)，你只知道一个信息那么肯定啥也导出不了啊。我们考虑发掘几个性质：

确定一个派系和一个阵营可以唯一确定一位导师。
题目中 ban 导师的相当于不选钦定的派系和阵营。

上述性质启示我们让每一个学生去确定它们的派系和阵营，而不是导师去确定学生。但是还有我们的 “坏” 学生，不喜欢选的。我们先丢掉它们，先考虑 k=0k=0k=0 的部分分。
有一个显然的 DP 就是 f(i,j)f(i,j)f(i,j) 表示 iii 个蓝阵营的人，jjj 个鸭阵营的人的方案数，剩余两个可以由这两个状态唯一表示出来，时间复杂度 O(nm2)O(nm^2)O(nm2)，仍无法通过。正解启示 O(nm)O(nm)O(nm)，考虑进一步发掘性质：

题目中学生来自的城市限制，和学校限制是互相独立互不冲突的。

这个性质启发我们分离上面状态设计中的 i,ji,ji,j。那么不妨设 f(i)f(i)f(i) 表示蓝阵营有 iii 个人的方案数，g(i)g(i)g(i) 表示鸭阵营有 iii 个人的方案数，两个答案可以通过乘法原理分别算出来之后乘起来即可，时间复杂度 O(nm)O(nm)O(nm)。
现在考虑 k&gt;0k&gt;0k&gt;0，一个重要的观察是 k≤30k\le 30k≤30。状压、枚举？都不对。我们上面的计算答案过程中体现了乘法原理的思想，也就是说我们也可以分离 “坏学生” 和 “好学生”，好学生单独做，坏学生单独做，最后乘起来即可。
坏学生的限制怎么处理，我们肯定不能用 O(nm)O(nm)O(nm) 的算法了，这个算法肯定是无法处理我们的限制的。回看我们之前 O(nm2)O(nm^2)O(nm2) 的解法，这个就能够很好的处理性质，因为状态能够表示所有派系阵营选择人数，我们可以用这个算法处理坏学生就可以啦。时间复杂度做的话是 O(k2sm)O(k^2sm)O(k2sm) 的。
那么时间复杂度就是 O(nm+k2sm)O(nm+k^2 sm)O(nm+k2sm)。
总结：

我们在设计状态的时候，应当尽量个限制紧密贴合。在优化 DP 的时候我们要考虑我们计算贡献具体需要什么信息，我们需要什么信息就足够了，去掉冗余的无用信息。
题目可能会故意引导你走向死路，如果一个方向想不通，不妨正难则反或换一种方法想，这里体现的是正难则反的思路。

#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2520,MOD=998244353;int F[MN][MN],G[MN][MN],f[MN],g[MN],h[MN],s[MN],b[MN],sumb[MN],sums,n,c,c0,c1,d0,d1,C,K,D,ans;bool hc[MN];void init()&#123;    memset(F,0,sizeof(F));    memset(G,0,sizeof(G));    memset(f,0,sizeof(f));    memset(g,0,sizeof(g));    ans=C=D=0; sums=0;    for(int i=1;i&lt;=n;i++)&#123;        h[i]=-1;        sumb[i]=0;        hc[i]=false;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;c&gt;&gt;c0&gt;&gt;c1&gt;&gt;d0&gt;&gt;d1;    init();    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i]&gt;&gt;s[i];        sums+=s[i];        sumb[b[i]]+=s[i];    &#125;    cin&gt;&gt;K;    for(int i=1;i&lt;=K;i++)&#123;        int x;cin&gt;&gt;x&gt;&gt;h[x];        hc[b[x]]=true;    &#125;    f[0]=1;    for(int i=1;i&lt;=c;i++) if(!hc[i]&amp;&amp;sumb[i])&#123;        for(int j=c0;j&gt;=sumb[i];j--) f[j]=(f[j]+f[j-sumb[i]])%MOD;    &#125;    for(int i=1;i&lt;=c0;i++) f[i]=(f[i-1]+f[i])%MOD;    g[0]=1;    for(int i=1;i&lt;=n;i++) if(h[i]==-1)&#123;        for(int j=d0;j&gt;=s[i];j--) g[j]=(g[j]+g[j-s[i]])%MOD;    &#125;    for(int i=1;i&lt;=d0;i++) g[i]=(g[i-1]+g[i])%MOD;    F[0][0]=1;    for(int ct=1;ct&lt;=c;ct++) if(hc[ct])&#123;        C+=sumb[ct]; C=min(C,c0);        for(int i=0;i&lt;=C;i++) for(int j=0;j&lt;=D;j++) G[i][j]=F[i][j];        for(int x=1;x&lt;=n;x++) if(h[x]!=-1&amp;&amp;b[x]==ct)&#123;            int t=s[x]; D+=t; D=min(D,d0);            if(h[x]==1)&#123;                 for(int i=0;i&lt;=C;i++)&#123;for(int j=D;j&gt;=t;j--) F[i][j]=F[i][j-t]; for(int j=0;j&lt;t;j++) F[i][j]=0;&#125;            &#125;            if(h[x]&gt;=2)&#123;                 for(int i=0;i&lt;=C;i++) for(int j=D;j&gt;=t;j--) F[i][j]=(F[i][j]+F[i][j-t])%MOD;            &#125;            if(h[x]==3)&#123;                 for(int i=0;i&lt;=C;i++)&#123;for(int j=D;j&gt;=t;j--) G[i][j]=G[i][j-t]; for(int j=0;j&lt;t;j++) G[i][j]=0;&#125;            &#125;            if(h[x]&lt;=1)&#123;                 for(int i=0;i&lt;=C;i++) for(int j=D;j&gt;=t;j--) G[i][j]=(G[i][j]+G[i][j-t])%MOD;            &#125;        &#125;        int t=sumb[ct];        if(t&gt;0)&#123;            for(int i=C;i&gt;=t;i--) for(int j=0;j&lt;=D;j++) F[i][j]=F[i-t][j];            for(int i=0;i&lt;t;i++) for(int j=0;j&lt;=D;j++) F[i][j]=0;        &#125;        for(int i=0;i&lt;=C;i++) for(int j=0;j&lt;=D;j++) F[i][j]=(F[i][j]+G[i][j])%MOD;    &#125;    for(int i=0;i&lt;=C;i++) for(int j=0;j&lt;=D;j++)&#123;        int l1=max(0ll,sums-c1-i),r1=c0-i; if(l1&gt;r1) continue;        int l2=max(0ll,sums-d1-j),r2=d0-j; if(l2&gt;r2) continue;        int ret1=f[r1],ret2=g[r2];        if(l1) ret1=(ret1-f[l1-1]+MOD)%MOD;        if(l2) ret2=(ret2-g[l2-1]+MOD)%MOD;        ans=(ans+ret1*ret2%MOD*F[i][j])%MOD;    &#125;    cout&lt;&lt;(ans+MOD)%MOD&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    ios::sync_with_stdio(0);cin.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P7214治疗计划</title>
    <url>/posts/d30abee3/</url>
    <content><![CDATA[把未感染和感染抽象为 0/1，那么原问题可以转化为初始有一个全为 111 的序列，可以在特定时间进行一次区间覆盖操作（有代价），111 会向左右扩散，问能不能将整个序列全部覆盖为 0 且使得操作代价最小。
对于选择区间进行覆盖的问题，这一类经典问题有一种状态设计就是设 f(i)f(i)f(i) 表示将 [1,i][1,i][1,i] 这个前缀进行覆盖的最小代价。但是问题在于这样转移是 O(nm)O(nm)O(nm) 的不太好搞，考虑这个 mmm 的瓶颈就是在于我们需要知道每一个覆盖区间右端点在哪里。考虑切换一下 dp 状态，设 f(i)f(i)f(i) 表示将 [1,ri][1,r_i][1,ri​] 覆盖的最小代价，转移通过 ttt 的偏序关系进行转移：
f(i)←f(j)+cirj−li+1≥∣ti−tj∣\begin{aligned}f(i) &amp; \leftarrow f(j)+c_i &amp; r_j -l_i+1 \ge |t_i -t_j| \end{aligned}
f(i)​←f(j)+ci​​rj​−li​+1≥∣ti​−tj​∣​
时间复杂度还是 O(nm)O(nm)O(nm)，无敌了。而且还自带两个偏序关系更是逆天。但是观察这个 DP 是一个类似于最短路形式的转移（说人话就是转移代价只和目标的代价有关），考虑用 Dijkstra 优化这个 DP。让后绝对值可以通过对 ttt 排序去掉，对于转移可以用线段树优化这个最小值转移，势能分析有时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
这个题目有一个巨大的卡阻就是在于 DP 容易选择会以时间作为主体，这样的话你无论怎么都无法优化掉时间这一维。一开始想的就是 f(i,j)f(i,j)f(i,j) 添加了时间 jjj 这一个维度，但是发现这个枚举时间反而成为了瓶颈。这个时候，我们需要分析，我们知道什么就够了。分析下来 jjj 反而可以从转移中天然的去掉，这样我们就做到了优化 DP 的过程。
#include&lt;bits/stdc++.h&gt;#include &lt;queue&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e5+15,INF=1e18;struct Node&#123;    int l,r,c,t;&#125;a[MN];int n,m,f[MN],ans=INF;bool vis[MN];priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;struct Segment&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,mn[2];    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].mn[0]=min(t[ls].mn[0],t[rs].mn[0]);        t[p].mn[1]=min(t[ls].mn[1],t[rs].mn[1]);    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        t[p].mn[0]=t[p].mn[1]=INF;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);    &#125;    void modify(int p,int pos,int x,int y)&#123;        if(t[p].l==t[p].r)&#123;            t[p].mn[0]=x-y;            t[p].mn[1]=x+y;            return;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) modify(ls,pos,x,y);        else modify(rs,pos,x,y);        pushup(p);    &#125;    void update(int p,int fl,int fr,int op,int v,int w)&#123;        if(t[p].mn[op]&gt;v) return;        if(t[p].l==t[p].r)&#123;            f[t[p].l]=w+a[t[p].l].c;            q.push(pir(f[t[p].l],t[p].l));            t[p].mn[0]=t[p].mn[1]=INF;            return;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) update(ls,fl,fr,op,v,w);        if(mid&lt;fr) update(rs,fl,fr,op,v,w);        pushup(p);    &#125;    #undef ls    #undef rs&#125;sg;bool cmp(Node x,Node y)&#123;    return x.t&lt;y.t;&#125;void dijkstra()&#123;    memset(f,0x3f,sizeof(f));    for(int i=1;i&lt;=m;i++)&#123;        if(a[i].l==1)&#123;            f[i]=a[i].c;            q.push(pir(f[i],i));            sg.modify(1, i, INF, 0);        &#125;else sg.modify(1, i, a[i].l, a[i].t);    &#125;    while(!q.empty())&#123;        auto fr=q.top();        q.pop();        int u=fr.second;        if(vis[u]) continue;        vis[u]=1;        sg.update(1,1,u-1,0,a[u].r-a[u].t+1,f[u]);        sg.update(1,u+1,m,1,a[u].r+a[u].t+1,f[u]);    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;a[i].t&gt;&gt;a[i].l&gt;&gt;a[i].r&gt;&gt;a[i].c;    &#125;    sort(a+1,a+1+m,cmp);    sg.build(1,1,m);    dijkstra();    for(int i=1;i&lt;=m;i++)&#123;        if(a[i].r==n)&#123;            ans=min(ans,f[i]);        &#125;    &#125;    if(ans&gt;=INF) cout&lt;&lt;-1;    else cout&lt;&lt;ans;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P9804_Skwarki题解</title>
    <url>/posts/156c0b37/</url>
    <content><![CDATA[可能更洛谷的阅读体验
好题，写一篇题解记录一下。
首先考虑计数 DP，但是直接做发现不太好做，我们思考能否对删除操作进行进一步转化成好的条件取做。
对于原题目的限制，即只要一个数左右两侧一旦有一个大的就会被删，既有位置限制和数值限制。一步很妙的转化的就是将这个思想转成笛卡尔树，那么删除操作就是在笛卡尔树上删有儿子的点。
我们不妨设 gug_{u}gu​ 表示删空 uuu 子树（包括 uuu 号点）的所需次数，因为题意表明删除操作是同时进行的，不难有如下转移：
gu=max⁡{gls,grs,min⁡(gls,grs)+1}g_{u}=\max\left\{ g_{\text{ls}},g_{\text{rs}},\min(g_{\text{ls}},g_{\text{rs}})+1 \right\}
gu​=max{gls​,grs​,min(gls​,grs​)+1}
其中 ls 表示左儿子，rs 表示右儿子，注意在没有左儿子和右儿子的时候要特判。
方程表明如下情况：

gls,grsg_{\text{ls}},g_{\text{rs}}gls​,grs​：因为操作是并行的，我们可以直接对左右儿子删除操作取 max⁡\maxmax 即可。
某一子树删除完毕后，花一次操作删根节点 uuu 让后把剩下子树接上去。

注意到删除最多删除树的一半节点，也就是当删除操作数量 k≤log⁡(n)k\le \log(n)k≤log(n) 时才可能有解。
验证考虑分类讨论，讨论左右子树操作次数相同和不同的情况即可简明验证。不难发现的一点是答案一定是全局的最大值，并且一定作为叶子节点出现。
接下来我们考虑如何把它搬到计数 DP 上，真的在笛卡尔树上 DP 显然是不现实的，因为树的结构会改变。
我们利用笛卡尔树的性质：我们设一个区间 [l,r][l,r][l,r] 最大值的位置为 pospospos，发现可以把区间分成 [l,pos][l,pos][l,pos]和 [pos,r][pos,r][pos,r] 两个区间，并且两个区间互不影响，也就是说我左边怎么乱搞放数也不会影响右边的区间。这个时候全局最大值作为区间的端点出现。

我们利用笛卡尔树结构的特点，设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示 iii 个元素的排列，恰好 jjj 次删空，全局最大值是否在区间的端点。
对于 f(i,j,0)f(i,j,0)f(i,j,0) 的转移，根据我们上面所述的笛卡尔树的节点，我们需要枚举区间的最大值的位置来进行转移，对于每个位置 kkk 在分配左儿子的方案有 (i−1k−1)\binom{i-1}{k-1}(k−1i−1​) 种方案给乘起来，左儿子 f(k−1,l,0)f(k-1,l,0)f(k−1,l,0) 右儿子 f(i−k,r,0)f(i-k,r,0)f(i−k,r,0)，其中 l,rl,rl,r 是枚举儿子区间最大值的位置，转移即可。
考虑 f(i,j,1)f(i,j,1)f(i,j,1) 的转移，我们不考虑区间端点到底在哪里，因为排列的对称性可以完全统计答案，那么转移只需统计左儿子或者右儿子任一出现最大值的方案数即可，再乘上 (i−1k−1)\binom{i-1}{k-1}(k−1i−1​) 即可。
转移的 jjj 需要通过上面的 ggg 单独计算，答案统计仍枚举最大值转移即可，见代码，时间复杂度 O(n2k2)O(n^{2}k^{2})O(n2k2)。
注意到 kkk 最大为 log⁡(n)\log(n)log(n)，那么时间复杂度就是 O(n2log⁡2n)O(n^2 \log^{2} n)O(n2log2n)，这个复杂度下会被卡常，需要减少取模操作。注意到转移方程可以前缀和优化，那么时间复杂度即为 O(n2log⁡n)O(n^{2} \log n)O(n2logn)，这里就不用关心了。
不同于一些连续段 DP，这种转移的技巧叫做枚举最大值转移，实质就是上面所提到的在笛卡尔树上排列的 DP 结构，这种题类型很少见，但是我可以推荐一道题供大家练习：CF1580B。
#include&lt;bits/stdc++.h&gt;#define int __int128using namespace std;constexpr int MN=1520;int f[MN][MN][2],pw[MN],inv[MN],n,K,nj,MOD;template&lt;typename type&gt;inline type read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();    return flag?x=-x:x;&#125;template&lt;typename type&gt;inline void write(type x)&#123;    x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;    static short Stack[50],top(0);    do Stack[++top]=x%10,x/=10;while(x);    while(top) putchar(Stack[top--]|48);&#125;int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++) pw[i]=pw[i-1]*i%MOD;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;signed main()&#123;    read(n),read(K),read(MOD);    if(K&gt;__lg(n)+1)&#123;        cout&lt;&lt;0;        return 0;    &#125;    init();    f[0][0][0]=f[0][0][1]=1;    for(int i=1;i&lt;n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            for(int l=0;l&lt;=K;l++)&#123;                for(int r=0;r&lt;=K;r++)&#123;                    // l和r枚举两个孩子区间最大值位置                    nj=(l==r)?l+1:max(l,r);// 小 g 的凭借                    f[i][nj][0]=(f[i][nj][0]+f[j-1][l][0]*f[i-j][r][0]*getC(i-1,j-1)%MOD)%MOD;                    nj=max(l,r+1);                    f[i][nj][1]=(f[i][nj][1]+f[j-1][l][1]*f[i-j][r][0]%MOD*getC(i-1,j-1)%MOD)%MOD;                &#125;            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        for(int l=0;l&lt;=K;l++)&#123;            for(int r=0;r&lt;=K;r++)&#123;                if(max(l,r)==K)&#123;                    // 根据方程枚举区间拼接，可以看上面图理解                    ans=(ans+(f[i-1][l][1]*f[n-i][r][1]%MOD*getC(n-1,i-1)%MOD))%MOD;                &#125;            &#125;        &#125;    &#125;    write(ans);    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM后缀自动机学习笔记</title>
    <url>/posts/94c0669/</url>
    <content><![CDATA[ 0.前言
后缀自动机，在字符串算法中居于一种万能的地位，其本体代码编写较简单，优美的 O(n)O(n)O(n) 构建复杂度，是一类极其有用但难以真正理解的字符串后缀结构。笔者投入了大约一周的时间来学习，现在进行总结复习，看看能不能悟到一些新的东西。
同时后缀自动机本身的难度（10 级）决定了理解较难，笔者同时也是这样的感受。我在编写第一二三章节的时候会尽量用图来解释，尽量减少繁杂的符号化语言。必要的也不会省略。
后缀自动机在做习题的时候，需要有非常扎实的 DS 基础以及面向对象程序设计思想，不然在编写的时候就会炸掉（不然大纲为什么要有这个程序设计思想）。
一些基本约定：

本文章默认字符串下标从 111 开始。
我们用打字机字体表示字符串的内容，如：s=wjyppm1403s=\texttt{wjyppm1403}s=wjyppm1403。
拼接：s+ts+ts+t 表示将 ttt 拼接 sss 后。
字符集：即构成字符串中字符的集合。
空串：不含任何字符的字符串称为空串。
子串：在 sss 开头或末尾删去若干字符得到的字符串称作为 sss 的子串，sss 本身和空串也是 sss 的子串。我们定义 s[l,r]s[l,r]s[l,r] 表示 l→rl \to rl→r 上所有字符链接而成子串。
匹配：称 ttt 匹配 sss 当且仅当 ttt 在 sss 中出现。
字符串长度：我们用 ∣s∣|s|∣s∣ 来表示 sss 的长度。

前后缀：

前缀：在 sss 末尾删除若干字符得到的字符串称作 sss 的前缀，记为 preprepre。
后缀：在 sss 开头删除若干字符得到的字符串称作 sss 的后缀，记为 sufsufsuf。
最长公共前缀：LCP⁡(s,t)\operatorname{LCP}(s,t)LCP(s,t)，表示 s,ts,ts,t 的最长公共前缀，即最长的 uuu 使得 uuu 为 s,ts,ts,t 的前缀。最长公共后缀同理，我们称为 LCS⁡(s,t)\operatorname{LCS}(s,t)LCS(s,t)。LCP 的长度格式为：∣LCP⁡(s,t)∣|\operatorname{LCP}(s,t)|∣LCP(s,t)∣。
字典序：定义空字符小于任何字符。称 sss 的 字典序 小于 ttt 当且仅当去掉 LCP⁡(s,t)\operatorname{LCP}(s,t)LCP(s,t) 后，sss 的第一个字符小于 ttt 的第一个字符。等价于以第 iii 个字符作为第 iii 关键字比较。

我们先从概念讲起。
 1. 自动机
自动机，在 OI 中一般我们涉及的是有限状态自动机（DFA），它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以通过输入自动机指令（严谨来说就是字符），让自动机切换到其他的状态。任意时刻状态机只能处在一个状态。
而有限状态机可以表示为一个有向图：

从图中看出来一个信竞复读机（人类的本质是？）一共包含 5 个状态：学信竟，学 whk，吃吃饭，睡睡觉，摸摸鱼。每种带有箭头的连线，表示可以从当前状态切换到其他的状态，以及切换的条件。
我们列个转移表格：




学信竟
学 whk
吃吃饭
睡睡觉
摸摸鱼




学信竟


去机房

摆烂时间到


学 whk
信竟时间到


回去午睡



吃吃饭
去食堂
去教室





睡睡觉

回教室
被吵醒




摸摸鱼



回家




表格中左侧第一列为当前状态。
表格中上方第一行为切换的下一个状态。
表格中每行从左到右为状态切换的条件(状态 A 能不能切换到状态B)。
举例：

学 whk -&gt; 学信竟：条件（信竟时间到）。
学信竟 -&gt; 摸摸鱼：条件（摸鱼时间到）。
摸摸鱼 -&gt; 睡睡觉：条件（回家）。

一个自动机，我们应当还有起始状态，在本图中我们的起始状态是 “睡睡觉”。（不准通宵！）
那为啥叫自动呢，是因为只要输入符号和转移规则确定，状态变化是自动的，自动机可以自己通过设定好的路线（即有向图的边权）来进行转移。自动机的工作方式和流程图类似，但是不同的是自动机每一个节点都是一个判定节点，只是一个单纯的状态而非任务。
我们借用 Oi-Wiki 的例子，例如完成「判断一个二进制数是不是偶数」的自动机如下：

从起始结点开始，从高到低接受这个数的二进制序列，然后看最终停在哪里。如果最终停在红圈结点，则是偶数，否则不是。
而自动机的实质就是：状态集合（点）+ 转移规则（边）。
在竞赛中的应用我们有 AC 自动机，后缀自动机，DP 套 DP 等。
严谨的定义可以看 Oi-Wiki 的讲解，这里不再深入研究：传送门
 2. 后缀自动机
 2.1 概念
后缀自动机（SAM）是能够存储和识别一个字符串 SSS 的所有后缀的自动机。
正如我们上面所提到的自动机的定义，后缀自动机也是一个自动机，把节点看作状态，节点之间连的有向边是状态的转移。我们有一个初始状态 ststst，从 ststst 通过有向边到达其他所有节点，其中有一些状态是终止状态（即自动机到达这个状态后不会在转移）。任意一条从 ststst 出发到达某个终止状态所经过路径上的字符集合是 SSS 的一个子串。不同的路径代表不同的子串，这些路径与 SSS 的子串一一对应，不多也不少。
这么说有点复杂，读者应该知道 Trie 吧，字典树其实也是一个自动机，我们看看字典树的形状，我们借用 OI-Wiki 的图：

那我们回看上面的自动机表示图，你会发现两者十分相似，事实上 Trie 本身也是一个自动机。而我们把字符串所有后缀子串通过字典树的方法建立的一颗树，我们叫做后缀 Trie，后缀 Trie 也可以看作一种简单的后缀自动机：

如上是 S=abcbcS=\texttt{abcbc}S=abcbc 的后缀 Trie，其中绿色节点表示终止节点。算上跟节点需要共 13 个节点，比较浪费空间，原因是因为做了重复存储，如蓝色虚线内圈起来的两个子串是重复的，那么有没有什么更省空间的结构呢？后缀自动机的结构就是我们想要的结构！
SAM 中除了上面的定义，还有一个额外条件：结点数最少。关键就在于如何把上面的图给压缩，压缩点重复的地方。而 SAM 将压缩做到极致，做到 O(n)O(n)O(n) 的节点规模。那么怎么压缩成结点数最少呢？我们把上面的结构用 SAM 的结构表示：

我们把上面后缀 Trie 重复的部分给合并起来，就能够得到上面的一张图。上面的图是一张 DAG，它不仅能表示后缀，还能表示 SSS 的所有子串。任意从初始状态 000 开始的路径，如果我们将路径上的所有转移的标号写下来，都会形成 sss 的一个子串。而每个子串都对应从初始状态开始的某条路径。到达某个状态的路径可能不止一条，在图中也是有表现的，因此我们说一个状态对应一些字符串的集合，这个集合中的字符串分别对应着这些路径。
那么如何得到这个 DAG，这个节点数量是 O(n)O(n)O(n) 的吗。
我尝试建立这个 DAG，每一次我们都尝试添加一个字符，我们从 S=aS=\texttt{a}S=a 开始，每次在上一次的末尾添加一个新的节点

这个 DAG 有多少节点？显然每一次加入节点只会增加 O(1)O(1)O(1) 级别的点数，至少有 n+1n+1n+1 个点，但是实际上我们建 SAM 的点数会出现冲突的情况，这个时候会复制节点，但是最多复制一次，所有实际上最多也只会有 2n2n2n 个节点。
SAM 的每一个节点都对应的是原字符串 sss 的某个子串，读者看图应能自行领会，接下来我们给出几个小定义。

substr⁡(p)\operatorname{substr}(p)substr(p)：表示状态 ppp 所有子串的集合。
shorest⁡(p)\operatorname{shorest}(p)shorest(p)：表示状态 ppp 所有子串长度最短的那一个。
longest⁡(p)\operatorname{longest}(p)longest(p)：表示状态 ppp 所有子串长度最长的那一个。
minlen⁡(p)\operatorname{minlen}(p)minlen(p)：表示状态 ppp 所有子串长度最短的那一个的长度。
len⁡(p)\operatorname{len}(p)len(p)：表示状态 ppp 所有子串长度最长的那一个的长度。

 2.2 Endpos 等价类
endpos 等价类是 SAM 中关键的地方，通过它我们可以高效地进行建图。
我们定义 endpos⁡(t)\operatorname{endpos}(t)endpos(t) 表示字符串 ttt 在 sss 中所有出现的结束位置的集合，例如当 s=&quot;abcbc&quot;s=\texttt{&quot;abcbc&quot;}s=&quot;abcbc&quot; 的时候，endpos⁡(&quot;bc&quot;)={3,5}\operatorname{endpos}(\texttt{&quot;bc&quot;})=\left\{ 3,5\right\}endpos(&quot;bc&quot;)={3,5}，因为 &quot;bc&quot;\texttt{&quot;bc&quot;}&quot;bc&quot; 出现在 sss 的第 3,53,53,5 位置。
我们把 sss 的所有子串的 endpos⁡\operatorname{endpos}endpos 都列出来，有：



子串：
a
b
c
ab
bc
cb
abc
bcb
cbc
abcb
bcbc
abcbc




endpos⁡\operatorname{endpos}endpos
1
2,4
3,5
2
3,5
4
3
4
5
4
5
5



我们定义空串 ∅\varnothing∅ 的 endpos⁡={1,2,3,4,5}\operatorname{endpos}=\left\{ 1,2,3,4,5 \right\}endpos={1,2,3,4,5} 我们按照 endpos 排序如下：



子串
∅\varnothing∅
a
ab
b
abc
bc,c
abcb,bcb,cb
abcbc,bcbc,cbc




endpos⁡\operatorname{endpos}endpos
1,2,3,4,5
1
2
2,4
3
3,5
4
5



我们把 endpos 相等的称之为等价类，如 &quot;c&quot;,&quot;bc&quot;\texttt{&quot;c&quot;},\texttt{&quot;bc&quot;}&quot;c&quot;,&quot;bc&quot; 的enpos 等于 {3,5}\left\{ 3,5 \right\}{3,5} 是等价类。
一个很有趣的事实就是，这样每一个等价类都对应 SAM 的一个状态，读者可以通过 SAM 的图来理解：

接下来我们来阐述 Endpos 等价类所具有的一些特殊性质，endpos 等价类的性质体现的是后缀之间的包含关系。
以下证明来自 Oi-Wiki：

引理 1：同一个等价类中较短子串是较长子串的后缀。

证明是显然成立的，通过定义感性理解：字符串 ttt 在 sss 中所有出现的结束位置的集合。若结束位置相同，那么必然从这个结束位置向左拓展，必然是后缀。

引理 2：对于两个非空子串 u,wu,wu,w，假设 ∣u∣≤∣w∣|u| \le |w|∣u∣≤∣w∣。那么，要么 endpos(u)⁡∩endpos(w)⁡=∅\operatorname{endpos(u)} \cap \operatorname{endpos(w)}=\varnothingendpos(u)∩endpos(w)=∅，要么 endpos⁡(u)⊆endpos⁡(w)\operatorname{endpos}(u) \subseteq \operatorname{endpos}(w)endpos(u)⊆endpos(w)，后者成立当且仅当 uuu 是 www 的后缀。

如果集合 endpos⁡(u)\operatorname{endpos}(u)endpos(u) 与 endpos⁡(w)\operatorname{endpos}(w)endpos(w) 有至少一个公共元素，那么由于字符串 uuu 与 www 在相同位置结束，uuu 是 www 的一个后缀。所以在每次 www 出现的位置，子串 uuu 也会出现。所以 endpos⁡(w)⊆endpos⁡(u)\operatorname{endpos}(w)\subseteq \operatorname{endpos}(u)endpos(w)⊆endpos(u)。

引理 3：同一个等价类中子串长度不等，且依次递增 1，覆盖了从最短到最长的子串的区间。即同一个状态对应的子串的长度各不相同，而且是连续的若干自然数，其中较短的总是较长的子串的后缀。

如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 111 的等价类。
由引理 1，endpos⁡\operatorname{endpos}endpos 相同的两个不同字符串中，必定一长一短，且较短者总是较长者的真后缀。也就是说，等价类中没有等长的字符串。
记 www 为等价类中最长的字符串，uuu 为等价类中最短的字符串。由引理 1，字符串 uuu 是字符串 www 的真后缀。现在考虑长度在区间 [∣u∣,∣w∣][\left|u\right|,\left|w\right|][∣u∣,∣w∣] 中的 www 的任意后缀。容易看出，这个后缀也在同一等价类中，因为这个后缀只能在字符串 sss 中以 www 的一个后缀的形式存在（这是因为较短的后缀 uuu 在 sss 中只以 www 的后缀的形式存在）。因此，由引理 1，这个后缀和字符串 www 的 endpos⁡\operatorname{endpos}endpos 相同。
 2.3 Parent Tree
根据上面 3 个引理，我们知道 endpos 等价类中的子串是具有包含关系，而 SAM 中的节点（或称作状态）就是一个等价类，这样我们通过包含关系把普通后缀树的臃肿给压缩了。
引理 1 和 3 表示了同一个等价类的包含关系，且长度连续，是一个状态就可以表示的。而引理 2 表示状态时如何进行转移的，若 endpos⁡(v)⊆endpos⁡(u)\operatorname{endpos}(v)\subseteq \operatorname{endpos}(u)endpos(v)⊆endpos(u) 我们定义转移方向从 u→vu \to vu→v，即 vvv 是 uuu 的父节点，这里不理解为什么要让大集合向小集合连边可以先了解，后面我们会细说。
下面我们通过 S=&quot;abcbc&quot;S=\texttt{&quot;abcbc&quot;}S=&quot;abcbc&quot; 来建立一颗 SAM。初始状态 t0t_{0}t0​ 是空集 ∅\varnothing∅，每一个节点是一个状态，表示一个 endpos 等价类。这棵树只有 8 个点，少于后缀树的 13 个点，我们把这个树称作为母树，即 Parent 树。

这里借用的是 Oi-Wiki 的图，其中 Parent 树中每一个节点我们选取最长字符串来代表状态。我们把表格复制一下列到下面供参考：



子串
∅\varnothing∅
a
ab
b
abc
bc,c
abcb,bcb,cb
abcbc,bcbc,cbc




endpos⁡\operatorname{endpos}endpos
1,2,3,4,5
1
2
2,4
3
3,5
4
5



Parent 树能够完整表达所有子串，有 5 个叶子节点，而 5 个叶子节点对应的endpos 正好是 1 到 5 的完整位置，从根到一个叶子节点的路径上，包含了以这个位置为终点的所有后缀。如最右边的路径。
Parent 树和 AC 自动机的 Fail 树及其相似，如果你知道什么是 Fail 树的话，可以把 Parent 树看作为 Fail 树的压缩版。
但是这里的 Parent 树并不实用，因为我们 SAM 这要这么建立的话那么对于每一个节点我们要存一堆字符串，空间复杂度会爆炸。如果我们通过路径表示子串，像 Trie 树一样多好，让每一条独立的路径对应一个独立的子串，这样即好添加节点，也可以操作啦。而 SAM 通过用路径表示子串来进行的。
我们根据上面的图不难发现 SAM 和 Parent 树及其相似，但是怎么从 Parent 树转化到 SAM 呢？
 2.4 后缀链接
后缀链接是我们将 SAM 和 Parent 树之间建立的一个桥梁，事实上，构建 SAM 的过程和母树是息息相关的。
考虑 SAM 上的一个不是根的节点 vvv，它的后缀链接（link）定义为它上层的一个节点 uuu，其中 uuu 的等价类所包含的子串也是  所包含的子串的后缀。其实就是上文 Parent 树上每个点的父亲。其作用就是将两个不同节点的连续子串连接起来，如下图的母树补充，vvv 的最短子串长度等于 uuu 的最长字串长度加 1，它们是相邻的两个后缀。

这图糊的已经没救了。
我们再补充几个例子：
endpos(&quot;a&quot;)={1}\mathrm{endpos}(\texttt{&quot;a&quot;}) = \{1\}
endpos(&quot;a&quot;)={1}
endpos(&quot;ab&quot;)={2}endpos(&quot;abcb&quot;, &quot;bcb&quot;, &quot;cb&quot;)={4}⊊endpos(&quot;b&quot;)={2,4}\begin{aligned}
\mathrm{endpos}(\texttt{&quot;ab&quot;}) = \{2\} \\
\mathrm{endpos}(\texttt{&quot;abcb&quot;, &quot;bcb&quot;, &quot;cb&quot;}) = \{4\} \\
\end{aligned}
\subsetneq
\mathrm{endpos}(\texttt{&quot;b&quot;}) = \{2, 4\} endpos(&quot;ab&quot;)={2}endpos(&quot;abcb&quot;, &quot;bcb&quot;, &quot;cb&quot;)={4}​⊊endpos(&quot;b&quot;)={2,4}
endpos(&quot;abc&quot;)={3}endpos(&quot;abcbc&quot;, &quot;bcbc&quot;, &quot;cbc&quot;)={5}⊊endpos(&quot;bc&quot;, &quot;c&quot;)={3,5}\begin{aligned}
\mathrm{endpos}(\texttt{&quot;abc&quot;}) = \{3\} \\
\mathrm{endpos}(\texttt{&quot;abcbc&quot;, &quot;bcbc&quot;, &quot;cbc&quot;}) = \{5\} \\
\end{aligned}
\subsetneq
\mathrm{endpos}(\texttt{&quot;bc&quot;, &quot;c&quot;}) = \{3, 5\}endpos(&quot;abc&quot;)={3}endpos(&quot;abcbc&quot;, &quot;bcbc&quot;, &quot;cbc&quot;)={5}​⊊endpos(&quot;bc&quot;, &quot;c&quot;)={3,5}
每个节点有且仅有一个后缀链接，沿着后缀链接往上走对应的后缀长度会连续变短，最后到达根，。即，一条从根出发到某个节点的后缀链，表达了一个完整的后缀组合，这是母树的本质。后缀链接构成的树本质上是 endpos⁡\operatorname{endpos}endpos 集合构成的一棵树。我们从小集合往大集合建边我们充分利用了 endpos 集合中长度单调递增 1 的性质，并且使得具有上面后缀链的性质。
类似于 AC 自动机的甜蜜组合 Trie+Fail，我们 SAM 就是把转移图和 Parent 树给融合到一起的究极形态。
 2.5 构建 SAM
构建的核心思想就是我们前面提到过的增量发，我们在 s[1,i−1]s[1,i-1]s[1,i−1] 的基础上的 SAM 进行更新，从而得到 s[1,i]s[1,i]s[1,i] 的 SAM。构建 SAM 只需要 3 个步骤：

打开 SAM。
插一个字符。
关上 SAM。

冰箱梗，读者不难看出 SAM 的构建是在线算法，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护 SAM。
建立 SAM 的关键在于：

起点和终点之间的边代表在当前的字符串后添加一个字符。
从根到达图中任意路径形成的子串都是 SSS 中的一个子串。
要保证每个点的所有字串属于一个 endpos 等价类。
要符合 Parent 树的父子关系。

我们这里先给出代码实现与算法流程，让后再逐步说明原理。
一开始我们钦定 SAM 中有一个根节点 t0t_{0}t0​，编号就是 0，定义 len⁡(t0)=0,link⁡(t0)=−1\operatorname{len}(t_{0})=0,\operatorname{link}(t_{0})=-1len(t0​)=0,link(t0​)=−1。
让后我们考虑添加一个字符 ccc 拓展 SAM。

令 lstlstlst 为添加 ccc 之前整个字符串 SSS 所对应的节点（即上一个所更新的节点）。
创建一个新的状态，并将 len⁡(cur)=len⁡(lst)+1\operatorname{len}(cur)=\operatorname{len}(lst)+1len(cur)=len(lst)+1。
从 lstlstlst 开始遍历遍历后缀链接，如果当前结点 vvv 没有标记字符 ccc 的出边，创建一条 v→curv\to curv→cur 的边，标记为 ccc。
如果遍历到了 t0t_{0}t0​，令 link⁡(cur)=0\operatorname{link}(cur)=0link(cur)=0，跳到第 8 步。
如果当前结点 vvv 已经有了标记字符 ccc 的出边，停止遍历，并把这个结点标记为 ppp，标记 ppp 沿着标记字符 ccc 的出边到达的点为 qqq。
如果 len⁡(p)+1=len⁡(q)\operatorname{len}(p)+1=\operatorname{len}(q)len(p)+1=len(q)，令 link⁡(cur)=q\operatorname{link}(cur)=qlink(cur)=q，跳到第 8 步。
否则，复制状态 qqq 到一个新的状态里 nqnqnq（包括 link 与它在 DAG 上的出边），将 len⁡(nq)=len⁡(p)+1\operatorname{len}(nq)=\operatorname{len}(p)+1len(nq)=len(p)+1。赋值之后在令 link⁡(q)=nq,link⁡(cur)=nq\operatorname{link}(q)=nq,\operatorname{link}(cur)=nqlink(q)=nq,link(cur)=nq。从 ppp 遍历后缀链接，设当前遍历到的点为 vvv，若 vvv 有标记为 ccc 的出边且 v→qv\to qv→q，则重定向这条边为 v→nqv \to nqv→nq。若 vvv 没有标记为 ccc 的出边或者 vvv 的标记为 ccc 的出边所到达的点不是 qqq ，停止遍历，转 8。
令 lst=curlst=curlst=cur，结束。

代码实现如下：
int newnode()&#123;    int cur=++tot;    memset(nxt[cur],0,sizeof(nxt[cur]));    return cur;&#125;int clone(int from)&#123;    int cur=++tot;    fa[cur]=fa[from];    memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));    return cur;&#125;void extend(int c)&#123;    int cur=newnode(); //步骤1    len[cur]=len[lst]+1;//步骤2    int p=lst;    while(p!=-1&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];//步骤3    if(p==-1) fa[cur]=0;//步骤4    else&#123;        int q=nxt[p][c];//步骤5        if(len[q]==len[p]+1) fa[cur]=q;//步骤6        else&#123;//步骤7            int nq=clone(q);            len[nq]=len[p]+1;            fa[q]=fa[cur]=nq;            while(p!=-1&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];        &#125;    &#125;    lst=cur;//步骤8&#125;
关于每一步的解释，大家可以去看后缀自动机(SAM)奶妈式教程 - ZTer 的教程，这里就不再详细展开了，以防篇幅过长。
实现代码如下：
struct SAM&#123;    int nxt[MN][26],fa[MN],len[MN],tot,lst;    vector&lt;int&gt; adj[MN];    void init()&#123;        tot=0;        lst=0;        fa[0]=-1;        len[0]=0;        memset(nxt[0],0,sizeof(nxt[0]));        cnt_init[0]=0;    &#125;    int newnode()&#123;        int cur=++tot;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=++tot;        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    void extend(int c)&#123;        int cur=newnode();        len[cur]=len[lst]+1;        int p=lst;        while(p!=-1&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(p==-1) fa[cur]=0;        else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1) fa[cur]=q;            else&#123;                int nq=clone(q);                len[nq]=len[p]+1;                while(p!=-1&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];                fa[q]=fa[cur]=nq;            &#125;        &#125;        lst=cur;    &#125;    void inittree()&#123;// 构建 link 树        for(int i=0;i&lt;=tot;i++)&#123;            adj[i].clear();            cnt[i]=-1;        &#125;        for(int i=1;i&lt;=tot;i++)&#123;            adj[fa[i]].push_back(i);        &#125;    &#125;&#125;sam;
 3. 广义后缀自动机
这里讲的是在线做法，因为在线做法只需要在原先的板子上更改一下就可以了。
广义后缀自动机是后缀自动机的升级版，可以同时表示多个字符串所有字串集合的数据结构。
而假的在线构建方法及其简单，就是插入完一个字符串后把 lastlastlast 指针指向根节点，接着插就可以了，但是这样构建的 SAM 虽然能用，但是并不满足前面我们所提过的最小结构。具体来说，有以下两种情况：

一个等价类被拆成若干个节点，子串信息被分散。
出现空节点。

注意到上面的节点的问题在于重复的前缀会被拆分或者重复创建新节点。我们可以通过在 expand 函数中添加特判，重复的前缀会被特判处理到，这样我们就可以对了。
以下是 expand 代码：
int extend(int c,int lst)&#123;    if(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]+1) return nxt[lst][c]; // / 如果节点已经存在，且 len 值相对应，即连续转移，则直接转移。    int cur=newnode(),p=lst,flag=0,q,nq;    len[cur]=len[p]+1;    while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];    if(!p)&#123;        fa[cur]=1;    &#125;else&#123;        q=nxt[p][c];        if(len[q]==len[p]+1)&#123;            fa[cur]=q;        &#125;else&#123;            if(p==lst) flag=1,cur=0,tot--;            nq=clone(q);            len[nq]=len[p]+1;            fa[q]=fa[cur]=nq;            while(p&amp;&amp;nxt[p][c]==q)&#123;                nxt[p][c]=nq;                p=fa[p];            &#125;        &#125;    &#125;    return flag?nq:cur; //// 如果 len[las][it] 存在，则 cur 是空壳，返回 nq 即可&#125;
上面的方法本质就是对匹配串建出 trie 后进行 dfs 构建 SAM。
 4. 常用技巧与结论
 求本质不同子串个数
根据 SAM 的性质，每一个字串对应的是唯一一个状态，那么答案就是 len⁡(p)−len⁡(fap)\operatorname{len}(p)-\operatorname{len}(fa_{p})len(p)−len(fap​)。其中 fapfa_{p}fap​ 表示 link 树上 ppp 状态的父亲。
 线段树合并维护 endpos 集合。
有一些题目我们需要知道 endpos 集合内的内容具体是什么，以刻画每个子串在字符串中所有出现位置的信息。
根据上面所提到的，endpos 集合构建出来的树就是 link 树。为此，我们可以通过在 link 树上进行线段树合并的方式可以得到每个状态的 endpos 集合。
同时注意，线段树合并会破坏原有线段树的结构，如果我们需要保留每一个节点的 endpos 集合的话，我们线段树合并的形式应当是新建节点的方式而不是在原有结构直接复制的方式。
 快速定位一个子串的对应状态
给定区间 [l,r][l,r][l,r]，求 s[l,r]s_{[l,r]}s[l,r]​ 在 SAM 上对应的状态，在构建 SAM 时候像 AC 自动机一样预处理 s[1,i]s_{[1,i]}s[1,i]​ 所表示的状态 posipos_iposi​，我们从 posrpos_rposr​ 上倍增二分找到第一个 len≥r−l+1len \ge r-l+1len≥r−l+1 的状态，这个状态就是我们所求的状态。
 桶排确定 dfs 顺序
link 树上父亲的 len 值一定小于儿子的，但编号小的不一定 len 也小！考虑对于所有结点按照 len 值从大到小进行桶排序，让后按照顺序合并每个状态及其父亲，效果等同于 link 树自底向上合并信息的过程。
 5. 实战演练
 P3804 【模板】后缀自动机 (SAM)
答案就是 ∑∣endpos⁡(p)∣≥2len⁡(p)×∣endpos⁡(p)∣\sum\limits_{|\operatorname{endpos}(p)|\ge 2} \operatorname{len}(p)\times |\operatorname{endpos}(p)|∣endpos(p)∣≥2∑​len(p)×∣endpos(p)∣，求出 endpos 集合大小即可，具体怎么求可以看代码：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=3e6+15;int n;ll ans;string s;struct SAM&#123;    int nxt[MN][26],fa[MN],len[MN],cnt[MN],tot,lst;    int cnt_init[MN];    vector&lt;int&gt; adj[MN];    void init()&#123;        tot=0;        lst=0;        fa[0]=-1;        len[0]=0;        memset(nxt[0],0,sizeof(nxt[0]));        cnt_init[0]=0;    &#125;    int newnode()&#123;        int cur=++tot;        cnt_init[cur]=1;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=++tot;        fa[cur]=fa[from];        cnt_init[cur]=0;        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    void extend(int c)&#123;        int cur=newnode();        len[cur]=len[lst]+1;        int p=lst;        while(p!=-1&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(p==-1) fa[cur]=0;        else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1) fa[cur]=q;            else&#123;                int nq=clone(q);                len[nq]=len[p]+1;                while(p!=-1&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];                fa[q]=fa[cur]=nq;            &#125;        &#125;        lst=cur;    &#125;    void inittree()&#123;        for(int i=0;i&lt;=tot;i++)&#123;            adj[i].clear();            cnt[i]=-1;        &#125;        for(int i=1;i&lt;=tot;i++)&#123;            adj[fa[i]].push_back(i);        &#125;    &#125;    int dfs(int u)&#123;        if(cnt[u]!=-1) return cnt[u];        int sum=cnt_init[u];        for(auto v:adj[u])&#123;            sum+=dfs(v);        &#125;        cnt[u]=sum;        if(cnt[u]!=1)&#123;            ans=max(ans,1ll*cnt[u]*len[u]);        &#125;        return cnt[u];    &#125;&#125;sam;int main()&#123;    cin&gt;&gt;s;    n=s.length();    s=&quot; &quot;+s;    sam.init();    for(int i=1;i&lt;=n;i++)&#123;        sam.extend(s[i]-&#x27;a&#x27;);    &#125;    sam.inittree();    sam.dfs(0);    cout&lt;&lt;ans;    return 0;&#125;
 P6139 【模板】广义后缀自动机（广义 SAM）
本质不同子串个数我们已经提到过了，这里不再叙述。
直接放个板子：
struct gySAM&#123;    int nxt[MN][26],fa[MN],pos[MN],len[MN],tot;    vector&lt;int&gt; adj[MN];    void init()&#123;        for(int i=0;i&lt;=tot;i++)&#123;            adj[i].clear();            fa[i]=pos[i]=len[i]=0;            memset(nxt[i],0,sizeof(nxt[i]));        &#125;        tot=1;    &#125;    gySAM()&#123;        init();    &#125;    int newnode()&#123;        int cur=++tot;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=++tot;        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    int extend(int c,int lst)&#123;        if(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]+1) return nxt[lst][c];        int cur=newnode(),p=lst,flag=0,q,nq;        len[cur]=len[p]+1;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                if(p==lst) flag=1,cur=0,tot--;                nq=clone(q);                len[nq]=len[p]+1;                fa[q]=fa[cur]=nq;                while(p&amp;&amp;nxt[p][c]==q)&#123;                    nxt[p][c]=nq;                    p=fa[p];                &#125;            &#125;        &#125;        return flag?nq:cur;    &#125;    void inittree()&#123;        for(int i=2;i&lt;=tot;i++)&#123;            adj[fa[i]].push_back(i);        &#125;    &#125;    void insert(string s)&#123;        int len=s.length(),lst=1;        s=&quot; &quot;+s;        for(int i=1;i&lt;=len;i++)&#123;            lst=extend(s[i]-&#x27;a&#x27;,lst);        &#125;    &#125;&#125;sam;
 P4070 [SDOI2016]生成魔咒
答案就是 len⁡(p)−len⁡(fap)\operatorname{len}(p)-\operatorname{len}(fa_{p})len(p)−len(fap​)。其中 fapfa_{p}fap​ 表示 link 树上 ppp 状态的父亲。
void extend(int c)&#123;    int cur=++tot;    len[cur]=len[lst]+1;    cnt_init[cur]=1;    nxt[cur].clear();    int p=lst;    while(p!=-1&amp;&amp;!nxt[p][c])&#123;        nxt[p][c]=cur;        p=fa[p];    &#125;    if(p==-1) fa[cur]=0;    else&#123;        int q=nxt[p][c];        if(len[q]==len[p]+1)&#123;            fa[cur]=q;        &#125;        else&#123;            int nq=++tot;            len[nq]=len[p]+1;            nxt[nq]=nxt[q];            fa[nq]=fa[q];            cnt_init[nq]=0;            while(p!=-1&amp;&amp;nxt[p][c]==q)&#123;                nxt[p][c]=nq;                p=fa[p];            &#125;            fa[q]=fa[cur]=nq;        &#125;    &#125;    lst=cur;    ans+=len[cur]-len[fa[cur]];&#125;
其中 cnt_init 没有任何用，只是复制板子复制上的。
 P4022 [CTSC2012]熟悉的文章
典。
战术二分答案 midmidmid，问题转化为判断这个 LLL 是否可行，考虑 DP。设 fif_{i}fi​ 表示文章 iii 前缀最长符合限制的匹配长度，有转移方程：
fi=max⁡{fj+i−(j+1)+1,fi−1}j∈[i−mxlen(i),i−mid]\begin{aligned}f_{i} &amp; =\max \{ f_{j}+i-(j+1)+1,f_{i-1} \} &amp; j \in [i-mxlen(i),i-mid]\end{aligned}
fi​​=max{fj​+i−(j+1)+1,fi−1​}​j∈[i−mxlen(i),i−mid]​
其中 mxlenmxlenmxlen 表示以 iii 为结尾的字符串出现在模板串中的最长长度，用 SAM 类似于 LCS 的方法即可。
转移是 O(n2)O(n^2)O(n2) 的，可以通过单调队列优化成 O(n)O(n)O(n)。时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MN = 5e5 + 15;int n, m, len, f[MN], ql, qr, q[MN], L[MN];struct SAM &#123;    int nxt[MN][3], fa[MN], cnt[MN], len[MN], cnt_init[MN], tot, lst;    void init() &#123;        tot = lst = 0;        fa[0] = -1;        len[0] = 0;        memset(nxt[0], 0, sizeof(nxt[0]));        cnt_init[0] = 0;    &#125;    void find(string s, int slen) &#123;        int p = 0, now = 0;        for (int i = 0; i &lt; slen; i++) &#123;            int x = s[i] - &#x27;0&#x27;;            if (x &lt; 0 || x &gt; 1) continue;            if (nxt[p][x]) &#123;                now++;                p = nxt[p][x];            &#125; else &#123;                for (; p != -1 &amp;&amp; !nxt[p][x]; p = fa[p]);                if (p == -1) p = 0, now = 0;                else now = len[p] + 1, p = nxt[p][x];            &#125;            L[i + 1] = now;        &#125;    &#125;    void extend(int c) &#123;        int cur = ++tot;        len[cur] = len[lst] + 1;        cnt_init[cur] = 1;        memset(nxt[cur], 0, sizeof(nxt[cur]));        int p = lst;        while (p != -1 &amp;&amp; !nxt[p][c]) &#123;            nxt[p][c] = cur;            p = fa[p];        &#125;        if (p == -1) &#123;            fa[cur] = 0;        &#125; else &#123;            int q = nxt[p][c];            if (len[q] == len[p] + 1) &#123;                fa[cur] = q;            &#125; else &#123;                int nq = ++tot;                len[nq] = len[p] + 1;                memcpy(nxt[nq], nxt[q], sizeof(nxt[q]));                fa[nq] = fa[q];                cnt_init[nq] = 0;                while (p != -1 &amp;&amp; nxt[p][c] == q) &#123;                    nxt[p][c] = nq;                    p = fa[p];                &#125;                fa[q] = fa[cur] = nq;            &#125;        &#125;        lst = cur;    &#125;&#125; sam;bool check(int mid) &#123;    int ql = 0, qr = -1;    for (int i = 0; i &lt;= mid - 1; i++) f[i] = 0;    for (int i = mid; i &lt;= len; i++) &#123;        f[i] = f[i - 1];        while (ql &lt;= qr &amp;&amp; (f[i - mid] - (i - mid)) &gt; (f[q[qr]] - q[qr])) qr--;        q[++qr] = i - mid;        while (ql &lt;= qr &amp;&amp; q[ql] &lt; (i - L[i])) ql++;        if (ql &lt;= qr) f[i] = max(f[i], f[q[ql]] - q[ql] + i);    &#125;    return f[len] * 10 &gt;= len * 9;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    sam.init();    for (int i = 1; i &lt;= m; i++) &#123;        string s;        cin &gt;&gt; s;        for (auto c : s) &#123;            sam.extend(c - &#x27;0&#x27;);        &#125;        sam.extend(2);     &#125;    for (int i = 1; i &lt;= n; i++) &#123;        string s;        cin &gt;&gt; s;        len = s.length();        sam.find(s, len);        int l = 1, r = len+1;        while (l + 1 &lt; r) &#123;            int mid = (l + r) &gt;&gt; 1;            if (check(mid)) &#123;                l = mid;            &#125; else &#123;                r = mid;            &#125;        &#125;        cout &lt;&lt; l &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;
 SP8093 JZPGYZ - Sevenk Love Oimaster
重要结论，SAM 上暴力跳链是 O(nn)O(n\sqrt{n})O(nn​) 的，下面是证明：
设一个串长度为 LLL，那么覆盖 L2L^2L2 的路径长度；同时又有SAM一个节点最多被覆盖后缀树上儿子个数次，因此这个上限是 ∣S∣|S|∣S∣（SAM大小）
那么跳链的复杂度就是 min⁡(L2,∣S∣)=L⋅min⁡(L,∣S∣L)\min(L^2,|S|)=L\cdot \min(L,\dfrac{|S|}{L})min(L2,∣S∣)=L⋅min(L,L∣S∣​) 的，由均值不等式不难得出不超过 S\sqrt{S}S​。
把所有串丢进广义SAM，对每一个节点打标记，记录组后一次它暴力跳到的串的编号。如果已经相同就不跳了。对于每一个询问，沿着转移边走，走到终止节点的覆盖次数即为答案。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=5e6+15;struct Query&#123;    int l,r,id;&#125;;int n,m,pre[MN],ans[MN];vector&lt;int&gt; adj[MN];vector&lt;int&gt; col[MN];vector&lt;Query&gt; qry;struct gySAM&#123;    int nxt[MN][26],fa[MN],pos[MN],len[MN],cnt[MN],tot;    int cnt_init[MN];    void init()&#123;        for(int i=0;i&lt;=tot;i++) adj[i].clear();        tot=1; // 初始状态设为1        fa[1]=-1;        len[1]=0;        memset(nxt[1],0,sizeof(nxt[1]));        cnt_init[1]=0;    &#125;    int extend(int c,int lst)&#123;        if(nxt[lst][c] &amp;&amp; len[nxt[lst][c]] == len[lst]+1) return nxt[lst][c];        int cur=++tot;        len[cur]=len[lst]+1;        cnt_init[cur]=1;        memset(nxt[cur],0,sizeof(nxt[cur]));        int p=lst;        while(p != -1 &amp;&amp; !nxt[p][c])&#123;            nxt[p][c]=cur;            p=fa[p];        &#125;        if(p == -1) fa[cur]=1; // 初始状态是1        else&#123;            int q=nxt[p][c];            if(len[q] == len[p]+1) fa[cur]=q;            else&#123;                int nq=++tot;                len[nq]=len[p]+1;                memcpy(nxt[nq],nxt[q],sizeof(nxt[q]));                fa[nq]=fa[q];                cnt_init[nq]=0;                while(p != -1 &amp;&amp; nxt[p][c]==q)&#123;                    nxt[p][c]=nq;                    p=fa[p];                &#125;                fa[q]=fa[cur]=nq;            &#125;        &#125;        return cur;    &#125;    void inittree()&#123;        for(int i=0;i&lt;=tot;i++) adj[i].clear();        for(int i=2;i&lt;=tot;i++) adj[fa[i]].push_back(i);    &#125;&#125;sam;struct BIT&#123;    int t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void modify(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;namespace Tree&#123;    int siz[MN],dfn[MN],id[MN],dtot;    void dfs(int u,int pre)&#123;        dfn[u]=++dtot;        id[dtot]=u;        siz[u]=1;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs(v,u);            siz[u]+=siz[v];        &#125;    &#125;&#125;using namespace Tree;bool cmp(Query x,Query y)&#123;    return x.r&lt;y.r;&#125;int main()&#123;    sam.init();    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        int lst=1; // 初始状态设为1        for(auto c:s)&#123;            lst=sam.extend(c-&#x27;a&#x27;,lst);            col[lst].push_back(i);        &#125;    &#125;    sam.inittree();    dtot=0;    dfs(1,-1); // DFS根节点设为1    for(int i=1;i&lt;=m;i++)&#123;        string s;        cin&gt;&gt;s;        int p=1; // 初始状态设为1        for(auto c:s)&#123;            p=sam.nxt[p][c-&#x27;a&#x27;];            if(!p) break;        &#125;        if(p)&#123;            qry.push_back(&#123;dfn[p],dfn[p]+siz[p]-1,i&#125;);        &#125;    &#125;    sort(qry.begin(),qry.end(),cmp);    int current_p=1; // 维护全局的current_p    for(auto q:qry)&#123;        while(current_p &lt;= q.r)&#123;            int u=id[current_p];            for(auto c:col[u])&#123;                if(pre[c]) bit.modify(pre[c],-1);                bit.modify(current_p,1);                pre[c]=current_p;            &#125;            current_p++;        &#125;        ans[q.id]=bit.query(q.r)-bit.query(q.l-1);    &#125;    for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 P3649 [APIO2014] 回文串
首先建 SAM，让后跑 manacher，一旦出现回文串我们就放到 SAM 上查询。
现在问题转化为快速查询一个字串的出现次数，用上面我们提到的技巧倍增二分即可，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
也有纯 SAM 的，但是理解过于复杂，看不懂 www。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=6e5+15;int n,m,r[MN],poss[MN];long long ans;int pre[20][MN];char p[MN];string s;struct SAM&#123;    int nxt[MN][26],len[MN],c[MN],cnt[MN],id[MN],pos[MN],fa[MN],tot,lst;    void init()&#123;        tot=lst=1;    &#125;    int newnode()&#123;        int cur=++tot;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=newnode();        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    void expand(int c)&#123;        int cur=newnode();        len[cur]=len[lst]+1;        cnt[cur]=1;        int p=lst;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                int nq=clone(q);                len[nq]=len[p]+1;                fa[cur]=fa[q]=nq;                while(p&amp;&amp;nxt[p][c]==q)&#123;                    nxt[p][c]=nq,p=fa[p];                &#125;            &#125;        &#125;        lst=cur;    &#125;    void getcnt()&#123;        for(int i=1;i&lt;=tot;i++) c[len[i]]++;        for(int i=1;i&lt;=n;i++) c[i]+=c[i-1];        for(int i=1;i&lt;=tot;i++) id[c[len[i]]--]=i;        for(int i=tot;i&gt;=1;i--)&#123;            cnt[fa[id[i]]]+=cnt[id[i]];        &#125;    &#125;    void initst()&#123;        for(int i=1;i&lt;=tot;i++) pre[0][i]=fa[i];        for(int i=1;i&lt;20;i++)&#123;            for(int j=1;j&lt;=tot;j++)&#123;                pre[i][j]=pre[i-1][pre[i-1][j]];            &#125;        &#125;    &#125;    void find(int l,int r)&#123;        if(l&lt;1||r&gt;n) return;        int slen=r-l+1,now=pos[r];        for(int i=19;i&gt;=0;i--)&#123;            if(pre[i][now]&amp;&amp;len[pre[i][now]]&gt;=slen) now=pre[i][now];        &#125;        ans=max(ans,1ll*cnt[now]*(r-l+1));    &#125;    &#125;sam;void manacher()&#123;    p[++m]=&#x27;@&#x27;;    for(int i=1;i&lt;=n;i++)&#123;        p[++m]=&#x27;#&#x27;;        p[++m]=s[i];        poss[m]=i;    &#125;    p[++m]=&#x27;#&#x27;,p[++m]=&#x27;$&#x27;;    int pos=0,mx=0;    for(int i=1;i&lt;=m;i++)&#123;        if(i&lt;mx) r[i]=min(mx-i,r[pos*2-i]);        else r[i]=1;        sam.find(poss[i-r[i]+2],poss[i+r[i]-2]);        while(p[i-r[i]]==p[i+r[i]])&#123;            r[i]++;            sam.find(poss[i-r[i]+2],poss[i+r[i]-2]);        &#125;        if(i+r[i]&gt;mx)&#123;            mx=i+r[i],pos=i;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;s;    sam.init();    n=s.length();    s=&quot; &quot;+s;    for(int i=1;i&lt;=n;i++)&#123;        sam.expand(s[i]-&#x27;a&#x27;);        sam.pos[i]=sam.lst;    &#125;    sam.initst();    sam.getcnt();    manacher();    cout&lt;&lt;ans;    return 0;&#125;
 P5546 [POI 2000] 公共串
战术建立广义 SAM，所有串的最长公共子串长度肯定不会超过最短的那个串，所以可以拿最短的那个串建机，然后把其他串放到上面匹配，让后记录每一个点经过的最小值，让后答案就是节点最小值的最大值。
 CF1037H Security
战术建立 SAM，对于每个询问串，我们要在原串中求出一个字典序最小的串，使得其字典序比他大。考虑在 SAM 的 DAG 转移图上贪心从小到大选取点走，同时还需要利用线段树合并来判断当前字符串是否作为 [l,r][l,r][l,r] 的子串出现过，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
Submission #327862208 - Codeforces
 CF700E Cool Slogans
神仙结论题。
link 树有一个结论，若 ppp 是 qqq 的祖先，则状态 ppp 所表示的子串集合在 longest⁡(q)\operatorname{longest}(q)longest(q) 中出现次数与出现位置相同。
既然都这么说了，考虑建立 SAM，在 link 树上从根向下进行 dp，设 fif_{i}fi​ 表示到节点 iii 时最大值。
如果一个父节点的子串在子节点的子串中出现了至少两次，则转移时 fff 加一，否则不变。
考虑如何判断至少出现两次，根据我们上面的结论，出现次数与出现位置相同。考虑设此时节点为 xxx，那么找到 xxx 对应的 endpos 中任意一个位置 pospospos，则 pospospos 的子串一定在 link 树父亲节点出现了一次，那么我们只需要在 [pos−len(x)+len(fax),pos−1][pos-len(x)+len(fa_{x}),pos-1][pos−len(x)+len(fax​),pos−1] 中出现即可，用线段树合并可以轻松解决，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
Submission #327902686
 UVA1673 数字子串的和 str2int 
建立广义后缀自动机，让后现在问题是计数，考虑 link 树上计数 DP。
设 fif_{i}fi​ 表示 SAM 上点 iii 代表的转台结尾的数字之和，gig_{i}gi​ 表示不同的数字数目。
有转移：
gy=∑nxt[x][c]=ygxg_{y}=\sum\limits_{nxt[x][c]=y} g_{x}
gy​=nxt[x][c]=y∑​gx​
fy∑nxt[x][c]=yfx×10+gx×cf_{y}\sum\limits_{nxt[x][c]=y} f_{x}\times 10+g_{x}\times c
fy​nxt[x][c]=y∑​fx​×10+gx​×c
初始化 f[1]=0,g[1]=1f[1]=0,g[1]=1f[1]=0,g[1]=1，答案即为 ∑fi\sum\limits f_{i}∑fi​。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15,MOD=2012;int n,f[MN],g[MN];struct gySAM&#123;    int nxt[MN][26],c[MN],id[MN],fa[MN],len[MN],mxl,tot;    vector&lt;int&gt; adj[MN];    void init()&#123;        for(int i=0;i&lt;=tot;i++)&#123;            adj[i].clear();            fa[i]=g[i]=f[i]=len[i]=c[i]=id[i]=0;            memset(nxt[i],0,sizeof(nxt[i]));        &#125;        tot=1;        mxl=0;        g[1]=1;    &#125;    gySAM()&#123;        init();    &#125;    int newnode()&#123;        int cur=++tot;        f[cur]=g[cur]=0;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=newnode();        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    int extend(int c,int lst)&#123;        if(nxt[lst][c]&amp;&amp;len[nxt[lst][c]]==len[lst]+1) return nxt[lst][c];        int cur=newnode(),p=lst,flag=0,q,nq;        len[cur]=len[p]+1;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                if(p==lst) flag=1,cur=0,tot--;                nq=clone(q);                len[nq]=len[p]+1;                fa[q]=fa[cur]=nq;                while(p&amp;&amp;nxt[p][c]==q)&#123;                    nxt[p][c]=nq;                    p=fa[p];                &#125;            &#125;        &#125;        return flag?nq:cur;    &#125;    void insert(string s)&#123;        int len=s.length(),lst=1;        s=&quot; &quot;+s;        mxl=max(mxl,len);        for(int i=1;i&lt;=len;i++)&#123;            lst=extend(s[i]-&#x27;0&#x27;,lst);        &#125;    &#125;    void initc()&#123;		for(int i=1; i&lt;=tot; ++i) c[len[i]]++;		for(int i=0; i&lt;=mxl; ++i) c[i]=0;		for(int i=1; i&lt;=tot; ++i) c[len[i]]++;		for(int i=1; i&lt;=mxl; ++i) c[i]+=c[i-1];		for(int i=1; i&lt;=tot; ++i) id[c[len[i]]--]=i;        &#125;    void solve()&#123;        for(int i=1;i&lt;=tot;i++)&#123;            int u=id[i];            cerr&lt;&lt;u&lt;&lt;&quot; &quot;;            for(int j=0;j&lt;10;j++)&#123;                if((u==1&amp;&amp;!j)||!nxt[u][j]) continue;                (f[nxt[u][j]]+=g[u]*j+f[u]*10)%=MOD;                (g[nxt[u][j]]+=g[u])%=MOD;            &#125;        &#125;    &#125;&#125;sam;void solve()&#123;    sam.init();    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        sam.insert(s);    &#125;    sam.initc();    sam.solve();    int ans=0;    for(int i=1;i&lt;=sam.tot;i++) (ans+=f[i])%=MOD;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    while(cin&gt;&gt;n)&#123;        solve();    &#125;    return 0;&#125;
 CF666E Forensic Examination
SAM 技巧大集合。首先考虑建出 s,tis,t_{i}s,ti​ 的广义 SAM，目标是查询 SSS 的子串在模板串区间的哪个串里出现次数最多。由于查询的是一个区间次数，考虑线段树合并维护，让后子串查询状态可以用倍增二分的技巧跳到对应状态在线段树上查询最大值就可以了。时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
Submission #327723329 - Codeforces
 P5576 [CmdOI2019] 口头禅 - 洛谷
command_block 题解
做法 3 好写，真的。
 P8368 [LNOI2022] 串 - 洛谷
题解：P8368 [LNOI2022] 串 - 洛谷专栏 我的题解不是因为我不想复制，篇幅过长。
 6. 后言
留一点练习题：

轻重子树分治：P4482 [BJWC2018] Border 的四种求法 - 洛谷
后缀树优化建图：P5284 [十二省联考 2019] 字符串问题 - 洛谷
线段树合并：P4770 [NOI2018] 你的名字 - 洛谷
LCT 在 link 树的应用（不会的可以用 ODT）：P6292 区间本质不同子串个数 - 洛谷
性质套 SAM：P3346 [ZJOI2015]诸神眷顾的幻想乡
第 kkk 小：P3975 [TJOI2015]弦论

 参考

罗勇军的《算法竞赛》
常见字符串算法 II：自动机相关 - qAlex_Weiq
zzctommy的后缀自动机练习记录
后缀自动机学习笔记 | Menci’s OI Blog
Oi-Wiki
后缀自动机练习记录 - zzctommy - 博客园
command_block 题解
神秘的物质

]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>SOSDP高维前缀和</title>
    <url>/posts/ff3126df/</url>
    <content><![CDATA[ 0. 前言
前置知识：

状压 DP。

 1. 概念与介绍
SOSDP，翻译过来就叫做子集和 DP，又称作高维前缀和，用来解决一些涉及子集和计算的问题。
我们通过一道例题来进行引入：

给你一个含 2n2^n2n 的集合 SSS，对于所有的 i∈[0,2n−1]i\in [0,2^n-1]i∈[0,2n−1]，求解 ∑j⊂isj\sum_{j\subset i}s_j∑j⊂i​sj​。

有一个显然的想法是模拟即可 O(4n)O(4^n)O(4n)，但是显然我们可以通过枚举子集轻松做到 O(3n)O(3^n)O(3n)，还能不能可以更优？
上面枚举子集的方法我们看有没有什么问题，我们发现当一个状态的二进制位上有 kkk 个 0，那么它将在其他状态的带的时候被访问 2k−12^k-12k−1 次，存在许多重复且无用的计算，原因是因为我们每一个对应的 sis_isi​ 没有和状态建立起对应的练习，而是直接暴力枚举子集，我们需要添加另一个状态来避免上述的重复计算。
我们考虑状态的设计与添加，设状态 S(sta)={x∣x⊂sta}S(sta)=\{ x|x \subset sta\}S(sta)={x∣x⊂sta}。上述的语句其实就是表明这些集合存在许多相交的部分，现在我们需要把这个集合划分为不相交的组。
设状态 S(sta,i)={s∣s⊂sta,sta⊕x&lt;2i+1}S(sta,i)=\{ s|s\subset sta,sta \oplus x&lt; 2^{i+1} \}S(sta,i)={s∣s⊂sta,sta⊕x&lt;2i+1}。我们将二进制位数从 0 开始从低位向高维表示，那么集合 S(sta,i)S(sta,i)S(sta,i) 表示的就是只有第 iii 位以及更低位与 stastasta 不同的 xxx 的集合。
我们尝试将 stastasta 与 xxx 建立起来联系，那么有如下的分类讨论：

stastasta 第 iii 位为 0：显而易见的，stastasta 与 xxx 的第 iii 位均为 0。因此 xxx 仅有 0∼i−10\sim i-10∼i−1 位和 stastasta 不同，那么就有 S(sta,i)=S(sta,i−1)S(sta,i)=S(sta,i-1)S(sta,i)=S(sta,i−1)。
stastasta 第 iii 位为 1：

若 xxx 的对应位置为 0，那么就是 S(sta⊕2i,i−1)S(sta\oplus 2^i,i-1)S(sta⊕2i,i−1)。
若 xxx 的对应位置为 1，那么就是 S(sta,i−1)S(sta,i-1)S(sta,i−1)。



下图描述了如何将 S(sta,i)S(sta,i)S(sta,i) 集合相互关联。任何集合 S(sta,i)S(sta,i)S(sta,i) 的元素都是其子树中的叶子。红色前缀表示的这一部分对其所有子结点都是公共的，而黑色部分允许不同。

实现了这些关系之后，我们可以很容易地写出相应的动态规划。
for(int sta=0;sta&lt;(1&lt;&lt;N);sta++)&#123;    dp[sta][-1]=A[sta];// 叶结点	for(int i=0;i&lt;N;i++)	&#123;		if(sta&amp;(1&lt;&lt;i))			dp[sta][i]=dp[sta][i-1]+dp[sta^(1&lt;&lt;i)][i-1];		else dp[sta][i]=dp[sta][i-1];	&#125;	F[sta]=dp[sta][N-1];&#125;
注意到空间过于无敌，考虑滚动数组：
for(int i=0;i&lt;(1&lt;&lt;N);i++)	F[i]=A[i];for(int i=0;i&lt;N;i++)	for(int sta=(1&lt;&lt;N)-1;sta&gt;=0;sta--)	    if(sta&amp;(1&lt;&lt;i))			F[sta]+=F[sta^(1&lt;&lt;i)];
注意到这里其实可以正序枚举，但是养成好习惯吧以后写倒序的。
时间复杂度为 O(n⋅2n)O(n\cdot 2^n)O(n⋅2n)。
上面代码所求的是子集和，其实 SOSDP 还可以求超集和。具体的，设数组 f[mask]f[mask]f[mask] 表示每个集合 mask 的初始值，定义：
g[S]=∑T⊇Sf[T]g[S] = \sum_{T \supseteq S} f[T]
g[S]=T⊇S∑​f[T]
我们要求的是所有包含 SSS 的超集的和。
考虑每一位从低到高处理，对于第 iii 位：


如果当前集合 mask 不含第 iii 位：

就可以加上 含第 iii 位的集合的贡献（即 mask | (1 &lt;&lt; i)）。



这相当于枚举所有包含 mask 的超集。
代码如下：
for(int i=0;i&lt;(1&lt;&lt;n);i++) g[i]=f[i];for(int i=0;i&lt;n;i++)    for(int mask=0;mask&lt;(1&lt;&lt;n);mask++)        if((mask&gt;&gt;i&amp;1)==0)            g[mask]+=g[mask|(1&lt;&lt;i)];
另一种实现：
for(int i=0;i&lt;N;i++)	for(int sta=(1&lt;&lt;N)-1;sta&gt;=0;sta--)	    if(!(sta&amp;(1&lt;&lt;i)))			F[sta]+=F[sta^(1&lt;&lt;i)];
其实超集和其实相当于就是反过来的子集求和，子集和变化相当于就是从小集合转移到大集合，而超集和变化相当于从大集合转移到小集合。
 2.例题
 CF165E
SOSDP 模板题。
二进制下与为 0 就是二进制位全部都不一样，那么取反之后就是二进制位完全相同的集合或这个集合的子集即可，通过 SOSDP 即可解决。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=23,MK=2e6+15;int n,a[MK],f[1&lt;&lt;MN];int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        f[a[i]]=a[i];    &#125;    for(int i=0;i&lt;22;i++)&#123;        for(int j=0;j&lt;(1&lt;&lt;22);j++)&#123;            if((j&gt;&gt;i&amp;1)&amp;&amp;f[j^(1&lt;&lt;i)])&#123;                f[j]=f[j^1&lt;&lt;i];            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        int x=((1&lt;&lt;22)-1)^a[i];        cout&lt;&lt;(f[x]?f[x]:-1)&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;
 arc100c
考虑 i∣j≤ki|j\le ki∣j≤k 实际上就是两个数在二进制表示下 1 位置的集合为 kkk 表示集合的子集。
注意到我们只需要这个子集的最大值和次大值即可，考虑 SOSDP 维护最大值和次大值的值，转移的时候后合并需要考虑最大值和次大值而变化。答案就是子集的前缀最大值，时间复杂度 O(n⋅2n)O(n\cdot 2^n)O(n⋅2n)。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=20,INF=1e9;int n,ans;pir a[1&lt;&lt;MN];pir mergep(pir x,pir y)&#123;    pir ret;    if(x.first&lt;y.first) swap(x,y);    ret=x;    if(y.first&gt;ret.second) ret.second=y.first;    return ret;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;        int x;        cin&gt;&gt;x;        a[i]=pir(x,-INF);    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int s=0;s&lt;(1&lt;&lt;n);s++)&#123;            if((s&gt;&gt;i)&amp;1)&#123;                a[s]=mergep(a[s],a[s^(1&lt;&lt;i)]);            &#125;        &#125;    &#125;    for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123;        ans=max(ans,a[i].first+a[i].second);        cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 CF1208F
有没有感觉这个题和上面的题差不太多，但是这里有了个与操作。但其实不太对，因为上面的问题是限制，这里的问题是求值。
注意到或运算的性质，即只要有一个二进制位为 1 那么这个位数贡献的答案就是定死的，启发我们枚举或的数，这样我们只需要解决后的的与操作了。
考虑如何让答案最大，注意到二进制的与或等操作在每一位都是独立的，启发我们按位贪心，既然是最大，考虑从高位到低位贪心。如果有两个数他们的与在这一位为 1，那么最后的答案中一定有这一位。
我那么我们逐位考虑，并且考虑是否有两个在右边的数他们 “与” 的结果为当前答案的超集即可，有的话答案直接加上这一位。
用 SOSDP 求解即可。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=22;int n,mn[1&lt;&lt;MN],ans;struct NodeMX&#123;    int fir,sec;    friend NodeMX operator +(const NodeMX &amp;x,const NodeMX &amp;y)&#123;        int xmx=x.fir,ymx=y.fir;        if(xmx&lt;ymx) swap(xmx,ymx);        return (NodeMX)&#123;xmx,max(&#123;ymx,x.sec,y.sec&#125;)&#125;;    &#125;&#125;mx[1&lt;&lt;MN];signed main()&#123;    memset(mn,0x3f,sizeof(mn));    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin&gt;&gt;x;        mx[x]=mx[x]+(NodeMX)&#123;i,0&#125;;        mn[x]=min(mn[x],i);    &#125;    for(int i=0;i&lt;21;i++)&#123;        for(int j=(1&lt;&lt;21)-1;j&gt;=0;j--)&#123;            if(!(j&amp;(1&lt;&lt;i)))&#123;                mx[j]=mx[j]+mx[j^(1&lt;&lt;i)];                mn[j]=min(mn[j],mn[j^(1&lt;&lt;i)]);            &#125;        &#125;    &#125;    for(int i=20;i&gt;=0;i--)&#123;        int now=ans|(1&lt;&lt;i);        bool flag=0;        for(int j=now;;j=(j-1)&amp;now)&#123;            if(mn[j]&lt;mx[now^j].sec) flag=1;            if(flag||!j) break;        &#125;        if(flag) ans=now;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P6422
注意到 m≤20m\le 20m≤20，启发我们进行状压。转化为选若干个数使它们按位或为全集。
设 f(i,S)f(i,S)f(i,S) 表示目前到第 iii 个箱子，至少放了一次玩具构成的集合为 SSS 的方案书，转移枚举选或者不选，显然超时。
考虑优化，注意到我们一开始的只需要让他们按位或Wie全集就可以了，但是按位或如果直接算贡献的话会算重，考虑容斥。
设 fif_ifi​ 表示选取若干个箱子或起来为状态 iii 的方案数，设 gig_igi​ 表示选取若干个数火起来为状态 iii 的子集的方案数。显然，设 cnticnt_icnti​ 表示 iii 有 cnticnt_icnti​ 个子集，那么 gi=2cntig_i=2^{cnt_i}gi​=2cnti​。求解 fif_ifi​ 可以考虑乘上容斥系数即可了，系数见代码即可，时间复杂度 O(n+m⋅2m)O(n+m\cdot 2^m)O(n+m⋅2m)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=22,MM=1e6+15,MOD=1e9+7;int n,m,ans,f[1&lt;&lt;MN],pw2[MM];void initpw()&#123;    pw2[0]=1;    for(int i=1;i&lt;MM;i++)&#123;        pw2[i]=pw2[i-1]*2%MOD;    &#125;&#125;signed main()&#123;    initpw();    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        int k,st=(1&lt;&lt;m)-1;        cin&gt;&gt;k;        while(k--)&#123;            int x;            cin&gt;&gt;x;            st^=(1&lt;&lt;(x-1));        &#125;        f[st]++;    &#125;    for(int i=0;i&lt;21;i++)&#123;        for(int j=0;j&lt;(1&lt;&lt;21);j++)&#123;            if((j&gt;&gt;i)&amp;1)&#123;                (f[j^(1&lt;&lt;i)]+=f[j])%=MOD;            &#125;        &#125;    &#125;    for(int i=0;i&lt;(1&lt;&lt;m);i++)&#123;        int cnt=__builtin_popcountll(i);        if(cnt&amp;1)&#123;            ans=(ans-pw2[f[i]]+MOD)%MOD;        &#125;        else ans=(ans+pw2[f[i]])%MOD;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>SP7363_Tree_Sum题解</title>
    <url>/posts/18e18e77/</url>
    <content><![CDATA[好题，话说我写黑题题解是不是有点飘了 www。
众所周知，第二类斯特林数有一个如下的性质：
mn=∑i=0n{ni}×i!×(mi)m^n=\sum\limits_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix}\times i! \times \binom{m}{i}
mn=i=0∑n​{ni​}×i!×(im​)
更众所周知的是，杨辉三角递推式：
(nm)=(n−1m)+(n−1m−1)\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}
(mn​)=(mn−1​)+(m−1n−1​)
原题的答案求的是：
ansx=∑i=1n(dis(x,i))kans_{x}=\sum\limits_{i=1}^n (dis(x,i))^k
ansx​=i=1∑n​(dis(x,i))k
其中 ansxans_xansx​ 表示在以 xxx 为根节点的情况下的答案，注意到选取的 xxx 不同所对应的答案不同，这启示我们进行类似于换根 DP 的计算（是不是有点太超前了）。
我们利用上面的公式变换一下：
ansx=∑i=1n(dis(x,i))k=∑i=1n∑j=0k{kj}×j!×(dis(x,i)j)=∑j=0k{kj}×j!∑i=1n(dis(x,i)j)\begin{aligned}
ans_{x} &amp; =\sum\limits_{i=1}^n (dis(x,i))^k \\

&amp; = \sum_{i=1}^n \sum_{j=0}^{k} \begin{Bmatrix} k \\ j \end{Bmatrix}\times j! \times \binom{dis(x,i)}{j} \\

&amp; = \sum_{j=0}^{k} \begin{Bmatrix} k \\ j \end{Bmatrix}\times j! \sum_{i=1}^n   \binom{dis(x,i)}{j}

\end{aligned}
ansx​​=i=1∑n​(dis(x,i))k=i=1∑n​j=0∑k​{kj​}×j!×(jdis(x,i)​)=j=0∑k​{kj​}×j!i=1∑n​(jdis(x,i)​)​
注意到前面可以暴力处理，瓶颈在于后面，考虑如何快速求后面的式子。
我们不妨考虑树形 DP 和换根 DP 计算（还真是换根耶），设 f(i,j)f(i,j)f(i,j) 表示以 iii 及其子树内，(dis(x,i)j)\dbinom{dis(x,i)}{j}(jdis(x,i)​) 的总和，考虑转移方程推导。
考虑转移，转移由孩子节点转移过来，而根节点求的为 ∑v∈sub(u)(dis(u,v)j)\sum\limits_{v\in sub(u)} \binom{dis(u,v)}{j}v∈sub(u)∑​(jdis(u,v)​)，转化为求 ∑x∈son(u)∑v∈sub(u)(dis(x,v)+1j)\sum\limits_{x\in son(u)} \sum\limits_{v\in sub(u)} \binom{dis(x,v)+1}{j}x∈son(u)∑​v∈sub(u)∑​(jdis(x,v)+1​)，用上面提到的组合数递推式即可解得：
f(u,j)=∑v∈son(u)f(v,j)+f(v,j−1)f(u,j)=\sum_{v\in son(u)} f(v,j)+f(v,j-1)
f(u,j)=v∈son(u)∑​f(v,j)+f(v,j−1)
求解完之后考虑换根，我们不妨设为 g(i,j)g(i,j)g(i,j)。换根的式子推导过于繁杂，这里篇幅限制，感兴趣可以看其他的题解，方程如下：
g(u,j)=g(fa,j)+g(fa,j−1)−2×f(u,j−1)−f(u,j−2)g(u,j)=g(fa,j)+g(fa,j-1)-2\times f(u,j-1)-f(u,j-2)
g(u,j)=g(fa,j)+g(fa,j−1)−2×f(u,j−1)−f(u,j−2)
预处理斯特林数和阶乘即可，时间复杂度 O(nk+k2)O(nk+k^2)O(nk+k2)。
多测太难受了啊：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e4+15,MK=26,MOD=1e9+7;int f[MN][MK],s[MK][MK],pw[MK],n,K;vector&lt;int&gt; adj[MN];void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MK;i++) pw[i]=pw[i-1]*i%MOD;    s[0][0]=1;    for(int i=1;i&lt;MK;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            s[i][j]=(s[i-1][j-1]+j*s[i-1][j]%MOD)%MOD;        &#125;    &#125;&#125;void dfs1(int u,int pre)&#123;    f[u][0]=f[u][1]=1;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs1(v,u);        f[u][0]=(f[u][0]+f[v][0])%MOD;        for(int i=1;i&lt;=K;i++)&#123;            f[u][i]=(f[u][i]+f[v][i]+f[v][i-1])%MOD;        &#125;    &#125;&#125;void dfs2(int u,int pre)&#123;    if(pre)&#123;        for(int i=K;i&gt;=0;i--)&#123;            f[u][i]=f[pre][i];            if(i&gt;0)&#123;                f[u][i]=(f[u][i]+f[pre][i-1])%MOD;                f[u][i]=(f[u][i]-f[u][i-1]*2+MOD)%MOD;            &#125;            if(i&gt;1) f[u][i]=(f[u][i]-f[u][i-2]+MOD)%MOD;        &#125;    &#125;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs2(v,u);    &#125;&#125;void clear()&#123;    memset(f,0,sizeof(f));    for(int i=1;i&lt;=n;i++) adj[i].clear();&#125;void solve()&#123;    clear();    cin&gt;&gt;n&gt;&gt;K;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        u++,v++;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs1(1,0);    dfs2(1,0);    for(int i=1;i&lt;=n;i++)&#123;        int ans=0;        for(int j=0;j&lt;=K;j++)&#123;            ans=(ans+f[i][j]*pw[j]%MOD*s[K][j]%MOD)%MOD;        &#125;        cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;    &#125;    cout&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    ios::sync_with_stdio(0);    init();    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>SP21132题解</title>
    <url>/posts/37bc7e0d/</url>
    <content><![CDATA[怎么没有 SAM 版本的，我来补一发 www。
SAM 直接找回文串不太好找，考虑用 Manacher 找回文串，一旦有回文串我们就去 SAM 上查询。闲杂问题转化为查询 S[l,r]S[l,r]S[l,r] 在原串中出现多少次。首先我们得找到 s[l,r]s[l,r]s[l,r] 在 SAM 上对应的节点，这个问题是经典技巧，首先我们预处理 sss 每一个位置 sis_{i}si​ 对应的 SAM 节点，记为 posipos_{i}posi​，让后我们每一次查询 S[l,r]S[l,r]S[l,r] 从 posrpos_rposr​ 开始在 Link 树往上跳，直到跳到第一个位置 kkk 使得 lenk&lt;r−l+1len_{k}&lt; r-l+1lenk​&lt;r−l+1，此时 kkk 代表的就是 s[l,r]s[l,r]s[l,r] 对应的节点。
我们得到节点了，还有一个问题出现多少次，我们在 SAM 插入字符的时候维护一个 cntcntcnt 表示当前节点是否是子串节点，让后在 Link 树上从下往上合并（加），让后答案就是 cntk×(r−l+1)cnt_{k}\times (r-l+1)cntk​×(r−l+1) 取 max⁡\maxmax 岂可。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,m,r[MN],poss[MN];long long ans;int pre[31][MN];char p[MN];string s;struct SAM&#123;    int nxt[MN][26],len[MN],c[MN],cnt[MN],id[MN],pos[MN],fa[MN],tot,lst;    void init()&#123;        tot=lst=1;    &#125;    int newnode()&#123;        int cur=++tot;        memset(nxt[cur],0,sizeof(nxt[cur]));        return cur;    &#125;    int clone(int from)&#123;        int cur=newnode();        fa[cur]=fa[from];        memcpy(nxt[cur],nxt[from],sizeof(nxt[from]));        return cur;    &#125;    void expand(int c)&#123;        int cur=newnode();        len[cur]=len[lst]+1;        cnt[cur]=1;        int p=lst;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                int nq=clone(q);                len[nq]=len[p]+1;                fa[cur]=fa[q]=nq;                while(p&amp;&amp;nxt[p][c]==q)&#123;                    nxt[p][c]=nq,p=fa[p];                &#125;            &#125;        &#125;        lst=cur;    &#125;    void getsiz()&#123;        for(int i=1;i&lt;=tot;i++) c[len[i]]++;        for(int i=1;i&lt;=n;i++) c[i]+=c[i-1];        for(int i=1;i&lt;=tot;i++) id[c[len[i]]--]=i;        for(int i=tot;i&gt;=1;i--)&#123;            cnt[fa[id[i]]]+=cnt[id[i]];        &#125;    &#125;    void initst()&#123;        for(int i=1;i&lt;=tot;i++) pre[0][i]=fa[i];        for(int i=1;i&lt;=30;i++)&#123;            for(int j=1;j&lt;=tot;j++)&#123;                pre[i][j]=pre[i-1][pre[i-1][j]];            &#125;        &#125;    &#125;    void find(int l,int r)&#123;        if(l&lt;1||r&gt;n) return;        int slen=r-l+1,now=pos[r];        for(int i=30;i&gt;=0;i--)&#123;            if(pre[i][now]&amp;&amp;len[pre[i][now]]&gt;=slen) now=pre[i][now];        &#125;        ans=max(ans,1ll*cnt[now]*(r-l+1));    &#125;    &#125;sam;void manacher()&#123;    p[++m]=&#x27;@&#x27;;    for(int i=1;i&lt;=n;i++)&#123;        p[++m]=&#x27;#&#x27;;        p[++m]=s[i];        poss[m]=i;    &#125;    p[++m]=&#x27;#&#x27;,p[++m]=&#x27;$&#x27;;    int pos=0,mx=0;    for(int i=1;i&lt;=m;i++)&#123;        if(i&lt;mx) r[i]=min(mx-i,r[pos*2-i]);        else r[i]=1;        sam.find(poss[i-r[i]+2],poss[i+r[i]-2]);        while(p[i-r[i]]==p[i+r[i]])&#123;            r[i]++;            sam.find(poss[i-r[i]+2],poss[i+r[i]-2]);        &#125;        if(i+r[i]&gt;mx)&#123;            mx=i+r[i],pos=i;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;s;    sam.init();    n=s.length();    s=&quot; &quot;+s;    for(int i=1;i&lt;=n;i++)&#123;        sam.expand(s[i]-&#x27;a&#x27;);        sam.pos[i]=sam.lst;    &#125;    sam.initst();    sam.getsiz();    manacher();    cout&lt;&lt;ans;    return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA10829_L-GapSubstrings题解</title>
    <url>/posts/751079ec/</url>
    <content><![CDATA[形式化题面如下：

多组测试数据 TTT，给出一个字符串 sss，求多少个相距为 ggg 的子串是相同的。
1≤T≤10,1≤g≤10,1≤s≤5×1041\le T \le 10,1\le g \le 10,1\le s \le 5\times 10^41≤T≤10,1≤g≤10,1≤s≤5×104

看到子串，并且要 O(nlog⁡n)O(n \log n)O(nlogn)，首先想到的就是 SA 和 SAM。
让后如果你做过 P1117 [NOI2016] 优秀的拆分的话，你会发现这个题和那个题很相似，都是在统计子串，不过这里有了距离限制。
我们考虑枚举子串长度 LLL，设第一段起始点为 lll，那么第一段范围为 [l,l+L−1][l,l+L-1][l,l+L−1]。第二段起始点 rrr 就是 r=l+L+gr=l+L+gr=l+L+g，同理 [r,r+L−1][r,r+L-1][r,r+L−1]。那么它们什么时候才能够作为子串相同呢，这里有一个结论就是它们两端的 LCS（最长公共后缀） 与 LCP（最长公共前缀）的长度和（注意算重两个端点要减一）大于等于我们枚举的长度，也就是 LCS⁡(l,r)+LCP⁡(l,r)−1≥L\operatorname{LCS}(l,r)+\operatorname{LCP}(l,r)-1\ge LLCS(l,r)+LCP(l,r)−1≥L。那么我们可以枚举起始点 lll，rrr 可以 O(1)O(1)O(1) 算出来，利用 SA 或 SAM 能够 O(1)→O(log⁡n)O(1)\to O(\log n)O(1)→O(logn) 查出它们的 LCS 和 LCP。
我们考虑怎么优化，注意到我们实际上就是在拿一个长为 LLL 的滑块在去滑，如果 [l,l+L−1][l,l+L-1][l,l+L−1] 可以的话，那么我们在枚举 [l+1,l+L−1][l+1,l+L-1][l+1,l+L−1] 实际上是没必要的，因为 LCS⁡(l,r)+LCP⁡(l,r)−1≥L\operatorname{LCS}(l,r)+\operatorname{LCP}(l,r)-1\ge LLCS(l,r)+LCP(l,r)−1≥L 一但合法，若等于 LLL 那么说明 LCS 和 LCP 恰好碰到一起，就是 1 个，而一旦重合，那么说明这个字符串区间我们可以向后拓展几位也是合法的，那么最多能拓展多少呢？每一次向后拓展 LCS 与 LCP 都会减一，那么最多只能拓展 LCS⁡(l,r)+LCP⁡(l,r)−1−L+1\operatorname{LCS}(l,r)+\operatorname{LCP}(l,r)-1-L+1LCS(l,r)+LCP(l,r)−1−L+1 次，原题目只让我们统计合法的个数，所以一个滑块的答案是可以 O(1)O(1)O(1) 算出来的。
这样的话，我们可以直接跳到 l+Ll+Ll+L 开始枚举，这种方法相当于将字符串分成了 ∣s∣L\dfrac{|s|}{L}L∣s∣​ 的块，根据调和级数原理 ：
∣s∣1+∣s∣2+⋯+∣s∣∣s∣=∣s∣×(11+12+⋯+1∣s∣)≈O(nlog⁡n)\dfrac{|s|}{1}+\dfrac{|s|}{2}+\dots+\dfrac{|s|}{|s|}=|s|\times(\dfrac{1}{1}+\dfrac{1}{2}+\dots+\dfrac{1}{|s|})\approx O(n \log n)
1∣s∣​+2∣s∣​+⋯+∣s∣∣s∣​=∣s∣×(11​+21​+⋯+∣s∣1​)≈O(nlogn)
那么时间复杂度就是 O(nlog⁡n)O(n \log n)O(nlogn)，对于 SA 可以做到 O(nlog⁡n)O(n \log n)O(nlogn) 预处理 LCP，SAM 预处理就是两个 endpos 集合在 link 树上的 LCA，可以做到 O(nlog⁡n)O(n \log n)O(nlogn) 预处理，O(1)→O(log⁡n)O(1) \to O(\log n)O(1)→O(logn) 查询 LCA，时间复杂度为 O(nlog⁡n)→O(nlog⁡2n)O(n \log  n)\to O(n \log^2 n)O(nlogn)→O(nlog2n)。
这种技巧是对字符串的分块思想。如果题目中出现一些构造字符串循环构成的问题，我们可以不妨考虑枚举这个循环的长度 LLL，让后按照 LLL 将字符串划分关键点分块（即按照 LLL 的倍数分块）利用分块和字符串的重复性质，将看似全局的问题局部化解决。对应到后缀数组上就是对相邻两块的块进行 LCP 和 LCS 查询。
文尾推销自己万字全家桶：后缀数组全家桶-从哈希乱搞到入门 - 洛谷专栏。
SAM 实现如下，用树刨求 LCA 时间复杂度 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e5+15;int n,g,casetot;string s;struct SAM&#123;    int nxt[MN][26],len[MN],pos[MN],fa[MN],tot,lst;    int siz[MN],dep[MN],hson[MN],htop[MN];    vector&lt;int&gt; adj[MN];    void init()&#123;        for(int i=0;i&lt;=tot;i++)&#123;            adj[i].clear();            len[i]=fa[i]=0;            siz[i]=dep[i]=hson[i]=htop[i]=0;            memset(nxt[i],0,sizeof(nxt[i]));        &#125;        tot=lst=1;    &#125;    void expand(int c,int id)&#123;        int cur=++tot;        len[cur]=len[lst]+1;        pos[id]=cur;        int p=lst;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                int nq=++tot;                len[nq]=len[p]+1;                fa[nq]=fa[q];                memcpy(nxt[nq],nxt[q],sizeof(nxt[q]));                fa[cur]=fa[q]=nq;                while(p&amp;&amp;nxt[p][c]==q) nxt[p][c]=nq,p=fa[p];            &#125;        &#125;        lst=cur;    &#125;    void dfs1(int u,int pre)&#123;        siz[u]=1;        dep[u]=dep[pre]+1;        for(auto v:adj[u])&#123;            dfs1(v,u);            siz[u]+=siz[v];            if(!hson[u]||siz[hson[u]]&lt;siz[v]) hson[u]=v;        &#125;    &#125;    void dfs2(int u,int ltop)&#123;        htop[u]=ltop;        if(!hson[u]) return;        dfs2(hson[u],ltop);        for(auto v:adj[u])&#123;            if(v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;    void inittree()&#123;        for(int i=2;i&lt;=tot;i++)&#123;            adj[fa[i]].push_back(i);        &#125;        dfs1(1,0);        dfs2(1,1);    &#125;    int lca(int x,int y)&#123;        while(htop[x]!=htop[y])&#123;            if(dep[htop[x]]&lt;dep[htop[y]]) swap(x,y);            x=fa[htop[x]];        &#125;        return dep[x]&lt;dep[y]?x:y;    &#125;    int lcs(int x,int y)&#123;        x=pos[x],y=pos[y];        return len[lca(x,y)];    &#125;&#125;sam1,sam2;void solve()&#123;    sam1.init();    sam2.init();    cin&gt;&gt;g&gt;&gt;s;    n=s.length();    s=&quot; &quot;+s;    for(int i=1;i&lt;=n;i++)&#123;        sam1.expand(s[i]-&#x27;a&#x27;,i);    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sam2.expand(s[i]-&#x27;a&#x27;,i);    &#125;    sam1.inittree();    sam2.inittree();    int ans=0;    for(int j=1;j&lt;=(n-g)&gt;&gt;1;j++)&#123;        for(int i=1;i+j+g&lt;=n;i+=j)&#123;            int l=i,r=i+j+g;            int lcs=min(sam1.lcs(l,r),j),lcp=min(sam2.lcs(l,r),j);            int len=lcs+lcp-1;            if(len&gt;=j) ans+=len-j+1;        &#125;    &#125;    cout&lt;&lt;&quot;Case &quot;&lt;&lt;++casetot&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA11090题解</title>
    <url>/posts/488f899b/</url>
    <content><![CDATA[本题就是大名鼎鼎的最优比率环的问题。
我们不难注意到，平均值就是如下：
x‾=∑cicnt\overline{x}=\frac{\sum c_i}{cnt}
x=cnt∑ci​​
其中 cntcntcnt 代表点个数，而 cic_{i}ci​ 代表权值和。
学过分数规划的想必已经秒了，没事我们一步一步推。
根据题意有：
ans→∑cicnt≥x‾=∑ci≥x‾×cnt=∑ci−x‾×cnt≥0=∑(ci−x‾)≥0=∑(x‾−ci)≤0\begin{aligned}

ans &amp; \rightarrow \frac{\sum c_i}{cnt} \ge \overline{x} \\

&amp; =\sum c_i \ge \overline{x} \times cnt \\

&amp; =\sum c_{i} - \overline{x} \times cnt \ge 0 \\

&amp; = \sum (c_{i} - \overline{x}) \ge 0 \\ 

&amp; = \sum (\overline{x}- c_{i}) \le 0

\end{aligned}
ans​→cnt∑ci​​≥x=∑ci​≥x×cnt=∑ci​−x×cnt≥0=∑(ci​−x)≥0=∑(x−ci​)≤0​
这是什么，负环？我们把边权改成 mid−cimid-c_{i}mid−ci​ 不就是在让我们找一个环使得权值为负数，这不就是负环吗。
根据上面的不等式，我们不难看出我们需要二分这个 x‾\overline{x}x。我们用 SPFA 来判断负环，若有负环我们将 x‾\overline{x}x 调小，否则调大，这样就满足题意了。
接下来是代码时间，但是这里需要有几点注意：

BFS 的 SPFA 会炸，请使用 DFS 版本的 SPFA，详情见代码。
double 精度不够，请使用 long double。
时刻注意精度问题！
最后结果要输出 l+r2\dfrac{l+r}{2}2l+r​，不然会被 hack 精度（没错 long double 还是不够）。

代码通过 uDebug 上所有 hack，同时讨论区内个人 hack 也通过，感谢 hack 提供者们的贡献。也欢迎来 hack 我代码 www。
#include&lt;bits/stdc++.h&gt;#define double long doubleusing namespace std;constexpr int MN=55;constexpr double eps=1e-10;struct Edge&#123;    int v;    double w;&#125;;int n,m,tot;double l,r,dis[MN];bool vis[MN];vector&lt;Edge&gt; adj[MN];int cmp(double x,double y)&#123;    if(fabs(x-y)&lt;eps) return 0;    if(x&gt;y) return 1;    return -1;&#125;bool dfs(int u,double k)&#123;    vis[u]=1;    for(auto e:adj[u])&#123;        int v=e.v;        auto w=e.w;        if(dis[v]&gt;dis[u]+w-k)&#123;            dis[v]=dis[u]+w-k;            if(vis[v]||dfs(v,k))&#123;                return vis[u]=0,1;            &#125;        &#125;    &#125;    return vis[u]=0;&#125;bool check(double k)&#123;    memset(dis,0,sizeof(dis));    for(int i=1;i&lt;=n;i++)&#123;        if(dfs(i,k)) return 1;    &#125;    return 0;&#125;void init()&#123;    for(int i=1;i&lt;=n;i++) adj[i].clear(),vis[i]=0;&#125;void solve()&#123;    init();    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        double w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);    &#125;    l=0,r=1e9;    while(r-l&gt;eps)&#123;        double mid=(l+r)/2;        if(check(mid)) r=mid;        else l=mid;    &#125;    if(cmp(l,1e9)==0) cout&lt;&lt;&quot;No cycle found.\n&quot;;    else cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(l+r)/2&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;++tot&lt;&lt;&quot;: &quot;;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12369题解</title>
    <url>/posts/d68d5922/</url>
    <content><![CDATA[带限制的期望我们一般喜欢用 DP 来解决，因为这样能够更好的处理相邻之间的限制。其实一般说来好多期望都是通过 DP 来解决，而一小部分是直接能够算出概率求得。
观察题目总共 444 个限制，同时还有大小王的灵活使用。不难有状态 f(a,b,c,d,e,f)f(a,b,c,d,e,f)f(a,b,c,d,e,f)，表示用了 aaa 个黑桃，bbb 个红桃，ccc 个梅花，ddd 个方块，小王状态 eee，大王状态 fff。其中大小王状态格式为：000 为未使用，1→31\rightarrow 31→3 为当作黑桃，红桃，梅花，方块。
不妨设已经用过的牌数量为 sumsumsum，显然 sum=a+b+c+d+[e≠0]+[f≠0]sum=a+b+c+d+[e\neq 0]+[f \neq 0]sum=a+b+c+d+[e=0]+[f=0]。对于一个状态合法，即满足 a,b,c,d≤13,sum≤54a,b,c,d\le 13,sum \le 54a,b,c,d≤13,sum≤54。考虑转移方程，有如下情况：

黑桃：抽中的概率为 13−a54−sum\dfrac{13-a}{54-sum}54−sum13−a​，那么期望即为 13−a54−sum+f(a+1,b,c,d,e,f)\dfrac{13-a}{54-sum}+f(a+1,b,c,d,e,f)54−sum13−a​+f(a+1,b,c,d,e,f)。
红桃：抽中的概率为 13−b54−sum\dfrac{13-b}{54-sum}54−sum13−b​，那么期望即为 13−b54−sum+f(a,b+1,c,d,e,f)\dfrac{13-b}{54-sum}+f(a,b+1,c,d,e,f)54−sum13−b​+f(a,b+1,c,d,e,f)。
梅花：抽中的概率为 13−c54−sum\dfrac{13-c}{54-sum}54−sum13−c​，那么期望即为 13−c54−sum+f(a,b,c+1,d,e,f)\dfrac{13-c}{54-sum}+f(a,b,c+1,d,e,f)54−sum13−c​+f(a,b,c+1,d,e,f)。
方块：抽中的概率为 13−d54−sum\dfrac{13-d}{54-sum}54−sum13−d​，那么期望即为 13−d54−sum+f(a,b,c,d+1,e,f)\dfrac{13-d}{54-sum}+f(a,b,c,d+1,e,f)54−sum13−d​+f(a,b,c,d+1,e,f)。
小王：这里有点不同，能抽中小王当且仅当 [e=0][e=0][e=0] 成立，那么成立时概率即为 154−sum\dfrac{1}{54-sum}54−sum1​，考虑如何转移，题面中已经说明会选择期望最小的的来转移，那么期望即为 154−sum×min⁡i=11≤i≤4f(a,b,c,d,i,f)\dfrac{1}{54-sum}\times \min_{i=1}^{1\le i \le 4} f(a,b,c,d,i,f)54−sum1​×mini=11≤i≤4​f(a,b,c,d,i,f)。
大王：同上推导，当且仅当 [f=0][f=0][f=0] 成立，即 154−sum×min⁡i=11≤i≤4f(a,b,c,d,e,i)\dfrac{1}{54-sum}\times \min_{i=1}^{1\le i \le 4} f(a,b,c,d,e,i)54−sum1​×mini=11≤i≤4​f(a,b,c,d,e,i)。

最后加起来即可。我们转移的顺序一般从终止状态开始计算，而起始作为目标，因为在很多情况下，终止状态有很多，而起始是唯一的。所以一般期望 DP 我们会采取倒推的手段，区别于概率 DP 的正推。
注意到状态转移太过于难受，我们考虑记忆化搜索的方式实现，这样起码好些不坐牢，故代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=25;constexpr double INF=1e18;int A,B,C,D;bool vis[MN][MN][MN][MN][5][5];double dp[MN][MN][MN][MN][5][5];double dfs(int a,int b,int c,int d,int e,int f)&#123;    if(vis[a][b][c][d][e][f]) return dp[a][b][c][d][e][f];    vis[a][b][c][d][e][f]=1;    int sum=a+b+c+d+(e!=0)+(f!=0);    double val=0;    if(a&gt;13||b&gt;13||c&gt;13||d&gt;13||sum&gt;54)&#123;        dp[a][b][c][d][e][f]=INF;        return dp[a][b][c][d][e][f];    &#125;    if(a+(e==1)+(f==1)&gt;=A&amp;&amp;b+(e==2)+(f==2)&gt;=B&amp;&amp;c+(e==3)+(f==3)&gt;=C&amp;&amp;d+(e==4)+(f==4)&gt;=D) dp[a][b][c][d][e][f]=0;    else&#123;        val+=(13.0-a)/(54.0-sum)*dfs(a+1,b,c,d,e,f);        val+=(13.0-b)/(54.0-sum)*dfs(a,b+1,c,d,e,f);        val+=(13.0-c)/(54.0-sum)*dfs(a,b,c+1,d,e,f);        val+=(13.0-d)/(54.0-sum)*dfs(a,b,c,d+1,e,f);        if(e==0)&#123;            double minn=INF;            for(int i=1;i&lt;=4;i++) minn=min(minn,dfs(a,b,c,d,i,f));            val+=1.0/(54.0-sum)*minn;        &#125;        if(f==0)&#123;            double minn=INF;            for(int i=1;i&lt;=4;i++) minn=min(minn,dfs(a,b,c,d,e,i));            val+=1.0/(54.0-sum)*minn;        &#125;        dp[a][b][c][d][e][f]=val+1.0;    &#125;    return dp[a][b][c][d][e][f];&#125;void solve()&#123;    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;D;    memset(dp,0,sizeof(dp));    memset(vis,0,sizeof(vis));    dfs(0,0,0,0,0,0);    if(dp[0][0][0][0][0][0]&gt;54) cout&lt;&lt;&quot;-1.000\n&quot;;    else cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;dp[0][0][0][0][0][0]&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T,cnt=0;    cin&gt;&gt;T;    while(T--)&#123;        cout&lt;&lt;&quot;Case &quot;&lt;&lt;++cnt&lt;&lt;&quot;: &quot;;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>abc423题解</title>
    <url>/posts/9dc41a00/</url>
    <content><![CDATA[省流：ABCDEF，G 感觉有点难了而且慢速选手无法完成 www，rk280。
 A,B,C
略去，不过这里需要特别提醒一下 C 题，显然有结论，就是我们锁上门后显然不会再打开，否则一定不优，开操作和闭操作各自至多进行一次。要能够把所有门都变为锁状态的充要条件是：在完成所有开操作之后，仍然处于打开状态的锁的编号集合必须是形如 {i∣X≤i≤Y}\{i\mid X\le i\le Y\}{i∣X≤i≤Y} 的一个连续区间（并满足 X≤R,;R−1≤YX\le R,;R-1\le YX≤R,;R−1≤Y）。令 Li=0L_i=0Li​=0 的最小下标为 xxx、最大下标为 yyy。当 x≤R−1x\le R-1x≤R−1 时，只需进行使得门 x,x+1,…,R−1x,x+1,\dots,R-1x,x+1,…,R−1 的钥匙全部打开的操作；当 y≥Ry\ge Ry≥R 时，只需进行使得门 R,R+1,…,yR,R+1,\dots,yR,R+1,…,y 的钥匙全部打开的操作，也可以暴力模拟，时间复杂度 O(n)O(n)O(n)。
 D
用一个堆维护当前在餐馆内的人，模拟即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e5+15;struct Node&#123;    int a,b,c,id;&#125;a[MN];struct PNode&#123;    int a,b,c,id,tim;    PNode(Node x,int t)&#123;        a=x.a,b=x.b,c=x.c,id=x.id,tim=t;    &#125;    friend bool operator&gt;(const PNode &amp;x,const PNode &amp;y)&#123;        return x.tim&gt;y.tim;    &#125;&#125;;int n,K,T,pcnt,ans[MN];priority_queue&lt;PNode,vector&lt;PNode&gt;,greater&lt;PNode&gt;&gt; q;bool cmp(Node x,Node y)&#123;    return x.a&lt;y.a;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;K;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].c;        a[i].id=i;    &#125;    sort(a+1,a+1+n,cmp);    ans[a[1].id]=a[1].a;    T=a[1].a;    pcnt=a[1].c;    q.push(PNode(a[1],T+a[1].b));    for(int i=2;i&lt;=n;i++)&#123;        if(pcnt+a[i].c&gt;K)&#123;            while(!q.empty()&amp;&amp;pcnt+a[i].c&gt;K)&#123;                auto tp=q.top();                q.pop();                T=tp.tim;                pcnt-=tp.c;            &#125;            T=max(T,a[i].a);            ans[a[i].id]=T;            pcnt+=a[i].c;            q.push(PNode(a[i],T+a[i].b));        &#125;else&#123;            pcnt+=a[i].c;            T=max(T,a[i].a);            ans[a[i].id]=T;            q.push(PNode(a[i],T+a[i].b));        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 E
显然的想法就是历史和线段树加扫描线，属于子区间计数的经典应用。
不过显然这是求和，考虑贡献法将贡献拆到每一个位置上，考虑 [L,R][L,R][L,R] 的区间内有多少个子区间可以让 aia_{i}ai​ 贡献上，答案是 (R−i+1)(i−L+1)(R-i+1)(i-L+1)(R−i+1)(i−L+1) 次，故答案就是对于 [L,R][L,R][L,R] 区间求 ∑i∈[L,R](R−i+1)(i−L+1)ai\sum\limits_{i\in [L,R]} (R-i+1)(i-L+1)a_{i}i∈[L,R]∑​(R−i+1)(i−L+1)ai​ 即可，注意到显然可以拆开，拆开后会出现 i2aii^2 a_{i}i2ai​、iaiia_{i}iai​ 和 aia_{i}ai​ 这三项的前缀和，维护即可，时间复杂度 O(n)O(n)O(n)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15;int sumx[MN],sumy[MN],sumz[MN],a[MN],n,q;signed main()&#123;    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        sumx[i]=a[i];        sumy[i]=i*a[i];        sumz[i]=i*i*a[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        sumx[i]+=sumx[i-1];        sumy[i]+=sumy[i-1];        sumz[i]+=sumz[i-1];    &#125;    while(q--)&#123;        int l,r;        cin&gt;&gt;l&gt;&gt;r;        int X = sumx[r]-sumx[l-1];        int Y = sumy[r]-sumy[l-1];        int Z = sumz[r]-sumz[l-1];        cout &lt;&lt; (l+r)*Y+(r-l+1)*X-l*r*X-Z &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;
 F
正着直接状压枚举很难，因为可能会算重很多。正难则反容斥，直接状压加二项式反演。不妨设 fkf_{k}fk​ 表示恰好有 kkk 个物种同时爆发的年份数，gkg_{k}gk​ 表示至少有 kkk 个物种同时爆发的年份数，显然有二项式反演公式：
gk=∑i=kn(ik)fi⇔fk=∑i=kn(−1)i−k(ik)gig_{k}=\sum\limits_{i=k} ^n \binom{i}{k} f_{i} \Leftrightarrow f_{k}=\sum\limits_{i=k}^n (-1)^{i-k} \binom{i}{k} g_{i}
gk​=i=k∑n​(ki​)fi​⇔fk​=i=k∑n​(−1)i−k(ki​)gi​
其中 nnn 就是题目中的物种上限。现在问题转化为至少怎么求。首先由于 n≤20n\le 20n≤20 不难想到状压，然后是这个至少怎么解决呢？当然！我们可以转为钦定，我们钦定的年份必须选择，然后计算选取它们至少有多少个年份合法即可！具体的我们可以枚举非空子集 SSS，然后计算其 lcm⁡\operatorname{lcm}lcm 即最小公倍数，若 lcm⁡≤y\operatorname{lcm}\le ylcm≤y，则所有是 lcm⁡\operatorname{lcm}lcm 的倍数的年份都至少包含 SSS 中枚举的蝉，那么有多少个倍数呢，答案就是 ⌊Ylcm⁡(S)⌋\lfloor \dfrac{Y}{\operatorname{lcm}(S)} \rfloor⌊lcm(S)Y​⌋，然后根据上面的公式反演容斥一下即可，时间复杂度为 O(n2n)O(n2^n )O(n2n)。
话说为什么我预处理组合数炸了非要让我现算呢？还有记得开 __int128。
同时这里说明，二项式反演公式描述的是至少与恰好之间的关系，与具体 fff 与 ggg 如何计算无任何关系，只要满足上面的公式就可以。
#include&lt;bits/stdc++.h&gt;#define int long long#define lint __int128using namespace std;constexpr int MN=25;int n,m;lint a[MN],ans,Y,pw[MN],inv[MN];signed main()&#123;    read(n,m,Y);    for(int i=0;i&lt;n;i++)&#123;        read(a[i]);    &#125;    for(int s=1;s&lt;(1&lt;&lt;n);s++)&#123;        int cnt1=__builtin_popcountll(s);        lint ret=1;        bool flag=0;        for(int i=0;i&lt;n;i++)&#123;            if((s&gt;&gt;i)&amp;1)&#123;                ret = lcm(ret,a[i]); //新c++版本默认有 lcm和gcd函数                if(ret&gt;Y)&#123;                    flag=1;                    break;                &#125;            &#125;        &#125;        if(flag) continue;        int res=Y/ret;        if(cnt1 &gt;= m) &#123;            int C=1;            for(int i=0;i&lt;m;i++)&#123;                C=C*(cnt1-i)/(i+1);// C(cnt1, m)            &#125;            if((cnt1-m)%2) res=-res;            ans+=C*res;        &#125;    &#125;    put(ans);    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>agc056b题解</title>
    <url>/posts/500326e7/</url>
    <content><![CDATA[ 正解
首先在分析问题的时候不难发现操作的一个性质就是同一个 xix_ixi​ 对应多个所谓的 p[l,r]p_{[l,r]}p[l,r]​ 序列。
对于这种操作对应多个序列不好计数的限制，一般情况下我们有下面两种思路

探究一下什么序列能够被得到，而不是从操作序列的角度设计 DP 状态。
若硬是从操作序列入手，我们可以通过给操作附上某种特定的顺序，让每一个序列都附上一个唯一的代表元，而这个代表元就是我们需要分题目去设计的。

如果你从第一个思路想的话你会很快陷入瓶颈，不建议自行尝试不然你会很痛苦。
我们从第二个思路入手，那么我们要对操作序列确定一个顺序，使得我们的决策可以唯一化。
考虑用插入法，我们可以从大到小钦定每一个值的位置，就是倒着遍历 n,n−1,n−2,…,2,1n,n-1,n-2,\dots,2,1n,n−1,n−2,…,2,1,。每一次我们把对应的值插到当前最左端的位置。
通过这种方式，我们可以将问题从对 xxx 计数变为对上面合法构造的排列 ppp 进行计数。
考虑如果 DP，注意到每一次操作都是涉及的是 max⁡\maxmax 操作，不妨考虑利用大根堆笛卡尔树的形态进行刻画，笛卡尔树一个很好的特性就是形态是确定的而不是变化的。
那么原题目中的最大值位置 xix_ixi​ 能够产生贡献的区间一定是一个排列上的连续区间，对应到笛卡尔树上就是笛卡尔树的一个子树。那么现在问题转化为对笛卡尔树形态计数，考虑枚举最大值 DP，设 f(l,r,k)f(l,r,k)f(l,r,k) 表示当前枚举的最大值位置在大于等于 kkk 的范围，管辖的子树区间为 [l,r][l,r][l,r] 的笛卡尔树形态数量。
转移显然可以考虑递归处理 [l,k−1],[k+1,r][l,k-1],[k+1,r][l,k−1],[k+1,r]，或者从 f[l,r,k+1]f[l,r,k+1]f[l,r,k+1] 传递过来，对于 f(k+1,r,∗)f(k+1,r,*)f(k+1,r,∗) 的这个第三维是好说的，就是 k+1k+1k+1。但是 f(l,k−1,∗)f(l,k-1,*)f(l,k−1,∗) 是比较难以确定的，因为我们不好确定这个范围。
这里有一个结论，设 k′k&#x27;k′ 表示 [l,k−1][l,k-1][l,k−1] 最大值的位置，那么 [l,r][l,r][l,r] 合法的充要条件是：[l,k−1],[k+1,r][l,k-1],[k+1,r][l,k−1],[k+1,r] 是合法的，并且不能存在一个 l≤li≤k′≤k≤ri≤rl\le l_i \le k&#x27; \le k \le r_i \le rl≤li​≤k′≤k≤ri​≤r。
必要性是显然的，假设不存在 l≤li≤k′≤k≤ri≤rl\le l_i \le k&#x27; \le k \le r_i \le rl≤li​≤k′≤k≤ri​≤r 的话那么我直接把最大值钦定为 k′k&#x27;k′ 也是合法的。考虑证明充分性，如果存在 l≤li≤k′≤k≤ri≤rl\le l_i \le k&#x27; \le k \le r_i \le rl≤li​≤k′≤k≤ri​≤r，那么根据前提条件左区间合法性可以知道把最大值钦定在 k′k&#x27;k′ 的左边都是不合法的，而如果把最大值钦定在 [k′,k)[k&#x27;,k)[k′,k) 中某个位置，那么 xi≠kx_i \neq kxi​=k 了，所以最左端和发位置就是 kkk 了，证毕。
那么我们可以预处理 g(l,r,k)g(l,r,k)g(l,r,k) 表示 [l,r][l,r][l,r] 最大值在 kkk 的时候，[l,k−1][l,k-1][l,k−1] 的最大值位置最小是多少，预处理是 O(n3)O(n^3)O(n3) 的，转移可以做到 O(1)O(1)O(1)，时间复杂度为 O(n3)O(n^3)O(n3)。
提交记录
 反思
这个题还是比较好的，我们在遇见这种操作序列出现多个对应一个的时候，我们要找出的就是那个序列对应的唯一代表元。通过将结果与唯一的操作序列对应起来，从而设计出无重复的 DP。

探究一下什么序列能够被得到，而不是从操作序列的角度设计 DP 状态。
若硬是从操作序列入手，我们可以通过给操作附上某种特定的顺序，让每一个序列都附上一个唯一的代表元，而这个代表元就是我们需要分题目去设计的。

笛卡尔树形态特别适合这种计数思想，尤其是当最大值反复横跳的时候考虑笛卡尔树会有奇效，其实笛卡尔树上的 DP，就是所谓的枚举最大值转移。
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset大肘子</title>
    <url>/posts/39b8edbd/</url>
    <content><![CDATA[ 0. 前言
//整数，string和char数组可以强制类型转换成bitset//不支持迭代器//类似string，可以存入unordered_set/map，可以用cin/cout输入输出//转化为整数时0为最低位，转化为字符串时顺序与原先顺序相同，输出时从高位到低位输出bitset&lt;N&gt;b;//定义初始值全为0的bitset，N为整型常量bitset&lt;N&gt;b(x);//用无符号整型x初始化bitset，不超过unsigned long long范围bitset&lt;N&gt;b(s);//用s初始化b，s可以是basic_string类型或bitset类型，若为basic_string类型则s中只能包含&#x27;0&#x27;或&#x27;1&#x27;bitset&lt;N&gt;b(s,p);//用s从p位置开始到末尾初始化b，此处s只能为basic_string类型，下同bitset&lt;N&gt;b(s,p,n);//用s从p开始的n个数初始化b，p和n都是整数b=b2,b==b2,b!=b2;//b赋值为b2，b与b2是否相等，是否不等b&amp;b2,b|b2,b^b2,b&lt;&lt;n,b&gt;&gt;n,~b;//位运算，返回bitset类型b&amp;=b2,b|=b2,b^=b2,b&lt;&lt;=n,b&gt;&gt;=n;//位运算赋值b[p],b.test(p);//下标访问。test会检查越界抛出异常，但返回为右值不能修改b.flip(p),b.set(p),b.set(p,x),b.reset(p);//取反第p位，第p位设为1，第p位设为x，第p位设为0，O(1)b.flip(),b.set(),b.reset();//所有位取反，所有位设为1，所有位设为0，O(n/w)b.to_ulong(),b.to_ullong();//分别返回unsigned long和unsigned long long类型，表示将bitset转为整数，to_ullong需要C++11b.to_string();//bitset转字符串b.size(),b.any(),b.none(),b.all();//b的大小，是否存在1，是否全为0，是否全为1，all需要C++11，复杂度均为O(1)b.count();//b中1的个数，O(n/w)b._Find_first(),b._Find_next(p);//返回b中第一个1的位置，返回b中p以后不含p第一个1的位置，若不存在返回b的大小，O(n/w)
bitset 的原理实际上就是将 www 个 bool 压到一个整形变量中，每次操作我们同时对 www 个 bool 操作，使时间常数除以 www，通常 www 等于 32 或 64，取决于你是 32 位还是 64 位。
同时显然可以优化空间。
 1. DP
bitset 可以优化可行性 DP，也就是值为 0/10/10/1 的 DP，这一类中最常见的就是背包问题。
 CF1239E Turtle
首先考虑给定矩阵，如何刻画乌龟的路径，有性质：乌龟走的一定是第一行从开头的一段的连续路径，然后下去走到头。故设 preipre_{i}prei​ 表示第一行的前缀和，sufisuf_{i}sufi​ 表示第二行的后缀和。那么答案就是 max⁡i{prei+sufi+1}\max_{i}\{pre_{i}+suf_{i+1}\}maxi​{prei​+sufi+1​}。
考虑重排操作有没有什么性质，有一个贪心的想法，我们让第一行从小到大排序，第二行从大到小排序，这样列列操作一定是最优的，证明考虑从逆序对入手进行反证法即可。然后问题转化为行行之间刻画，可以考虑利用 DP 进行计算，但是代价计算是 max⁡i{prei+sufi+1}\max_{i}\{pre_{i}+suf_{i+1}\}maxi​{prei​+sufi+1​}。我们没法进行转移啊！
考虑简化代价，我们考虑排序的会对乌龟的决策带来什么决策，关键性质：乌龟要么在开头就往下走然后走完第二行，要么走完第一行然后往下走走到终点。
那么代价可以简化成：a(1,1)+a(2,n)+max⁡{∑i=2na(1,i),∑i=1n−1a(2,i)}a(1,1)+a(2,n)+\max\{\sum\limits_{i=2}^{n}a(1,i),\sum\limits_{i=1}^{n-1} a(2,i)\}a(1,1)+a(2,n)+max{i=2∑n​a(1,i),i=1∑n−1​a(2,i)}。前面是固定的，后面是不固定的。直接飞上去 DP 进行决策：设 f(i,j,k)f(i,j,k)f(i,j,k) 表示考虑到第 iii 个数，第一行一共选了 jjj 个数，选出数的总和 kkk 是否可能。最后让总和尽可能对半分即可。
注意到这个是可行化 DP，但是值域和 nnn 极小，可以用 bitset 优化，时间复杂度 O(1wn2∑a)O(\dfrac{1}{w}n^2 \sum\limits a)O(w1​n2∑a)。
 CF1481F AB Tree
注意到答案很奇怪，写个暴力（自从那个构造之后就有写暴力发现性质）发现答案上界在最大深度和最大深度加 111 之间徘徊。
考虑分析最优解构造，注意到答案和深度有关。考虑按层构造，每一层我们尽量填入相同的字符，设出现次数较大的字符为 ccc，因为要降低对儿子的影响，所以把非叶节点填入颜色 ccc，设 mmm 为未填写的字符，因为非叶节点的出现次数 ≤m2\le \dfrac{m}{2}≤2m​，而 c≥m2c\ge \dfrac{m}{2}c≥2m​，所以一定能填满，然后把 ccc 填入这一层的叶节点，剩下的就只有另一种颜色的，填入到其它点中，不难发现只有当前层会多一种不同的字符。
那么现在问题转化为能不能每一层都能填写相同字符,若可行输出用 DP 求解答案并输出方案，否则贪心按照上述方法构造即可。
不难发现这个 DP 可以当作背包 DP，把每一层的节点数量当作物品，那么这就是一个多重背包可行性问题。直接做是 O(n2)O(n^2)O(n2) 的，但是发现物品种类数最多 O(n)O(\sqrt{n})O(n​) 级别的（。可以通过 bitset 加二进制分组优化到 O(nnw)O(\dfrac{n\sqrt{n}}{w})O(wnn​​)，输出方案可以加个回溯也是 ok 的。
我写的是 O(nn)O(n\sqrt{n})O(nn​) 的神秘完全背包做法：题解：CF1481F AB Tree - 洛谷专栏
 2. 矩阵乘法
当矩阵乘法取值只有 0 或 1 时，考虑 bitset 优化：
 CF576D
又是特殊限制，我们还是设 DP。
设 f(i,j)f(i,j)f(i,j) 表示在第 iii 个点，在走过的边数为 jjj 的情况下是否能够到达（取值为 0 或 1），由 j−1j-1j−1 可以转移过来，并且矩阵味很重，转移是或的关系，可以考虑矩阵优化。
考虑无解的情况怎么做，不妨假设 1 号节点边都可以走，如果都可以走的情况下还是到不了那就 GG。
我们根据操作手册，发现在第五步就炸了，因为每一次 did_idi​ 的更新都需要重新设置转移矩阵，考虑根据 did_idi​ 的变化量进行快速幂，每一次中断跑多源 BFS 更新答案，让后就做完了。
我们不难发现 fff 的取值只有 0 或 1，可以利用  bitset 优化，写的时候如下：
struct Matrix&#123;    bitset&lt;MN&gt; mat[MN];    Matrix(int x=0)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                mat[i][j]=0;            &#125;        &#125;        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int k=0;k&lt;MN;k++)&#123;                if(mat[i][k])&#123;// 把j省去了                    ret.mat[i]|=x.mat[k];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;
 3. 异或方程组
异或方程组就是模 2 意义下的线性方程组，所有未知数取值为 0 或 1，已知条件形如若干个未知数异或值为 0 或 1。
bitset 可以优化高斯消元，时间复杂度 O(n3w)O(\dfrac{n^3}{w})O(wn3​)。
和一般的高斯消元一样从前到后依次消每一列。
bitset&lt;MN&gt; bit[MN];int gauss(int n,int m)&#123;    int ans=-1;    for(int i=1;i&lt;=n;i++)&#123;        int cur=i;        while(cur&lt;=m&amp;&amp;!bit[cur].test(i))&#123;            cur++;        &#125;        if(cur&gt;m) return 0;        ans=max(ans,cur);        if(cur!=i) swap(bit[cur],bit[i]);        for(int j=1;j&lt;=m;j++)&#123;            if(i!=j&amp;&amp;bit[j].test(i))&#123;                bit[j]^=bit[i];            &#125;        &#125;    &#125;    return ans;&#125;
P2447 [SDOI2010] 外星千足虫 - 洛谷
 4. 字符串匹配
bitset 可以在 O(nmw)O(\dfrac{nm}{w})O(wnm​) 的时间复杂度内求解字符串匹配，在 m 较小时比 kmp 更优秀，而且支持带修，具体的我们维护每个字符在哪些位置上出现过，记 iii 字符出现在 bib_{i}bi​ 集合的位置，现有匹配串 ststst，维护当前仍然合法的起始点集合 pospospos，则有 pos=pos∧(bsti&gt;&gt;i)pos=pos \land (b_{st_i}&gt;&gt;i)pos=pos∧(bsti​​&gt;&gt;i)。
 CF914F Substrings in a String
bitset 好神秘！
对 26 个字母各开一个 bitset，存这个字母出现的位置。
对于询问，新建一个 bitset。从前到后枚举询问串的每个位置 yi​，和这个字母对应的 bitset 右移 i 位取 and。
最终得到的 bitset 中 1 的个数即为询问串在原串出现次数。
 P4465 [国家集训队] JZPSTR
bitset，bitset，bitset！
虽然标程是分块加 SAM， 但是显然大家都不喜欢这么毒瘤的。注意到插入删除询问次数独立的都很少，并且字符集很少，考虑 bitset。我们维护每个字符在哪些位置上出现过，记 iii 字符出现在 bib_{i}bi​ 集合的位置，现有匹配串 ststst，维护当前仍然合法的起始点集合 pospospos，则有 pos=pos∧(bsti&gt;&gt;i)pos=pos \land (b_{st_i}&gt;&gt;i)pos=pos∧(bsti​​&gt;&gt;i)。
讲完了就好说了，强两个操作显然可以用位运算暴力，第二个就用我们上面的操作，时间复杂度是 O(nTw+nlw)O(\dfrac{nT}{w}+\dfrac{nl}{w})O(wnT​+wnl​) 其中 l=max⁡ilen⁡(zi)l=\max\limits_{i} \operatorname{len}(z_{i})l=imax​len(zi​)。
轻松最优解第二位，不知道第一位如何做到？
 5. 与莫队结合
bitset 常用于常规数据结构难以维护的的判定、统计问题，而莫队可以维护常规数据结构难以维护的区间信息。把两者结合起来使用可以同时利用两者的优势。
 P5355 [Ynoi Easy Round 2017] 由乃的玉米田
bitset 神秘密！
首先飞一个莫队上去，考虑加法操作如何解决，显然只要存在 x+y=kx+y=kx+y=k 即可满足，而题目只要求可行性而非要求个数，故考虑 bitset 维护值域数是否出现，那么加法操作就是 (s1&amp;(s1&lt;&lt;qry[i].x)).any()，其中 s1s1s1 表示值域维护。
然后考虑减法，显然减法可以维护一个 105−x10^5 -x105−x 的 bitset，设为 s2s2s2，那么判断方法就是：(s1&amp;(s2&gt;&gt;(1e5-qry[i].x))).any()。然后考虑乘法，枚举约数 O(nn)O(n\sqrt{n})O(nn​) 做。问题在于除法很难维护，考虑根号分治，&gt;n&gt;\sqrt{n}&gt;n​ 的暴力找。但是问题在于 ≤n\le \sqrt{n}≤n​ 怎么做？
先将询问按左端点降序排列。然后取一个指针，一开始指向 nnn。若当前询问的左端点为 lll，则将 [l,j][l,j][l,j] 上所有元素的贡献插入树状数组中，并使 j=l−1j=l-1j=l−1，完成后直接在树状数组上获取当前询问的答案，时间复杂度 O(nmax⁡iailog⁡n)O(n \sqrt{\max_i a_i}\log n )O(nmaxi​ai​​logn)，直接做即可。
 6. 维护连通性
bitset 常用于维护有向图连通性（无向图直接并查集就行）。，在正反图上跑一个 bitset 统计可达性就可以简单做到 O(n2w)O(\dfrac{n^2}{w})O(wn2​)。
P2881 [USACO07MAR] Ranking the Cows G - 洛谷
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>manacher算法</title>
    <url>/posts/517465e0/</url>
    <content><![CDATA[ 1.Manacher马拉车算法介绍
Manacher算法，又称马拉车算法。用于计算字符串每一个位置为对称中心的回文串长度，即可以用来查询一个长度为nnn的最长回文字串。他的时间复杂度是O(n)O(n)O(n)。是该情景中效率最高的（你不遍历整个字符串咋求出来）
回文串就是从头读到尾部和从尾部读到头都一样的字符串，例如“abbba”。一个回文串是镜像对称的，也就是说他反转之后也是和原串相同的，我们就是依靠这个性质来跑出马拉车算法的。
回文串有两种，一种是奇数的串，就是字符个数有奇数个。一种是偶数的串，例如“abba”就是一个。对于奇数的传，我们可以发现他的对称中心就是中间的‘b’，但是偶数的串呢。他就有2个对称中心，一个是第二个字符‘b’，一个是第三个字符‘b’（门前有两颗树，一颗是B树，另一个也是B树）
总之偶数的回文串对称中心有2个。
 2.暴力法求解
不是说讲马拉车吗？怎么先给我讲暴力法啦？
其实马拉车就是暴力法的改进。所以我们先讲讲暴力法如何求解。
我会枚举！，每次选一个点让后判断是不是回文串！
O(n3)O(n^3)O(n3)
我会优化！我们考虑到上述加粗的，一个回文串是镜像对称的，也就是说我们可以枚举中心，让后向左右两边拓展。例如以“abc”来说，以b为中心，a≠ca\ne ca=c，所以直接结束！
时间复杂度O(n2)O(n^2)O(n2)
写起来差不多就是核心这个循环，其中p[i]p[i]p[i]表示回文半径
while (s[i+p[i]+1]==s[i-p[i]-1])&#123;//+1和-1是向外拓展一格	p[i]++;&#125;
我们仔细思考一下为什么效率低，可以发现我们每次枚举端点都会扫一遍字符串，在最坏的情况下这个字符串里面有许多的回文串，而且都很长，效率近乎降至O(n2)O(n^2)O(n2)，所以马拉车就是利用上面镜像的性质，减少了重复检查。
 3.马拉车算法核心
这里引用Lstdo的博客图
首先我们设maxlmaxlmaxl和maxrmaxrmaxr跟别表示目前找到的回文串左端点最左的位置和右端点最右的位置，pospospos表示这个回文串的对称中心。
回到回文串，回文串的性质是镜像对称，也就是我们可以得出一个重要的性质回文的镜像也是回文。

例如上图，如果jjj处有一个回文字串，黄色部分完全一致，那么对称过去iii处也就肯定有一个回文字串。我们可以很简单的求出来jjj的位置就是pos⋅2−ipos\cdot 2-ipos⋅2−i的，也就是说我们可以直接把p[j]p[j]p[j]的值赋给p[i]p[i]p[i]…吗？
处理时，问题并没有那么的简单，这里我们将一一列举。

最普通的情况，这种情况就是上面的情况，我们就直接赋值即可。
如下，如果发现我们直接赋值的话，那么肯定会超过maxrmaxrmaxr

那就不能直接赋值，这个时候我们要尽可能缩在区间内，所以我们要和j−maxlj-maxlj−maxl和maxr−imaxr-imaxr−i取minminmin。
当iii在右端点的后面

这没办法啦，只能暴力扩展啦。

综上：

如果i&lt;maxri&lt;maxri&lt;maxr,就更新pip_ipi​
暴力拓展
更新maxrmaxrmaxr和pospospos
这就是马拉车，十分甚至九分的简单

等会！你这个我数了（不是哥们），是奇数串！那如果是偶数串呢？
我们不得不说这确实是一个问题，中心为一个字符或两个编码十分的麻烦。我们这里运用一个小技巧，就是在SSS的每一个字符左右插入一个不属于SSS的字符，比如说’#'，把“abcba”变成“#a#b#c#b#a#”，中心字符还是c，如果是偶数串，那么“abba”变为“#a#b#b#a#”唉这不就变成奇数串，中心就是两个b中间夹的“#”。但是还有一个问题，会越界啊。这个时候我们可以在开头和结尾各加上2个不同的字符，比如说“$”和“&amp;”，这样就变成了 ” $#a#b#c#b#a#&amp; “在暴力拓展的时候就不会越界了。
代码如下
// TODO：学麻辣烫车#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MN=1.1*1e7+15;string s1,s;int p[MN*2];//这里一定要开2倍！void change()&#123;//直接用pushback怎么说，stl的魅力    s.push_back(&#x27;$&#x27;);    s.push_back(&#x27;#&#x27;);    for(int i=0;i&lt;s1.length();i++)&#123;        s.push_back(s1[i]);        s.push_back(&#x27;#&#x27;);    &#125;    s.push_back(&#x27;&amp;&#x27;);&#125;void manacher()&#123;    int r=0,c;    for(int i=1;i&lt;s.length();i++)&#123;        if(i&lt;r)&#123;//将两种情况合并            p[i]=min(p[c*2-i],p[c]+c-i);        &#125;        while (s[i+p[i]+1]==s[i-p[i]-1])        &#123;//暴力扩展，注意加一和减一是向外拓展            p[i]++;        &#125;        if(p[i]+i&gt;r)&#123;//如果超范围啦，直接就更新r和c变为当前节点的回文串            r=p[i]+i;            c=i;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;s1;    change();    // cout&lt;&lt;s&lt;&lt;endl;    manacher();    int ans=0;    for(int i=0;i&lt;s.length();i++)&#123;        ans=max(ans,p[i]);    &#125;    // for(int i=0;i&lt;s.length();i++)&#123;    //     cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;    // &#125;    // cout&lt;&lt;endl;    cout&lt;&lt;ans;    return 0;&#125;
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>prufer序列</title>
    <url>/posts/bee84f80/</url>
    <content><![CDATA[ 0. 前言
邦邦卡邦！又学会了新的双射方式！这次是关于树的双射内容！
 1. 定义与构建
 1.1 定义
prufer 序列，又叫做 prüfer 序列，因为键盘平时不太好打出来 ü 所以一般叫做 prufer 序列。他的作用就是可以将一个有标号的 nnn 个点的树映射成一个由 n−2n-2n−2 个在 [1,n][1,n][1,n] 范围内的数所组成的序列，同时这个序列也会唯一对应一个树。也就是说，prufer 序列和树结构构成双射。
 1.2 构建
钦定 nnn 为树的根节点，因为这个树我没有说这是有根树，所以不会影响。
每次选择编号最小的叶子结点并删掉它，再把它的父亲的编号加入序列中。重复此操作，直到树上只有两个点为止。显然，这两个点中必有一个是编号最大的点 nnn。为什么是两个点呢？假设我们再进行一次操作，那么进入序列的必然是 nnn。这是没有意义的操作。而如果我们进行了这次操作，末尾不为 nnn 的 prufer 序列将失去对应一个树的优秀性质。
以下是一个 n=7n=7n=7 的例子：

最终的序列就是 {2,2,3,3,2}\{2,2,3,3,2\}{2,2,3,3,2}。
 1.3 还原
那么可以看得出来，经过此操作，每个树都对应了一个 prufer 序列。如果我么能从 prufer 序列还原出树，那么就证明了树和 prufer 序列是一一对应的。
prufer 序列有一个性质如下：

树上每个点的度数等于在 prufer 序列上出现的次数加 111。

这个性质很好想，因为度数要么来自儿子要么来自父亲贡献，没删掉一个儿子，这个点就会在 prufer 序列上出现一次。而众所周知的是树上一个节点有且仅有一个父亲，所以出现次数加 111 就是度数。而对于根节点为 nnn 则不一样，它在 prufer 序列中出现的次数为它的儿子数减 111，即它的度数减 111。
有了这个性质，我们就可以得知没有出现在 prüfer 序列上的点，一定是叶子结点。
这样我们轻易就能得到树上最小的叶子结点的编号，就是没有在 prüfer 序列上出现的点。我们将这个叶子结点与 prüfer 序列上的第一个数连边，然后删除这个点和 prüfer 序列上的第一个数。如果将编号大于该叶子结点的编号减一，我们就得到了一个长度为 n−3n-3n−3 的 prüfer 序列，对应一个大小为 n−1n-1n−1 的树。因此可以使用同样的方法重复操作，再把最后剩下的点连向 nnn，就可以得到原树。
以下为 {2,2,3,3,2}\{2,2,3,3,2\}{2,2,3,3,2} 的构造：

度数：dg[1,7]={1,4,3,1,1,1,1}dg[1,7]=\{1,4,3,1,1,1,1\}dg[1,7]={1,4,3,1,1,1,1}。
取出 111，令 1→21\to 21→2，dg[1,7]={0,3,3,1,1,1,1}dg[1,7]=\{0,3,3,1,1,1,1\}dg[1,7]={0,3,3,1,1,1,1}。
取出 444，令 4→24\to 24→2，dg[1,7]={0,2,3,0,1,1,1}dg[1,7]=\{0,2,3,0,1,1,1\}dg[1,7]={0,2,3,0,1,1,1}。
取出 555，令 5→35\to 35→3，dg[1,7]={0,2,2,0,0,1,1}dg[1,7]=\{0,2,2,0,0,1,1\}dg[1,7]={0,2,2,0,0,1,1}。
取出 666，令 6→36\to 36→3，dg[1,7]={0,2,1,0,0,0,1}dg[1,7]=\{0,2,1,0,0,0,1\}dg[1,7]={0,2,1,0,0,0,1}。
取出 333，令 3→23\to 23→2，dg[1,7]={0,1,0,0,0,0,1}dg[1,7]=\{0,1,0,0,0,0,1\}dg[1,7]={0,1,0,0,0,0,1}。
prufer 序列遍历完，还剩下 n=7n=7n=7 和 222 号点，连接即可。

总连边：
1 24 25 36 33 27 2
可以自行验证，有结果：

故证明成立。
 1.4 线性时间做到构造与还原
显然可以使用堆做到 O(nlog⁡n)O(n\log n)O(nlogn) 的复杂度，但其实有更优的做法。
维护一个下标 ppp，初始值为最小的叶结点编号。重复以下操作：

删除编号为 ppp 的结点，并检查是否使其父亲成为叶结点。
设其父亲的编号为 xxx。先将 xxx 加入序列。若 xxx 成为了新的叶子结点，判断其与 ppp 的大小关系。若 x&lt;px&lt;px&lt;p，则立即删除 xxx，然后重复判断 xxx 的父亲；否则不管。
使 ppp 自增，直到 ppp 指向一个叶子结点为止。

因为每条边最多被访问一次（在删点的时候访问父亲），指针最多遍历每个点一次，所以复杂度是 O(n)O(n)O(n) 的。
这有点像可删堆的操作，可以结合理解。
对于还原类似，用同样的方法寻找编号最小的叶结点删除即可。
以下为 P6086 【模板】Prüfer 序列 的代码：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e6+15;int fa[MN],dg[MN],p[MN],n,m,ans;void TtoP()&#123;    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;fa[i];        dg[fa[i]]++;    &#125;    for(int i=1,x,j=1;i&lt;=n-2;i++,j++)&#123;        while(dg[j]) j++;        p[i]=fa[x=j];        while(i&lt;=n-2&amp;&amp;!--dg[p[i]]&amp;&amp;p[i]&lt;j)&#123;            p[++i]=fa[x=fa[x]];        &#125;    &#125;    for(int i=1;i&lt;=n-2;i++)&#123;        ans^=1ll*i*p[i];    &#125;&#125;void PtoT()&#123;    for(int i=1;i&lt;=n-2;i++)&#123;        cin&gt;&gt;p[i];        dg[p[i]]++;        p[n-1]=n;    &#125;    for(int i=1,x,j=1;i&lt;=n-1;i++,j++)&#123;        while(dg[j]) j++;        fa[x=j]=p[i];        while(i&lt;=n-1&amp;&amp;!--dg[p[i]]&amp;&amp;p[i]&lt;j) fa[x=fa[x]]=p[++i];    &#125;    for(int i=1;i&lt;=n-1;i++)&#123;        ans^=1ll*i*fa[i];    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    if(m==1)&#123;        TtoP();    &#125;else PtoT();    cout&lt;&lt;ans;    return 0;&#125;
 1.5 性质总结
说了这么多，我们来总结几个关键的性质来辅助做题。

Prufer 序列与树构成唯一双射，在计数问题中对一般树计数可以考虑直接对 prufer 序列计数。
树上每个点的度数等于在 prufer 序列上出现的次数加 111。
所有没在序列里出现过的点，一定是树中的叶子。
对于完全图 KnK_{n}Kn​ 有 nn−2n^{n-2}nn−2 颗生成树。（任意一个长度为 n−2n-2n−2 的值域 [1,n][1,n][1,n] 的序列计数）

我们对第四个结论进行推广：

nnn 个点形成有 kkk 颗树的有标号无根树森林，使得给定的 kkk 个点两两不属于同一棵树，此时的方案总数为 k⋅nn−k−1k\cdot n^{n-k-1}k⋅nn−k−1。
指定点度数的生成树方案为 (n−2)!∏i=1n(di−1)\dfrac{(n-2)!}{\prod_{i=1}^n (d_{i}-1)}∏i=1n​(di​−1)(n−2)!​。
若 nnn 个点已经被连成大小为 {si}i=1k\{s_{i}\}_{i=1}^k{si​}i=1k​ 的 kkk 个连通块，则在这些连通块之间加边构成生成树的方案数为 nk−2∏i=1ksin^{k-2}\prod_{i=1}^k s_{i}nk−2∏i=1k​si​。

推广 1 的证明：给定 nnn 个点和 kkk 个指定点，两两不在同一棵树的无根森林数：

每个指定点作为不同树的根，有根森林数 n n−kn^{\,n-k}nn−k。
无根森林对应有根森林，每棵树根可选择 kkk 种，调整得到：

k⋅n n−k−1.k \cdot n^{\,n-k-1}.
k⋅nn−k−1.
推广 2 的证明：指定 nnn 点度数 {di}\{d_i\}{di​} 的生成树数：

Prüfer 序列长度 n−2n-2n−2。
每点 viv_ivi​ 出现 di−1d_i-1di​−1 次。
多重排列计数：

(n−2)!∏i=1n(di−1)!.\frac{(n-2)!}{\prod_{i=1}^n (d_i-1)!}.
∏i=1n​(di​−1)!(n−2)!​.
推广 3 在后面例题会证明。
 2. 例题
 推广 2 P2290
显然。
 推广 3 CF156D Clues
设 sis_{i}si​ 为第 iii 个连通块的点数，did_{i}di​ 表示连通块在树上的度数。
那么有 Prufer 序列方案数：
(k−2)!(d1−1)!(d2−1)!…(dn−1)!\dfrac{(k-2)!}{(d_{1}-1)!(d_{2}-1)!\dots (d_{n}-1)!}
(d1​−1)!(d2​−1)!…(dn​−1)!(k−2)!​
而一个连通块连接边的方案为 ∏i=1ksidi\prod_{i=1}^k s_{i}^{d_{i}}∏i=1k​sidi​​。那么总方案数枚举 did_{i}di​乘起来即为：
∑di&gt;1,∑i=1kdi=2k−2(k−2)!(d1−1)!(d2−1)!…(dn−1)!∏i=1ksidi\sum\limits_{d_{i}&gt;1,\sum\limits_{i=1}^k d_{i}=2k-2}\dfrac{(k-2)!}{(d_{1}-1)!(d_{2}-1)!\dots (d_{n}-1)!} \prod_{i=1}^k s_{i}^{d_{i}}
di​&gt;1,i=1∑k​di​=2k−2∑​(d1​−1)!(d2​−1)!…(dn​−1)!(k−2)!​i=1∏k​sidi​​
设 ei=di−1e_{i}=d_{i}-1ei​=di​−1，有
∑ei&gt;0,∑i=1kei=k−2(k−2)!e1!e2!…ek!∏i=1ksiei+1\sum\limits_{e_{i}&gt;0,\sum\limits_{i=1}^k e_{i}=k-2}\dfrac{(k-2)!}{e_{1}!e_{2}!\dots e_{k}!} \prod_{i=1}^k s_{i}^{e_{i}+1}
ei​&gt;0,i=1∑k​ei​=k−2∑​e1​!e2​!…ek​!(k−2)!​i=1∏k​siei​+1​
考虑多元二项式定理：
(x1+⋯+xm)p=∑ci≥0,∑i=1mci=p(pc1,c2,⋯ ,cm)⋅∏i=1mxici(x_1 + \dots + x_m)^p = \sum_{c_i \ge 0,\sum_{i=1}^m c_i = p}\binom{p}{c_1, c_2, \cdots ,c_m}\cdot \prod_{i=1}^m{x_i}^{c_i}
(x1​+⋯+xm​)p=ci​≥0,∑i=1m​ci​=p∑​(c1​,c2​,⋯,cm​p​)⋅i=1∏m​xi​ci​
原式变为：
(s1+s2+⋯+sk)k−2⋅∏i=1ksi(s_1+s_2+\cdots+s_k)^{k-2}\cdot\prod_{i=1}^ks_i
(s1​+s2​+⋯+sk​)k−2⋅i=1∏k​si​
即：
nk−2⋅∏i=1ksin^{k-2}\cdot\prod_{i=1}^ks_i
nk−2⋅i=1∏k​si​
 P2624 [HNOI2008] 明明的烦恼
只给了一些点的度数，对于给定度数点的排列方案数也是可以算出来的，记 sum=∑i=1n(di−1)sum=\sum\limits_{i=1}^n (d_{i}-1)sum=i=1∑n​(di​−1)，令 cntcntcnt 表示已知度数的点的个数。那么由上述推论 2 有：
(n−2sum)×sum!∏i=1cnt(di−1)\binom{n-2}{sum}\times \frac{sum!}{\prod_{i=1}^{cnt} (d_{i}-1)}
(sumn−2​)×∏i=1cnt​(di​−1)sum!​
然后剩下的 n−cntn-cntn−cnt 个数任意插在 (n−sum−2)(n-sum-2)(n−sum−2) 的位置上即可，即 (n−cnt)n−sum−2(n-cnt)^{n-sum-2}(n−cnt)n−sum−2。答案就是乘起来即可，但是不给模数是有什么心事吗？我直接 python 喵了。
 CF917D Stranger Trees
等会，题面这个图还有题目背景，莫非是？

咳咳，回到正题，首先看到 “恰好” 直接哈气。用二项式反演反演成至少，有：gk=∑i=kn(ik)fi⇔fk=∑i=kn(−1)i−k(ik)gig_{k}=\sum\limits_{i=k} ^n \binom{i}{k} f_{i} \Leftrightarrow f_{k}=\sum\limits_{i=k}^n (-1)^{i-k} \binom{i}{k} g_{i}gk​=i=k∑n​(ki​)fi​⇔fk​=i=k∑n​(−1)i−k(ki​)gi​。其中 fff 为答案，ggg 为至少 kkk 条边相同的方案数。
然后考虑 ggg 怎么算，发现这玩意我们把钦定的 iii 条边断开，会形成 n−in-in−i 个连通块，而这些连通块都是独立树计数的。根据 Prufer 定理有任意连边方案数：
nm−2∏i=1msin^{m-2}\prod_{i=1}^m s_{i}
nm−2i=1∏m​si​
mmm 为连通块个数，其中 sis_{i}si​ 还是连通块大小。
然后考虑如何快速计算，发现如果直接做因为边不确定状压直接爆炸。数据范围 O(n3)O(n^3)O(n3)，考虑发掘性质。
我们考虑把 gkg_{k}gk​ 的组合意义拆分，前式子可以随便计算，而后面却要求我们快速不用状压计算。考虑 DP，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示 iii 子树内，分成了 jjj 个连通块，当前 iii 所在连通块大小为 kkk 的方案数。时间复杂度 O(n3)O(n^3)O(n3) 可以 O(1)O(1)O(1) 转移但是我认为是 O(n4)→O(n5)O(n^4)\to O(n^5)O(n4)→O(n5) 就很难泵。
但是我们显然有更好的做法，考虑我们只是在计算 ∏i=1msi\prod_{i=1}^m s_{i}∏i=1m​si​，考虑复杂度瓶颈就是在于这个 kkk 这一维度让我们的优化没有前途。考虑切换组合意义，发现 ∏i=1msi\prod_{i=1}^m s_{i}∏i=1m​si​ 的本质就是给每个连通块内部任意定根的方案数，把根是否确定放进状态中即可。
那么这很好考虑设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示 iii 子树内，分成了 jjj 个连通块，iii 所在连通块是否定根的方案数，转移用背包对子树合并即可，时间复杂度 O(n2)O(n^2)O(n2)。
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>zxy思维题乱做</title>
    <url>/posts/e46562f0/</url>
    <content><![CDATA[有很大一部分来自于 zxy，课件等，一般都是很强的 Trick。
 7和8月
 CF1476F
考虑 DP，设 f(i)f(i)f(i) 表示前 iii 个灯可以点亮的最长前缀，有转移：

iii 朝右，若 f(i−1)≥if(i-1)\ge if(i−1)≥i，则 f(i)=max⁡(f(i−1),i+pi)f(i)=\max(f(i-1),i+p_i )f(i)=max(f(i−1),i+pi​)，若 f(i−1)&lt;if(i-1)&lt;if(i−1)&lt;i，则 f(i)=f(i−1)f(i)=f(i-1)f(i)=f(i−1)。
iii 朝左：不难发现只要将前缀覆盖到 i−pii-p_ii−pi​ 即可就行，设 jjj 为第一个 f(j)≥i−pif(j)\ge i-p_if(j)≥i−pi​ 的位置，那么 [j+1,i−1][j+1,i-1][j+1,i−1] 的位置都可以朝右，那么 f(i)=max⁡k=j+1i−1k+pkf(i)=\max\limits_{k=j+1}^{i-1}k+p_kf(i)=k=j+1maxi−1​k+pk​，可以二分 jjj 加 ST 表查出 max⁡[j+1,i−1]\max [j+1,i-1]max[j+1,i−1]。

反思：当我们要 DP 点覆盖的问题的时候，我们可以考虑覆盖一段前缀的形式。同时设计 DP 状态的时候一定要时刻考虑最小状态设计原则。
 HDU6157 The Karting
权值是负的！不能贪心，直接 DP。
但是状态怎么设计呢？考虑记录路径，但是显然会算重一堆。我们可以只考虑断电，让后用前缀和记录回路的贡献。
用 DP 来处理端点，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示前 iii 个点中，选出 jjj 个端点，其中从左往右的端点比从右往左的端点多了 kkk 个（k≥0k\ge 0k≥0），转移考虑当前点的贡献，一共四种情况：

不选这个点：f(i,j,k)←f(i−1,j,k)f(i,j,k)\leftarrow f(i-1,j,k)f(i,j,k)←f(i−1,j,k)；
选这个点但是只经过：f(i,j,k)←f(i−1,j−1,k)f(i,j,k)\leftarrow f(i-1,j-1,k)f(i,j,k)←f(i−1,j−1,k)；
选了这个点从左往右的端点：f(i,j,k)=←f(i−1,j−1.k−1)+a0−2×sif(i,j,k)=\leftarrow f(i-1,j-1.k-1)+a_0 -2\times s_if(i,j,k)=←f(i−1,j−1.k−1)+a0​−2×si​；
选了这个点从右往左的端点：$f(i,j,k)\leftarrow f(i-1,j-1,k+1) + a_0 + 2\times s_i $。

因为要走回去，那么答案就是 f(n,m,0)f(n,m,0)f(n,m,0)，时间复杂度 O(n3)O(n^3)O(n3)。
反思：对于匹配的问题，我们可以拆解贡献到匹配点，考虑到某一个匹配点时候带着贡献和需要匹配的记号转移，这样就能够保证转移的顺序性。
 P6944 Gem Island
好题！
直接飞上去 DP 直接爆炸。考虑分析性质，首先这个过程过于庞大，我们可以分析末状态的性质。先看看对于一种最终状态 a1,a2,…,ana_1,a_2,\dots,a_na1​,a2​,…,an​ 其发生的方案数，可以分为两个部分：

将 ddd 天分给 nnn 个人，钦定这 ddd 天是谁的手上的宝石数增加了：

∏i=1n(d−∑j=1i−1(aj−1)ai−1)=d!∏i=1n(ai−1)!\prod_{i=1}^n \binom{d-\sum_{j=1}^{i-1} (a_j -1)}{a_i-1}=\frac{d!}{\prod_{i=1}^n (a_i-1)!}
i=1∏n​(ai​−1d−∑j=1i−1​(aj​−1)​)=∏i=1n​(ai​−1)!d!​

对于每一天，计算当钦定的人手上宝石数增加的方案数，有：

∏i=1n(ai−1)!\prod_{i=1}^n (a_i -1)!
i=1∏n​(ai​−1)!
不
那么我可以直接 DP 求方案数啦，但是问题在于我怎么求方案中前 rrr 大的 aia_iai​ 和呢？有一种 DP 方法，叫搭楼梯的 dp 方法。
通俗易懂的，我们要用 DP 维护下面的东西：
***********************************************************
设 f(i,j)f(i,j)f(i,j) 表示当前最高的楼梯有 iii 列，楼梯里头 * 的总数为 jjj 的方案数，上面这个东西就是 f(3,59)f(3,59)f(3,59) 的一种方案。
转移很简单，考虑转移的时候在最高层加入一行，枚举这行里头有 kkk 个 *，让后从现有的 jjj 列里头选 kkk 列放到最左边，让后在这 kkk 行上面各加上一个 * 就是一种转移了。比如说上面的例子，枚举 k=2k=2k=2 的时候可以转移到 f(2,61)f(2,61)f(2,61)，转移系数为 (32)\binom{3}{2}(23​)，转移后的形态可以这么表示：
**          &lt;--- 新增的行***********************************************************
这种类似搭楼梯的逐层构造 DP，本质是对所有 “列高单调” 的状态等权枚举，将每一层的结构直接拆分贡献，凡是这类问题：

对象可以抽象为高度具有单调性的多列；
每一层的新增元素对目标量的贡献是可局部计算的（只依赖这一层的列数 kkk，而不依赖更复杂的全局信息）

那么我们就可以用这种转移做前 kkk 大（或小）的期望，总和，分布等。
回到本题，我们把宝石对应成 *，让后每一列对应一个人就可以啦。计算前 kkk 大的方案也就转化为了前 kkk 列的 * 的和，由于我们每次加入一行的那些列，不难观察出一定就是前 kkk 大的列，而且一次局部贡献只加入一个 *，所以可以直接计算。具体的，我们设 g(i,j)g(i,j)g(i,j) 表示当前维护前 iii 大，一共有 jjj 个宝石中所有方案数前 kkk 大的和，有转移：
g(i,j)=∑k=imin⁡(n,i)(g(k,j−i)+min⁡(i,r)×f(k,j−i))×(ki)g(i,j)=\sum_{k=i}^{\min(n,i)} (g(k,j-i) +\min(i,r) \times f(k,j-i))\times \binom{k}{i}
g(i,j)=k=i∑min(n,i)​(g(k,j−i)+min(i,r)×f(k,j−i))×(ik​)
其中 rrr 就是题目中所要的前 kkk 大。
答案就是 ∑i=1ng(i,d)∑i=1nf(i,d)\dfrac{\sum_{i=1}^n g(i,d)}{\sum_{i=1}^n f(i,d)}∑i=1n​f(i,d)∑i=1n​g(i,d)​。
反思：
对于这种多过程的题目，如果过程难以维护，我们可以考虑末状态有没有什么特殊性质。
学到了新的转移( •̀ ω •́ )y
哎我发现你过一段时间回来看这个题发现有些新的收获( •̀ ω •́ )y。
 CF1442
想 DP，但是发现太难了耶。因为操作过于难了，并不是 DP 过于难了。
我们考虑如何简化这个问题，发掘以下性质。首先不难发现所有连在一起的同颜色的点可以一起删。也就是缩点。
让后怎么做？先从简单情况入手，把万能的灰点暂时禁言。让后考虑树是一条链的情况怎么做，因为没有灰点且已经缩点的情况下，这个链一定是黑白相见的，设链长为 lenlenlen，那么答案就是 ⌊len2⌋+1\lfloor \dfrac{len}{2} \rfloor+1⌊2len​⌋+1，贪心策略是将出现次数较多的颜色删掉，让后剩下的连通块逐个删掉就可以了。
接着考虑树不是一条链的时候怎么做，发现上面的策略好像不太好去拓展，且有些情况下不是最优解。考虑再发掘一种策略，有一种策略：从最外层（度数为 111）把同色点一层一层删掉，设 lenlenlen 为直径，那么次数就是 ⌊len2⌋+1\lfloor\dfrac{len}{2} \rfloor+1⌊2len​⌋+1。不难发现这个策略更优，可以用势能分析得出。
接着考虑有灰点的情况，问题可以转化为我们给每一个灰点选择一种颜色，使得再次所点后直径长度最短。这种情况需要我们进行 dp 了。设 f(u,i)f(u,i)f(u,i) 表示 uuu 颜色为 iii 的最长链，g(u,i)g(u,i)g(u,i) 表示 uuu 颜色为 iii，经过 uuu 的最长路径，转移的时候把子树 vvv 合并上来：
g(u,i)←max⁡{g(u,i),min⁡(f(u,i)+f(v,j)+(i≠j))}g(u,i)\leftarrow\max\{ g(u,i),\min(f(u,i)+f(v,j)+(i\neq j)) \}
g(u,i)←max{g(u,i),min(f(u,i)+f(v,j)+(i=j))}
f(u,i)←max⁡{f(u,i),min⁡(f(v,j)+(i≠j))}f(u,i)\leftarrow \max \{ f(u,i),\min(f(v,j)+(i\neq j)) \}
f(u,i)←max{f(u,i),min(f(v,j)+(i=j))}
r=max⁡{min⁡(g(u,i))}r=\max\{\min(g(u,i))\}r=max{min(g(u,i))}，时间复杂度 O(n)O(n)O(n)。
反思：在分析问题的时候，我们通过发掘性质让我们的 dp 有的放矢。从简单问题入手，一步步发掘真相，类似于侦探的过程，这种是常见的思维技巧。
 CF1517F Reunion
直接统计十分困难，考虑转化问题，不难发现可以把问题转化为统计半径 ≥r\ge r≥r 的园的个数。但是如果你对这个进行计数 DP 的话你会发现这个极其容易算重，因为这个是存在问题。
我们考虑存在问题能不能转化为限制问题，这是计数问题中一个常用的思维技巧。不难转化为对于所有黑点周围 ≤r\le r≤r 点的并集不是所有点，这个问题是一个染色问题，我们可以进行 dp。考虑状态中记录黑点往上覆盖的最远距离，或者是子树内最深的还没有被覆盖的点。这两个信息只有一个有效，因为如果子树内有没有被覆盖的点，设点 xxx 能覆盖这个点，那么点 xxx 的覆盖范围一定是子树内黑点往上覆盖范围的超集。
考虑设 f(u,i)f(u,i)f(u,i) 表示子树 uuu 内，i≥0i\ge 0i≥0 则表明子树内黑点网上覆盖的最远距离是 iii，i&lt;0i&lt;0i&lt;0 则表示子树内最深没被覆盖点的深度为 i+1i+1i+1，转移要分讨四种情况，时间复杂度 O(n3)O(n^3)O(n3)。
反思：计数问题中所有限制问题优于存在限制问题。预计那这种会算重的存在性问题想一想能不能转化为限制性问题。
 CF1368H1
一个显然的想法是建出来网络流的图，即 SSS 连蓝色接口，红色接口连 TTT，矩形内的所有点也建出来，向四周连容量为 111 的无向边，然后对原图跑最大流就是答案。
显然会炸掉，考虑不能跑最大流，那怎么办，利用最大流最小割定理，我们可以把原命题转化为求最小割，转化一下就是把矩阵的所有点染蓝或者染红（代表最后和起点还是和终点联通），求所有染色方案下的最小端点异色边数。
考虑 DP，发现直接 DP 没太大啥用。考虑发掘性质，我们发现如果考虑整张图都是红色的情况下，那么割就是蓝色点数，现在问欧体转化为我们要把矩形中一些点改成蓝色使得割最小。那么有一个想法就是改点一定要挨着边界，让后要改要么改一整行要么改一整列。
那么有结论：最优染色方案一定是一整行或一整列颜色相同。对行 DP，翻转矩阵后对列再 DP 就可以了，时间复杂度 O(n)O(n)O(n)。
反思：从高复杂度算法开始，一步一步进行优化，这个和从简单问题推广到更难的问题一样。
最大流问题如果无法优化可以转化为最小割问题。手算最小割属于是一个常见套路。
 acg009c
区间 DP，设 f(i,0/1)f(i,0/1)f(i,0/1) 表示考虑到 iii 个，第 iii 划分到 A 或 B 的方案数。转移的话考虑 0→1,1→00\to 1,1 \to 00→1,1→0 即可，但是要满足两个性质：

区间内部满足条件。
区间两端满足条件。

让后发现第一个的决策集合是一个 [1,i][1,i][1,i] 的一个后缀，第 2 个是一个前缀。用前缀和维护，第一个用分段 for 处理，第二个双指针。
 CF573D
好题，但是田忌赛马。
有一个显然的想法就就是二分图带权最大匹配(或网络流），但是时间复杂度是 O(n3)O(n^3)O(n3) 及其难受，考虑 DP 但直接 DP 十分困难，考虑发掘一些性质。
利用贪心思想，先对 www 和 hhh 进行从小到大的排序，一个基本思想就是对应位置的相乘，用调整法不难证明这是最优决策，但是本题目中存在第 iii 个人不能骑自己的马，所以最优解可能不会取到。
考虑到这个限制只是限制自己不能骑自己的马，合理猜测 iii 位置匹配马的决策是一个范围，有结论：匹配范围为 [i−2,i+2][i-2,i+2][i−2,i+2]。证明考虑反证法，设 iii 的禁止匹配位置为 baniban_{i}bani​。那么反证法，假设如果在这个以外的范围选，那么最多向前会造成两次 (i,i−1)(i,i-1)(i,i−1) 无法匹配，自行画图发现这种情况最劣情况下也只会在 i−2i-2i−2 的情况形成匹配。
借用 _sys 的图：

完美匹配至少有三个红线和黑线相交整法不难证明如果两条线相交那么交换这两个匹配会得到更优的解。
让后考虑交换的过程，我们如果前 iii 个人和前 iii 匹马匹配完全，那么存在 k&lt;3k&lt;3k&lt;3，使得 [i,i+k][i,i+k][i,i+k] 这区间内的人和马匹配，可以用反证法证明。
故，设 fif_{i}fi​ 表示前 iii 个人和前 iii 匹马完成匹配的最大全职，所以从 fi−3,fi−2,fi−1f_{i-3},f_{i-2},f_{i-1}fi−3​,fi−2​,fi−1​ 转移过来即可，同时改成矩阵方式维护 DP 做动态 DP 即可，时间复杂度 O(27nlog⁡n)O(27n \log n)O(27nlogn)，其中 272727 是矩阵带来的常数。
提交记录
反思：限制过松的题目，我们可以通过强化限制使得题目范围的解缩小，让题目简化。
 AGC009E
我太拉了，还是看 大佬 的题解吧。
反思：在具有强烈过程性的题目可以往结果的方向猜性质，观察性质的时候可以观察操作是否具有什么特殊性质，例如本题的 kkk 叉树。
 CF1481E 还有 abc201F
不难发现每本书最多移动一次，移动多次一定是不优的。
把每本书的状态定义为 0/1 表示移动或不移动，枚举这本书的状态，如果以最后一本不动书为界限，那么前面的书那么前面的书如果属于同一种类，那么一定同时移动或者同时不移动，否则这本不动书就会使他们不能相聚。
所以我们枚举最后一本不动书，它后面的数一定要动，现在要决策它前面的书，其实就是选出来书种类的区间不能相交，那设 f(i)f(i)f(i) 表示前 iii 本书中最大的不动书个数，预处理每本书左端点 lil_ili​ 和右端点 rir_iri​ 以及出现次数 cnticnt_icnti​ 就简单了。
反思：状态设计如果没有思路，可以尝试使用枚举法来设计状态，有助于思考。
同类型的题：abc201f
 CF1474F
头脑风暴！
注意到 xxx 对答案一点用都没有，因为我们求的是长度，光一个 ddd 就能够确定答案了。
发现最长严格上升子序列的性质不太好刻画，我们考虑这个添加数的操作过程能不能以一种形式来表现出来。注意到每一个数具体取值只和最后一个数的变化有关，而且变化是连续的，考虑给它拍到二维平面上，横轴按照每一次添加一个数划分时间，纵轴为最后一个值的具体取值，原操作在二维平面上表现的是斜率为 1 或 -1 的一堆直线，如下图，红点表示一次插入操作的：

最长严格上升子序列的性质就很好刻画了，因为根据图来看其实就是最低点和最高点的极差就是我们的长度（因为斜率为 ±1\pm 1±1）。让后我们考虑这个子序列个数怎么解决。发现直接 DP 求解答案十分困难，考虑发掘性质，首先不难发现一个性质：一个段不可能贡献超过一种答案，即一个点不可能成为最低点或最高点。
这个性质有什么用呢，也就是说，我们可以统计对段的答案进行贡献统计。然而注意到段数极小（数据范围 nnn），值域极大，有一个强烈的矩阵味道，但是我到现在连状态都没设计耶？
最长严格上升子序列可能从任意值拼过来，考虑在状态中加上这一个，设 f(i,j)f(i,j)f(i,j) 表示目前计算到第 iii 段，末尾值为 jjj 的方案数，哎这矩阵味道对了，转移：
f(i,j)=∑k=0if(k,j−1)f(i,j)=\sum\limits_{k=0}^i f(k,j-1)
f(i,j)=k=0∑i​f(k,j−1)
矩阵快速幂优化，时间复杂度 O(n4log⁡∣V∣)O(n^4 \log |V|)O(n4log∣V∣)。
Submission #333002703
反思：状态设计中需要是可考虑当前状态能否刻画子问题，不要受限于定居思维。
 CF1463F
容易发现以最优解应是以某一循环节重复多次的形式。
考虑对循环节求解，发现数 iii 的躯体取值仅和前 max⁡(x,y)\max(x,y)max(x,y) 个数的选取情况有关，注意到 max⁡(x,y)≤22\max(x,y)\le 22max(x,y)≤22，考虑状压。因为循环节选取情况一样，所以我们只用遍历第一个循环节的数进行状压。
令 g=max⁡(x,y)g=\max(x,y)g=max(x,y)，全集为 UUU。设 f(i,S)f(i,S)f(i,S) 表示在第 iii 个点，前 ggg 个数选取状态为 SSS 的最优解。
记 ttt 表示 iii 不选的选取状态，那么有转移 f(i,t)=max⁡{f(i,t),f(i−1,s)}f(i,t)=\max\{ f(i,t),f(i-1,s) \}f(i,t)=max{f(i,t),f(i−1,s)}。
若选，则要满足 i−x,i−yi-x,i-yi−x,i−y 没有被选，那么有 f(i,t+1)=max⁡{f(i,t+1),f(i−1,s)+val(i)}f(i,t+1)=\max\{ f(i,t+1),f(i-1,s)+val(i)\}f(i,t+1)=max{f(i,t+1),f(i−1,s)+val(i)}。
其中 val(i)val(i)val(i) 表示 iii 能产生的贡献，具体的：若 L=x+yL=x+yL=x+y，那么原串可以被分为多个长度为 LLL 的循环节，个数不妨设为 numnumnum 个，和最后的 n mod Ln \bmod LnmodL 的遗留串，不妨设长度为 L′L&#x27;L′。
若 i≤L′i\le L&#x27;i≤L′，那么 val(i)=num+1val(i)=num+1val(i)=num+1，反之则为 numnumnum，故可以直接做。
MLE 了记得滚动数组。
反思：若状态转移过大的时候，考虑找规律，矩阵快速幂，或者找循环节。
 Cf1188D
题目要求的就是求：
min⁡x≥0∑cnt1(x+max⁡a−ai)\min_{x\ge 0} \sum cnt1(x+\max a-a_i)
x≥0min​∑cnt1(x+maxa−ai​)
其中 cnt1cnt1cnt1 表示二进制位中 1 的个数，为了方便不妨令 ai←max⁡a−aia_i \leftarrow \max a-a_iai​←maxa−ai​。
考虑如何求解这个式子，我们考虑按位规划，我们考虑以下信息：

xxx 在这一位规划的代价。
所有 aia_iai​ 在这一位的出现情况。
aia_iai​ 是否在之前的规划中出现过进位。

如果我们直接暴力状压进位的话，时间复杂度是 O(n2n)O(n2^n)O(n2n)，及其难受，但是，我们考虑到如果只保留前 i−1i-1i−1 位，越大的 aia_iai​ 约有可能进位，如果我们把所有 aia_iai​ 排序后，那么发现进位的一定是 aaa 的一个前缀。故设 f(i,j)f(i,j)f(i,j) 表示考虑到第 iii 位，有 jjj 个数发生仅为的最小代价，时间房租啊都 O(nlog⁡nlog⁡∣a∣)O(n\log n \log |a|)O(nlognlog∣a∣)。
反思：我们在 dp 优化过程中可以考虑只保留我们需要计算代价相关的状态，这是一个常见的 dp 优化方式。
 CF1539E
首先答案可以抽象为 0/1 相间的串，进一步，可以把答案看作 0 一段，1 一段的串。
如果说，我们答案串里面有一串 0，区间在 [l,r][l,r][l,r]，那么这一段给出的每一个数一定满足：

al,i≤ki≤bl,ia_{l,i}\le k_i \le b_{l,i}al,i​≤ki​≤bl,i​
ar,i≤kl−1≤br,ia_{r,i}\le k_{l-1} \le b_{r,i}ar,i​≤kl−1​≤br,i​

考虑到操作对后续有影响，而对前面没有影响，考虑倒着确定每一个数，倒着扫。维护 0 一段 1 一段的合法区间，每扫一个位置看看上面第二个条件是否满足，如果可以就转移。对于转移是否合法可以用布尔加与运算维护。时间复杂度 O(n)O(n)O(n)。
反思：对于答案是 01 交错的题目，要有把答案切成许多全 1 或全 0 串的思路。对于值要满足后面会出现的限制条件，可以考虑倒着扫。
 CF375E
注意到红色位置没有一丁点用，而且交换操作是很难记录的。注意到黑点总数是固定的，而且交换时任意位置进行交换，不妨考虑让子树内钦定放了几个黑点。
但是这个转化还没有解决 ≤x\le x≤x 的问题，可以满足子树内（不包括 uuu）的点满足条件，这么设计状态是可以的，但是如果包括 uuu 了就得直到谁给 uuu 产生贡献。如果第三维度加上距离 xxx 不好确定，因为贡献不唯一，但是如果我们钦定谁能解决 uuu 的问题的话那么问题就很好做了。
即，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示 iii 子树内放 jjj 个黑点，用 kkk 点解决 iii 点距离的问题。满足的最小代价。
转移考虑枚举第三维这个点具体是什么，从儿子合并上来，有分类讨论：

若儿子 vvv 第三维 k′=kk&#x27;=kk′=k：那么有 f(i,j+j′,k)←f(i,j,k)+f(v,j′,k)f(i,j+j&#x27;,k)\leftarrow f(i,j,k)+f(v,j&#x27;,k)f(i,j+j′,k)←f(i,j,k)+f(v,j′,k)
若儿子 vvv 第三维 k′≠kk&#x27; \neq kk′=k：考虑到父亲肯定不会选儿子 vvv 子树内的点，孩子也不会选子树外的，证明可以考虑调整法。 那么我们合并完 f(i,j+j′.k)f(i,j+j&#x27;.k)f(i,j+j′.k) 之后直接找到对于每个 vvv 子树内 k′k&#x27;k′ 对应最小的 f(v,j′,k′)f(v,j&#x27;,k&#x27;)f(v,j′,k′) 转移即可，时间复杂度 O(n3)O(n^3)O(n3)。

反思：问题前后相互影响的时候，或者操作是全局的，可以尝试把操作部分定义到局部变量里面跟翻遍我们去处理。
卡空间，用 short 即可：
提交记录
 P5289 皮配
题面过于复杂，有一个显然的想法就是让导师们去找学生，设 f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) 表示四个导师选的人数状态下的方案数，转移判断满不满足题目中所给的派系和阵营限制即可，时间复杂度 O(nm4)O(nm^4)O(nm4)，不难发现只需要确定三个即可，时间复杂度 O(nm3)O(nm^3)O(nm3)。然后就不会了。
观察这个 DP 及其难以优化，因为如果我们缺任何一个信息都无法描述完整的子问题，而且复杂度要求的可是 O(nm)O(nm)O(nm)，你只知道一个信息那么肯定啥也导出不了啊。我们考虑发掘几个性质：

确定一个派系和一个阵营可以唯一确定一位导师。
题目中 ban 导师的相当于不选钦定的派系和阵营。

上述性质启示我们让每一个学生去确定它们的派系和阵营，而不是导师去确定学生。但是还有我们的 “坏” 学生，不喜欢选的。我们先丢掉它们，先考虑 k=0k=0k=0 的部分分。
有一个显然的 DP 就是 f(i,j)f(i,j)f(i,j) 表示 iii 个蓝阵营的人，jjj 个鸭阵营的人的方案数，剩余两个可以由这两个状态唯一表示出来，时间复杂度 O(nm2)O(nm^2)O(nm2)，仍无法通过。正解启示 O(nm)O(nm)O(nm)，考虑进一步发掘性质：

题目中学生来自的城市限制，和学校限制是互相独立互不冲突的。

这个性质启发我们分离上面状态设计中的 i,ji,ji,j。那么不妨设 f(i)f(i)f(i) 表示蓝阵营有 iii 个人的方案数，g(i)g(i)g(i) 表示鸭阵营有 iii 个人的方案数，两个答案可以通过乘法原理分别算出来之后乘起来即可，时间复杂度 O(nm)O(nm)O(nm)。
现在考虑 k&gt;0k&gt;0k&gt;0，一个重要的观察是 k≤30k\le 30k≤30。状压、枚举？都不对。我们上面的计算答案过程中体现了乘法原理的思想，也就是说我们也可以分离 “坏学生” 和 “好学生”，好学生单独做，坏学生单独做，最后乘起来即可。
坏学生的限制怎么处理，我们肯定不能用 O(nm)O(nm)O(nm) 的算法了，这个算法肯定是无法处理我们的限制的。回看我们之前 O(nm2)O(nm^2)O(nm2) 的解法，这个就能够很好的处理性质，因为状态能够表示所有派系阵营选择人数，我们可以用这个算法处理坏学生就可以啦。时间复杂度做的话是 O(k2sm)O(k^2sm)O(k2sm) 的。
那么时间复杂度就是 O(nm+k2sm)O(nm+k^2 sm)O(nm+k2sm)。
总结：

我们在设计状态的时候，应当尽量个限制紧密贴合。在优化 DP 的时候我们要考虑我们计算贡献具体需要什么信息，我们需要什么信息就足够了，去掉冗余的无用信息。
题目可能会故意引导你走向死路，如果一个方向想不通，不妨正难则反或换一种方法想，这里体现的是正难则反的思路。

 P7214 治疗计划
把未感染和感染抽象为 0/1，那么原问题可以转化为初始有一个全为 111 的序列，可以在特定时间进行一次区间覆盖操作（有代价），111 会向左右扩散，问能不能将整个序列全部覆盖为 0 且使得操作代价最小。
对于选择区间进行覆盖的问题，这一类经典问题有一种状态设计就是设 f(i)f(i)f(i) 表示将 [1,i][1,i][1,i] 这个前缀进行覆盖的最小代价。但是问题在于这样转移是 O(nm)O(nm)O(nm) 的不太好搞，考虑这个 mmm 的瓶颈就是在于我们需要知道每一个覆盖区间右端点在哪里。考虑切换一下 dp 状态，设 f(i)f(i)f(i) 表示将 [1,ri][1,r_i][1,ri​] 覆盖的最小代价，转移通过 ttt 的偏序关系进行转移：
f(i)←f(j)+cirj−li+1≥∣ti−tj∣\begin{aligned}f(i) &amp; \leftarrow f(j)+c_i &amp; r_j -l_i+1 \ge |t_i -t_j| \end{aligned}
f(i)​←f(j)+ci​​rj​−li​+1≥∣ti​−tj​∣​
时间复杂度还是 O(nm)O(nm)O(nm)，无敌了。而且还自带两个偏序关系更是逆天。但是观察这个 DP 是一个类似于最短路形式的转移（说人话就是转移代价只和目标的代价有关），考虑用 Dijkstra 优化这个 DP。让后绝对值可以通过对 ttt 排序去掉，对于转移可以用线段树优化这个最小值转移，势能分析有时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
总结：
这个题目有一个巨大的卡阻就是在于 DP 容易选择会以时间作为主体，这样的话你无论怎么都无法优化掉时间这一维。一开始想的就是 f(i,j)f(i,j)f(i,j) 添加了时间 jjj 这一个维度，但是发现这个枚举时间反而成为了瓶颈。这个时候，我们需要分析，我们知道什么就够了。分析下来 jjj 反而可以从转移中天然的去掉，这样我们就做到了优化 DP 的过程。
 CF553E
考虑倒着 DP，设 f(i,j)f(i,j)f(i,j) 表示第 iii 个点走到 nnn，当前时间为 jjj 的期望。有转移：
f(u,j)=min⁡v∈son(i){∑kf(v,j+k)⋅pu,k}+wif(u,j)=\min_{v\in son(i)} \{ \sum_{k} f(v,j+k)\cdot p_{u,k} \}+w_i
f(u,j)=v∈son(i)min​{k∑​f(v,j+k)⋅pu,k​}+wi​
末状态 f(u,i)=dis(u,n)+x,i&gt;tf(u,i)=dis(u,n)+x,i&gt;tf(u,i)=dis(u,n)+x,i&gt;t，f(n,i)=0,i≤tf(n,i)=0,i\le tf(n,i)=0,i≤t
时间复杂度 O(nt2)O(nt^2)O(nt2)，无法通过，考虑优化，发现一堆优化板子都套不上去，但是发现 FFT 可以套上去。考虑 FFT 优化，但是注意到这个玩意差卷积不能卷因为这玩意是半在线的。考虑分治 FFT，但是对什么进行分治呢？考虑分析转移方程，注意到方程中时间的转移时具有顺序的，可以进行 CDQ。不妨对时间一维分治。
具体的，记 g(u,v),jg_{(u,v),j}g(u,v),j​ 来表示 ∑k=1tp(u,v),k×f(v,j+k)\sum_{k=1}^t p_{(u,v),k} \times f(v,j+k)∑k=1t​p(u,v),k​×f(v,j+k)，用 f→gf \to gf→g，在分治底层计算出 f(u,j)=min⁡v∈son(i){∑kf(v,j+k)⋅pu,k}+wif(u,j)=\min_{v\in son(i)} \{ \sum_{k} f(v,j+k)\cdot p_{u,k} \}+w_if(u,j)=minv∈son(i)​{∑k​f(v,j+k)⋅pu,k​}+wi​，时间复杂度 O(mtlog⁡2t)O(mt\log^2 t)O(mtlog2t)。
好消息是又学会了一个科技。
反思：DP 优化不仅仅可以从状态优化和一类特殊的转移优化，也可以通过转移的顺序进行优化。
 P3226 集合选数
纯纯构造题，首先 1≤n≤201\le n \le 201≤n≤20 可以通过状压枚举子集做到 O(3n)O(3^n)O(3n)，通过高位前缀和有 O(n2n)O(n2^n)O(n2n)。当然这都不是重点，问题是 n≤105n\le 10^5n≤105。
考虑分析性质，先简化问题，从只有 2x2x2x 的性质。考虑转化模型，让 x→2xx\to 2xx→2x 连边。那么分析图性质不难发现图形成了一条一条的链，那么原命题相当于在上面求解独立集。
接着考虑 3x3x3x 的性质，让 x→3xx\to 3xx→3x，发现图转化为了如下的形态：

那么不难发现图形成了网格图的结构，但原命题相当于还是在上面求解独立集问题。分析这个网格图，发现行数大约为 log⁡2n\log_{2} nlog2​n，列数大约为 log⁡3n\log_{3} nlog3​n，数量极小。考虑状压求解独立集即可。设 f(i,S)f(i,S)f(i,S) 表示考虑到第 iii 行，一行选取数状态为 SSS。预处理合法状态转移即可。
总结：
我们可以通过图论等模型来对题目性质进行进一步转化，同时从简单问题出发，一步一步添加限制也是一个思维角度，在添加限制的过程中会发现一些奇妙的性质。
 CF830D
这玩意好像直接 DP 求发现我们无法确定这个转移顺序和 DP 主体，有可能是路径长度或者树本身。考虑从这个图发掘一些性质，手摸几个小深度的不难发现一些小性质（仅对正解有启示作用）：

一定存在经过所有点的路径（即哈密顿路径），且路径起点终点一定是叶子，这个路径一定算入答案中。
kkk 树的两个孩子由 k−1k-1k−1 树构成，同理 k−1k-1k−1 两个孩子由 k−2k-2k−2 树构成 ，以此类推。
路径可以看作一条有向链。

由于仅对正解起启示作用，故不给详细证明。性质 1 的证明可以归纳法证明，由叶子到叶子的哈密顿路径可在每个父节点处用左右子树的哈密顿路径路递归拼接得到，因此总能存在经过所有顶点的简单路径。
同时结合性质 2，任一节点的子树在哈密顿路径中必须整体连续出现，且路径端点必是叶子，因此全局路径只能自底向上由叶子路径块依次合并成更大的块，否则无法覆盖所有组合且会漏算。启示我们 DP 的主体以树为主体而非路径长度，顺序为自底向上合并。
让后设 f(i)f(i)f(i) 表示 iii 树的贡献，但是发现合并贡献的时候不知道信息，考虑添加一维 jjj 表示有 jjj 条路径链的方案数。转移如下：
f(i,j)←{f(i−1,k)⋅f(i−1,j−k)不算根f(i−1,k)⋅f(i−1,j−k−1)算根f(i−1,k)⋅f(i−1,j−k)⋅2k根合并一条f(i−1,k)⋅f(i−1,j−k+1)⋅k(k+1)根合并两条f(i,j) \leftarrow
\begin{cases}
f(i-1,k)\cdot f(i-1,j-k) &amp; \text{不算根} \\
f(i-1,k)\cdot f(i-1,j-k-1) &amp; \text{算根} \\
f(i-1,k)\cdot f(i-1,j-k) \cdot 2k &amp; \text{根合并一条} \\
f(i-1,k)\cdot f(i-1,j-k+1) \cdot k(k+1) &amp; \text{根合并两条} \\
\end{cases}
f(i,j)←⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​f(i−1,k)⋅f(i−1,j−k)f(i−1,k)⋅f(i−1,j−k−1)f(i−1,k)⋅f(i−1,j−k)⋅2kf(i−1,k)⋅f(i−1,j−k+1)⋅k(k+1)​不算根算根根合并一条根合并两条​
时间复杂度 O(n3)O(n^3)O(n3)。
提交记录
总结：
DP 顺序和方案顺序是不一样的，这道题通过类似于自底向上的合并顺序将若干条（有向）路径合并到一起。
有的时候不好确定 DP 主体和顺序的时候，可以考虑发掘一些小性质，通过小性质将不合法的转移顺序排除。
路径问题可以看作几个有向链的合并过程。
 gym102538H
这道题和上面一样，也是路径计数问题并且考虑的是有向链的合并过程。
首先考虑转移顺序，分析性质发现：

成环的部分一定是 1[ai]1[a_i]1[ai​] 所覆盖的。
环可以拆成两个有向链。

考虑 DP，首先对 aia_iai​ 排序从小到大覆盖区间，简化问题。每次增量一个左部的点，然后考虑它连出去的两条边，达到的效果就是合并两条路径。
设 f(i,j)f(i,j)f(i,j) 表示当前考虑前 iii 个点，形成了 jjj 条路径，转移有两个：

添加 ai−ai−1a_i -a_{i-1}ai​−ai−1​ 个右部单点：f(i,j)=∑k=0ai−ai−1f(i−1,j−k)⋅(ai−ai−1k)f(i,j)=\sum_{k=0}^{a_i-a_{i-1}} f(i-1,j-k) \cdot \binom{a_i-a_{i-1}}{k}f(i,j)=∑k=0ai​−ai−1​​f(i−1,j−k)⋅(kai​−ai−1​​)。
取两条路径合并：f(i,j)=f(i,j+1)×j(j+1)f(i,j)=f(i,j+1)\times j(j+1)f(i,j)=f(i,j+1)×j(j+1)。

时间复杂度 O(n2)O(n^2)O(n2)。
总结：上面两道题给我们了对路径计数问题的一种新看法：有向链的分散与合并。DP 的顺序和方案顺序可能并不一致。
 CF235D
首先很难发现这玩意就是让你求概率而并非期望，因为递归次数可以分配到每个点上，权值为 1，所以答案就是概率求和。
让后考虑概率怎么求，先定义概率是什么，我们发现如果一个点 uuu 要想给另一个点 vvv 组合，即选取点 uuu 为点分治中心，中心与 vvv 联通的概率。贡献的话，那么必须要保证 u→vu \to vu→v 的路径上必须没有点被删，即 uuu 是第一个被删的。大胆猜想概率就是 1dis(u,v)\dfrac{1}{dis(u,v)}dis(u,v)1​，考虑证明用归纳法证明：

若直接删除 uuu，概率就是 1n\dfrac{1}{n}n1​。
若没有删除，那么贡献必须保证删除点之后 u,vu,vu,v 联通。删除一个点的概率为 n−dis(u,v)n\dfrac{n-dis(u,v)}{n}nn−dis(u,v)​，子图内概率为 1dis(u,v)\dfrac{1}{dis(u,v)}dis(u,v)1​，故这种情况概率是 n−dis(u,v)n⋅dis(u,v)\dfrac{n-dis(u,v)}{n \cdot dis(u,v)}n⋅dis(u,v)n−dis(u,v)​

不难发现加起来就是 1dis(u,v)\dfrac{1}{dis(u,v)}dis(u,v)1​，暴力枚举点对时间复杂度 O(n2log⁡n)O(n^2 \log n)O(n2logn)。
考虑放到基环树上怎么做，发现这个 disdisdis 会出现环上两个路径的问题，概率上这两个路径的权重是等价的。考虑如何同时统计两个环上路径的概率，发现很难统计会算重。正难则反，考虑不遍历环，我们直接容斥，设两个路径长度分别为 x,yx,yx,y，令 u,vu,vu,v 到自己树根的距离为 dis(u),dis(v)dis(u),dis(v)dis(u),dis(v)，那么容斥就是 1dis(u)+dis(v)+x+1dis(u)+dis(v)+y−1dis(u)+dis(v)+x+y\dfrac{1}{dis(u)+dis(v)+x}+\dfrac{1}{dis(u)+dis(v)+y}-\dfrac{1}{dis(u)+dis(v)+x+y}dis(u)+dis(v)+x1​+dis(u)+dis(v)+y1​−dis(u)+dis(v)+x+y1​，即多算了两个路径都联通的贡献，时间复杂度 O(n2log⁡n)O(n^2 \log n)O(n2logn)。
总结：
合理利用期望的线性性，要分清是求期望还是概率，别一上去发现求的是概率就搞笑了。
从简单往难推是一个合理的思考思路。
 CF1608F
有一个显然的想法就是状压所有我们选过的数，发现时间复杂度是 O(n2nlog⁡∣V∣)O(n2^n \log |V|)O(n2nlog∣V∣)，及其难泵，考虑分析 mex 运算的性质。

当前 aia_iai​ 选的数比 mex 大，mex 取值不变，同理选的小，不过我们不考虑小的情况从小到大选。
每个位置 mex 的取值是具有限制的。是一个值域范围。

我们考虑我们的状态设计，我么需要在规划完前缀 iii 的时候得到它的 mex，也就是我们的状态必须有这两个维度。除此之外我们还需要所有大于 mex 的值才能让我们转移 mex，但是这不又回到了状压了吗？
我们考虑寻找大于 mex 的等价性，如果我们在一个数对 mex 产生贡献的时候再去计算的话就可以啦。设 f(i,j,k)f(i,j,k)f(i,j,k)，表示目前到第 iii 个，大于 mex 的数为 jjj 个，但是我们未确定这些数，mex 为 kkk 的方案数。

ai&lt;ka_i &lt; kai​&lt;k，对 mexmexmex 不会造成影响：f(i+1,j,k)←f(i,j,k)⋅kf(i+1,j,k) \leftarrow f(i,j,k) \cdot kf(i+1,j,k)←f(i,j,k)⋅k
ai&gt;ka_i &gt; kai​&gt;k，对 mexmexmex 不会造成影响，但是要考虑它是归入已有的未确定的值中：
f(i+1,j,k)←f(i,j,k)⋅jf(i+1,j,k) \leftarrow f(i,j,k) \cdot jf(i+1,j,k)←f(i,j,k)⋅j；
还是新增一种未确定的值：
f(i+1,j+1,k)←f(i,j,k)f(i+1,j+1,k) \leftarrow f(i,j,k)f(i+1,j+1,k)←f(i,j,k)
ai=ka_i = kai​=k，我们改变 mexmexmex 变成 ttt（t&gt;kt &gt; kt&gt;k），那么需要用卡未确定的值来填补 (k,t)(k,t)(k,t) 的这一段，
方案数就是排列数 Ajk−t−1:f(i+1,j−(t−k−1),t)←f(i,j,k)⋅j!(j−(k−t−1))!A^{k-t-1}_j: f(i+1,j-(t-k-1),t) \leftarrow f(i,j,k) \cdot \frac{j!}{(j-(k-t-1))!}Ajk−t−1​:f(i+1,j−(t−k−1),t)←f(i,j,k)⋅(j−(k−t−1))!j!​

时间复杂度 O(n2k2)O(n^2 k^2)O(n2k2)，考虑优化，我们把最后一种转移优化一下，把状态偏移：f′(i,j+k,k)=f(i,j,k)f&#x27;(i,j+k,k)=f(i,j,k)f′(i,j+k,k)=f(i,j,k)，最后一种转移可以对第三维做前缀和，其他转移同下：
f′(i+1,j,k)←j⋅f′(i,j,k)f′(i+1,j+1,k)←f′(i,j,k)f′(i+1,j+1,t)←f′(i,j,k)⋅(j−k)!(j−t)!f&#x27;(i+1,j,k) \leftarrow j\cdot f&#x27;(i,j,k) \\
f&#x27;(i+1,j+1,k)  \leftarrow f&#x27;(i,j,k) \\
f&#x27;(i+1,j+1,t)  \leftarrow f&#x27;(i,j,k)\cdot\frac{(j-k)!}{(j-t)!}
f′(i+1,j,k)←j⋅f′(i,j,k)f′(i+1,j+1,k)←f′(i,j,k)f′(i+1,j+1,t)←f′(i,j,k)⋅(j−t)!(j−k)!​
时间复杂度 O(n2k)O(n^2 k)O(n2k)。
总结：

能需要根据限制的特性，提前或延迟确定一些元素的过程。

 HDU 6566
有一个 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示 iii 子树内权重和为 jjj，当前点选不选的最大权值。时间复杂度 O(Tnm2)O(Tnm^2)O(Tnm2) 无法通过。考虑优化，我们用 dfs 序转移来进行优化，但是发现 dfs 序从 i→i+1i\to i+1i→i+1 的时候进行转移，若 i+1i+1i+1 对应的节点在 iii 对应的节点的上方时，就可能不知道 i+1i+1i+1 选取的情况，而且暴力状压是不行的。
发掘性质，dfn 相邻的点的移动轨迹一定是往上跳若干步然后往下走一步（这个性质很有用），官方题解告诉我们先进行轻重链剖分 然后划定 dfs 序的时候最后遍历重儿子 这样你在 i→i+1i\to i+1i→i+1 的时候会直接跳过上面的一段重链，我们发现对于每个点只需要记录每个重链的链底就好了，由轻重子树剖分性质不难有状压状态数为 O(2log⁡n)=O(n)O(2^{\log n})=O(n)O(2logn)=O(n)。
设 f(i,S,j)f(i,S,j)f(i,S,j) 表示考虑到 dfn 为 iii 的点，当前根的链底的点状态为 SSS，已经用了容量为 jjj，转移可以写成 O(1)O(1)O(1)，时间复杂度 O(n2m)O(n^2m)O(n2m)。
反思：头一次见树形 DP 还可以转到 DFS 序上进行操作，属于是切换了转移顺序。发现就是如果你切换转移顺序可以利用切换至后带来的特殊性质，使得状态是可以减小。
 P7213
这题真是无敌了，想 30 分钟结果连状态都没设出来。
直接 DP 发现没有什么好玩意，考虑发掘一些性质，发现性质是真 dmt 的难找：

序列 A 所代表的末状态 hhh 所构成的集合其取值一定是一个 [1,n][1,n][1,n] 的排列。
震柱子从 2 到 1 一定是值域从大到小震。
操作造成贡献是对值域上位置最靠后的值操作。

由上面三个操作可以一个操作的导出：从值域上从大到小，我们将两个位置位置靠前的减。发现这个没有什么前途因为我试了 www。
考虑性质都是从位置靠后的值操作，有一个操作直接导出就是位置从后往前扫，维护当前值最后一个出现的位置，如果没有出现过，就维护不变，否则减 1。
让后发现每一次都要执行这个操作，如何做到 O(n)O(n)O(n) 而不是 O(n2)O(n^2)O(n2) 操作，发现如果当前柱子之后有高度为 1∼h1\sim h1∼h 的柱子各一根，那么当前柱子及之前的柱子，如果高度 ≤h\le h≤h，都会被直接震没。
发现这个玩意及其有用，我们考虑在这个上面 DP，借鉴 CF1608F 的思路，设 f(i,j)f(i,j)f(i,j) 表示进行到第 iii 个，取出集合最大值为 jjj 的方案数。
方便转移，我们需要设定几个参数：

cnt0cnt0cnt0：表示后 i−1i-1i−1 钦定消失的数量。
cnt1cnt1cnt1：表示后 i−1i-1i−1 钦定存在的数量。

此外需要区分一下同样高度的两个柱子（比如染色）以便转移，最终答案就需要除掉 2n2^n2n。
分类讨论：

如果 iii 钦定消失，那么 jjj 不变，从 f(i−1,j)f(i-1,j)f(i−1,j) 转移，此时有 2j2j2j 个可用高度，而 jjj 个给了取出集合，还有 cnt0cnt0cnt0 个已经钦定，那么系数就是 j−cnt0j-cnt0j−cnt0。
如果 iii 钦定保留，我们同样考虑它的 hhh 取值：

如果 hi&gt;j+1h_{i}&gt;j+1hi​&gt;j+1，我们只能稍后进行确定，从 f(i−1,j)f(i-1,j)f(i−1,j) 转移系数为 1。
若 hi=j+1h_{i}=j+1hi​=j+1，有些标准柱的高度还未确定，所以我们需要考虑接起来之后的高度阈值。我们枚举一个最大值 kkk，此时从 f(i,k)→f(i−1,j)f(i,k)\to f(i-1,j)f(i,k)→f(i−1,j)，计算系数有：

选定位置 (cnt1−jk−j−1)\dbinom{cnt1-j}{k-j-1}(k−j−1cnt1−j​)。
确定当前长度 (k−j+1)(k-j+1)(k−j+1)。
考虑 k−j+1k-j+1k−j+1 的形成方案数，令其为 ggg。
乘起来即可。





现在考虑 ggg 的转移，我们枚举最后产生的高度 jjj，那么有：

h≤j−1h\le j-1h≤j−1 和 h&gt;j+1h&gt; j+1h&gt;j+1，显然不会互相产生影响。这部分的系数为 gj−1×gi−jg_{j-1}\times g_{i-j}gj−1​×gi−j​。
h≤j−1h\le j-1h≤j−1 和 h≥j+1h\ge j+1h≥j+1，排列总方案数 (i−1j−1)\dbinom{i-1}{j-1}(j−1i−1​)。
考虑 jjj 的方案数，共 2(i−j+1)2(i-j+1)2(i−j+1) 个高度可以选择，但是 i−ji-ji−j 已经被选了，所以还剩下 (i−j+2)(i-j+2)(i−j+2) 种方案。
转移乘起来即可，时间复杂度 O(n3)O(n^3)O(n3)。

总结：
这个题实在是太复杂了，即运用到 CF1608F 的延后确定值的思想，又有许多的特殊性质，这个题提取出的精华就是这种延后确定值和钦定值的思想。
 P2048 [NOI2010] 超级钢琴
不难发现答案要求的就是前 kkk 大。
先考虑 k=1k=1k=1 如何做，有一种做法先前缀和，让后固定左端点 lll，那么其对应的右端点区间就是 [l+L,l+R][l+L,l+R][l+L,l+R]，用 ST 表查这个区间对应的最大值前缀和就可以取到多大就可以了。对每一个 lll 做一遍时间复杂度是 O(nlog⁡n+n)O(n\log n+n)O(nlogn+n)，瓶颈在 ST 表预处理。
接着考虑 k&gt;1k&gt;1k&gt;1 如何做，考虑求前 kkk 大的一个经典技巧：用堆维护状态，但要保证堆内情况能做到不重不漏遍历所有情况。
发现每一个左端点对应唯一一个大根堆（以前缀和权值）笛卡尔树，我们可以考虑类似于遍历笛卡尔树的过程进行操作。具体的，先遍历所有 lll，都做一遍 k=1k=1k=1 的操作，让后设定状态 (l,L,R,val,pos)(l,L,R,val,pos)(l,L,R,val,pos) 表示左端点在 lll，管辖区间为 [l+L,l+R][l+L,l+R][l+L,l+R]，当前状态点最大权值为 valvalval，决策取在 pospospos 这个右端点。把所有左端点的答案丢进以 valvalval 决策的大根堆，让后取出堆顶，记录答案，让后类似笛卡尔树一样，把这个以 pospospos 劈开成 [L,pos−1],[pos+1,R][L,pos-1],[pos+1,R][L,pos−1],[pos+1,R]，重新求 valvalval 加入堆里面，重复做 kkk 次即可。
大部分题解的做法可以归类到笛卡尔树的结构，但是我在课上说这个大概是一车人没听懂。
总结：前 kkk 大/小 的权值可以通过用堆来维护状态，但是我们在用堆来进行维护的时候要做到不重不漏的遍历所有情况，状态的设计是一个重要思路。
 CF1060F Shrinking Tree
这题状态涉及真有点巧妙和困难吧？
直接飞上去树形 DP，发现坠机了。考虑发掘一些性质能够，首先规划一个复杂度目标是 O(n4)O(n^4)O(n4)。

根不固定，答案一定和子树大小有关。
u→vu\to vu→v 进行边缩点操作，不妨最后得到的点为 uuu，那么 vvv 的儿子会全部接到 uuu，产生新的限制。
操作是全局的，如果我们无法确定子问题操作顺序的话我们无法确定合理的 DP 顺序。

先确定 DP 主体，我们要对断边的顺序进行概率 DP，将这些概率求和之后除掉 (n−1)!(n-1)!(n−1)! 就可以啦。
让后解决性质带来的问题，对于第一个性质（问题）的解决，我们可以考虑通过枚举法枚举树根给他固定下来，让后钦定这个点是我们最后缩点剩下的点，让后在进行 DP。
发现第二个性质和第三个性质是绑定在一起的，因为如果我们不知道操作顺序的话我们也无法知道缩点之后产生了多少新的限制。先考虑第二个性质，断边之后会带来新的限制，我们可以规划到 vvv 的子问题，就是单独考虑 vvv 的时候这些边不能让 vvv 被消掉。
而对于第三个性质，有一个 Trick：全局操作可以将操作设进局部状态内。具体的，这里的新限制一定是在删除 (u,v)(u,v)(u,v) 这条边之后产生的，我们状态中需要记录操作的时刻。设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内，删除顺序中后 jjj 条边不让 iii 点被消掉的概率。同时记 ggg 表示只考虑子树 vvv 和边 (u,v)(u,v)(u,v) 的概率。
转移考虑枚举 (u,v)(u,v)(u,v) 断开的时间 j′j&#x27;j′：

若 j′≤jj&#x27;\le jj′≤j：那么我们必须要乘上 12\dfrac{1}{2}21​ 的概率，后面的 j−1j-1j−1 条边需要改接到 uuu 上。转移就是 gj←12⋅f(v,j′−1)g_{j}\leftarrow \dfrac{1}{2}\cdot f(v,j&#x27;-1)gj​←21​⋅f(v,j′−1)。
若 j&gt;j‘j&gt;j‘j&gt;j‘，那么 (u,v)(u,v)(u,v) 和我们没关系，这条边会提前断开，但是仍然需要考虑那些改接到 uuu 上的边，所以 gj←f(v,j)g_{j}\leftarrow f(v,j)gj​←f(v,j)。

求出辅助 ggg 之后我们可以背包得到新的 fuf_{u}fu​。因为我们还需要规划断边的顺序，而子树间的断边是互不影响的，所以可以直接用组合数计算方案数，保证考虑到的边和没考虑到的边之间的顺序即可：
fu,i+j′←fu,i⋅gj⋅(i+ji)⋅(sizu−i−1+sizv−jsizv−j)f&#x27;_{u,i+j}\leftarrow f_{u,i}\cdot g_j\cdot{i+j\choose i}\cdot{siz_u-i-1+siz_v-j\choose siz_v-j}
fu,i+j′​←fu,i​⋅gj​⋅(ii+j​)⋅(sizv​−jsizu​−i−1+sizv​−j​)
答案就是 f(i,n−1)(n−1)!\dfrac{f(i,n-1)}{(n-1)!}(n−1)!f(i,n−1)​，时间复杂度 O(n4)→O(n3)O(n^4)\to O(n^3)O(n4)→O(n3)，优化是前缀和优化。
总结：
全局操作可以通过转化例如本题的记录时间转化到局部状态内部。
对于变量我们可以通过枚举法帮助我们进行决策，同时寻找状态之间的不动点。
寻找子问题最重要的是找状态之间的相似性，所谓相似性的含义就是信息记录在子问题中的一部分的占比，本题目中我们通过构造不动色这一相似性来让我们的子问题可以刻画。
 WC2022杂题选讲 stars
为什么我搜不到题啊？

一颗星星可以抽象成 kkk 维空间中的一个整点。称若干星星构成的集合 SSS 是奇妙的，当且仅当在 kkk 维空间中的整点 PPP，PPP 与 SSS 中的每颗星星存在至少有一维坐标相同。
有一个长度为 nnn 的星星序列 AAA，请你求出所有奇妙子区间的个数之和。
1≤n≤105,1≤k≤51 \le n \le 10^5, 1 \le k \le 51≤n≤105,1≤k≤5

触发敏感词 “存在”，联想到 CF1517F 战败经历直接哈气转限制问题。首先 kkk 很小，可以暴力枚举法来确定我们坐标的相同的限制。
有了这个思路，我们来判断 SSS 中集合是否是奇妙的。我们首先把 S0S_{0}S0​ 拿出来，暴力枚举我们钦定的第一个相同的位置。让后接着往后遍历，遇到一个不符合相同的，就在暴力枚举一个，一直往后做直到方案可行即可。
发现上述的过程就是在枚举一个 ppp 的排列，按照这个排列钦定即可（也可以不用全部都用），让后我们要把他搬到计数上，首先发现排列数级别在 O(5!)O(5!)O(5!)，数量 120 极小，可以直接加进 DP 状态内。
倒着扫更方便我们处理，设 f(i,S)f(i,S)f(i,S) 表示我们扫到第 iii 个，钦定顺序为 SSS 的情况下，最远能拓展的距离。发现直接转移是十分困难的。
写出转移需要强大的观察能力，我们可以观察子问题之间的相似性来进行转移，我们考虑 f(i,S)f(i,S)f(i,S) 和 f(i+1,S′)f(i+1,S&#x27;)f(i+1,S′)，其中 S′S&#x27;S′ 为去掉 S0S_{0}S0​ 的排列。只是对于 f(i+1,S′)f(i+1,S&#x27;)f(i+1,S′) 第一个需要新增元素但是可以被 S0S_{0}S0​ 解决的位置是不需要新增的，我们可以让 S0S_{0}S0​ 去解决，所以我们把 S0S_{0}S0​ 插入到当前最后一个锦囊的下一个位置就得到了 i+1i+1i+1 的等效子问题，也就是对于以后的影响都等效地传递下去了。
时间复杂度 O(nk⋅k!)O(nk\cdot k!)O(nk⋅k!)。
总结：
发现之前 DP 的做法顺序有一定的问题，我自己在做 DP 的问题在发掘完性质后就直接开始设置状态，我们在这些过程中融入了一个看似缺失的步骤：寻找子问题。

状态是对子问题的抽象描述，而子问题是状态所对应的具体计算问题。

为什么说是抽象地描述，前面我们所一直重复提及的 “最优最简状态” 的状态优化，就是在设出状态后要通过一系列的抽象化将状态变得简洁且更易计算。而我们状态的抽象化的前提是你的抽象化能够完整导出整个子问题才可以。
那么如何刻画子问题，需要把已经被当前处理的影响“消除”或封装好，让子问题状态只包含“未来的必需信息”，不受当前操作遗留的后效影响。我们将其简称为：“消除后效性”。
而寻找子问题最重要的是找状态之间的相似性。所谓相似性的含义就是信息记录在子问题中的一部分的占比，相似性越大你写转移就越容易，换句话说就是两个状态在未来计算中共享的“信息/行为”比例。
意义在于：高相似性可以让转移方程更统一、简洁，相似性越大你写转移就越容易，而低相似性转移方程复杂、需要处理很多特例。这也就是为什么转移方程有的时候及其难写，根本原因就是在于相似性程度低，状态太细，信息的共性没有利用，未来影响无法统一处理。
这需要强大的观察力和性质分析来分析这个相似性。
回到本题，为什么我们无法写出来转移方程，因为我们没有发现相似性。等效子问题就是一个关键相似性，等效子问题把复杂的状态差异“折叠”掉，只保留对未来影响的核心信息。
于是可以总结一个关键操作：当某个元素的决策影响很远，但 DP 每次只能一步更新时，通过找到一个当前问题的等效子问题，可以把这个远程影响一次性传递给下一步，实现高效转移。
求&quot;满足某种条件的子串/子序列&quot;的长度和、个数。
若无思路可以先考虑如何判断合法，再试图通过 DP 求得答案。
收获的地方就是在于遇到转移方程难写的时候，我究竟应该干什么了。还有等效子问题的优化方法。
 CF1439D INOI Final Contests
我们是对 a,ba,ba,b 进行计数，发现没有空位的情况下是十分好做的，思路就是把人分配到空位置里。但是有空位的情况下就不太好做了，但是借鉴之前的思路，将位置分配给人。
设 f(i,j)f(i,j)f(i,j) 表示考虑 iii 个位置，jjj 个人情况下的贡献，同时需要方案数方便进行转移，设为 g(i,j)g(i,j)g(i,j)，定义同前。转移考虑分类讨论，有两种情况：i&gt;ji&gt;ji&gt;j 和 i=ji=ji=j。即有空位和无空位：

i&gt;ji&gt;ji&gt;j：有一个想法就是我们可以通过空位划分子问题，考虑边缘的空位是限制最小的，枚举空位 kkk，划分为 i−k−1i-k-1i−k−1 和 kkk 的子问题。有转移：

g(i,j)=g(i−1,j)+∑k&gt;0g(i−k−1,j−k)g(k,k)⋅(jk)g(i,j)=g(i-1,j)+\sum\limits_{k&gt;0} g(i-k-1,j-k)g(k,k)\cdot \binom{j}{k}
g(i,j)=g(i−1,j)+k&gt;0∑​g(i−k−1,j−k)g(k,k)⋅(kj​)
f(i,j)=f(i−1,j)+∑k&gt;0(g(i−k−1,j−k)⋅f(k,k)+g(k,k)+f(i−k−1,j−k))⋅(jk)f(i,j)=f(i-1,j)+\sum\limits_{k&gt;0} (g(i-k-1,j-k)\cdot f(k,k)+g(k,k)+f(i-k-1,j-k))\cdot \binom{j}{k}
f(i,j)=f(i−1,j)+k&gt;0∑​(g(i−k−1,j−k)⋅f(k,k)+g(k,k)+f(i−k−1,j−k))⋅(kj​)

i=ji=ji=j：这个时候就不能套用上面的做法，但是我们枚举最后一个人的最终位置 jjj，同时通过这个划分为两个子问题，令 sum(x)=∑i=1xi=x(x+1)2sum(x)=\sum\limits_{i=1}^x i=\dfrac{x(x+1)}{2}sum(x)=i=1∑x​i=2x(x+1)​，有：

g(i,i)=(i+1)∑j=1ig(j−1,j−1)⋅g(i−j,i−j)⋅(i−1j−1)g(i,i)=(i+1)\sum\limits_{j=1}^i g(j-1,j-1)\cdot g(i-j,i-j) \cdot\binom{i-1}{j-1}
g(i,i)=(i+1)j=1∑i​g(j−1,j−1)⋅g(i−j,i−j)⋅(j−1i−1​)
f(i,i)←∑j=1i(sum(i−j)+sum(j))⋅g(j−1,j−1)⋅g(i−j,i−j)⋅(i−1j−1)\begin{aligned}f(i,i)\leftarrow  \sum\limits_{j=1}^i (sum(i-j)+sum(j))\cdot g(j-1,j-1)\cdot g(i-j,i-j) \cdot \binom{i-1}{j-1} \end{aligned}
f(i,i)←j=1∑i​(sum(i−j)+sum(j))⋅g(j−1,j−1)⋅g(i−j,i−j)⋅(j−1i−1​)​
f(i,i)←(i+1)∑j=1if(j−1,j−1)⋅g(i−j,i−j)+f(i−j,i−j)⋅g(j−1,j−1)⋅(i−1j−1)\begin{aligned}f(i,i)\leftarrow  (i+1) \sum\limits_{j=1}^i  f(j-1,j-1)\cdot g(i-j,i-j)+f(i-j,i-j)\cdot g(j-1,j-1) \cdot \binom{i-1}{j-1} \end{aligned}
f(i,i)←(i+1)j=1∑i​f(j−1,j−1)⋅g(i−j,i−j)+f(i−j,i−j)⋅g(j−1,j−1)⋅(j−1i−1​)​
时间复杂度 O(n3)O(n^3)O(n3)。
总结：
这道题就是枚举法划分子问题的巅峰神作之一，总和运用枚举法划分子问题。本题目就是通过限制设置分界线，将一个子问题划分为两个子问题，最后是转移的时候选限制最小的方式转移。突然发现枚举最大值 DP 这玩意和这个极其类似，通过枚举最大值划分子问题。
 CF461E Appleman and a Game
神仙题，不是思路神仙，而是带来的收获很神仙。
先考虑我们直到 sss 的情况下如何求最小，一个显然的想法就是建出 SAM，让后把 sss 丢到 SAMSAMSAM 匹配，如果新加入字符使得当前状态不是子串，直接回到根节点，让后添加 1 的操作（SAM 能表示 ttt 的所有子串）。
让后我们对 sss 计数，当然也可以这么做，设 f(i,j)f(i,j)f(i,j) 表示当前进行到第 iii 个字符，SAM 自动机状态在 jjj 的最小方案数。转移枚举新插入的字符 ccc，让后考虑状态 jjj 的变化。时间复杂度 O(n∣t∣)O(n|t|)O(n∣t∣) 直接爆炸，考虑优化。
发现及其难以优化，因为这玩意瓶颈就是在于枚举字符了，于是，我们使用刚刚学到的新技巧：“大步小步转移”
那么什么是大步小步转移呢？

小步：每次转移只做最细粒度的一步，比如一次只加一个字符、只处理一个元素、只走一步图边。小步适于考虑转移，但是可能会消耗更多时间
大步：一次转移跨过多步，把若干个“小步”打包成一个“段”直接跳过去。例如矩阵快速幂，倍增优化 DP。大步常常会很复杂，但是可能起到加速的效果。

我们尝试增大转移跨度，我们考虑操作次数为 kkk 的时候，能解决长度 xxx 以内的所有字符串，这个 xxx 最大时多少。
我们发现这个玩意毕竟和原命题不太类似，但是我们可以通过二分答案 kkk，若 x&lt;nx&lt;nx&lt;n 则 kkk 合法，最后的答案就是 k+1k+1k+1。
虑这个新问题怎么设计状态，一次操作对应着一段字符串，要满足相邻两个字符串之间不能产生 ttt 的子串，充要条件就是前面一个字符串在末尾添加上下一个字符串的第一个字符不能是 ttt 的子串。
这说明我们只需要记录开头一段的第一个字符，设 f(i,c)f(i,c)f(i,c) 表示 iii 次操作，开头段的第一个字符是 ccc。能构造出来的字符串最短时 f(i,c)+1f(i,c)+1f(i,c)+1，设 g(c,d)g(c,d)g(c,d) 表示字符 ccc 开头，末尾为 ddd 之后就不再是子串 的最短子串。那么转移拼一段上去：
f(i,c)=min⁡dg(c,d)+f(i−1,d)f(i,c)=\min_{d}g(c,d)+f(i-1,d)
f(i,c)=dmin​g(c,d)+f(i−1,d)
通过矩阵快速幂加倍增二分可以做到 O(∣t∣2+log⁡n∣t∣)O(|t|^2+\log n |t|)O(∣t∣2+logn∣t∣)。
总结：
移的大步小步。小步适于考虑转移，但是可能会消耗更多时间；大步常常会很复杂，但是可能起到加速的效果。我们经常先用小步确定规则，再用大步优化效率。在大步小步之间切换，才能写出合适的转移。
 CF559E Gerald and Path
wc，这题 3 个解法简直就是层层递进，一步一步接近真相。
这题完全有必要我单独写一篇题解。
 解法 1
我们发现这个线段既可以向左延申，也可以向右延申。但是有一个问题就是重复被覆盖的，我们不能把他计入贡献，例如下面三种情况：

两个线段 i,ji,ji,j 不交。
线段 i,ji,ji,j 只交一部分。
iii 把 jjj 完全包含。

由于这道题覆盖多次只计入单次贡献，所以转移顺序不能混乱。
先把状态设出来，发现长度延申只和处于最右端的线段决策有关，故设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示前 iii 个线段，右端点最靠右的线段是 jjj，朝向为左或右，所得到的最大覆盖长度。
考虑转移，转移我们要从状态向后拓展，考虑下一个产生贡献的线段 kkk，新增的贡献长度为 min⁡(lenk,rk−rj)\min(len_{k},r_{k}-r_{j})min(lenk​,rk​−rj​)（它最多能延伸自己长度，但若它和前面线段有重叠，只能算到不重叠的部分）而中间线段 [i+1,k−1][i+1,k-1][i+1,k−1] 的处理，如果这些线段如果完全在 kkk 的范围内，我们钦定它们方向让它们被覆盖，相当于忽略它们的贡献。  ——这步是本题的关键：否则你会担心“是不是算少了”。但实际上算少不会影响正确性，因为最优解一定会被统计到；而乱算反而会导致重复覆盖。
转移时间复杂度 O(n3)O(n^3)O(n3)。
总结：思考转移顺序是十分重要的，在覆盖 / DP 问题里，很多时候覆盖多次只算一次，或 顺序影响贡献。如果顺序乱了反而会把贡献重复统计，所以要设计合适的转移顺序。
忽略思想是转移顺序中的一个重要一环，同时也可以将一些不优解算入答案，只要不影响最终答案即可。
 解法 2
大家还记得 Lantern 把，那么覆盖一段前缀的设计。
这里我们先把 ai−bi,ai,ai+bia_{i}-b_{i},a_{i},a_{i}+b_{i}ai​−bi​,ai​,ai​+bi​ 这些位置都离散化，考虑最终点亮的情况一定是若干个不交的段。转移的关键就变成了判定段是否合法，用 Lantern 的方法求出 g(l,r)g(l,r)g(l,r) 表示用点 [l,r][l,r][l,r] 之间的线段是否能够覆盖 [l,r][l,r][l,r] 这些点，用 fif_{i}fi​ 表示前 iii 个点的答案，有转移：
fi=max⁡(fj−1+si−sj)f_{i}=\max(f_{j-1}+s_{i}-s_{j})
fi​=max(fj−1​+si​−sj​)
转移条件 gj,ig_{j,i}gj,i​ 为真，时间复杂度 O(n2log⁡n)O(n^2 \log n)O(n2logn)。
总结：思考最后答案的形式，可能会帮助你把最优化问题转化为判定问题。寻找子问题要考虑消除后面操作的影响。
 解法 3
既然覆盖条件不好求，正难则反，直接计算不被覆盖的区间付出代价，现在目标变为用尽量少的“代价边”覆盖所有点。
设 f(i,j)f(i,j)f(i,j) 表示用前 iii 个点的线段覆盖前缀长度 jjj 的最小代价。
如果线段向右覆盖：
f(i,ri)←f(i−1,k),i≤k&lt;rif(i,r_{i})\leftarrow f(i-1,k),i\le k &lt; r_{i}
f(i,ri​)←f(i−1,k),i≤k&lt;ri​
如果线段向左覆盖，需要加一个 g(i,j)g(i,j)g(i,j) 表示第 iii 条线段向左倒。通过前缀最小值优化转移。
另外还要加上使用“代价边”的情况：
f(i,i)←f(i−1,i−1)+(pi−pi−1)f(i,i)\leftarrow f(i-1,i-1)+(p_{i}-p_{i-1})
f(i,i)←f(i−1,i−1)+(pi​−pi−1​)
时间复杂度 O(n2)O(n^2)O(n2)。
 【UER #6】逃跑
答案求的是 DxDxDx，可以写作 E(x2)−E2(x)E(x^2) -E^2 (x)E(x2)−E2(x)，用线性性拆括号即可做到，这个 xxx 就是我们新经过的点数，而 x2x^2x2 表示两两配对。
考虑预处理 g(i,x,y)g(i,x,y)g(i,x,y) 表示过了 iii 的时间走到 (x,y)(x,y)(x,y) 的期望，可以 O(n3)O(n^3)O(n3) 简单递推，这个玩意是基础我们先求才能地推出其他东西。同时令 pwi=(w1+w2+w3+w4)ipw_{i}=(w_{1}+w_{2}+w_{3}+w_{4})^ipwi​=(w1​+w2​+w3​+w4​)i。
考虑求解 E(x)E(x)E(x) 需要我们求单点对期望的贡献，而且是对每个时间都要求值，考虑设 f(i)f(i)f(i) 表示第 iii 时间新经过 (x,y)(x,y)(x,y) 的期望求和，有转移：
f(i)=pwi−∑j=1i−1f(j)⋅g(i−j,0,0)f(i)=pw_{i}-\sum\limits_{j=1}^{i-1} f(j)\cdot g(i-j,0,0)
f(i)=pwi​−j=1∑i−1​f(j)⋅g(i−j,0,0)
而 E(x)E(x)E(x) 就是：
E(x)=∑i=0nf(i)⋅pwn−iE(x)=\sum\limits_{i=0}^n f(i) \cdot pw_{n-i}
E(x)=i=0∑n​f(i)⋅pwn−i​
接着考虑 E(x2)E(x^2)E(x2)，我们要处理点对之间的贡献，设 h(i,x,y)h(i,x,y)h(i,x,y) 表示时间 iii 内对所有坐标 (a,b)→(a+x,b+y)(a,b)\to (a+x,b+y)(a,b)→(a+x,b+y) 的方案数，转移考虑容斥原理，总的方案数是先第一次走到 (a,b)(a,b)(a,b)，然后任意走到 (a+x,b+y)(a+x,b+y)(a+x,b+y)。需要减去经过 (a+x,b+y)→(a,b)→(a+x,b+y)(a+x,b+y)\to (a,b) \to (a+x,b+y)(a+x,b+y)→(a,b)→(a+x,b+y) 的方案和完成目标后在原地打转的方案。总转移方程：
h(i,x,y)=∑j=0i−1f(j)⋅g(i−j,x,y)−h(j,−x,−y)⋅g(i−j,x,y)−h(j,x,y)⋅g(i−j,0,0)h(i,x,y)=\sum\limits_{j=0}^{i-1} f(j)\cdot g(i-j,x,y)-h(j,-x,-y)\cdot g(i-j,x,y)-h(j,x,y)\cdot g(i-j,0,0)
h(i,x,y)=j=0∑i−1​f(j)⋅g(i−j,x,y)−h(j,−x,−y)⋅g(i−j,x,y)−h(j,x,y)⋅g(i−j,0,0)
因为我们按照顺序计算的贡献，直接求和求出来的是 E((x2))E(\binom{x}{2})E((2x​))，那么求答案可以这么写：
E(x2)=E(x)+2∑h(i,x,y)⋅pw(n−i)E(x^2)=E(x)+2\sum\limits h(i,x,y)\cdot pw(n-i)
E(x2)=E(x)+2∑h(i,x,y)⋅pw(n−i)
总结：正难则反是一个重要的技巧，通过正难则反，减去的东西就规约到了子问题。
而本题状态定义相当于将等价类定义到了状态中，大大减少了不必要的状态，这是因为它们的总方案易于计算，而容斥的方式是本质相同的，最后的答案也只需要求和，所以可以压缩在一起。这种涉及等价类的状态我们可以学习，这一类题也同样在皮配出现，寻找等价类是就是找它们的共同点。
 P1721 [NOI2016] 国王饮水记
直接 DP 发现不会转移难泵了。
考虑发掘性质：

hi&lt;h1h_{i}&lt; h_{1}hi​&lt;h1​ 不会贡献答案，显然可以去掉不会影响答案。
一个水站最多会被除 h1h_{1}h1​ 之外合并一次。
若操作次数管够，一定是将 hhh 从小到大，一个一个和 h1h_{1}h1​ 进行操作。

我们发现第三个性质很 ok 啊，我们考虑给它拓展有拓展次数的情况，那么我们观察样例解释发现他们会通过把一些数取平均数后，然后和 111 整体操作。
那么就好说了，我们有一个策略，就是如果有操作次数的情况下，我们将这个 hhh 从小到大，让后我们将它们划分为几段，让后我们一个一个和 111 进行操作。这其中要满足段数单调不增。
现在可以 DP 了，设 f(i,j)f(i,j)f(i,j) 表示进行到前 iii 个，划分了 jjj 段，h1h_{1}h1​ 的最大取值。转移枚举下一个划段：
f(i,j)←f(k,j−1)+∑p=k+1ihpi−k+1f(i,j)\leftarrow \dfrac{f(k,j-1)+\sum\limits_{p=k+1}^i h_{p}}{i-k+1}
f(i,j)←i−k+1f(k,j−1)+p=k+1∑i​hp​​
转移是 O(n3p)O(n^3 p)O(n3p)，可以通过前缀和优化，设 sumhi=∑i=1ihisumh_{i}=\sum\limits_{i=1}^i h_{i}sumhi​=i=1∑i​hi​，有：
f(i,j)←f(k,j−1)+sumhi−sumhki−k+1f(i,j)\leftarrow \dfrac{f(k,j-1)+sumh_{i}-sumh_k}{i-k+1}
f(i,j)←i−k+1f(k,j−1)+sumhi​−sumhk​​
时间复杂度 O(n3)O(n^3)O(n3)，考虑优化，这个分式有点奇怪，考虑变形：
f(i,j)←sumhi−(sumhk−f(k,j−1))i−(k−1)f(i,j)\leftarrow \dfrac{sumh_{i}-(sumh_{k}-f(k,j-1))}{i-(k-1)}
f(i,j)←i−(k−1)sumhi​−(sumhk​−f(k,j−1))​
这是一个不是很典型斜率优化，考虑把转移的含义看成最大化斜率。具体的，平面有一堆 (i−1,si−f(i,j−1))(i-1,s_{i}-f(i,j-1))(i−1,si​−f(i,j−1)) 的转移点，要求 (i,si)(i,s_{i})(i,si​) 到选定转移点连成直线的斜率最大。
我们要维护的是转移点的下凸包，可以用单调队列优化至 O(n2p)O(n^2p)O(n2p)。
最后的分数需要发现非 111 的段只有 O(log⁡n)O(\log n)O(logn) 个，也就是说我们只需要 dp 大概 14 层即可，后面的的拿单个补齐，层数很少的时候 dp 可以直接用 double，让后得到转移点之后用高精度计算即可，时间复杂度 O(nlog⁡n+np)O(n\log n+np)O(nlogn+np)。
总结：这种是不常见的斜率优化式子，是要求我们变形出斜率的形式，来去维护凸包。
 2025牛客多校第一场（模拟赛T2）

分析性质，发现这个切割可以看作一个树形结构，将区间树选择一个地方劈开，让后会分裂为左右子树，而左右子树也可以继续递归直到叶子，而叶子我们是直到答案的就是 0。启示我们进行类似于区间 dp 的操作
设 f(l,r)f(l,r)f(l,r) 表示将 [l,r][l,r][l,r] 整段切开的最小代价，设 g(l,r)g(l,r)g(l,r) 表示 [l,r][l,r][l,r] 切第一刀的决策点在哪里，转移枚举分界点通过 g(l,r)g(l,r)g(l,r) 转移满足限制即可，时间复杂度 O(n3)O(n^3)O(n3)。
很遗憾，这是错的，只有 20 分，为什么？因为我们的状态无法满足题目的限制，放到树上相当于就是父节点的不平衡值大于等于子区间所有不平衡值，但是我们 DP 在计算过程中低代价方案可能被剪掉（即本来有代价更大，但是满足限制但是因为 DP 没有记录导致错误），导致有解的方案输出无解。
故设 f(l,r,k)f(l,r,k)f(l,r,k) 表示 [l,r][l,r][l,r] 但是分割点在 kkk 的阈值 DDD 和最小代价（二元组）。
转移考虑先枚举切点 kkk，左右和 L=sum(l,k),R=sum(k+1,r)L=sum(l,k),R=sum(k+1,r)L=sum(l,k),R=sum(k+1,r)，那么不平衡度就是 D=∣L−R∣D=|L-R|D=∣L−R∣，代价就是 cost=min⁡(L,R)⋅⌈log⁡2D⌉cost=\min(L,R)\cdot \lceil \log_{2}D\rceilcost=min(L,R)⋅⌈log2​D⌉。
转移即为：
f(l,r)←(D,ask{f(l,k),D}+ask{f(k+1,r),D}+C)f(l,r)\leftarrow (D,\text{ask}\{f(l,k),D\}+\text{ask}\{f(k+1,r),D\}+C)
f(l,r)←(D,ask{f(l,k),D}+ask{f(k+1,r),D}+C)
其中 ask\text{ask}ask 表示一个函数，支持查询区间 [l,r][l,r][l,r] 能在最大不平衡 ≤D\le D≤D 的条件下实现的最小总代价。可以通过前缀 min⁡\minmin 加二分实现。
时间复杂度 O(n3log⁡n)O(n^3 \log n)O(n3logn)。
总结：
在设计状态的时候，要考虑情况完全，要保证设计的状态能够导出整个子问题。本题错点不再子问题寻找，而是在于状态的设计出了锅。以后 DP 转移一定要列全，跟着 OI BIG Trick 的步骤一步一步做。
 P11085 [ROI 2019] 学生座位
考虑发掘性质：


将学生按升高排序之后相邻两个配对最优。


把课桌升序排序之后按顺序分给学生最优。


性质 2 是很有用的，但是后面再说。
既然这么说了，我们可以把 mmm 组同学相邻同学绑到一起，一共一组最多 O(n)O(n)O(n) 块。而计算课桌的代价的时候因为课桌升序排序之后按顺序分给学生最优，可以通过单调性双指针，时间复杂度 O(nm+mk)O(nm+mk)O(nm+mk)，无法通过。
我们没有很好的利用单调性，第二个代表决策单调性，每次求第 midmidmid 的最优匹配点，然后左右的决策点范围是 [ql,mid],[mid,qr][ql,mid],[mid,qr][ql,mid],[mid,qr]，用 CDQ 分治容易有 O((k+nm)log⁡m)O((k+nm)\log m)O((k+nm)logm)。
 CF1562E Rescue Niwen!
2500* 没做出来。
考虑最长上升子序列有什么性质，遥想当年 DIV3 模拟赛 LIS 的一个解法：维护末尾元素的转移。这里我们同样的，维护结尾子串的转移。但是还不能进行 DP，考虑发掘性质：

对于子串，字典序大小有 s[i,j]&lt;s[i,j+1]s[i,j]&lt;s[i,j+1]s[i,j]&lt;s[i,j+1]。也就是说一旦选取 s[i,j]s[i,j]s[i,j]，那么 s[i,j+1],s[i,j+2],…,s[i,n]s[i,j+1],s[i,j+2],\dots,s[i,n]s[i,j+1],s[i,j+2],…,s[i,n] 一定会被选。证明考虑反证法，我证明了 5 万年。

这个性质很有用，考虑直接对末尾进行 DP，设 f(i)f(i)f(i) 表示结尾为 [i,n][i,n][i,n] 的子串的最长上升子序列，转移考虑枚举新后缀 jjj，求它们之间的最长公共前缀 lcplcplcp，只要 si+lcp&gt;sj+lcps_{i+lcp}&gt;s_{j+lcp}si+lcp​&gt;sj+lcp​ 即可转移，转移方程如下：
fi=(n−i+1)+max⁡1≤j&lt;i{fj−lcp(i,j)}f_{i}=(n-i+1)+\max_{1\le j &lt;i} \{ f_{j}-\text{lcp}(i,j) \}
fi​=(n−i+1)+1≤j&lt;imax​{fj​−lcp(i,j)}
时间复杂度 O(n2)O(n^2)O(n2)。
总结：
考虑有效状态又多了一种思路：只求出跟答案相关的 dp 值即可，只用于转移的 dp 值可以考虑其性质。
 CF708E Student’s Camp
这个题好像每太那么多的性质，那么直接 DP 发掘性质吧。设 f(i,j,l,r)f(i,j,l,r)f(i,j,l,r) 表示 iii 天过去了，第 jjj 行，[l,r][l,r][l,r] 还在的概率。但是我们发现我们都钦定第 jjj 行谁还联通，不如大胆一点，直接把天数去掉！设 f(i,l,r)f(i,l,r)f(i,l,r) 表示第 iii 行，[l,r][l,r][l,r] 还在并且前 i−1i-1i−1 行还联通的概率。
然后考虑转移，发现转移有些困难，但是在这之前我们需要预处理一个玩意 gig_{i}gi​ 表示一行掉了 iii 个格子的概率，这个玩意可以 O(1)O(1)O(1) 做：
gi=(ki)pi(1−p)k−ig_{i}=\binom{k}{i}p^i (1-p)^{k-i}
gi​=(ik​)pi(1−p)k−i
然后回到主题转移，发现转移时真的困难，因为转移的时候我们需要保证 i−1i-1i−1 连通，正难则反，考虑容斥减去不连通的方案数。
f(i,l,r)=gl−1⋅gm−r⋅(∑l′≤r′f(i−1,l′,r′)−∑l′≤r′&lt;lf(i−1,l′,r′)−∑r&lt;l′≤r′f(i−1,l′,r′))f(i,l,r)=g_{l-1}\cdot g_{m-r} \cdot (\sum\limits_{l&#x27;\le r&#x27;}f(i-1,l&#x27;,r&#x27;)-\sum\limits_{l&#x27;\le r&#x27; &lt; l}f(i-1,l&#x27;,r&#x27;)-\sum\limits_{r&lt;l&#x27;\le r&#x27;}f(i-1,l&#x27;,r&#x27;))
f(i,l,r)=gl−1​⋅gm−r​⋅(l′≤r′∑​f(i−1,l′,r′)−l′≤r′&lt;l∑​f(i−1,l′,r′)−r&lt;l′≤r′∑​f(i−1,l′,r′))
不难后面的东西可以前缀和优化，令：
F(i)=∑l′≤r′f(i−1,l′,r′)L(i,x)=∑l′≤r′&lt;xf(i−1,l′,r′)R(i,x)=∑x&lt;l′≤r′f(i−1,l′,r′)\begin{aligned}F(i)&amp;=\sum\limits_{l&#x27;\le r&#x27;}f(i-1,l&#x27;,r&#x27;)\\L(i,x)&amp;=\sum_{l&#x27;\leq r&#x27;&lt;x}f(i-1,l&#x27;,r&#x27;)\\R(i,x)&amp;=\sum_{x&lt;l&#x27;\leq r&#x27;} f(i-1,l&#x27;,r&#x27;) \end{aligned}
F(i)L(i,x)R(i,x)​=l′≤r′∑​f(i−1,l′,r′)=l′≤r′&lt;x∑​f(i−1,l′,r′)=x&lt;l′≤r′∑​f(i−1,l′,r′)​
优化即可时间复杂度 O(n3)O(n^3)O(n3)，然后就不会优化了。
事实上当然是可以的啦，考虑后面的求和式子，一个关键观察式子只和求和有关而没有其他的式子，考虑以这个突破口，考虑到答案只需要整体求和，我们可以把状态也定义成和式。设 S(i,r)=∑l≤rf(i,l,r)S(i,r)=\sum\limits_{l\le r}f(i,l,r)S(i,r)=l≤r∑​f(i,l,r)，考虑写出这个和式的转移：
S(i,r)=∑lgl−1gm−r⋅(F(i−1)−L(i−1,l)−R(i−1,r))S(i,r)=\sum\limits_{l}g_{l-1}g_{m-r}\cdot (F(i-1)-L(i-1,l)-R(i-1,r)) 
S(i,r)=l∑​gl−1​gm−r​⋅(F(i−1)−L(i−1,l)−R(i−1,r))
把 rrr 有关的部分提出来有：
S(i,r)=gm−r⋅{(F(i−1)−R(i−1,r))⋅∑l≤rgl−1−∑l≤rgl−1⋅L(i−1,l)}S(i,r)=g_{m-r}\cdot\{(F(i-1)-R(i-1,r))\cdot \sum\limits_{l\le r} g_{l-1}-\sum\limits_{l\le r}g_{l-1}\cdot L(i-1,l)\}
S(i,r)=gm−r​⋅{(F(i−1)−R(i−1,r))⋅l≤r∑​gl−1​−l≤r∑​gl−1​⋅L(i−1,l)}
用前缀和维护 ∑l≤rgl−1\sum\limits_{l\le r} g_{l-1}l≤r∑​gl−1​ 和 ∑l≤rgl−1⋅L(i−1,l)\sum\limits_{l\le r} g_{l-1} \cdot L(i-1,l)l≤r∑​gl−1​⋅L(i−1,l) 即可，而 RRR 的计算可以用对称性用 LLL 计算，这是因为左右是等价的，所以翻折之后对应的值是相等的。
时间复杂度 O(n2)O(n^2)O(n2)。
总结：
这里给出了 DP 的一种的新的优化方式，如果 DP 式子只和求和有关，我们可以将状态定义为和式来进行计算。
 ARC160FCount Sorted Arrays
邦邦卡邦！学会了新的排列双射方式！
一个新的排列双射方式就是将排列 PPP 拆成 nnn 个 0/1 串 C1,…,CnC_{1},\dots,C_{n}C1​,…,Cn​，其中 Ci,j=[Pj≥i]C_{i,j}=[P_{j}\ge i]Ci,j​=[Pj​≥i]，那么 PPP 与 CCC 构成双射。而一个排列合法当且仅当分成的每个 01 序列最后操作完都是有序的。
同时分析题目的操作，因为逆序对数最多是 O(n)O(n)O(n) 个，所以交换最多也只能是 O(n2)O(n^2)O(n2) 级别的。
我们回到这题，我们考虑让 Cx,jC_{x,j}Cx,j​，其中 xxx 从 n,n−1,…,1n,n-1,\dots,1n,n−1,…,1 一次下降，每降一次阈值，就恰好有一个位置 iii（值等于当前的 xxx）从 0 变成 1。因此得到的 01 串序列是：

起点：全 0（可以看作 x=n+1x=n+1x=n+1）
每一步把某个坐标从 0 翻到 1
终点：全 1（x=1x=1x=1)

这正是一条在 {0,1}n\{ 0,1\}^n{0,1}n 上 “只增不减” 的单调路径。
并且“哪一个坐标在第 ttt 步被翻到 1”，恰好是“值为第 ttt 大的元素所在的位置”。
故每个排列对应一条唯一的单调路径，双射成功！问题转化为格路计数问题！时间复杂度 O(q2n)O(q2^n)O(q2n)，同时操作数是 O(n2)O(n^2)O(n2) 级别的也是可以特判的，只有存在至少一个 01 排序后还有 pu&gt;Pvp_{u}&gt; P_{v}pu​&gt;Pv​​ 时 (u,v)(u,v)(u,v) 操作才是有必要的。
更新操作必要性状态即可，时间复杂度 O(n32n)O(n^3 2^n)O(n32n)。
总结：
计数问题当我们无从下手，我们可以借助一些已有的知识与原命题构成双射。简化问题。
 CF1387B2 Village (Maximum)
发现这个就是点之间进行配对，有一个 Trick 就是将点对之间贡献分摊到边的贡献上。我们考虑边的贡献，也即是这条边究竟被经过了多少次，这个次数有一个显然的上界就是 2×min⁡(sizu,sizv)2\times \min(siz_{u},siz_{v})2×min(sizu​,sizv​)，其中 sizsizsiz 表示子树大小。
考虑如何构造使得经过次数最大，考虑式子 2×min⁡(sizu,sizv)2\times \min(siz_{u},siz_{v})2×min(sizu​,sizv​) 与取 min⁡\minmin 有关，也就是说我们应当尽量让这个 min⁡\minmin 大。考虑这个 min⁡\minmin 上界是多少，有 sizu+sizv=nsiz_{u}+siz_{v}=nsizu​+sizv​=n 不难证明 min⁡\minmin 上界就是 ⌊n2⌋\lfloor \dfrac{n}{2}\rfloor⌊2n​⌋。这个上界什么时候取到，当然就是在树的重心。
考虑以树的重心为根，下面挂的子树大小都不超过 n2\dfrac{n}{2}2n​。那么子树里面的点贪心策略一定是跨子树配对，故我们可以将所有节点按照 DFS 序后，第 iii 个节点配对 (i+n2−1) mod n+1\left(i+\dfrac{n}{2}-1\right)\bmod n +1(i+2n​−1)modn+1 个节点即可在另一个子树配对，时间复杂度 O(n)O(n)O(n)。
总结：这道题的一个小 Trick 的就是将点对贡献分摊到边上，同时我们在最大化链的长度的时候要尽量跨子树。同时这个循环移位配对也是很好的思想。
 CF516D Drazil and Morning Exercise
首先我们分析 fff 怎么求，不难想到这个 fff 一定和直径有关，那么 fff 其实就是到直径两点中最长距离的那一个，证明利用直径为最长链的性质即可证明。
然后考虑 O(qn2)O(qn^2)O(qn2) 怎么做，有一个显然的想法就是暴力枚举最小值，固定的点，让后从这个最小值的点向外进行拓展，直到拓展到 xxx 的限制。
然后考虑如何优化这一过程，我们发现瓶颈首先在于枚举最小值，考虑优化这一步骤，我们发现最小的 min⁡f\min fminf 一定在直径上取到，考虑直径上取 min⁡f\min fminf 的点为根作为树。这个树有一个性质就是从当前点往下走，fff 单调不降。也就是说从该点到祖先的链上 fff 具有单调性，我们可以在遍历这个树的时候维护祖先链，然后二分查找连通块大小即可，这个玩意直接做还是 O(qn2log⁡n)O(qn^2\log n)O(qn2logn)，通过树上差分有 O(qnlog⁡n)O(qn\log n)O(qnlogn)。
总结：树上最远点问题可以转直径端点
 CF1622F Quadratic Set
平方数没看懂，换成完全平方数就看懂了。连夜将 OI BIG TRICK 中的完全平方数的性质改为平方数的性质。
性质：

∏i=1ni!=∏i=1nin−i+1\prod_{i=1}^n i!=\prod_{i=1}^n i^{n-i+1}∏i=1n​i!=∏i=1n​in−i+1，也就是说 i,ni,ni,n 不同奇偶的时候是一个完全平方数。
打表发现答案下界为 n−3n-3n−3？

我们考虑这个连乘阶乘能否分析：
∏i=12ki!=∏i=1k(2i)!⋅(2i−1)!=∏i=1k[(2i−1)!]2⋅(2i)=2k⋅k!∏i=1k[(2i−1)!]2\begin{aligned}
\prod_{i=1}^{2k} i! &amp; =\prod_{i=1}^k (2i)!\cdot (2i-1)! \\ &amp; =\prod_{i=1}^k [(2i-1)!]^2\cdot (2i) \\
&amp; =2^k \cdot k! \prod_{i=1}^k [(2i-1)!]^2
\end{aligned}
i=1∏2k​i!​=i=1∏k​(2i)!⋅(2i−1)!=i=1∏k​[(2i−1)!]2⋅(2i)=2k⋅k!i=1∏k​[(2i−1)!]2​
后面是完全平方数，考虑前面的式子。

当 nnn 为偶数，也就是说 n=2kn=2kn=2k。

当 kkk 为偶数，构造考虑将 kkk 去掉即可。
当 kkk 为奇数，构造将 2,k2,k2,k 去掉即可。


当 nnn 为奇数，把 nnn 去掉就可以变成上一种情况。

然后考虑完全平方数的性质如何满足，注意到完全平方数的本质就是质因数上次数都为偶数，注意到我们只关心就行即可，我们考虑异或哈希，设 f(x)f(x)f(x) 表示 xxx 的哈希函数，若 xxx 为质数则随机赋权，反之为质因数异或和。然后利用异或哈希模拟上述过程即可，时间复杂度 O(能过)O(\text{能过})O(能过)。
总结：
当性质不好发现的时候，考虑打表发掘性质，尤其这一类数学限制题。
当答案很小的时候，我们可以通过分类讨论，用讨论法解决问题，排除掉所有简单情况之后剩下的就是那种较复杂的情况。
 P9520 [JOISC 2022] 监狱
考虑分析性质，本题只有有无正解，考虑无解的情况：


两个囚犯路径有重合，且相向而行。


两个囚犯路径呈包含与被包含关系。


两个囚犯路径有重合，但处理不当，使其在中途相遇。


在分析第三条的处理，我们考虑一个合法的处理顺序是怎样的。囚犯们当然可以先安排一个囚犯走完他的路径，再同理安排另一个，这是因为每个囚犯的移动路径是独立的，要想判断最终情况是否合法，这要知道先后顺序，这与囚犯们谁先走完路径是无关的，故这种移动策略是合理的。
所以我们取思考囚犯的一定顺序，有性质：

如果 A 的起点在 B 的路径上，那么 A 必须比 B 先走。
如果 A 的终点在 B 的路径上，那么 B 必须比 A 先走

这表现了一个决定关系，可以利用拓扑排序判断关系是否成环，发现边数达到 m2m^2m2 级别用线段树优化建图即可。
总结：
分析只输出有无解的情况可以从什么时候会无解，让后分析无解的条件，通过条件导出问题。
 AT_agc012_eCamel and Oases
这个就不写代码，就写题解了。考虑分析性质：

一个位置能够走到的位置是是一段连续的区间。
根据贪心，每次跳都是灌满水后再跳，最多 log⁡V\log VlogV 次。

上面两个性质，问题就变成了：在每层选一个线段，将整个区间完全覆盖。其中第一层选择的线段是钦定的（因为要对每个出发点求是否有解）由于层数是 log⁡V\log VlogV 级别的可以暴力预处理和状压 DP，状态 SiS_{i}Si​ 为 1 表示第 iii
层已经选了一个线段。我们要 dp 出两个东西：LSL_SLS​ 表示状态 SSS 下，从左到右能完全覆盖的最右边位置；RSR_{S}RS​ 表示状态 SSS 下，从右到左能完全覆盖的最左边位置，转移通过预处理区间即可做到转移。
但是上述转移是要枚举状态和枚举线段的，复杂度会不会爆炸呢？不会。显然的，若第一层线段多于 log⁡v\log vlogv 个，那不可能有解，在这种情况下直接全部输出 Impossible 即可。
 CF1658F Juju and Binary String
考虑发掘性质，对于可爱度换一个定义：
cnt1cnt0+cnt1=cnt1n\dfrac{cnt1}{cnt0+cnt1}=\dfrac{cnt1}{n}
cnt0+cnt1cnt1​=ncnt1​
那么问题要求子串拼接起来后仍和整个串满足上面这个式子，而且要求分出来的段数极小。
考虑从 0/1 个数入手，发现选取子串 1 的个数和为 c=cnt1⋅mnc=\dfrac{cnt1\cdot  m}{n}c=ncnt1⋅m​，那么有 n∣cnt1⋅mn|cnt1\cdot mn∣cnt1⋅m 则无解。但这是必要条件。
搞笑的是，将原串首尾成环，必然存在长为 mmm 的子串满足条件。考虑若所有子串都大于/小于整串密度，显然不可能。若存在一个子串大于，一个子串小于，由于一个子串删头添尾之后 1 的个数增加量绝对值 ≤1\le 1≤1，所以中间必然经过一个子串密度等于原串密度。
前缀和判断答案为 1 即可，否则为 2。
总结：
把题目中的链性质转化为环，会有意想不到的性质。因为在环上，每个位置是等价的。但在链上每个位置是不等价的。
同时环上长度为 mmm 的子段和的和，每个点会贡献 mmm 次，所以答案是环上所有点的和乘 mmm。
 CF1097G Vladislav and a Great Legend
考虑发掘性质，首先把这个 kkk 次方但是 kkk 不大，套用经典技巧斯特林反演不难转化有：
∑xf(x)k=∑x∑i=1kS(k,i)⋅i!⋅(f(x)i)=∑i=1kS(k,i)⋅i⋅∑x(f(x)i)\sum_{x}f(x)^k=\sum_x\sum_{i=1}^k S(k,i)\cdot i!\cdot {f(x)\choose i}=\sum_{i=1}^k S(k,i)\cdot i\cdot \sum_x{f(x)\choose i}
x∑​f(x)k=x∑​i=1∑k​S(k,i)⋅i!⋅(if(x)​)=i=1∑k​S(k,i)⋅i⋅x∑​(if(x)​)
现在问题转化为求解 (f(x)i)\dbinom{f(x)}{i}(if(x)​)，考虑发掘性质。
首先 f(x)f(x)f(x) 是虚树的边集大小，而众所周知，唯一确定点集就可以唯一确定一颗虚树。而且虚树于 LCA 强相关，可以以 LCA 为根，其左右孩子又能划分为另一个 LCA，即另一个子问题（子问题刻画完成）。换一种角度，如果我们知道左右孩子，我们也可以通过合并左右孩子虚树得到其父亲的答案（子问题合并）。
同时回顾题目答案求解，即让我们在所有虚树的边集中选出恰好 iii 条边的方案数。考虑这个上面虚树计数是独立的，可以合并到 DP 里面做。故设 f(u,i)f(u,i)f(u,i) 表示 uuu 子树内选了 iii 条边的方案数。合并的时候两颗虚树如何合并，我们知道 uuu 选 jjj 条边的方案，vvv 选 kkk 条边的方案，那么合并相当于将 j+k=ij+k=ij+k=i 的情况相乘让后累加即可。
即转移，设 tmpitmp_{i}tmpi​ 为 f′(u,i)f&#x27;(u,i)f′(u,i) 的辅助更新数组，有：
tmpi+j←f(u,i)×f(v,j),tmpi+j+1←f(u,i)×f(v,j)tmp_{i+j}\leftarrow f(u,i)\times f(v,j),tmp_{i+j+1}\leftarrow f(u,i)\times f(v,j)
tmpi+j​←f(u,i)×f(v,j),tmpi+j+1​←f(u,i)×f(v,j)
还有一个部分是考虑点的状态，在合并完之后我们考虑算出 uuu 以内的虚树加 vvv 以内的虚树加 u,vu,vu,v 的合并虚树 即可。第一三种情况好算，第二种情况讨论一下父边的是否选即可。
所以计算答案时必须要在合并时计算（要保证我们考虑的边在点集的作用下都可以生效），这样一种方案会在点集的 LCA 处统计到。
但是时间复杂度是多少，合并边界是 min⁡(sizu,k)×min⁡(sizv,k)\min(siz_{u},k)\times \min(siz_{v},k)min(sizu​,k)×min(sizv​,k)。时间复杂度 O(nk)O(nk)O(nk)。
总结：
观察这类 kkk 的次方式子但是 kkk 不太大的时候，考虑斯特林反演。
树背包真正的复杂度是第一维大小乘上第二维大小，特别是第二维很小的情况，要时刻注意计算。
 AT_agc026_d
首先看到柱状图的形式，考虑建出广义笛卡尔树，然后在上面进行 DP。
首先将原题目的红蓝色转化为黑白色这样就能看懂，然后考虑一列染色方案有哪些：

黑白交替；
全白或全黑；

第一种方案可以直接延续或者翻转后延续，而第二种方案只能进行翻转才可以，启示在状态中分类讨论。
令 lenulen_{u}lenu​ 表示 uuu 这一段的长度，heuhe_{u}heu​ 表示 uuu 这一段的高度。
设 fuf_{u}fu​ 表示 uuu 这一段总方案数，gug_{u}gu​ 表示 uuu 这一段非 01 交错方案数，而 huh_{u}hu​ 表示 uuu 这一段 01 交错方案数。
先不考虑高度：
fu=∏v∈son(u)(gv+2hv)⋅2lenu−∑vlenvf_{u}=\prod_{v\in son(u)}(g_{v}+2h_{v})\cdot2^{len_{u}-\sum\limits_{v}len_{v}}
fu​=v∈son(u)∏​(gv​+2hv​)⋅2lenu​−v∑​lenv​
hu=2×∏v∈son(u)hvh_{u}=2\times \prod_{v\in son(u)}h_v
hu​=2×v∈son(u)∏​hv​
gu=fu−hug_{u}=f_{u}-h_{u}
gu​=fu​−hu​
再考虑高度：
hu′=hu×2heu−1h&#x27;_{u}=h_{u}\times 2^{he_{u}-1}
hu′​=hu​×2heu​−1
fu=gu+hu′f_{u}=g_{u}+h&#x27;_{u}
fu​=gu​+hu′​
f1f_{1}f1​ 即为所求，时间复杂度 O(n2)→O(nlog⁡n)O(n^2)\to O(n\log n)O(n2)→O(nlogn)。
总结：
对于柱状图和多边形一类的 DP 问题，我们可以通过笛卡尔树结构作为 DP 主体。
当限制特殊情况很少的时候，可以考虑分类套路怒，并将分类讨论的情况融入 DP 的设计中。
树形不仅有自下往上合并，也有自上往下递推的写法，这一类经常在笛卡尔树分治出现。
 P7163 [COCI 2020/2021 #2] Svjetlo
这是困难的，但也是好的，第 299 道紫。
原命题叽里咕噜可以转化为树上路径问题。有起点和终点不固定，每经过一个点就可以置反当前状态，问最短路径使得所有状态为 111。
显然考虑 DP，但是我们 DP 的顺序，考虑枚举法确定我们路径的起始点，令我们枚举的点为 rtrtrt。那么将这个枚举的点 rtrtrt 作为有根树提起来。然后考虑如何在这个有根树上进行 DP。考虑一条路径会有如下两种情况：

一个直下，一个绕一圈在回来（南下和北上）。考虑 DP 状态中我们需要融入这个状态，设 f(u,0/1,0/1)f(u,0/1,0/1)f(u,0/1,0/1) 表示 uuu 子树内都为 111，是否返回 uuu 点，当前最终状态是 0/10/10/1 的最短路径答案。
转移不太好直接转移，考虑合并子树答案，以下令 tmptmptmp 为转移临时存储更新后答案的数组，⊕\oplus⊕ 运算代表异或，转移考虑枚举最终状态 ddd，以下转移按顺序进行：
tmp(0,d)←{2+min⁡{f(u,0,d⊕1)+f(v,1,0),f(u,0,d)+f(v,1,1)+2}1+min⁡{f(u,1,d)+f(v,0,0),f(u,1,d⊕1)+f(v,0,1)+2}tmp(0,d)\leftarrow
\begin{cases}
2+\min\{f(u,0,d\oplus 1)+f(v,1,0),f(u,0,d)+f(v,1,1)+2\} \\ \\
1+\min\{f(u,1,d)+f(v,0,0),f(u,1,d\oplus 1)+f(v,0,1)+2\}
\end{cases}
tmp(0,d)←⎩⎪⎪⎨⎪⎪⎧​2+min{f(u,0,d⊕1)+f(v,1,0),f(u,0,d)+f(v,1,1)+2}1+min{f(u,1,d)+f(v,0,0),f(u,1,d⊕1)+f(v,0,1)+2}​
tmp(1,d)←2+min⁡{f(u,1,d⊕1)+f(v,1,0),f(u,1,d)+f(v,1,1)+2}tmp(1,d)\leftarrow 2+\min\{ f(u,1,d\oplus1)+f(v,1,0),f(u,1,d)+f(v,1,1)+2  \}
tmp(1,d)←2+min{f(u,1,d⊕1)+f(v,1,0),f(u,1,d)+f(v,1,1)+2}
f(u,0/1,d)←tmp(0/1,d)f(u,0/1,d)\leftarrow tmp(0/1,d)
f(u,0/1,d)←tmp(0/1,d)
以下解释转移方程。根据上面的图，我们有两种路径模式：直下和绕圈返回。贡献我们可以分摊到边的贡献，对于 tmp(0,d)tmp(0,d)tmp(0,d) 的第一部分就是在绕圈进行分讨：

常数 222 代表回路一条边经过两次，固定贡献。
f(u,0,d⊕1)+f(v,1,0)f(u,0,d\oplus 1)+f(v,1,0)f(u,0,d⊕1)+f(v,1,0)：我们把 vvv 子树当成一个完整的回路，然后我们将两端连接，由于绕了一圈 ddd 一开始就是被置反过的，所以为 d⊕1d\oplus 1d⊕1。
f(u,0,d)+f(v,1,1)+2f(u,0,d)+f(v,1,1)+2f(u,0,d)+f(v,1,1)+2：依旧是回路，但是 vvv 这里最终状态变了，因为经过路径会使得 vvv 被取反两次，为了使得贡献能够匹配上，我们要把内部在做一次回路改奇偶的操作，这个返回使得 vvv 子树内边经过 222 次。

第二部分是直下：

常数 111 代表边经过一次。
f(u,1,d)+f(v,0,0)f(u,1,d)+f(v,0,0)f(u,1,d)+f(v,0,0) 代表 uuu 需要返回而 vvv 必须要，我们两部分用路径穿起来即可。
f(u,1,d⊕1)+f(v,0,1)+2f(u,1,d\oplus 1)+f(v,0,1)+2f(u,1,d⊕1)+f(v,0,1)+2：同样是穿越，但是我们也要和上面一样来通过做一次改变奇偶性的操作来使得贡献能够匹配上。

对于 tmp(1,d)tmp(1,d)tmp(1,d) 的同理，这里不再细说，但是只用分讨回路的情况即可，因为因为要回到 uuu。
对于合并当子树已经保证全为 111 的时候可以不用合并，对答案无影响。直接做，时间复杂度 O(n2)O(n^2)O(n2)。但是注意到转移只有和式，可以通过换根 DP 来进行代替枚举法的决策。具体的，我们需要维护一个 pre,sufpre,sufpre,suf 表示前缀儿子 fff 合并后的数组和后缀 fff 合并后的数组，转移利用 preprepre 和 sufsufsuf 即可，具体见代码，时间复杂度 O(n)O(n)O(n) 但有巨大常数难泵。
总结：枚举法可以帮助我们确定决策，虽然我们可以在后面优化掉，但这是一个优秀的决策确定方式。同时对于树上路径 DP 问题（不要和点分治搞混了）可以考虑枚举起始点，然后通过换根 DP 确定。
 P6773 [NOI2020] 命运 - 洛谷
为什么上一题不是黑？我没有对这个题有意见这个题很好但是上面这个题是紫这也太炸杠了吧。
发现最近做 DP 题已经养成一个完整的流程了，这是极其好的。
首先考虑发掘性质，题目叽里咕噜看不懂，但是有几个性质挺好：

对于一个 vvv 及其配对祖先 uuu，我们只需要选择最深的 uuu 即可满足限制。
一个点 uuu 将其下属边置为 111，会影响其子树内部分点的限制，但这个限制影响当且仅当范围包含 uuu（即最深祖先仍在 uuu 上方）。这个操作一开始看见有 “存在” 我就哈气，直接就转为钦定边为 111。

第二个性质是第一个性质的推论，其本质就点明了子问题的设计，即限制影响的设计。
两个性质启示我们 DP 状态的设计应当包含这个限制影响范围。设 f(u,i)f(u,i)f(u,i) 表示 uuu 子树内限制祖先深度最远到了深度为 jjj 的祖先，其他我们都保证合法的方案数。
转移考虑一个一个子树合并，利用性质 2 我们可以枚举边权设置为为 0/10/10/1 转移。

边权为 111：我们把儿子一些不合法的情况清楚，如果比 depudep_{u}depu​ 还大那就没法解决，统计为 f′(u,i)=f(u,i)×(∑j=0depuf(v,j))f&#x27;(u,i)=f(u,i)\times (\sum\limits_{j=0}^{dep_{u}}f(v,j))f′(u,i)=f(u,i)×(j=0∑depu​​f(v,j))。
边权为 000，考虑合并并且讨论大小关系：

f′(u,i)=f(u,i)×∑j≤if(v,j)f&#x27;(u,i)=f(u,i)\times \sum\limits_{j\le i}f(v,j)f′(u,i)=f(u,i)×j≤i∑​f(v,j)；
f′(u,j)=(∑i&lt;jf(u,i))×f(v,j)f&#x27;(u,j)=(\sum\limits_{i&lt;j}f(u,i))\times f(v,j)f′(u,j)=(i&lt;j∑​f(u,i))×f(v,j)。



时间复杂度为 O(n2)O(n^2)O(n2)，但是发现转移是一个区间形式的转移，考虑用线段树优化这一过程，第一个式子是全局乘，第二个式子是前后缀乘法，可以利用线段树合并优化这一过程。时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
本题目的精髓在于状态设计的方面，在很多带限制的树形 DP中，我们会遇到一种现象就是子树内部能解决一部分限制，但有些限制不能在当前子树内解决，只能依赖于“更高的祖先”去兜底。本题目的限制 1/21/21/2 说明的就是这一点。
所以 DP 状态不能只描述当前子树内部已经解决的情况，还必须记录子树内尚未解决、但需要祖先去兜底的“残余需求”。
这是一个经典模型，以前没记录过只在脑海中有影响，现在把他记录一下，即树形 DP 留一部分问题给祖先考虑的特征状态设计。
同时像这种具有前后缀和转移关系的 DP，我们可以通过线段树合并进行优化，另一个题用到这个技巧的就是 P5298 [PKUWC2018] Minimax - 洛谷
 Gym102798K
这玩意我是真做不出来，少一个性质都做不出来，而且关键是掐死在我不了解的地方。不过这个性质刻画真挺好的吧？

给出一个长为 nnn 的排列 ppp，现在要把这 nnn 个点按照下标顺序依次建立 BST。给定区间 [L,R][L,R][L,R]，问把 [L,R][L,R][L,R] 区间重排（顺序随意）后使得 BST 最小深度和是多少。
1≤n≤105,R−L&lt;2001\le n \le 10^5,R-L&lt;2001≤n≤105,R−L&lt;200。

接下来，你将看到看起来比较简单性质。
考虑这玩意怎么建树，BST 我看不懂，但是我换成笛卡尔树就看懂了。换成笛卡尔树就是以下标作为堆键值，以 pip_{i}pi​ 作为满足二叉搜索树的值。
然后，考虑如何刻画这个笛卡尔树，注意到这个笛卡尔树子树管辖区间从下标区间变成了值域区间。但是我们以值域区间来刻画的话发现没有什么深度和的性质。
我们考虑把它放到坐标系（没错这个我用了将近很长时间才想出来），坐标为 (pi,i)(p_{i},i)(pi​,i)，那么笛卡尔树的形态在坐标系上表现如下，以下为 p={3,1,2,5,4}p=\{3,1,2,5,4\}p={3,1,2,5,4} 的形态：

我们考虑操作，操作 [L,R][L,R][L,R] 重排就是任意交换 y∈[L,R]y\in [L,R]y∈[L,R] 这些点的 xxx 坐标。
考虑设这些点为关键点，然后我们手摸几个交换操作不难发现一个性质：

关键点所形成的极大连通块进行重排操作只改变内部的结构，而且不会相互影响，其他连通块的结构都不变。原因就是因为不改变其他点和关键点之间的偏序关系。

我们考虑借助这个来进行重排过程，我们 DP 的主体就可以对连通块进行考虑了，但是深度和怎么刻画，接下来我们就要用一个我不知道的二叉树性质：
∑i=1nsizi=∑i=1ndepi\sum\limits_{i=1}^n siz_{i}=\sum\limits_{i=1}^n dep_{i}
i=1∑n​sizi​=i=1∑n​depi​
当且仅当 deprt=1dep_{rt}=1deprt​=1，若为 000 需要额外加 nnn。
现在问题转化为最小化关键点的子树大小和，我们设连通块大小为 mmm，我们把这个连通块内接的 m+1m+1m+1 个子树全部都取出来，让后将里面所接的 m+1m+1m+1 个子树全部都取出来，然后将它们的 sizsizsiz 按照中序遍历排列成 aaa，让后次拿一个根然后把区间划分成两部分。这是区间 DP，设 f(l,r)f(l,r)f(l,r) 表示区间 [l,r][l,r][l,r] 所得最小子树和：
f(l,r)=(r−l+∑i∈[l,r]ai)+min⁡(f(l,k),f(k+1,r))f(l,r)=(r-l+\sum\limits_{i\in[l,r]}a_{i})+\min(f(l,k),f(k+1,r))
f(l,r)=(r−l+i∈[l,r]∑​ai​)+min(f(l,k),f(k+1,r))
时间复杂度 O(n+(R−L)3)O(n+(R-L)^3)O(n+(R−L)3)。
总结：
深度和学到了可以用子树和上进行规划来转化。
二叉搜索树可以转成笛卡尔树建立，这启示我们简单结构可以从复杂结构反推。
树重排规划问题联想区间 dp，因为它的枚举断点过程其实就是树枚举根的过程。
 P11364 [NOIP2024] 树上查询
人生中第 300 道洛谷上的紫！
一眼数据结构题，但是我们做题步骤也可以借鉴 DP。考虑发掘性质，首先这个 LCA*\text{LCA*}LCA* 操作如何刻画呢，考虑所有操作都是 LCA，多次涉及 LCA 考虑往虚树考虑。
然后发现这玩意其实就是 min⁡i=lr−1LCA(i,i+1)\min_{i=l}^{r-1} \text{LCA}(i,i+1)mini=lr−1​LCA(i,i+1)。证明用虚树逐渐加点就可以证明。至此，我们可以解决 B 性质，B 性质的本质就是在问上面，可以 O(nlog⁡n)O(n\log n)O(nlogn) 预处理 LCA 加线段树求得，这样我们就有了 12 分可以做啦。
接着我们考虑有了这个段如何做？考虑发掘继续发掘性质：

题目所有询问的区间都是编号连续的区间，且询问可以离线。
固定右端点，延申左端点 LCA*\text{LCA*}LCA* 单调不降。

首先定个目标时间复杂度为 O(nlog⁡2n)∼O(nlog⁡n)O(n\log^2 n)\sim O(n\log n)O(nlog2n)∼O(nlogn)。
然后根据题意模拟将询问离线下来，我们可以暴力根据 kkk 预处理询问，然后暴力处理，时间复杂度 O(n2log⁡n)O(n^2\log n)O(n2logn)，无法通过。考虑优化，发现优化不动，因为无论怎么着我们都需要把询问都提前暴力预处理出来。
正难则反，考虑反着做，但是对什么反着做？考虑我们是根据 kkk 预处理段，然后询问答案。但是我们已经有的信息就是 LCA*，能不能枚举答案，然后询问有没有长 ≥k\ge k≥k 的段呢？
这样做或许可行，先简化问题，将上面区间的性质拆为 [1,n][1,n][1,n]，但是答案很难搞，我们把这个答案拆分贡献，将贡献拆到每个点上。即这个点贡献 LCA*。
我们有长为 n−1n-1n−1 的序列，值为 LCA(i,i+1)\text{LCA}(i,i+1)LCA(i,i+1)，另一个 n−1n-1n−1 的 01 序列初始全为 0。 考虑在答案值域上从大往小扫，那么从 i←i−1i\leftarrow i-1i←i−1，就会出现几个点被设为 1，而询问要求问的是有没有 ≥k\ge k≥k 长度的极长连续段。可以通过线段树维护最大子段和或并查集来做到 O(nlog⁡2n)∼O(nlog⁡n)O(n\log^2 n)\sim O(n\log n)O(nlog2n)∼O(nlogn)。
接着考虑有了区间限制，考虑这个区间限制如何合法，，不难分讨四种情况：

l≤l′≤r′≤rl\le l&#x27;\le r&#x27;\le rl≤l′≤r′≤r；
l′&lt;l≤r′≤rl&#x27;&lt;l\le r&#x27; \le rl′&lt;l≤r′≤r；
l≤l′≤r&lt;r′l\le l&#x27; \le r &lt; r&#x27;l≤l′≤r&lt;r′；
l′&lt;l≤r≤r′l&#x27;&lt; l \le r \le r&#x27;l′&lt;l≤r≤r′。

最后一种显然合法，第一个可以拍入到其他方案，而第二个第三个需要对 l,rl,rl,r 单独计算，是一个二维偏序，可以用扫描线做，但是直接做是三维偏序，很难维护，考虑进一步发掘性质。
k≤r−l+1k\le r-l+1
k≤r−l+1
我们考虑从大到小扫描 kkk，将 [l′,r′][l&#x27;,r&#x27;][l′,r′] 的询问拆成左端点询问到 r′−k+1r&#x27;-k+1r′−k+1，右端点询问到 l′+k−1l&#x27;+k-1l′+k−1。
时间复杂度 O(nlog⁡2n)→O(nlog⁡n)O(n\log^2 n)\to O(n\log n)O(nlog2n)→O(nlogn)。
总结：
本题目作为 NOIP T4 完全合理。部分分不知道链有什么性质。
正难则反什么时候会用到，你需要考虑正着做是没有前途（即无论如何都无法简化问题），那么可以考虑正难则反。
从简单情况入手，一步一步思考。同时数据结构能离线则先考虑离线，离线能够将算法卡死在一定范围内帮助思考。
在题目多次涉及 LCA 的时候往虚树思考，利用虚树来去刻画题目的限制。
 AT_abc216_h
好题，以后看到不相交路径可以直接开始哈气了。
首先假概率，实际上 ans=不相交路径方案数2nkans=\dfrac{\text{不相交路径方案数}}{2^{nk}}ans=2nk不相交路径方案数​。
那么现在问题转化为求解上面的东西，注意到这玩意有一套成熟的东西叫做 LGV 引理。但是我们知道的是 LGV 引理是有起点和终点的，但是这里只有起点没有终点。显然不能直接做，那么回归老本行，考虑发掘性质：

k≤10k\le 10k≤10。
LGV 引理的本质就是行列式求路径计数问题，是进一步的引理推论。

首先第一个性质至关重要，由于没有不相交路径，我们可以考虑枚举终点 yyy，那么从起点走到终点的方案数简简单单就能够算出来就是 (nyi−xi)\dbinom{n}{y_{i}-x_{i}}(yi​−xi​n​)。第二个性质表明路径计数的本质逆序对计数，可以转化为以下式子：
∑ysgn(y)∏i=1k(nyi−xi)\sum\limits_{y}\text{sgn}(y)\prod_{i=1}^k\binom{n}{y_{i}-x_{i}}
y∑​sgn(y)i=1∏k​(yi​−xi​n​)
其中 sgn\text{sgn}sgn 还是行列式那个奇偶性的容斥系数。显然可以用行列式计算，但是枚举 yyy 的成本过大。
注意到 k≤10k\le 10k≤10 且值域极小，考虑状压 DP。我们主体在 yyy 的值域上进行规划。设 f(i,S)f(i,S)f(i,S) 表示目前处理到坐标 iii，目前已经状态为 SSS 的起点确定了终点的合法方案数。转移就是枚举是否有一个起点选择位置 iii 作为终点（显然合法方案不会有两个起点走到一个位置作为终点）。
枚举哪个起点选择 iii 作为终点，有转移：
f(i,S)←f(i−1,S)(不选)f(i,S)←(−1)cnt(ni−xj)f(i−1,S)(选j)\begin{aligned}
f(i,S) &amp; \leftarrow f(i-1,S) &amp; (\text{不选}) \\
f(i,S) &amp; \leftarrow (-1)^{cnt}\binom{n}{i-x_{j}}f(i-1,S) &amp; (\text{选} j)
\end{aligned}
f(i,S)f(i,S)​←f(i−1,S)←(−1)cnt(i−xj​n​)f(i−1,S)​(不选)(选j)​
答案即为 f(V,2k−1)f(V,2^k -1)f(V,2k−1)，其中 VVV 为值域，时间复杂度 O(nk2k)O(nk2^k)O(nk2k)。
总结：
路径不相交问题首选逆序对容斥，然后分为两种情况：如果终点确定那么可以套用 LGV 引理；如果数据范围小那么可以 dp 计算容斥系数。
状压 DP 当然也可以用于确定序列，这个技巧同样在确定排列插入法的时候用过，时间复杂度会贡献 O(值域)O(\text{值域})O(值域)。
 AT_arc121_f
好题，因为这个题我直接在性质就翻车了。
对于这种构造操作顺序的题和合并问题可以从叶子开始考虑。
分类讨论叶子和连边情况：

叶子为 0 且边为 AND：操作这个点会让父亲为 0，优先操作一定最优。
叶子为 0 且边为 OR：可以省略无影响。
叶子为 1 且边为 AND：可以省略无影响。
叶子为 1 且边为 OR：叶子以外的部分任意操作，最后都能合法。

除了第一种情况剩下的我们都可以无脑操作。根据上面的结论我们可以暴力讨论写50行转移方程。但是官方给出更方便的做法，设 f(i)f(i)f(i) 表示子树内不存在 1 or 的情况，gig_{i}gi​ 表示 fif_{i}fi​ 中合法情况个数。转移：

考虑边是 and 或 or，我们把 1 or 的情况除掉：f(u)←(2f(v)−g(i))⋅f(u)f(u)\leftarrow (2f(v)-g(i))\cdot f(u)f(u)←(2f(v)−g(i))⋅f(u)。
考虑是 1 and 或 0 or：g(u)←g(u)⋅f(u)g(u)\leftarrow g(u)\cdot f(u)g(u)←g(u)⋅f(u)。

答案考虑容斥原理，就是 22n−1−f(1)+g(1)2^{2n-1}-f(1)+g(1)22n−1−f(1)+g(1)。
总结：对于这种构造操作顺序的题和合并问题可以从叶子开始考虑。因为叶子是树中最灵活的部分，就像质数在数论构造中的作用。可用于保证某个相关数值“能够调整至任意一个 [l,r][l,r][l,r] 内的值”。从叶子自底向上考虑是一个很好的思路。这个是我第一次见在其他地方运用这个技巧。
 P8392 [BalticOI 2022] Uplifting Excursion (Day1)
背包好题？
考虑发掘性质，注意到本题是多重背包，但是炸杠的是背包容量过大。考虑发掘性质，注意到背包物品容量极小，但是数量极大。考虑多重背包的做法有一个叫二进制拆分的做法。看一下能不能行。
首先将所有物品都进行二进制拆分，形式会如同 siz=20+21+22+⋯+剩余大小siz=2^0 +2^1+2^2+\dots+\text{剩余大小}siz=20+21+22+⋯+剩余大小。我们考虑将这个剩余大小完整拆分到二进制，然后将物品分配到对应的二进制位。
然后从低位到高位跑背包，设 f(i,j)f(i,j)f(i,j) 表示当前考虑到数位 iii，容量为 jjj 的最大选取个数。但是注意到这样容量这一维度显然会炸掉。但是我们发现我们数位就是在容量的二进制数位上进行 DP，考虑利用 2i2^i2i 进行优化，重设状态，设 f(i,j)f(i,j)f(i,j) 表示考虑到二进制瞎数位 iii，容量为 2i×j2^i\times j2i×j 的最大选取个数。
但是如果直接做的话还是不太行，因为我们贡献是累加到 jjj 的，继续优化，考虑一个动态的状态设计（Desant 后遗症），我们到下一个数位的时候可以将上一个的数位贡献去掉，那么这样第二维的状态数量就在 O(n2)O(n^2)O(n2) 级别。时间复杂度为 O(n3log⁡n)O(n^3\log n)O(n3logn)。
总结：
总容量大，但是物品重量很小的背包，可以按二进制位考虑压缩有效状态数。这种动态的状态设计可以优化掉一维度很大的方法，是一个不太常见的优化方法，类似的题目在 P5972 [PA 2019] Desant - 洛谷 出现。
 CF1239E Turtle
一巴掌给我扇飞了，好题但是我是 zz。
首先考虑给定矩阵，如何刻画乌龟的路径，有性质：乌龟走的一定是第一行从开头的一段的连续路径，然后下去走到头。故设 preipre_{i}prei​ 表示第一行的前缀和，sufisuf_{i}sufi​ 表示第二行的后缀和。那么答案就是 max⁡i{prei+sufi+1}\max_{i}\{pre_{i}+suf_{i+1}\}maxi​{prei​+sufi+1​}。
考虑重排操作有没有什么性质，有一个贪心的想法，我们让第一行从小到大排序，第二行从大到小排序，这样列列操作一定是最优的，证明考虑从逆序对入手进行反证法即可。然后问题转化为行行之间刻画，可以考虑利用 DP 进行计算，但是代价计算是 max⁡i{prei+sufi+1}\max_{i}\{pre_{i}+suf_{i+1}\}maxi​{prei​+sufi+1​}。我们没法进行转移啊！
考虑简化代价，我们考虑排序的会对乌龟的决策带来什么决策，关键性质：乌龟要么在开头就往下走然后走完第二行，要么走完第一行然后往下走走到终点。
那么代价可以简化成：a(1,1)+a(2,n)+max⁡{∑i=2na(1,i),∑i=1n−1a(2,i)}a(1,1)+a(2,n)+\max\{\sum\limits_{i=2}^{n}a(1,i),\sum\limits_{i=1}^{n-1} a(2,i)\}a(1,1)+a(2,n)+max{i=2∑n​a(1,i),i=1∑n−1​a(2,i)}。前面是固定的，后面是不固定的。直接飞上去 DP 进行决策：设 f(i,j,k)f(i,j,k)f(i,j,k) 表示考虑到第 iii 个数，第一行一共选了 jjj 个数，选出数的总和 kkk 是否可能。最后让总和尽可能对半分即可。
注意到这个是可行化 DP，但是值域和 nnn 极小，可以用 bitset 优化，时间复杂度 O(1wn2∑a)O(\dfrac{1}{w}n^2 \sum\limits a)O(w1​n2∑a)。
总结：
本题目创飞我一点就在于简化代价计算，比如取最大值的代价可以考虑会在那些地方取得（相当于拆分贡献思想），如果代价复杂 dp 是转移不动的。
同时本题目也体现了一个背包组合的约束现象，很多时候背包会存在（隐藏的）拓扑关系，这时候的结论可能是选了小价值物品就必须选大价值物品。
 CF1481F AB Tree
很可惜我不是来这里学二进制分组加 bitset 优化多重背包。我是来这里学完全背包优化可行性多重背包的。
注意到答案很奇怪，写个暴力（自从那个构造之后就有写暴力发现性质）发现答案上界在最大深度和最大深度加 111 之间徘徊。
考虑分析最优解构造，注意到答案和深度有关。考虑按层构造，每一层我们尽量填入相同的字符，设出现次数较大的字符为 ccc，因为要降低对儿子的影响，所以把非叶节点填入颜色 ccc，设 mmm 为未填写的字符，因为非叶节点的出现次数 ≤m2\le \dfrac{m}{2}≤2m​，而 c≥m2c\ge \dfrac{m}{2}c≥2m​，所以一定能填满，然后把 ccc 填入这一层的叶节点，剩下的就只有另一种颜色的，填入到其它点中，不难发现只有当前层会多一种不同的字符。
那么现在问题转化为能不能每一层都能填写相同字符,若可行输出用 DP 求解答案并输出方案，否则贪心按照上述方法构造即可。
不难发现这个 DP 可以当作背包 DP，把每一层的节点数量当作物品，那么这就是一个多重背包可行性问题。直接做是 O(n2)O(n^2)O(n2) 的，但是发现物品种类数最多 O(n)O(\sqrt{n})O(n​) 级别的（。可以通过 bitset 加二进制分组优化到 O(nnw)O(\dfrac{n\sqrt{n}}{w})O(wnn​​)，输出方案可以加个回溯也是 ok 的。但是问题在于我不是来这里学这个的。我们换个思路，因为多重背包求解的是存在性问题，可以转化为类似完全背包的模型。
具体的我们通过背包维护剩余数量，设 f(i,j)f(i,j)f(i,j) 表示用前 iii 种物品凑出 jjj 总和 jjj。若 f(i,j)&lt;0f(i,j)&lt;0f(i,j)&lt;0 则不可能凑出。若 f(i,j)≥0f(i,j)\ge 0f(i,j)≥0 表示第 iii 种物品还剩下 f(i,j)f(i,j)f(i,j) 种没用。
转移考虑分类讨论，令当前物品重量为 www，数量为 ccc：

不使用第 kkk 种物品，当且仅当 f(i−1,j)≥0f(i-1,j)\ge 0f(i−1,j)≥0。则 f(i,j)←cf(i,j)\leftarrow cf(i,j)←c。
已经用过第 kkk 种且 j−wj-wj−w 可行。则 f(i,j)←max⁡j−w≥0f(i,j−w)−1f(i,j)\leftarrow \max\limits_{j-w\ge 0} f(i,j-w)-1f(i,j)←j−w≥0max​f(i,j−w)−1。

实现中转移需要 jjj 从小往大遍历。这种用完全背包把数量限制转化为记录剩余数目的技巧有点常见。
总结：
一类不关乎价值只关乎重量的可行化多重背包可以用完全背包把数量限制转化为记录剩余数目。将空间简化。
 P3780 [SDOI2017] 苹果树
这是什么背包？
咨询 CatGPT 有一个我没理解的题意：选取了一条节点，那么从这个节点到祖先都要取。这个性质很好，问题相当于选择从根到某个点的路径，免费选一个苹果，再做树上依赖性背包。这个点肯定是叶子，因为多选免费苹果一定更优。
然后考虑 t−h≤kt-h\le kt−h≤k 有什么用，简单变形为 t≤k+ht\le k+ht≤k+h。注意到 hhh 就是最长深度。通过枚举法我们钦定一条到叶子的链作为最长深度（显然在上面）。然后剩下的就是简单的树上依赖性背包，直接做的话时间复杂度 O(n2(n+k))O(n^2(n+k))O(n2(n+k))，无法通过。考虑优化这一过程。
首先枚举法不能丢，我们发现对每个节点都重新求答案还是太超标了。能不能利用一些共性答案，我们发现如果以这个链把子树劈开，会分成左右两边，左边和右边是独立的与链无关，可以通过树上依赖背包算出来然后合并答案到一起。具体的，类似序列上的前后缀背包合并，我们求出正 dfn 序的背包和逆 dfn 序的背包，然后把它们合并起来就可以得到答案。
求解正序背包时，我们把必须选取的点（指选某个点导致其链上的点必须选取）和随意选取的点分开。进入一个点的时候加入随意选取的点，递归时把当前背包复制给儿子，然后从儿子回溯时加入当前点。
向背包中加入随意选区的点可以用单调队列优化，而逆序把建边从大到小编号建边即可。
答案合并就是 f(u,i)+g(u,k−i)+f(u,i)+g(u,k-i)+f(u,i)+g(u,k−i)+ 当前链长度，时间复杂度 O(nk)O(nk)O(nk)。
总结：
枚举法真的很好用！可以帮助我们确定决策，最好用的一集！
这种 DFS 序的多重背包其实正式名称就叫树上依赖性背包。树上依赖性背包形如在树上选出若干个物品做背包问题，满足这些物品连通。由于 01 背包，多重背包和完全背包均可以在 O(V)O(V)O(V) 的时间内加入一个物品，O(V2)O(V^2)O(V2) 的时间内合并两个背包，所以不妨设背包类型为多重背包。是前后缀背包思想的运用。
 CF917D Stranger Trees
等会，题面这个图还有题目背景，莫非是？

咳咳，回到正题，首先看到 “恰好” 直接哈气。用二项式反演反演成至少，有：gk=∑i=kn(ik)fi⇔fk=∑i=kn(−1)i−k(ik)gig_{k}=\sum\limits_{i=k} ^n \binom{i}{k} f_{i} \Leftrightarrow f_{k}=\sum\limits_{i=k}^n (-1)^{i-k} \binom{i}{k} g_{i}gk​=i=k∑n​(ki​)fi​⇔fk​=i=k∑n​(−1)i−k(ki​)gi​。其中 fff 为答案，ggg 为至少 kkk 条边相同的方案数。
然后考虑 ggg 怎么算，发现这玩意我们把钦定的 iii 条边断开，会形成 n−in-in−i 个连通块，而这些连通块都是独立树计数的。根据 Prufer 定理有任意连边方案数：
nm−2∏i=1msin^{m-2}\prod_{i=1}^m s_{i}
nm−2i=1∏m​si​
mmm 为连通块个数，其中 sis_{i}si​ 还是连通块大小。
然后考虑如何快速计算，发现如果直接做因为边不确定状压直接爆炸。数据范围 O(n3)O(n^3)O(n3)，考虑发掘性质。
我们考虑把 gkg_{k}gk​ 的组合意义拆分，前式子可以随便计算，而后面却要求我们快速不用状压计算。考虑 DP，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示 iii 子树内，分成了 jjj 个连通块，当前 iii 所在连通块大小为 kkk 的方案数。时间复杂度 O(n3)O(n^3)O(n3) 可以 O(1)O(1)O(1) 转移但是我认为是 O(n4)→O(n5)O(n^4)\to O(n^5)O(n4)→O(n5) 就很难泵。
但是我们显然有更好的做法，考虑我们只是在计算 ∏i=1msi\prod_{i=1}^m s_{i}∏i=1m​si​，考虑复杂度瓶颈就是在于这个 kkk 这一维度让我们的优化没有前途。考虑切换组合意义，发现 ∏i=1msi\prod_{i=1}^m s_{i}∏i=1m​si​ 的本质就是给每个连通块内部任意定根的方案数，把根是否确定放进状态中即可。
那么这很好考虑设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示 iii 子树内，分成了 jjj 个连通块，iii 所在连通块是否定根的方案数，转移用背包对子树合并即可，时间复杂度 O(n2)O(n^2)O(n2)。
总结：

当我们组合意义出现嵌套的时候，方法就是给我们的价值函数确定一个组合意义。常用的技巧是拆分法，把复杂的价值函数拆成几个可独立处理的部分，然后分别计算再合并。这个时候 dp 就需要同时完成确定局面和组合计数的功能。
当我们在对具有组合意义的价值函数进行 DP 的，如果我们发现优化不动（确定没有前途）那么我们可以考虑切换组合意义，来达到优化的效果。

 8.22 模拟赛 T3
2025 牛客多校 Ghost in the Parentheses
全场唯两个可做题。首先这个概率又是假的，直接拆成 合法方案数2∣S∣\dfrac{\text{合法方案数}}{2^{|S|}}2∣S∣合法方案数​。
首先考虑什么时候括号序列可以唯一确定，由 GF 惨痛经历我们将 ( 抽象为加 111，将 ) 抽象为减 111。
我们考虑，假如你是 Bob，你收到一个字符序列如何确定唯一？根据上面的法则，大胆猜想有一个结论：考虑去掉所有问号，我们对原序列按照上面做前缀和，记总和为 sumsumsum。当 ∣sum∣&gt;0|sum|&gt;0∣sum∣&gt;0，我们就把问号去掉一个，同时 ∣sum∣←∣sum∣−1|sum|\leftarrow|sum|-1∣sum∣←∣sum∣−1。若 ∣sum∣=0|sum|=0∣sum∣=0 但是还有问号，那么显然不唯一，否则唯一。
严谨的：定义从左到右扫描，设在位置 iii 之前（含已固定的 ?）的平衡必须取某个确定值（否则不能满足末尾为 0 或中间某个前缀非负）。若在某个时刻偏差为 d&gt;0d &gt; 0d&gt;0，则为了保证后文能回到 0，接下来至少要出现 ddd 次取 −1-1−1 的位（这些要么在已知字符里，要么必须由 ? 来承担）。若这些 −1-1−1 必须由特定位置的 ? 来提供（因为已知字符的位置和数量固定），那么这些 ? 的取法就被唯一决定；重复此论证直至结束，所有 ? 都被唯一确定。因此当贪心能把 ∣S∣|S|∣S∣ 一步步消到 0 恰好用尽所有 ? 时，没有任何 ? 是“可自由选择”的，从而合法补全唯一。
然后我们考虑这个结论怎么用？这还只是我们知道序列，但是现在不知道序列，我们思考什么时候我们能唯一确定 ?。
令 L,RL,RL,R 表示前缀左括号个数和于前缀右括号个数和。我们发现当一个某个位置前缀和为 111 的时候，那么一定是形如 合法序列+ ( 的形式。那么我们可以发现，如果我们把里面的 ( 随意改变为 ? 的话，根据上面的结论，不会影响答案，因为这些 ( 会被唯一确定，组合数 2Li2^{L_{i}}2Li​。同理于右括号，每个右边的 ) 仍然可以自由选择是否变成 ?，故一个前缀和为 111 的位置贡献是 2Li⋅2Rn−Ri2^{L_{i}}\cdot 2^{R_{n}-R_{i}}2Li​⋅2Rn​−Ri​。
通过加法原理和起来答案即可，但是会发现算重，我们算一个位置的贡献要减去下一个位置的贡献即可，时间复杂度 O(∣S∣)O(|S|)O(∣S∣)。
总结：不确定的元素可以思考其中的确定性作为突破口统计答案。
 CF1615G Maximum Adjacent Pairs
本题将不实现，原因涉及算法等级超标，但是这种建模思想和思路过程还是需要讲一下的。
考虑分析性质，首先不难观察到如下的性质：

值域 600600600 较小，对于 kkk 的限制条件计数只会算一次。
对于单个 000 的情况，可以考虑贪心的去匹配，即考虑左右两边挨的数是否已经匹配过了即可。对于多个 000 的情况，其左右两边可以根据前面所说的贪心匹配，而中间的段会单独贡献答案，可能需要特殊计算。
确定值的过程可以看作类似于二分图匹配的问题。

以后遇到这种问题，我们要出动三小只：DP，贪心，图论等其他模型建立。
考虑 DP，根据上面的性质显然有一个 DP 的想法就是设 f(i,S)f(i,S)f(i,S) 表示到了第 iii 个 000 数，当前相邻限制出现集合为 SSS。时间复杂度直接超标，考虑优化，发现这个限制是全局的，如果我们通过 DP 在构造过程中不去记录那么会不满足。容易发现 DP 是没有前途的，遂放弃。
考虑贪心，前面的性质我们已经提到过单个 000 的情况可以任意贪心，然而多个 000 是不太好去搞这种决策的，因为这个是具有后效性不太好搞，但是注意到我们是在注意确定值，而且要求恰好计数 1 次，这不就是图的匹配问题吗。
考虑图论模型，我们从这个题开始将开始大范围的凸轮联系，我们要和 DP 一样标准化做题流程。以这个题为例：
 图论模型的建立
首先我们要考虑对什么对象建立模型，即我们要选取建模主体，然后考虑用图论的意义来去表示原问题。
一般情况，我们会以题目的一个限制为基础建立模型，这一步不要被思维定势所局限，大胆去想，小心求证！
注意到我们是将 000 的值一一确定，且根据前面的相邻限制，一个值只会被计入一次，这是一个类似于二分图匹配的问题。
 图结构的分析与建立
我们思考原问题中各元素在图上的含义，一个值只贡献一次告诉我们把值建成点会好一些，同时我们把 0 也建成点，
0 的填法产生贡献相当于和对应的值匹配，我们建立边就可以决策这个过程。
更具体地可以考虑原序列上连续的一段 0，根据贪心原理只有连续段边上的 0 才会和值匹配，其他的 0 都另寻它路了，简单讨论一下：

如果连续段的长度为偶数，那么我们建立两个代表 0 的点 x,y，首先将 x,y 连一条边代表他们可以自己匹配，然后我们将 x 连向左边的值，y 连向右边的值。
如果连续段的长度为奇数，那么我们建立一个代表 0 的点 x，把它和左边的值和右边的值都连边。

 转化问题加寻找结论
如上建边，我们可以通过跑最大匹配来去解决问题，这个时候由于图显然这样建边会存在环，我们可以通过跑一般图最大匹配来去解决，然后就做完了，至于那些神秘的优化那都是后来的事情了。
总结：
这种题目属于一种难以处理的全局限制，这种全局性限制之所以难以处理就是我们无法拆分为独立的限制来去解决，以后遇到这种难以处理的全局性限制我们可以以图论的角度来去解决问题、
 CF1368G Shifting Dominoes
性质最多的一集，这是解题报告，所以会比较长且出现一些导向型但非正解的做法。
显然考虑计数，但是我们先分析性质再考虑用什么做法维护，在看题过程中不难发现如下性质：

所有骨牌最多左右上下移动一格。且一种方案有且只有两个空位。
对于移动所产生的效果的移动是连续的，以空位不断向外进行拓展。
看见方格图就哈气进行黑白染色，那么题目中删掉块所产生两个相邻的空格是黑白不同色的。
由性质 1 导出计数过程，方案是对局面的空格位置进行计数。

这些是一些基本的结论，通过性质 4 我们发现我们要将我们的计数主体放在空格上而不是方块上。
然后我们考虑一次骨牌移动到空位会产生什么影响，有图，这张图黑白染色改为了蓝红染色以作鲜明区分：

竖过来也是一样的，这种我们不好用 DP 来去解决这种空格移动，但是我们可以通过图论模型来表示这个操作！具体的就是根据上面类似的进行建边转移即可。
同时我们还能从这个图导出一些性质：

根据上面图和建边方式，不难发现一次移动两格，而我们图是黑白染色。也就是说一个空格移动所到达的点一定和这个空格同色。进一步的，也就是说黑色格子和白色格子是互相独立的。
所有点入度最多为 1。

性质 5 和 6 是非常好的性质，我们可以通过性质 5 导出独立性的结论，这样我们只需要对黑色格子和白色格子单独做一遍这个图论。而性质 6 通过和前面性质 2 结合起来能够说明本图至少是一个基环外向树。但是进一步的（显然我没想到这一点）可以发现本图不存在换，因为反证法，加入存在一个环，那么通过上面操作可以移动一圈将空格子回到原点，但是原点已经被一个骨牌覆盖了。
那么更好啦，这个图就是一个外向树森林，那么一个空格子所能转移到的都是这个森林某个树的一个子树，根据前面的性质也能导出来两个空格的移动是独立的。这是一个二维矩形问题，各个维度代表独立的格子，且到达的子树可以表示为一个 DFN 区间。那么我们可以通过扫描线求矩形面积并来解决这个问题，时间复杂度 O(nmlog⁡nm)O(nm\log nm)O(nmlognm)。
总结：
以后遇到这种矩形中类似推箱子的问题，可以把箱子的移动转化成空格的移动，建立关于空格移动路径的图。同时本题目我们通过性质 5 导出独立性的结论，将多个对象的问题可以找独立性来转化成单个对象的问题。
以后看见方格图就可以哈气染色，哈气是好习惯。
 CF1458D Flip and Reverse
不是上一个题那么多性质，我做这就很高兴。现在一个性质都没有？
这种数量相等可以借鉴检验括号序列的思路，我们将 0→−1,1→10\to -1,1\to 10→−1,1→1，那么做一个前缀和，那么操作的第一个条件数量相等就可以表示为前缀和 sumi=0sum_{i}=0sumi​=0，那么一个合法子串 s[l:r]s[l:r]s[l:r] 能够被表示的条件就是 suml=sumr=0sum_{l}=sum_{r}=0suml​=sumr​=0。然后就找不到性质了。
然而实际上我们可以通过前缀和的变化来看（差分），这种复杂的区间修改操作我们可以通过差分的思想来去解决。
我们考虑 sumsumsum 的变化，考虑按照原字符串建立一张图。对于每一个 sumsumsum 值建立一个点。例如说现在的 sumsumsum 值为 ttt, 遇到了一个 1, 然后我们从 ttt 到 t+1t+1t+1 连一条无向边。
选择一个 1 和 0 数量相等的字符串，前后的 sumsumsum 值一定相等。于是这就形成了一个环。
考虑将这个字符串取反，其实相当于从这个点绕着这个环走一圈。
然后我们要求的是这张图的最小字典序的欧拉路径。
可以考虑贪心，能向小的数走就往小数的走。
怎么判定数 t 能不能往小数 t−1 走？首先一定要有 t 到 t−1 的这条边，如果 t 有到 t+1 的边那么 t 到 t−1 的边数至少为 2 （肯定要返回 t）。时间复杂度 O(n)O(n)O(n)。
本题所考察的知识点最高难度等级为 6 级，并不算高，为欧拉路径(6)，贪心法(3)，前缀和(3)，string类与相关函数(2)，数组与数组下标(1)，cin语法scanf语句cout语句(2)，for语句(2)，难度不超过提高组所规范的难度，考察了选手图论建模的能力，实现标程极为简单。但预期绝大多数选手无法获得有效分数。
总结：
这种区间修改类的问题我们可以通过差分的思想来进行转化，区间元素和的判定问题可以把前缀和建成点，原图中的元素建成连接前缀和的边
 CF1361E James and the Chase
DFS 树经典应用。
首先考虑如何判断一个点是合法的，考虑建出 DFS 树，由于这是有向 DFS 树，那么会出现三种边：树边，横叉边，返祖边。不难发现只有横叉边只有一个不满足条件，所以只要保证 DFS 树里面没有横叉边即可。可以 O(n)O(n)O(n) 判断啦。
然后你发现复杂度是线性 log⁡\loglog 的直接爆炸，因为一次判断复杂度是 O(n)O(n)O(n)。考虑进一步发掘性质，我们无法枚举所有的点，也就是说我们只能枚举部分点，然后从这个部分点推出所有点的答案。
我们根据上面判断法则进一步推广，不妨设我们枚举的一个合法点为 rtrtrt（显然可以 O(n)O(n)O(n) 判断），那么先建立出 DFS 树，然后我们考虑一个结点 uuu 如何判断合法？
直接找充要条件显然是炸裂的，先找必要条件，首先由于是有向 DFS 树，一个点合法是能够到达所有点为前提条件的，那么它想要走出子树到达其他点显然只能靠返祖边，横叉边不行因为一开始我们枚举 rtrtrt 判断子树内没有横叉边了。
进一步限制这个从子树内走出子树外的返祖边有且仅有一条，否则 uuu 到祖先就有两种方案一定不合法。
现在考虑构造充分性，上述条件能走出子树有且仅能到达祖先点，但缺乏的条件就是到了祖先出了子树也可能也到不了其他点，或有多条路径。那么我们构造充分性，即返祖边连向的点 vvv 必须是好点，这样构造就能够保证简单路径唯一。用 set 启发式合并求出子树返祖边即可，时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
现在我们可以遍历一次求出所有答案啦，但是还有问题在于如果我们暴力枚举每一个点然后进行判断是否合法，求解是 O(n2+nlog⁡2n)O(n^2+n\log^2 n)O(n2+nlog2n) 的，无法承受，而且我们无法进一步优化。考虑到题目中 15n\dfrac{1}{5} n51​n 个合法点的限制，我们从这个限制入手，导出条件也就是说一个点有 15\dfrac{1}{5}51​ 的概率为关键点，45\dfrac{4}{5}54​ 的概率不是关键点，那么我们考虑随机化，随机点然后判断是否合法。那么设进行了 kkk 次随机化，那么错误概率为 (45)k(\dfrac{4}{5})^k(54​)k，当 kkk 取 100 左右时错误概率约为 2.03×10−102.03 \times 10^{-10}2.03×10−10，可以忽略不计。
总结：图论问题再判断合法性一定要主动放在 DFS 树上进行考虑。这个题有两个难点，第一个就是 DFS 树的综合利用以及判断，第二个就是这个 20% 的限制，这个 20% 是一个关键的阈值，如果达到了 20% 就能做某事，如果达不到 20% 就可能做不成某事（不是一定做不成），那么思考这件事是什么即可。
 CF901D Weighting a Tree
先从简单情况入手，首先当 m=n−1m=n-1m=n−1 的情况，也就说原图是一个 nnn 个点的树我们如何构造。这种树的构造方法一种常见的切入角度就是剖叶子。那么就有构造方法，即从叶子开始自底向上构造，要让叶子合法边的权值只有一种可能，所以最后我们能让除了根的所有点都一定合法。这样构造能够根据根是否合法直接给出解，因为显然不存在另外的边使得让不合法根能够获得点权合法。
然后我们加大难度，当 m=nm=nm=n 的时候如何构造？首先 m=nm=nm=n 原图就是一个基环树。注意到边权可以为 000，考虑断环为链，这里就是我们选环上的一点作为根 rtrtrt，然后将这个 rtrtrt 在环上所连接的一条边边权设置为 000，然后就可以按照上面的树方法做了。如果 rtrtrt 点权为 000，显然万事大吉。但是如果 rtrtrt 不为 000，那就不好说了，因为我们和上面树条件不同的地方在于我们这里有了一条可能让 rtrtrt 合法的边。
现在的情况是我们有了一个除了 rtrtrt 以外不合法的方案，现在我们尝试简化问题。首先这是一个基环树，我们可以把环上挂的子树都给删掉，只保留环，因为环上的子树答案显然是上述 m=n−1m=n-1m=n−1 的子问题，答案已经被唯一确定，所以现在我们只需要考虑环上的问题即可。我们可以通过调整法通过调整环上我们一开始赋值为 000 的边来保证合法。考虑到到现在我们都没有利用题目中的奇偶性，我们考虑利用这个奇偶性来作为我们的条件入手点。
先考虑答案如何构造，首先找必要条件，由样例 333 与 444 能够导出一个结论，环根的点权必须是偶数，否则无解，证明考虑分类讨论：

如果 rtrtrt 的点权是奇数，那就意味着它在环上无法平分，无论怎样调整  的位置，都会导致一边奇一边偶，矛盾。
如果 rtrtrt 的点权是偶数，它就能被分成两份分别放在两条路径里，这样才可能调整出合法情况。

接下来考虑充分性证明，我们考虑从这个赋值为 000 的边构成环的来考虑，考虑到偶环是没有用的，因为它无法使得修改的带你全集中在你要修改的点上，并且偶数长度导致在调整边权时符号在回到起点时相反，两个连接到根的边得到的调整是相反数，相加为 000，总结下来就是调整偶环无法改变答案。
我们再考虑奇环，如果非树边设置的权值为 xxx，那么调整非树边 xxx 会使得环根权值变化 −2x-2x−2x 或 2x2x2x，证明用在环上的距离证明即可。根据必要条件环根为偶数，所以一旦出现奇环必定有解，故如上构造即可，时间复杂度 O(n)O(n)O(n)。
当 m&gt;nm&gt;nm&gt;n 时，找出原图的一棵 dfs 树，然后把非树边的边权赋值成 0，按照 m=nm=nm=n 的方法去做，我们找出奇环，把奇环的环根当成树根建树，然后按照上述条件调整即可，时间复杂度还是 O(n)O(n)O(n)，当然你也可以任意挑出一个生成树，但是还是 DFS 树没有横叉边的爽。
总结：很多变元的构造题中，可以只考虑少部分的变元就能给出构造方案。直观上好像每个地方都能改，但实际上很多地方是“被迫的”，一旦你确定了某些关键部分，其余部分就自动唯一确定了。
 CF1019C Sergey’s problem
调整法真好用 (•ω•)
先从简单情况入手，我们先从链的情况入手，可以按这样的方法构造出点集 VVV：选取一个点 uuu，然后删除所有满足存在有向边 u→vu\to vu→v 的点 vvv，持续这个过程直到不能操作。这个操作可以进一步拓展到树，最终能拓展到 DAG。对于树的拓展是显然的，而 DAG 考虑做一次拓扑排序，按拓扑序贪心选一次即可。
考虑进一步拓展到有环的情况，但是发现很难拓展因为会出现连边的情况。考虑分析点集的性质，它满足所有点可以通过选取点一步之内走到，但是根据构造的特点，可能后选取的点向先选取的点连了边。但是考虑到两步之内走到的限制更为宽松，我们可以在此基础上调整。
注意到，我们选出点所能构成导出子图时 DAG，考虑用拓扑排序调整，对于我们选取的点 vvv，如果存在 uuu 被选取并且 u→vu\to vu→v，那么 vvv 就不用，否则必须保留。这样就不会产生冲突，且所有点都可以在两部稚嫩走到，时间复杂度 O(n)O(n)O(n)。
总结：
调整法是一个很重要的构造方法，如果存在两个需要我们构造满足的变量，我们可以先让初状态先满足一个条件，然后再调整。此时初状态的选取依然很重要。
从简单结构拓展到一般性结构是一个重要的思考方法，DAG 的思考具有一般图所没有许多性质。
 AT_joisc2016_i 電報
一会喂我好吃的，一会喂我史，为什么呢？
考虑出度全为 111 如何利用这个关键性质，既然要保证原图强连通且出度都为 111，那么经过操作后图一定是一个大环，即所有点入度为 111。同时容易证明原图除去一开始的合法情况一定是个基环树森林。
显然 DP 不好处理，考虑贪心，有一个显然的贪心就是将每个点保留权值最大的入边，其他入边贪心的删除即可。然而这样操作后会形成若干个环，我们需要将这些环接成一个大环，考虑这个具有什么贪心性质，发现环上必定会断开至少一条环边然后和其他环接起来。所以预处理非环边的最大权值，然后贪心地看替换环上哪个点最好即可。具体的，设 mxcimxc_{i}mxci​ 为所有连向 iii 边中代价最大的，crcicrc_{i}crci​ 表示不属于 iii 所在环中连向 iii 边中代价最大的。那么我们贪心的选取 mxci−crcimxc_{i}-crc_{i}mxci​−crci​ 最大的即可，时间复杂度 O(n)O(n)O(n)。
总结：本题中度数和连通性是可以互相联系，但是不同的地方在于度数是单点的限制，而连通性是整体的限制，我们考虑单点限制是比整体限制一般情况下是比较简单的，再考虑例外来修正我们的限制转化即可。
 JOISC 2015 Day2」Keys
我去这不省选集训 Day1 T1 吗，不行这一次我一定要做出来。
考虑分析性质，首先注意到每一个时间点有且仅有一名社员进行出入操作，启示对时间点之间进行分类讨论贡献与开门情况，有分类讨论，以下时间点均为 i,i+1i,i+1i,i+1 之间的分讨：

iii 出 i+1i+1i+1 出：显然让 iii 拿钥匙可以贡献。
iii 出 i+1i+1i+1 入：需要都拿钥匙。
iii 入 i+1i+1i+1 出：随便贡献。
iii 入 i+1i+1i+1 入：后者需要拿钥匙。
否则，门都会保持打开的状态，所以有没有钥匙都一定能合法。

考虑计算贡献，贡献 3 直接记录到答案中，贡献 2,4 记录在需要钥匙的那个人上，也就是这个人有钥匙就能产生贡献。贡献 1 记录在两个人之间的边上，表示两个人都有钥匙就能产生贡献。
那么问题转化为图上选点最大化贡献的问题，但是这个图有特殊限制，考虑每个点最多连出去两条边并且不会有环，所以这张图就是若干条链。我们把这条链的端点串起来，这样就变成了序列问题，就可以直接 dp 了，设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示前 iii 个点，放了 jjj 个 key，当前第 iii 个人有还是没有钥匙，时间复杂度 O(n2)O(n^2)O(n2)。
我很好奇能否直接进行 DP？但是显然是不行的，因为上面所说了链是多条的，如果瞎进行 DP 就会出现跨链的问题。当然我们也可以对每一条链单独做，然后背包合并。但是显然做法更麻烦，但是这个做法是在你一开始没想到链是森林状直接转移出错后会导出一个最直接的做法。
总结：
贡献法也能运用到规划问题中去，还是从小处入手，考虑贡献产生的条件即可，是无条件贡献？是点限制贡献？是边限制贡献？将贡献问题用图论进行刻画也是一个常用的技巧，将总贡献拆分到点上和边上。
 CF1307F Cow and Vacation
这是黑吗？
分析性质，发现路径一定形如：a→r1→r2→⋯→rk→ba\to r_{1}\to r_{2}\to \dots \to r_{k} \to ba→r1​→r2​→⋯→rk​→b，这种形式，其中 rrr 表示关键点（休息点）。考虑如果直接暴力去 BFS 的话显然是不行的，考虑到我们只需要判断可不可以达到即可，而路径是从 aaa 到一个关键点，然后从关键点到关键点，然后从关键点到终点 bbb。
自然引出一个想法，即我们先考虑关键点是否能到达关键点，这一点我们可以对每一个关键点维护并查集，然后通过暴力 BFS 这个题目给出的半径来维护关键点之间的连通性，设半径长度为 kkk，我们要向外拓展 k2\dfrac{k}{2}2k​ 的长度拓展。
同时，上面的做法也可以合并范围内的点能否到达这个关键点也是可以的。注意到上述拓展是最多 O(n)O(n)O(n) 遍历的。
然后我们就可以判断，首先若 dis(x,y)≤kdis(x,y)\le kdis(x,y)≤k 那么就不用走关键点。否则设 rar_{a}ra​ 和 rbr_brb​ 表示 xxx 和 yyy 在路径上前进 k2\dfrac{k}{2}2k​ 的点，若 rar_ara​ 和 rbr_brb​ 联通，则可以到达，否则不行。
直接做时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)，实现上因为 mmm 有可能是奇数，这个时候只需要双倍开点技巧让 mmm 变为偶数即可。
总结：可达性转连通性是一个关键技巧。
 CF1534F2 Falling Sand (Hard Version)
 Easy Version
分析性质，发现这个沙子掉落关系具有传递性和连锁反应，考虑用图论建模表示这种情况。
考虑用单向边表示这种扰动关系，即即若 A 能扰动 B，不代表 B 能扰动 A。考虑到建完边后一定会形成若干个强连通分量，显然随便强连通分量内的任意一个沙子都是会被掉落的，考虑缩点，得到的就是一个 DAG，而 Easy Version 由于数据保证有解而且要求沙子全部掉落，那么我们可以直接选取出度为 0 的点即可。
然而上述直接暴力建边是 O(n2m2)O(n^2m^2)O(n2m2) 的，无法通过，考虑优化建边，我们考虑沙子 AAA 下落会影响那些沙子，显然上下是具有传递性的，现在我们考虑左右，我们发现可以只需要连接 AAA 左侧第一个在它下面的点和右侧第一个在它下面的点，然后根据前面我们上下保留的边可以传递，所以这样优化之后就很好了边数为 O(4nm)O(4nm)O(4nm) 级别的，总结一下：

如果这个点上方一格有点，那么连边。
如果这个点下方有点，那么连边。
找到左侧第一个在它下面的点连边。
找到右侧第一个在它下面的点连边。

然后按照上述做法做即可。
 Hard Version
我们考虑 Hard 在哪里了，即我们不再要求所有沙子全部下落，因为同一列高的下落，矮的一定下落。那么有一个贪心的想法就是我们让每一列从下往上第 aia_{i}ai​ 个下落即可，我们让这些点为关键点。但是原题目中的限制是具有传递性的，所以现在问题转化成选取一些点，从这些点出发能覆盖到这些沙子对应的点。
现在回到主体，显然我们的 Easy Version 建图是可以继承过来思考的，但是我们发现直接做是没法做的，因为我们根本不知道你选取的点是以如何形式进行覆盖的。仔细思考也思考不动，怎么办？

当感觉一个问题不可做时，可以检查一下自己转化问题的时候是不是漏了什么性质。——gyh20

考虑进一步发掘性质，只能从图发掘性质了，我们发现这个图建边每条跨列边都指向比当前高度更低的格子，且每到一个点，必定是向左向右只跳一列的，不可能出现左列关键点和右列关键点被覆盖，中间列关键点没被覆盖。
大胆猜想，一个点所能到达并覆盖的关键点是一个连续区间。证明考虑反证法，假如说不是连续区间，那么必定存在三个从左至右的点 u,v,wu,v,wu,v,w，使得 uuu 能到达 www 但是到达不了 vvv，那么根据上面建图每条跨列边都指向比当前高度更低的格子，那么可以得到 uuu 高度比 www 小，而中间必定会经过 vvv 这一列一个点 iii，因为不能解决 vvv 的限制，所以 vvv 关键点肯定高于 iii，而根据前面高度推论显然 vvv 能够到达 www。
那么问题转化为了选取若干个区间的并集是全集，可以按照区间左端点或右端点排序即可，这个问题就是去年 CSPS T2，时间复杂度 O(nmlog⁡nm)O(nm\log nm)O(nmlognm)。
总结：这题真有点牛吧，如果不同的限制具有拓扑关系，根据题目特性可能可以忽略一些限制，这种拓扑覆盖问题可以考虑在原序列上的区间覆盖性质。
当感觉一个问题不可做时，可以检查一下自己转化问题的时候是不是漏了什么性质。
 CF1270H Number of Components
考虑分析性质，但是发现分析不出来性质，我们无法从连边的入手。我们考虑连通块的性质，发现连通块有一个关键性质：一个连通块代表的是一个序列的连续区间。证明考虑反证法即可简单证明。
那么原命题就被分成了若干个块区间，如果我们暴力维护块合并和分裂是 O(n2)O(n^2)O(n2) 级别的，肯定这也不是颜色段均摊，无法优化，考虑进一步分析性质：

连通块之间互相独立，互不影响。
值域 ∣V∣≤106|V|\le 10^6∣V∣≤106，且序列上所有数保证在值域上唯一表示。

对第一个性质进一步推广，即我们考虑一个块独立的条件，即什么时候会取到一个块的新左右端点（或分界点），设分界点为 ppp，那么也就是说对于 i∈[1,p]i\in [1,p]i∈[1,p]，j∈[p+1,n]j\in [p+1,n]j∈[p+1,n] 有 ai&gt;aja_{i}&gt;a_{j}ai​&gt;aj​。由于这个序列是被分界点分解成若干个块，考虑到只需要对这些分界点计数即可刻画连通块个数。
第二个性质启示我们值域较小且数被唯一标识，有很大的指示性提示我们要在值域上规划，考虑一个分界点的条件 ai&gt;aja_{i}&gt;a_{j}ai​&gt;aj​，这是偏序问题吗？不是，我们考虑枚举一个阈值 vvv，对于序列中 ≤v\le v≤v 的设置为 000，&gt;v&gt;v&gt;v 的设置为 111，那么原命题转化为求生成 010101 序列使得形如 111…11000…00111\dots 11000\dots 00111…11000…00 的阈值个数。
考虑对于每个 vvv 我们维护生成序列 101010 相邻数对的个数，如果数对个数为 111 就是合法的答案。可以用线段树维护，对于原序列上两个位置 i,i+1i,i+1i,i+1，其中 v∈[min⁡(ai,ai+1),max⁡(ai,ai+1)−1]v\in [\min(a_{i},a_{i+1}),\max(a_{i},a_{i+1})-1]v∈[min(ai​,ai+1​),max(ai​,ai+1​)−1] 的数对个数就会增加 111。
为了方便我们设置 a0=+∞a_{0}=+\inftya0​=+∞，an+1=−∞a_{n+1}=-\inftyan+1​=−∞，因为 101010 个数至少为 111，所以我们维护最小值和最小值的数量即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
这题是真的神，这种序列大小关系的处理我是第一次见，序列大小关系的处理可以转 01 序列，大于某个权值设为 1，否则设为 0，然后研究 01 序列的性质。
序列图论题的结论思考方向：图论某个量和原序列区间的联系。
维护某一个特定值的数量，思考他是否一定是最值，是的话转成维护最值和最值的数量。
 [AGC008E] Next or Nextnext
这个我是真难泵的，题解看 题解 AT2267 【Next or Nextnext】 - 洛谷专栏 的吧我还是太菜了 www。
总结：这种双图刻画限制我还是第一次见，双图策略可以帮助你充分考虑已知信息和所求，通过思考两个图之间的关系来发现问题性质。
 LOJ521 绯色 IOI 抵达
每做一道难题就要去 zxy 上找点清淡的吃。
又是构造题，树的构造先哈气考虑剖叶子。那么不难发现真是个天才的想法，因为叶子是唯一确定选择父亲的。
然后进一步发掘，由于题目每一个城市为唯一对应一个选择的点，所以一个非叶节点必须最多一个叶子，否则就不合法。
叶子的选择还好说，但是问题出在其父亲的，因为我不知道父亲可不可能选，我们考虑进一步发掘性质也发不出来什么，考虑父亲选择是很宽泛的，我们考虑能否强化限制，我们猜想叶子父亲究竟选什么，大胆猜想就是选叶子，证明考虑反证法即可。
然后就好说了，那么这两个节点的匹配方案是唯一确定的，我们把这两个节点同时删去之后得到一个新树，递归操作直到树为空即可，所以如果有解匹配方案也只有一种。这种方案我们如何考虑赋值呢，发现这个满足的是偏序关系，用拓扑排序确定顺序即可，时间复杂度 O(n)O(n)O(n)。
总结：从一些简单结论入手，然后再考虑强化结论。树的构造从叶子入手已经老 old trick 了。
当限制过松的时候，我们可以强化限制，可以只考虑少部分的变元就能给出构造方案。直观上好像每个地方都能改，但实际上很多地方是“被迫的”，一旦你确定了某些关键部分，其余部分就自动唯一确定了。
 CF798E Mike and code of a permutation
我想了 1 小时然后告诉我主席树优化建图喵了？
考虑到本题的限制都是偏序关系，我们要通过这些偏序关系来确定一个排列，这个是拓扑排序的拿手好戏。考虑用图论的建图来表示偏序关系。考虑顺序扫描中维护一个没有标记过集合 SSS。

若 ai=−1a_{i}=-1ai​=−1，对于 j∈[1,n]j\in [1,n]j∈[1,n] 且 j∉Sj\notin Sj∈/S，若 pj&lt;pip_{j}&lt;p_{i}pj​&lt;pi​ 则令 j→ij\to ij→i。
若 ai≠−1a_{i}\neq -1ai​=−1，对于 j∈[1,ai]j\in [1,a_{i}]j∈[1,ai​] 且 j∉Sj\notin Sj∈/S，若 pj&lt;pip_{j}&lt;p_{i}pj​&lt;pi​ 则令 j→ij\to ij→i。最后令 i→aii\to a_{i}i→ai​。

暴力建边加暴力拓扑的时间复杂度是 O(n2)O(n^2)O(n2)，无法承受，但是注意到这是一个动态删点加集合区间连边，可以用主席树优化建图，但我脑子没那么好所以想不到，所以先假设我不知道。
我们发现这样做是没前途的（哈？），因为直接光建图就是 O(n2)O(n^2)O(n2) 了。我们考虑维护入度，但是发现入度很难降到 O(n2)O(n^2)O(n2) 以下的复杂度进行维护。
考虑到限制是一个偏序关系，我们可以考虑不去维护入度，我们去维护最值。那么原来的拓扑排序图就不对了，但是我们可以通过建出原图的返图，让后枚举 1→n1\to n1→n，如果当前遍历到的点没有被访问过就以其为起点在反图上 dfs，最后回溯的顺序就是拓扑序。
那么这个方法一个好处就是我们只需要知道图上连出去的点是什么就可以遍历了。具体的连边情况，设 timitim_{i}timi​ 表示 iii 点被标记的时间，如果没有标记 timi=n+1tim_{i}=n+1timi​=n+1，为了方便 ai=n+1a_{i}=n+1ai​=n+1。那么正常点（即 ai≠n+1a_{i}\neq n+1ai​=n+1）有两个边：ai→ia_{i}\to iai​→i 和 i→ji\to ji→j 其中 j&lt;aij&lt;a_{i}j&lt;ai​ 且 i&lt;bji&lt;b_{j}i&lt;bj​ 即可，显然可以通过线段树优化建图。但是太麻烦了，我们不用真正维护出边，而是选出最有可能被遍历的那个点去更新它即可，我们可以转化为最值问题。具体的，对 iii 为下标建出线段树，维护 bib_{i}bi​ 的最大值，更新时找到 j∈[1,ai]j\in [1,a_{i}]j∈[1,ai​] 最大的 bjb_{j}bj​ 看是否满足 bj&gt;ib_{j}&gt;ibj​&gt;i，若满足遍历，否则无出边，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
如果不是计数问题，那么可以考虑把维护数量转化成维护最值。 维护最值当然是好做的啦。
这种 Dijkstra 的遍历思想大有用处，即如果每个点只需要遍历一次那么维护最有可能遍历的点.
 CF827F Dirty Arkady’s Kitchen
哦我的天啊这是什么？
首先我们如何处理不能停留的限制。因为不能停留，所以要么在一条边上来回转，要么润去其他边。这对点是不好维护的，但是对边全很好维护，只需要分奇偶性记录第一次到达的时间即可，剩下奇偶性相同的时间都能到达。并且每条边能到达的时间点并在一起正好就是该点能够被到达的时间点，因而不会漏掉什么情况。
转移尝试模仿 Dijkstra，我们按照第一次走的时间优先队列，用每条边去更新目标点后面的边。
将点拆成奇偶两个点，每条边分别从奇到偶、偶到奇连两条单向边，共四条边。每个点把边按起始时间排序，加入一个边就将所有起始时间小于它结束时间的边都扔到队列里。显然之后的边不会让这些边的开始时间更优，因此可以在列表中直接删除已经加入过的边。时间复杂度 O(mlog⁡m)O(m\log m)O(mlogm)。
本题难点不在于越早到某个点越好，考虑需要较晚到某一个点通路才开放，现有快路径和慢路径，可以先通过快路径到达这个点之后再在慢路径的最后一条边上来回横跳，这样可能达到和慢路径相同的效果。
总结：在有明显的时间戳的图论问题中，动态加边扩展是一个好方法。本题其实是用动态加边解决最小到达时间的问题（你可以理解成维护连通性的常见方法），然后维护最晚到达时间来判定这条边能不能用于扩展，本质就是两种限制的拆分导出了我们使用的方法。
 P3573 [POI 2014] RAJ-Rally
还真是，每做一道难题就要去 zxy 上找点清淡的吃。
直接给你 DAG，这么好？考虑拓扑排序，那么得到拓扑序后有一删点最长路径的性质：

设删除点 xxx，那么删除点之后的最长路一定是拓扑序小于 xxx 和大于 xxx 的点路径。

可以考虑暴力预处理路径，但是枚举修改点之后就是 O(n2)O(n^2)O(n2) 的了，题目要求的复杂度 O(nlog⁡n)O(n\log n)O(nlogn) 我们只能再遍历删除点的时候进行计算。
我们可以预处理出经过每条边的路径最大值（正图和反图跑拓扑），然后类似扫描线，离开一个点的时候加入所有边到 set，询问之后删除这个点的所有边，时间复杂度 O(mlog⁡m)O(m\log m)O(mlogm)。
总结：
删点后求最短路的问题有固定套路，就是考虑有一条边一定会跨过这个点，可以拼凑出路径来。
 CF605E Intergalaxy Trips
首先战术上期望 DP，设 f(i,j)f(i,j)f(i,j) 表示？哦不对，设 f(i)f(i)f(i) 表示第 iii 个点到 nnn 的最小期望步数，有转移：
f(u)=∑v≠unf(v)⋅pu,v⋅∏f(x)&lt;f(v)(1−pu,x)(1−∏E(v)&lt;E(u)(1−pu,v))f(u)=\frac{\sum_{v\not=u}^n f(v)\cdot p_{u,v}\cdot\prod_{f(x)&lt;f(v)}(1-p_{u,x})}{(1-\prod_{E(v)&lt;E(u)}(1-p_{u,v}))}
f(u)=(1−∏E(v)&lt;E(u)​(1−pu,v​))∑v=un​f(v)⋅pu,v​⋅∏f(x)&lt;f(v)​(1−pu,x​)​
这个转移很难泵，因为高斯消元不能直接消。但是我们发现每次我们肯定确定最小的 fff 然后再去确定大的并且一旦确定之后它的值就不会再改变了。这个玩意很想 Dijkstra，考虑用 Dijkstra 的顺序来进行转移，然后每次转移找最小的 fff 转移其他节点，时间复杂度 O(n2)O(n^2)O(n2)。
总结：
如果转移的顺序是值，并且值大的不会影响值小的。那么可以用类似 dijkstra 的方法，每次取出最小值并且固定，考虑它对其他值的影响即可。
 P7516 [省选联考 2021 A/B 卷] 图函数
由于全是和式而且还带删边，但是我们只需要算所有点的总和。我们只需要考虑单个点的贡献就可以了。
但是还不是太好考虑分析性质：

u→v,v→uu\to v,v\to uu→v,v→u 由于为有向图，所以肯定在强连通分量内才能算上贡献 fff。
删点是从小到大按照编号顺序删点。

那么也就是说我们可以从强连通分量的角度来进行考虑，但是我们显然有一个问题，我们要动态维护 Tarjan 强连通分量，显然极难维护。但是我们发现删点是从小到大进行删点的，我们可以考虑 uuu 的贡献，如果我们保留 [u,n][u,n][u,n] 的点和有关边的时候，和它能够互通的 vvv 点个数，而根据第二性质我们不用考虑 [1,v)[1,v)[1,v) 的点因为已经被删除了，时间复杂度是 O(n(n+m))=O(n2+nm)O(n(n+m))=O(n^2+nm)O(n(n+m))=O(n2+nm)。
然而搞笑的是有删边，但是发现删边是一个前缀，我们可以转化为反着加边。但是搞笑的是又遇到动态 tarjan 了，显然肯定不能做。但是我们思考我们是求的是和式，可以考虑固定点 uuu 求 f(u,∗)f(u,*)f(u,∗) 的贡献，最后累加起来。然后我们思考这玩意是动态加边，我们要动态维护点的连通性，如何在不使用 Tarjan 的情况下动态维护？考虑 (u,v)(u,v)(u,v) 之间两个路径，如果我们固定点 uuu 必定是向外拓展的，我们可以考虑建出正反图，然后在这两个图上进行拓展，每次加边我们动态 bfs。果加入的这条边两个端点都访问过就没用，如果终点没有访问过就以他开始 bfs，每次把 bfs 到的边删掉，如果两个端点都没访问过就加入图中。每条边只会被删除一次，所以时间复杂度 O(n2+nm)O(n^2+nm)O(n2+nm)。
总结：当不用求出具体值，只用求总和时，考虑贡献法。动态加边还可以直接维护强连通性，对正反图动态 bfs 即可 P7516 [省选联考 2021 A/B 卷] 图函数 - 洛谷
 CF1556G Gates to Another World
真的调不出来。
首先可达性可以转化为连通性，我们考虑如何维护连通性，冰茶几维护什么？
考虑题目给的这个 2n2^n2n 个点一定有它的性质，基本上离不开几个：线段树形态，二进制位表示等。
不难发现这个点连边我们可以用完全线段树的形态来表示，其中每个左儿子和右儿子的叶子节点对应连边，同时也不难发现线段树一个点所代表的区间内部是连通的。
但是搞笑的，有了删除操作就不好做了，注意到询问可以离线，直接一个战术时光倒流，将删点改成加点。我们给每一个点打上一个删除标记 ttt 表示删除这个点的时间，如果没有删除则 t=m+1t=m+1t=m+1，然后通过线段树结构来进行优化连边。搞笑的，这样做时间复杂度是 O(n3m)O(n^3m)O(n3m) 因为我们要先把所有节点的预先建出来，但是我们没有很好的利用这个叶子节点连边和点内区间联通的性质，注意到一个&quot;叶节点&quot;（并不是真正的叶子，而是动态开点之后没有儿子的结点）中所有叶节点的行为平行，因为它们删除的时间相同，并且一定联通，所有可以把他们当成一个点来考虑。
那么这样复杂度正确，于每个非叶节点一直递归下去，直到找到两个叶子连边，这条边被删除的时间是 min⁡(tx,ty)\min(t_{x},t_{y})min(tx​,ty​)，求出所有边之后我们离线逆序加边，用并查集判断连通性即可。时空复杂度均为 O(n2m)O(n^2m)O(n2m)。
总结：
这是一个对应点优化连边问题，这个优化建图无法用常规的优化，一般的做法是用数据结构维护某个量，读入所有修改后再优化建图。
对于带修改的问题来说，可以有一个统一的固定结构来处理两点连通的时刻（边起作用的时刻）
 P7056 [NWRRC 2015] Insider’s Information
随机化过于人类智慧故不讲。
首先考虑如何判断一个三元组是否合法，有一个必要条件就是 bbb 必须比 aaa 或 ccc 先插入，否则一定不合法。
剩下的，我们还需要确定 a,b,ca,b,ca,b,c 之间的偏序关系，这种确定偏序关系的我们可以考虑利用拓扑排序来去求解。考虑先建边来表示必要条件，那么有两个：a→ba\to ba→b 和 c→bc\to bc→b，但是发现你不可能确定两次，故我们可以让 b 的入度只增加 1 即可。这个操作很不好笑。
然后我们就有了一个合法的拓扑序，至于为什么合法因为题目没有给出无解该干什么所以一定有一个合法的拓扑序。我们可以利用这个拓扑序来决定每个数是放在最左边还是最右边，考虑 (a,b,c)(a,b,c)(a,b,c) 三元组在拓扑序上会呈现 4 种情况：

(a,b,c)(a,b,c)(a,b,c)；
(a,c,b)(a,c,b)(a,c,b)；
(c,a,b)(c,a,b)(c,a,b)；
(c,b,a)(c,b,a)(c,b,a)；

考虑到后两个和前两个是对称的，我们可以对前面两个单独进行考虑。我们思考两组什么时候会产生贡献？

(a,b,c)(a,b,c)(a,b,c)：产生贡献当且仅当 bbb 在最左侧。
(a,c,b)(a,c,b)(a,c,b)：产生贡献当且仅当 ccc 在最右侧。

剩下两组也是对称的，这说明：我们只需要在将要加入第二个元素的时候考虑这个限制。实现的时候我们将拓扑排序的决策同时进行，我们分讨是作为 bbb 的限制和作为 ccc 的限制（对应 aaa 已经插入）即可统计放在最左边和最右边的贡献，放较大的即可，由于每次都是少的往大的放，满足限制至少有 ⌈m2⌉\lceil \dfrac{m}{2}\rceil⌈2m​⌉ 个，时间复杂度 O(n)O(n)O(n)。
总结：这个贡献其实很巧妙，我们首先通过拓扑排序来确定顺序，然后将三元组的限制放在单点上来去简化问题。这种操作的前提条件需要我们先拆分限制简化条件。
类似的：#2999. 「JOISC 2015 Day2」Keys - 题目 - LibreOJ
 9月
 CF1062F Upgrading Cities
拓扑排序练习题，但没有完全理解拓扑排序。
考虑这玩意就是一个可达性，你在正反图上跑一个 bitset 统计可达性就可以简单做到 O(n2w)O(\dfrac{n^2}{w})O(wn2​)，但是不用猜都知道这个做法会被卡。
考虑优化，我们需要知道一个性质就是 DAG 上的拓扑排序，队列内的点是互相不可达到的，这个证明是显然的。所以我们可以通过分类讨论，设队头为 uuu 且此时未弹出队头元素，ttt 表示已访问过的点数：

若队列大小为 111，即只有 uuu。那么显然满足第一个条件可到达的点为 n−tn-tn−t。
若队列大小为 222，即有 uuu 又有 vvv，为了满足第二个条件我们考虑遍历 vvv 的出边，若一条 v→xv\to xv→x 的出边，但 xxx 的入度为 1 则显然不合法。反之则到达点位 n−t−1n-t-1n−t−1。
若队列大小 ≥3\ge 3≥3，两个条件都不合法。

在正反图上遍历即可，时间复杂度 O(n+m)O(n+m)O(n+m)。
总结：同在队列里的点没有任何到达关系，可以通过它来筛选合法点。这个我是真不知道很搞笑。
 AT_agc036_d [AGC036D] Negative Cycle
 P5664 [CSP-S2019] Emiya 家今天的饭
哈！
这个 k2\dfrac{k}{2}2k​ 的限制很难处理，因为组合很难直接去做，考虑正难则反，我们将 ≤k2\le \dfrac{k}{2}≤2k​ 转为求解 &gt;k2&gt;\dfrac{k}{2}&gt;2k​ 的，我们发现由于 k2\dfrac{k}{2}2k​ 的 kkk 是总数，那么 &gt;k2&gt;\dfrac{k}{2}&gt;2k​ 的列有且仅有一个。
考虑枚举法确定我们的决策列，然后我们计算方案数，然后我们用总方案减去不合法方案即可。
考虑 DP 求解，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示前 iii 行，选了 jjj 个点，当前枚举列选了 kkk 个点的方案数。转移枚举即可，时间复杂度 O(n3m)O(n^3m)O(n3m) 只有 84 分。
考虑优化，发现我们的瓶颈在于第二维，先猜想第二维是否状态数量上限，发现 O(mn⋅nn)O(mn\cdot n \sqrt{n})O(mn⋅nn​) 很炫猜都不用猜，我们考虑能否去掉第二维，发现我们状态的表示只需要确定 &gt;k2&gt;\dfrac{k}{2}&gt;2k​ 的限制是否满足即可。考虑分析：
k&gt;j2→2k−j&gt;0k&gt;\dfrac{j}{2} \to 2k-j&gt;0
k&gt;2j​→2k−j&gt;0
故 DP 直接去掉第二维，然后维护差值，设 f(i,j)f(i,j)f(i,j) 表示前 iii 行差值为 jjj 的方案数即可，时间复杂度 O(n2m)O(n^2m)O(n2m)。
总结：以后看到这种具有 ≤tot2\le \dfrac{tot}{2}≤2tot​ 的限制可以思考正难则反，对 &gt;tot2&gt;\dfrac{tot}{2}&gt;2tot​ 先进行思考，因为显然 &gt;tot2&gt;\dfrac{tot}{2}&gt;2tot​ 至多出现一次。
DP 在优化状态的时候，我们不仅要思考谁是瓶颈状态，还要思考导致瓶颈的原因是什么，才能更好的进行优化和发掘性质。
 P4769 [NOI2018] 冒泡排序
众所周知的是，冒泡排序的交换次数就是排列的逆序对数。
首先不考虑字典序（即特殊性质），我们如何计算有多少个排列满足逆序对数等于 12∑i=1n∣i−pi∣\dfrac{1}{2} \sum\limits_{i=1}^n |i-p_{i}|21​i=1∑n​∣i−pi​∣。我们考虑原式子为 cnt=12∑i=1n∣i−pi∣cnt=\dfrac{1}{2} \sum\limits_{i=1}^n |i-p_{i}|cnt=21​i=1∑n​∣i−pi​∣，变形有 2⋅cnt=∑i=1n∣i−pi∣2\cdot cnt=\sum\limits_{i=1}^n |i-p_{i}|2⋅cnt=i=1∑n​∣i−pi​∣，其中后面的式子我们考虑用图论刻画，即 i→pii\to p_{i}i→pi​ 进行连边，那么 ∣i−pi∣|i-p_{i}|∣i−pi​∣ 就表示跨过的距离，那么合法当且仅当每条边穿过的格子正好对应它参与的逆序对的个数，即所有逆序对两两配对成边的端点，且没有多余交叉。
也就是说，逆序对必须两两配对，不可能出现一个位置被两个人抢走配对的情况。
等价的转化提议，即不存在三元即以上的序列满足 i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k 使 pi&gt;pj&gt;pkp_{i}&gt;p_{j}&gt;p_{k}pi​&gt;pj​&gt;pk​。即不存在三元即以上的下降子序列。
那么这样如何刻画呢？我们发现这玩意由于没有一元子序列这一说法，那么必定为二元下降子序列，我们用图来表示合法序列数变化这一过程：

我们发现拐点必然是当前时刻序列的最大值然后接一个较小值，然后再继续上升。
故有一个 DP，设 f(i,j)f(i,j)f(i,j) 表示前 iii 个数构成的排列最大值为 jjj 的方案数，转移为 f(i,j)=f(i−1,j)+f(i,j−1)f(i,j)=f(i-1,j)+f(i,j-1)f(i,j)=f(i−1,j)+f(i,j−1)，要求 j≤ij\le ij≤i。这玩意是搞笑的 O(n2)O(n^2)O(n2)，但是不难发现这玩意就是格路计数但是有 j≤ij\le ij≤i 的限制，可以转化为卡特兰数，可以 O(1)O(1)O(1) 计算，或者公式为 (i+ji)−(i+jj+1)\dbinom{i+j}{i}-\dbinom{i+j}{j+1}(ii+j​)−(j+1i+j​)。
现在考虑有字典序的限制，这个限制我们可以转化为至少一个位置满足 pi&gt;qip_{i}&gt; q_{i}pi​&gt;qi​，其余任意。我们考虑枚举法确定这个位置什么，我们钦定一个位置 iii，前面的和 qiq_{i}qi​ 一致，第 iii 个必须大于 pip_{i}pi​。令 mx=max⁡j=1i−1qjmx=\max_{j=1}^{i-1} q_{j}mx=maxj=1i−1​qj​，mnmnmn 为最小可以填的数。
由于我们强制钦定之后从 (1,1)→(n,n)(1,1) \to (n,n)(1,1)→(n,n) 的 fff 的计算就不再适用了，我们将其定义为从 (i,j)(i,j)(i,j) 走到 (n,n)(n,n)(n,n) 的方案数。
接下来我们考虑如何计算方案数，考虑分类讨论：

若 pi=mnp_{i}=mnpi​=mn，那么我们显然只能填写 x&gt;mxx&gt;mxx&gt;mx 的方案，即 f(i,mx+1)f(i,mx+1)f(i,mx+1)。
若 mn&lt;pi&lt;mxmn&lt;p_{i}&lt;mxmn&lt;pi​&lt;mx，显然只能填写 x&gt;mxx&gt;mxx&gt;mx，但是显然这样构成不合法排列了，故无解。
若 pi≥mxp_{i}\ge mxpi​≥mx，只需要填写一个 x&gt;pix&gt;p_{i}x&gt;pi​ 的数就可以了，即 f(i,pi+1)f(i,p_{i}+1)f(i,pi​+1)。

时间复杂度 O(n)O(n)O(n)。
总结：通过将公式转化为清晰易懂的方式，如本题的图论和坐标系表示变化。这是常用的技巧，通过不断简化问题，我们才能发掘一些好玩的性质。
同时给出了 DP 优化一种新思路，通过 DP 式子的组合意义来进行优化，有的时候可以大幅降低复杂度。
本题目放在卡特兰数是有什么心事吗？
 AT_arc139_d [ARC139D] Priority Queue 2
好练习题！
我不知道为什么我的题面是让我算期望，但是问题是等价的。

有 nnn 个数 ai∈[1,M]a_{i}\in [1,M]ai​∈[1,M]，接下来进行 kkk 次操作：随机一个值域在 [1,M][1,M][1,M] 的数加入 aaa，然后删掉第 xxx 小的数。其中 xxx 给定。
问 ∑iai\sum\limits_{i} a_{i}i∑​ai​ 的期望，对 998244353998244353998244353 取模。
1≤n,m,k≤2000,x≤n+11\le n,m,k \le 2000,x\le n+11≤n,m,k≤2000,x≤n+1。

先考虑简化问题，我们考虑值域为 {0,1}\{0,1\}{0,1} 的情况下如何去做，那么显然每一次加入是等概率随机选取 {0,1}\{0,1\}{0,1} 加入，如果 111 的个数超过 n−xn-xn−x 的话我们就要把它删掉，000 我们不用管因为答案求的是 111 的个数的期望，贡献答案的只能是 111。
由于 aia_{i}ai​ 一开始给定，选择给定，答案贡献只能由 111 贡献。故我们可以枚举 kkk 次操作一共放了多少个 111，用组合数算一下就可以了，具体的就是枚举 111 个数 jjj，答案为 ans=∑j=0k(kj)pj(1−p)k−jf(j)ans=\sum\limits_{j=0}^k \dbinom{k}{j}p^j (1-p)^{k-j}f(j)ans=j=0∑k​(jk​)pj(1−p)k−jf(j)，其中 f(j)f(j)f(j) 为：
f(j)={min⁡(T,s0+j)if s0&lt;T,max⁡(T,s0−(k−j))if s0&gt;Tf(j)=
\begin{cases}
\min(T,s_{0}+j) &amp; \text{if } s_{0}&lt;T, \\ \\
\max(T,s_{0}-(k-j)) &amp; \text{if } s_{0}&gt;T
\end{cases}
f(j)=⎩⎪⎪⎨⎪⎪⎧​min(T,s0​+j)max(T,s0​−(k−j))​if s0​&lt;T,if s0​&gt;T​
其中 TTT 为题目中给出的删除阈值，即 T=n−x+1T=n-x+1T=n−x+1。时间复杂度 O(k)O(k)O(k)。
现在考虑到值域扩大到 [1,m][1,m][1,m] 如何去做，注意到这个第 xxx 小我们只需要关心相对大小即可，我们枚举权值，序列可以转为 010101 序列，大于某个权值设为 111，否则设为 000。这样转化后的命题是等价的，因为期望具有线性性，有 E(x)=∑iP(x≥i)E(x)=\sum\limits_{i} P(x\ge i)E(x)=i∑​P(x≥i)。只需要枚举权值 t=1,2,…t=1,2,\dotst=1,2,…，将 ≥t\ge t≥t 的数设为 111，否则设为 000。将所有上述问题的答案和相加即可。只需要做 mmm 遍上述过程即可，时间复杂度 O(mk)O(mk)O(mk)。
 「JOISC 2017 Day 1」港口设施
先考虑简化问题，即我们只有一个栈的情况下什么时候合法，我们将每一个元素的入出栈时间看作一个时间区间，那么合法的充要条件就是所有区间要么包含，要么独立，不能交。
有了这个判断条件好说了，有一个性质就是由于这两个栈都是独立的，所以我们可以通过选取区间分配到两个集合中，求有多少种合法的分配方案。说人话，求出有多少种二染色方案，使得同色的线段不交。我们把区间看成点，对于相交区间 [a,b][a,b][a,b] 和 [c,d][c,d][c,d]，满足 a&lt;c&lt;b&lt;da&lt;c&lt;b&lt;da&lt;c&lt;b&lt;d，我们让 [a,b]→[c,d][a,b] \to [c,d][a,b]→[c,d] 连边，然后我们求这张图的连通块个数 kkk，由于连通块内必定是黑白交替染色，故确定一个开始色即可，一个连通块贡献 222 个方案，答案就是 2k2^k2k。
暴力连边求解是 O(n2)O(n^2)O(n2) 的，无法通过，而且问题在于这些区间点属于散点没法硬上线段树优化建图。我们考虑按右端点从小到大扫描所有线段 [a,b][a,b][a,b]，每次维护右端点更大的线段组成的集合 SSS，那么当前点连接的点必定是 SSS 中的一段连续区间（左端点在 [a,b][a,b][a,b] 中的点）。
但是发现这样做还是会 O(n2)O(n^2)O(n2) 的很搞笑，看起来很难做了。我们继续发掘性质，发现一段区间被连接后的效果是，区间中的点必然同色。所以维护 nxtinxt_{i}nxti​ 表示与 iii 同色的点最多延伸到哪里，那么修改变成暴力访问一段区间，并且把这段区间的 nxtnxtnxt 全部指向区间的右端点。这个复杂度看起来不对，但是我们通过冰茶几路径压缩的复杂度来进行分析发现这玩意是对的，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：二分图染色问题，如果需要优化连边，得到同色的性质可以缩成一个点，然后套用并查集路径压缩的时间复杂度。
 CF1396E Distance Matching
CF1387B2 Village (Maximum) 做过吧？严格加强。但是我做不出来。
对于这种构造可行解使得权值和恰好为某一值的题，一般都是先求出可以构造出来的最大和最小值，然后从某个极值按照一定方法进行连续修改。
我们考虑剖叶子来描述上下界，但是剖叶子很难确定匹配问题的选取，但是注意到贡献是树上距离。这种树上距离我们可以考虑拆分贡献法，将点对之间的贡献拆分到边上。
我们考虑一条边 (u,v)(u,v)(u,v) 的贡献，那么很容易得到一条边贡献 www 的上下界，即为 sizu mod 2≤w≤min⁡(sizu,sizv)siz_{u}\bmod 2 \le w \le \min(siz_{u},siz_{v})sizu​mod2≤w≤min(sizu​,sizv​)。即子树尽量自己内部匹配和尽量跨边匹配。
考虑到 min⁡\minmin 是难受的，有一个 Trick 就是我们可以通过取重心为根就可以去掉子树 min⁡\minmin 的式子，那么贡献上界 mxmxmx 就是 ∑u≠rtsizu\sum\limits_{u\neq rt} siz_{u}u=rt∑​sizu​ 下界 mnmnmn 是 ∑u(sizu mod 2)\sum\limits_{u} (siz_{u}\bmod 2)u∑​(sizu​mod2)。
我们考虑必要条件，由于 dis(x,y)=depx+depy−2deplca(x,y)dis(x,y)=dep_{x}+dep_{y}-2dep_{\text{lca}(x,y)}dis(x,y)=depx​+depy​−2deplca(x,y)​，更换点的匹配只会引起 lca 这一项的变化，所以无论如何边权和的奇偶性不变。所以必要条件为 mn≤k≤mxmn\le k \le mxmn≤k≤mx 且 k≡mx(mod2)k\equiv mx \pmod 2k≡mx(mod2)，我们考虑给出充分性证明，显然只能构造了 www：
考虑到边权和为 mxmxmx 我们接着调整到 kkk 的方案，开始可以把 dfn 序为 i 的点和 dfn 序为 i+n/2 的点配对，这样是能构造到 mx 的（下文称之为初方案），而且所有路径都跨过重心，我们在构造时考虑维护根为重心的这个性质，所以我们选取点数最大的子树来操作，设 y 表示最深的非叶节点：

如果 2depy&lt;mx−k2dep_{y}&lt;mx-k2depy​&lt;mx−k，我们直接拿 yyy 配对（优先儿子，可以自身），那么配对后相较于初方案的边权和会减少 2depy2dep_{y}2depy​，配对后删除这两个点，树的形态不变，我们在新树上构造出新的初方案。
如果 2depy≥mx−k2dep_{y}\ge mx-k2depy​≥mx−k，因为 dep 连续这一特点，我们找到 2depz=mx−k2dep_z=mx−k2depz​=mx−k，然后类似于上述方案配对即可，边权和会减少 2depz2dep_{z}2depz​，这说明我们找到了答案。

如果还有未匹配的点就按 CF1387B2 Village (Maximum) 的方法来构造即可，用 set 维护即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
从一开始提到的本题两个，我们总结出一个构造思考路径：对于这种构造可行解使得权值和恰好为某一值的题，一般都是先求出可以构造出来的最大和最小值，然后从某个极值按照一定方法进行连续修改。
同时还能总结出，对于树上遇到 min⁡(siz)\min(siz)min(siz) 的式子的时候，可以通过取重心为根的方式来去除。
同时这是第二次对于树上路径和问题的贡献法应用。
 CF526G Spiders Evil Plan
最速通的一集。
先考虑分析性质，我们发现使用 kkk 条路径就可以覆盖一棵有 2k2k2k 的叶子的树，证明是显然的。其次，我们为了最大化路径一定会选取叶子到叶子的路径，而且一个最长的路径一定会涉及到直径，这种最长路径问题我们可以考虑往直径上面去想。我们思考，若一棵树以直径端点为根，那么树将会长这样：

我们通过这个进行分类讨论：

若 xxx 点在直径上，那么一定有一条路径选择的就是直径，剩下的通过拼凑一对黑色路径贡献，取 y−1y-1y−1 个就可以了。
若不再直径上，那么必定 xxx 在直径延申出的一条分支（图中的黑线）上，那么从分支一端（xxx 子树中最深点）为起点走到直径后拐弯往更远的直径端点走，剩下的继续拼凑更长链。

通过反证法和前面的路径不难证明上述就是最优方案，但是问题在于上面这玩意光是叶子到叶子的匹配是 O(n2)O(n^2)O(n2) 的无法通过。考虑到这个最优方案有什么性质，注意到直径的最远一端必定作为答案出现。考虑枚举法，说人话就是枚举作为答案选取的直径端点，然后以其为根建树。
接下来我们需要求除直径以外的最长链，考虑到除直径以外的最长链必定为：黑段 -&gt; 部分直径 -&gt; 黑段。
由于直径显然是必选的，所以直径不会贡献答案，我们只需要两两配对最长黑段就可以了，由于使用 kkk 条路径就可以覆盖一棵有 2k2k2k 的叶子的树，直径贡献 222 个叶子，我们只需要求前 2y−22y-22y−2 长的支链配对就可以了，怎么求，用长链剖分。
哎不对啊，xxx 的限制呢？考虑答案，如果在直径上就结束了。如果不再直径上那么方案必然为 xxx 子树中最深一点 -&gt; 黑段 -&gt; 部分直径 -&gt; 黑段（若 y=1y=1y=1 则为直径端点），我们只需要将选取支链集合中贡献最小的替换掉即可。
直接做，时间复杂度是 O((n+q)log⁡n)O((n+q)\log n)O((n+q)logn)。
总结：
边权和贡献最大问题可以往长链剖分这个角度考虑，如果是路径问题可以通过 2k 个叶子的构造性结论转化成最长链问题（前提是需要定根），同时以直径端点就可以通过上面的思维模型来辅助思考。
 P5327 [ZJOI2019] 语言
第 75 黑。
好题？
考虑树是一条链是怎么做，我们可以维护每个点为左端点最远覆盖到的右端点，用线段树求区间最大值然后把所有位置的贡献求个和即可。
考虑暴力的 40 分怎么拿？显然 O(nm)O(nm)O(nm) 的暴力对每一个点维护 set，然后 O(n2)O(n^2)O(n2) 的对于每一个点计算向外搜子树内能拓展到的点，设其数量为 numinum_{i}numi​，那么答案就是 ∑unumu\sum\limits_{u}num_{u}u∑​numu​。很好，现在你有 60 分了。
然后怎么拓展，考虑到我们不能暴力向外拓展，我们能不能将链的做法和暴力结合起来？考虑到路径必然是树上连续点集所构成的，所以一个点能到达的所有点恰好构成一棵生成树（即一个连通块）。
我们考虑这个生成树如何构造，发现如果路径 s→ts\to ts→t 包含点 uuu ，s,ts,ts,t 则是 uuu 的两个极远点。而 uuu 的生成树则是连通所有 uuu 的极远点的最小生成树。
肯定不能真的去求这个生成树，能否巧妙地计算出生成树大小？考虑点集 SSS，我们加入一个点 uuu，那么最深的 LCA(u,v)\text{LCA}(u,v)LCA(u,v)，其中 v∈Sv\in Sv∈S。那么 uuu 的贡献就是 depu−depLCAdep_{u}-dep_{\text{LCA}}depu​−depLCA​，这玩意很像虚树，有一个 Trick 就是将所有点按照 DFN 排序之后 lca=lca(u,lst)lca=lca(u,lst)lca=lca(u,lst)，其中 lstlstlst 表示上一个加入的点。注意第一个加入点的贡献并不是它的深度，而应该减去最上面联通点的深度，所以可以先记贡献为 depxdep_{x}depx​，最后再减去 deplcadep_{lca}deplca​，这里的 lcalcalca 是指的所有点的 LCA。
剩下一个问题，如何取出经过了这个点的路径，由于只需要计算一次答案，考虑树上差分即可，即在端点加入路径贡献，LCA 以及 falcafa_{lca}falca​ 处删除贡献。
加入点的问题可以用线段树维护，线段树的下标需要按 dfn 排序，上传的时候减去左儿子最右边的点和右儿子最左边的点的 lca 的深度即可，然后线段树是支持标记合并的，所以写个线段树合并就行了，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
要快速计算虚树的大小时，可以考虑下标为 dfn 序的线段树来维护。
 Ridiculous Netizens - HDU 6643
This is the true 好题！
首先你会想到用树形背包来做，但是问题在于如果你直接设置为 f(u,i)f(u,i)f(u,i) 表示为 uuu 子树内乘积为 iii 的方案数，但是直接做会出现两个问题：

你无法保证你选取的方案子树是连通的。
在不考虑乘积的情况下，你的合并是 O(mm)O(m\sqrt{m})O(mm​) 的，因为你要枚举约数。

先保证状态是 O(nm)O(nm)O(nm)，然后我们考虑把第一点解决掉，第一点的问题就是在于我们一般树形背包是自底向上合并的，但是这样可能中途就会断掉。转化思路，我们可以确定一个子树的根，然后从根自上向下贡献答案，说人话就是我们可以把原命题转化为一个单点加入问题，选取一个点就说明必须选它的父亲。这玩意是在 DFN 序上 dp 的过程，因为 dfn 特性，子树 dfn 序连续，考虑在 dfn 上进行 DP。但是显然实际实现肯定不能直接暴力求出 dfn 序，设 f(u,i)f(u,i)f(u,i) 表示 uuu 内加入点的构成的子树，乘积为 iii 的方案数，转移首先自上向下贡献 www，然后递归完子树后用儿子的答案更新当前点的答案即可。时间复杂度是 O(nm)O(nm)O(nm) 的。
然后考虑第二个情况，我们不考虑乘积暴力合并是 O(mm)O(m\sqrt{m})O(mm​) 的，我们的目标是要优化到 O(nm)O(n\sqrt{m})O(nm​) 的状态。看起来很难做，考虑发掘性质，注意到我们枚举约数中使得 i←i+1i\leftarrow i+1i←i+1 的时候，所管辖的区间有很多重叠的部分，同时又注意不到，⌊xnm⌋=⌊xnm⌋\lfloor \dfrac{x}{nm} \rfloor=\lfloor \dfrac{\dfrac{x}{n}}{m} \rfloor⌊nmx​⌋=⌊mnx​​⌋，可以用整除可以把 mmm 整除 iii 的值定义到状态里面。根据整除分块状态数变成 O(m)O(\sqrt{m})O(m​)，根据结论值相同在以后的转移方法也相同所以正确性得到保证。
但是这是无根树，每个根的过程是相对独立的所以不能一遍求出，且合并子树是 O(nm)O(n\sqrt{m})O(nm​)，但是插入点是 O(m)O(\sqrt{m})O(m​) 的可以承受，考虑点分治减少子树大小，即可优化到 O(nmlog⁡n)O(n\sqrt{m}\log n)O(nm​logn)。
总结：不支持合并的树上问题可以考虑转成 dfn 序上 dp，同时这种等价类的优化方法我也是第二次？见了，通过整除分块让状态数大幅减少（整除值相同的划分为等价类）。根独立的 dp 问题可以考虑用点分治优化，原理就是缩小子树中的需要考虑节点数。
 CF611H New Year and Forgotten Tree
nm 就给我给位数是吧。
考虑到这玩意实际上是给边分配点，同时不难观察到同位数的点它们是等价的，因为都要分配同位数的点。
考虑到同位数之间的边是容易的，因为我们可以显然把同色的点缩成一个块，但是不同位数连边是困难确定的，所以我们首先确定不同位数连边。我们考虑枚举法，钦定颜色代表点把这些代表点做生成树，剩下的点接在这些代表点上，这是因为如果存在解，那么就存在其他点之连接代表点的解。证明可以用反证法和调整法证明。
因为颜色数极小，可以考虑枚举 Prufer 序列来确定代表点之间的生成树，然后把每个颜色的点放在一起考虑，边 (i,j)(i,j)(i,j) 可以通过和颜色 j 关键点的连边解决一个颜色 i 中的点，也可以通过和颜色 i 关键点连边解决一个颜色 j 中的点。这玩意是一个二分图完美匹配问题，可以通过网络流或 Hall 定理来判断是否合法并构造最优解。
总结：这个细节不在于观察到等价，而是在于钦定代表点这个环节，对于还原树的问题中，可以分步还原，也就是先还原特殊点的结构，再还原整体的结构。
 CF1984F Reconstruction
这玩意前后缀和，首先我们先思考一个确定的序列什么能够判断合法。首先这个前缀和和后缀和太难受了，我们考虑转换成统一的，不妨令 preprepre 为前缀和 sufsufsuf 为后缀和，那么显然 sufi=pren−prei−1suf_{i}=pre_{n}-pre_{i-1}sufi​=pren​−prei−1​。只要不出现 ∣prei+k−prei∣&gt;k⋅m|pre_{i+k}-pre_{i}|&gt;k\cdot m∣prei+k​−prei​∣&gt;k⋅m 即可，对于这个的贡献是相邻两项所贡献的，可以对相邻两项分类讨论 4 种情况即可。考虑强化限制，只要我们知道 prenpre_{n}pren​ 的情况下我们就可以通过 DP 求出满足限制的方案，时间复杂度 O(n)O(n)O(n)。
考虑我们不知道 prenpre_{n}pren​ 的情况下怎么办，这种情况我们需要知道能够唯一确定 prenpre_{n}pren​ 的信息，注意到令 a0=an+1=0a_{0}=a_{n+1}=0a0​=an+1​=0，S0=PS_{0}=\texttt{P}S0​=P，Sn+1=SS_{n+1}=\texttt{S}Sn+1​=S 之后，任意意一个 PS 子串都可以决定 prenpre_{n}pren​，而显然至少存在一个这样的子串所以可以唯一确定，暴力枚举每个可能的 prenpre_{n}pren​ 计算 SSS 的数量即可，时间复杂度 O(nm)O(nm)O(nm)。
总结：这种部分不确定性的问题，我们需要思考其中确定的信息，通过这些确定的信息去确定其他的不知道的信息。
 AT_arc165_e [ARC165E] Random Isolation
大技巧题，我不会的技巧都叫做好题好吧（逃）
首先一看这玩意 “在剩下的点里随机选一个”，操作概率的分母一个一个都不一样。这种随机操作求期望的问题一般情况会出现在这里，这种情况下我们可以对于一个随机过程，可以考虑将所 有元素钦定优先级来刻画。 钦定优先级会将一个问题限定在离散的范围内，一些不同情况下 不好计算的概率在钦定优先级之后可能会很好计数。
对于这个题，我们转化问题，转化为对于随机长度为 nnn 的排列 ppp，我们按照 p1,p2,p3…,pnp_1,p_{2},p_{3}\dots,p_{n}p1​,p2​,p3​…,pn​ 的顺序依次考虑，若 pip_{i}pi​ 所在连通块大小大于 KKK，那么再当前树上删除 pip_{i}pi​；否则不进行任何操作，求有效操作的期望次数，忽略掉所有无效的操作之后，这个命题和原命题是等价的。
考虑能否对每个点计算共享，考虑删掉点的时候的连通块，显然它的大小需要 &gt;k&gt;k&gt;k。 既然这样，这之前对该连通块内点的操作显然全部需要成功。 因此，我们甚至可以假设所有这之前的操作都成功（因为即使切到别的连通块也不影响这个连通块的大小）。
那么有 DP，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示 iii 子树内，有 yyy 个点被删了，根节点连通块大小是 zzz 的方案数。时间复杂度 O(n4)O(n^4)O(n4)。
这是权值，最后还有概率要乘上，对于原树中一个以 uuu 为根，大小为 iii 的连通块，他能造成贡献，当且仅当与这个连通块相邻的 jjj 个点全部在他之前删除。剩下的点对他没有影响，所以只要考虑这 i+ji+ji+j 个点即可。产生贡献的概率是好算的，随便排是 (i+j)!(i+j)!(i+j)! 种，jjj 个先全删的有 i!j!i!j!i!j! 种，概率为 i!j!(i+j)!\dfrac{i!j!}{(i+j)!}(i+j)!i!j!​​。
总结：
学到了一种随机过程期望的方法，就是将所有元素钦定优先级来刻画。 钦定优先级会将一个问题限定在离散的范围内，一些不同情况下不好计算的概率在钦定优先级之后可能会很好计数。
 【UNR #1】火车管理
最快的一集。
考虑到操作 2 才是最 nb 的。显然不能每一个栈都去维护，5e5 让我们只能考虑一些 polylog 级别的数据结构，考虑线段树维护栈顶，但是问题在于弹栈，我们发现删除操作，可以看成回退到上一时刻，可以用保留所有历史版本的主席树来支持回退。你需要做的就是维护覆盖这个单点的时刻，然后修改单点查上一时刻的值，用这个值修改即可，时间复杂度 O(qlog⁡n)O(q\log n)O(qlogn)。
总结：删除操作，可以看成回退到上一时刻，可以用保留所有历史版本的主席树来支持回退。
 CF1651F Tower Defense
我知道分块的 O(nn)O(n\sqrt{n})O(nn​) 简单维护颜色段做法。但是我是来学主席树的 QwQ
考虑分析性质，发现如果只有一个怪物的情况下那么销毁的必定是一段前缀，但是如果怪物多起来了就会将序列分成一段一段，每一段的数值状况不一致。启示颜色段均摊，但是显然这个不是拿 ODT 维护的。但是我们可以拿个栈存一下每个段的分界点，按照左端点降序排列，询问时类似弹栈即可。
然后我们考虑原命题的限制 min⁡(ci,riT)\min(c_{i},r_{i}T)min(ci​,ri​T)，其中 TTT 为怪物到来的时间差，我们可以把他看作一个分段函数，即：
fi(T)={riTT≤⌊ciri⌋ciT&gt;⌊ciri⌋f_{i}(T)=
\begin{cases}
r_{i}T &amp; T\le \lfloor \dfrac{c_{i}}{r_i} \rfloor \\ \\
c_{i} &amp; T&gt;\lfloor \dfrac{c_{i}}{r_i} \rfloor
\end{cases}
fi​(T)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​ri​Tci​​T≤⌊ri​ci​​⌋T&gt;⌊ri​ci​​⌋​
考虑到一个段 [l,r][l,r][l,r]，我们如何判断当前的怪物能否清楚这个段呢？只需要看当前生命值 hhh 是否满足 h≥∑i=lrfi(T)h\ge \sum\limits_{i=l}^r f_{i}(T)h≥i=l∑r​fi​(T) 即可，当然如果 l=rl=rl=r 直接 O(1)O(1)O(1) 做就可以了，但区间求和考虑使用线段树来维护一次函数，但是分段函数如何维护呢？注意到值域是较小的，我们可以用可持久化线段树来维护这个分段函数，具体的，以自变量 TTT 为版本，线段树维护每一个 fif_{i}fi​，修改只需要在分段的地方单点修改即可，预处理的时间复杂度是 O(nlog⁡n)O(n\log n)O(nlogn)。
现在我们能判断能否一次清楚这个段了，但是如果无法清除那我们怎么维护呢？分析问题实质上就是我们需要求出我们能够清楚这个段最长能延伸到什么位置，可以考虑主席树上二分去求出这个位置 pospospos，那么 [l,pos][l,pos][l,pos] 和 [pos+1,r][pos+1,r][pos+1,r] 就是旧段操作后的新段，直接维护，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：维护分段函数，在值域较小的情况下，我们可以通过可持久化，以以自变量 xxx 为版本，线段树维护每一个 fif_{i}fi​。
 CF679E Bear and Bad Powers of 42
首先不难观察到 42k42^k42k 的值域在题目范围内是很少的，kkk 取值在 k≤11k\le 11k≤11。
其次第一个操作第二个操作是容易的，但是第三个操作是不容易的，因为是连续操作，而且我们要维护的是加法中触碰到特定值的部分。考虑到特定值的数量很少，我们有一个想法就是类似于树套树，外部为正常维护序列的线段树，内部为权值线段树，每一次枚举权值 kkk，查询是否有 k−xk-xk−x 的值存在，若存在则继续累加，直到结束。显然这个做法看起来很可以，但是内存会炸。
考虑这个做法能否优化，首先观察到我们每一次查询都是只需要查每一个权值 k−xk-xk−x 是否存在，但是我们记录所有权值的情况太过于浪费空间。我们思考，对于一个序列数 aia_{i}ai​，加法能影响到的只能是 &gt;ai&gt;a_{i}&gt;ai​ 的 42k42^k42k。有一个想法，我们对每一个 aia_{i}ai​ 维护到下一个 42k42^k42k 的距离 mnmnmn，如果有数的距离 mnmnmn 为 000，那么就再次进行操作 3 直到不为 0。
具体的，我们需要在线段树维护这个区间距离最小值，操作 2 可以暴力区间赋值。但是操作 3 是个问题，因为我们暴力修改每一个显然是不行的，但是注意到若一个区间距离最小值 ≥x\ge x≥x 是可以通过打标记 O(1)O(1)O(1) 做，若不满足就暴力递归下去，借鉴 Segment Beats 的势能法分析是可以的。我们不妨定义势能为：区间所有颜色段上方的 42 次幂个数之和。一次操作 2 会增加 O(log⁡nlog⁡42x)O(\log n \log_{42} x)O(lognlog42​x) 的势能，操作 333 通过 O(1)O(1)O(1) 时间减少 O(1)O(1)O(1) 势能，时间复杂度 O(nlog⁡nlog⁡42V)O(n\log n \log_{42} V)O(nlognlog42​V)。
总结：线段树上尽量不要去维护有关特定值的信息，如果需要维护常常可以通过放宽条件的方法解决。例如本题放宽为了考察区间中所有越过 42 次幂的数。
 【UR #19】前进四
哦我的天啊这是什么？
首先考虑 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)，首先这玩意可以转化为从后往前的极长下降子序列的长度，这玩意是 LCIS - HDU 3308 - Virtual Judge，可以使用我们的线段树理论简单构造出信息！
然而这玩意是区间求的，我们求得是一个后缀，如果用维护区间的去维护后缀就太浪费了。注意到题目可以离线，考虑离线，离线之后我们就可以考虑类似扫描线一样的后缀扫描，依次扫描询问，维护每个位置的数据结构。但是我们发现这玩意和上面做法没有什么差异，考虑变化主体，从后往前依次扫描位置，维护每个询问的数据结构。
我们把所有东西离线下来，那么修改变成了对一段询问区间取 min，询问变成了对于某个询问单点求 min 值的变化次数。用 Segment Beat 维护即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：先弄清维护的信息是什么，然后切换主体，保持维护信息的不变即可。通过离线我们可以方便的切换主体。
 CF1017G The Tree
神秘主体思想。
考虑链怎么做，显然不难发现原命题相当于黑色段和白色段，一个拓张，一个缩小，同时会有区间推平为白色操作。可以考虑分块维护颜色段，时间复杂度是 O(qn)O(q\sqrt{n})O(qn​)。
考虑放到树上怎么做，发现这玩意很抽象，因为如果我们暴力维护段的话直接就 T 了，考虑到如果对段暴力拓展显然是没有前途。有一个性质就是段拓展只会向下拓展，考虑到询问只有单点查询，我们考虑一个点什么会被变黑？上面的结论推论就是一个点若会被影响到当且仅当其祖先中操作次数足够到可以将范围扩大到影响当前点。
进一步转化，我们将每一个点权值初始设置为 −1-1−1，对于操作 1 在该点上进行单点加 111，那么单点查询时，为黑当且仅当当前点到根的链最大后缀（从当前点开始）权值和 ≥0\ge 0≥0，即距离能够够到，否则为白。
转化成 DFN 序上，用树剖加线段树维护，发现这玩意就是一个最大后缀和，可以直接用线段树维护，时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
总结：
本题目的精华就是在于将这个操作等效，等效操作的思想是很重要的，当你切换维护对象之后，可以通过等效操作来适应现在所维护的东西。
 P7735 [NOI2021] 轻重边
考虑分析性质，注意到每一个重边路径段都是互相独立互不干扰的，由于操作首先会将相邻边都变成轻边然后再变成重边。然后我们考虑怎么维护这些重边路径段，而且还要满足独立性，我们发现这玩意可以直接转化为维护边上的颜色段。
显然边上的颜色段不好维护，我们考虑边权转点权，那么我们给颜色段内的点赋一个颜色 ccc，这个 ccc 要满足每个颜色段对应是唯一的，那么是重边当切仅当 cu=cvc_{u}=c_{v}cu​=cv​。
树上路径带修我们考虑树剖，然后转化为为 DFN 上的区间问题，然后线段树维护即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：属于染色模型，一些类区间赋值类操作可以向染色模型转化。
呃呃呃。
 CF1458C Latin Square
啊啊啊。
首先观察到所有操作全是全局标记，维护整体标记，本题的核心是考察整体操作对单点的影响。
发现前四个操作对于单点是独立的，我们可以维护偏移量。但是问题在于后两个操作，后两个操作单看每个元素的位置变化是混乱的。
我们考虑能否独立化这些操作，考虑转化问题，我们转化到三维平面上，有 n2n^2n2 个坐标 (i,j,p)(i,j,p)(i,j,p)，对行取逆就是交换坐标的第二维和第三维；对列取逆就是交换坐标的第一维和第三维。那么我们再维护表示维护交换的整体标记即可，时间复杂度 O(n2+m)O(n^2+m)O(n2+m)。
很好的题啊啊啊啊，如果我们想要维护整体标记，我们要考虑整体操作对于单点的影响，把整体操作对单点的影响独立开来，分开维护，查询单点时，把操作一一作用在该点上，得到真实答案。
 P3352 [ZJOI2016] 线段树
需要把这些序列大小要整合到一起，不然不知道用什么处理？
笛卡尔树？bro 有点难。咱们还是考虑 01 序列怎么做吧。
首先没有概率，就是纯纯的求方案数乘上权值。考虑值域为 {0,1}\{0,1\}{0,1} 的时候怎么做，不难发现对答案造成贡献必定是 000 段和 111 段合并，并且发现 000 段必定会被 111 段给包夹（边界位置设置为 111)。考虑到每次操作 111 段大小单调不降，000 段大小单调不升，我们考虑 DP 主体应该为 000 段，有状态 f(i,l,r)f(i,l,r)f(i,l,r) 表示 iii 操作后 000 段缩小到 [l,r][l,r][l,r] 的方案数，有转移：
dp[i][l][r]←{dp[i−1][l][r]⋅l(l+1)+(n−r+1)(n−r+2)+(r−l)(r−l−1)2QwQdp[i−1][l′][r]⋅l′l′&lt;ldp[i−1][l][r′]⋅(n−r′+1)r′&gt;rdp[i][l][r]\leftarrow\begin{cases}dp[i-1][l][r]\cdot\frac{l(l+1)+(n-r+1)(n-r+2)+(r-l)(r-l-1)}{2} &amp; \text{QwQ}\\dp[i-1][l&#x27;][r]\cdot l&#x27; &amp; l&#x27;&lt;l \\ dp[i-1][l][r&#x27;]\cdot (n-r&#x27;+1) &amp; r&#x27;&gt; r\end{cases}
dp[i][l][r]←⎩⎪⎪⎨⎪⎪⎧​dp[i−1][l][r]⋅2l(l+1)+(n−r+1)(n−r+2)+(r−l)(r−l−1)​dp[i−1][l′][r]⋅l′dp[i−1][l][r′]⋅(n−r′+1)​QwQl′&lt;lr′&gt;r​
不难发现可以用前缀和优化转移，时间复杂度 O(n2q)O(n^2q)O(n2q)，拓展到一般序列上我们把 www 的贡献拆为 max⁡ai−max⁡i=0max⁡ai[w&lt;i]\max a_{i}-\max_{i=0}^{\max a_{i}} [w&lt;i]maxai​−maxi=0maxai​​[w&lt;i]，即把所有 ≥i\ge i≥i 的位置标为 1，把所有 &lt;i&lt;i&lt;i 的位置标为 0。此时我们就可以算出每一个位置 &lt;i&lt;i&lt;i 的方案数，时间复杂度 O(n3q)O(n^3q)O(n3q)，数据随机可过。
显然太吃运气了，考虑优化，发现所有的 dp 值的转移柿子都完全一致，所以我们可以把所有初始值放到同一个 dp 数组里面，然后进行一次整体的 dp，就可以求出答案。
总结：01 序列天地灭！
 P5443 [APIO2019] 桥梁
刚开始做操作分块，不太熟练。
考虑到这玩意显然不太好 polylog 去维护，基本上稍微复杂一点的都没法polylog？
首先可达性转连通性，问题转化为维护连通块内点个数，我们首先有一个显然的想法就是修改就暴力修改，对于每一个询问，在并查集中加入所有 ≥x\ge x≥x 的边，时间复杂度 O(qm⋅α(n))O(qm\cdot \alpha(n))O(qm⋅α(n))。
考虑没有修改操作的时候怎么做，注意到可以离线，考虑离线所有询问，然后按照 xxx 从大到小排序，每次加边用并查集维护连通性和来连通块内点个数，时间复杂度是 O(q+m)O(q+m)O(q+m) 的。
但是现在有修改操作，如果我们还是仿照以前的做法的话我们需要使用可撤销冰茶几，对于每一个 xxx 我们都暴力扫一边询问然后计算贡献，处理完每一个询问的时候，再撤销掉临时加入的边。时间复杂度是 O(q2log⁡m)O(q^2\log m)O(q2logm)，瓶颈再修改。
考虑操作分块，每 BBB 个操作分一块。注意到每一块内修改边权个数不超过  个，询问次数同理，因此考虑对于不在该块内修改的边，直接固定边权。和上面的做法一样，还是考虑离线询问按 xxx 从大到小，但是我们只用离线当前块内的询问，对于每一个询问，看看在该块内修改的边，在这个询问时权值分别是多少，然后加入 ≥x\ge x≥x 的边，询问连通块个数，然后撤销临时加入的边。
最后将新操作修改的边更新到原来的边上，相当于操作分块继承以前的贡献。时间复杂度令 B=qB=\sqrt{q}B=q​ 可以取到 O(mlog⁡mq)O(m\log m\sqrt{q})O(mlogmq​)。
 CF1588F Jumping Through the Array
啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊？？？？？？？？？？？根号？？？？？？？？？？？？？？？？？？？？？？？？？？
操作没有任何营养。考虑最没有营养的操作 3 去掉怎么做。发现如果是单点修改那就很好说，但是问题是区间修改啊啊啊，没法 Log 维护啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊。
考虑发掘性质，但是没有性质啊啊啊啊啊啊啊啊啊啊啊啊。
啊啊啊啊啊？根号！考虑到所有操作全是 O(n)O(n)O(n) 级别，我们考虑操作分块，每 BBB 个操作分成一块，我们发现对于每一个需要修改的位置，从它到它后边第一个需要修改位置之前的所有位置的 ppp 都不会发生变化，所以我们可以将这些位置缩成一个，这样环长就是 O(B)O(B)O(B) 级别了每次可以暴力遍历。而每次预处理要花 O(qB⋅n)O(\frac{q}{B}\cdot n)O(Bq​⋅n) 来缩点，其次对于 1 操作我们可以查询修改的位置所造成的贡献，就是对于这些点上打标记，存下来应哪些点，然后每次二分出这个缩后的点里面有多少个点在询问的区间里，时间复杂度是 O(Blog⁡n)O(B\log n)O(Blogn) 的，然后做完了？
总结：这 tm 什么玩意啊，操作分块这么神奇的吗？以后遇见这种图上神秘操作且 10 分钟内发觉不了性质直接开始想暴力，今天 byd 一个性质都没有，搞不搞笑。
 CF840E In a Trap
首先注意到这个玩意如果直接对整体维护显然是没有什么很好的性质的，但是有一个极其关键的性质就是 ai≤na_{i} \le nai​≤n，由于位运算在二进制位下是独立的，我们不妨考虑按位分治，就是值域分治，分成前八位和后八位，那么值域最多只需要处理 256256256 即可。
然后我们考虑将询问点分块，说人话就是将树上以链分成 256256256 长度的块，前 8 位我们可以用 Trie 来预处理然后询问时查询即可，后 8 位我们需要处理，设 f(u,i)f(u,i)f(u,i) 表示 uuu 向上的 256 个节点中最大的 av⊕(depu−depv)⊕(i⋅256)a_{v}\oplus (dep_{u}-dep_{v})\oplus (i\cdot 256)av​⊕(depu​−depv​)⊕(i⋅256)，查询可以先跳整块再跳散块。但是显然不能这么直接合并获得因为前 8 位也是一个限制，考虑设 g(u,i)g(u,i)g(u,i) 表示前 8 位为 iii 最大的 ((depu−depv)⊕av)⊕256((dep_u-dep_v)\oplus a_v)\oplus 256((depu​−depv​)⊕av​)⊕256，这样就可以合并了，时间复杂度时 O(nlog⁡nn)O(n\log n \sqrt{n})O(nlognn​)。
总结：看到 ai≤na_{i}\le nai​≤n 之类的限制多半要用到值域分块，对于加法和异或的混合问题可以考虑对半拆位。位运算和四则运算混合在一起是很恶心的，方法基本上只有按位考虑。
 [AGC002D] Stamp Rally
翻译全部错误 666.
最大编号尽可能小，考虑二分。问题转化为求经过边编号 ≤mid\le mid≤mid 的 x→yx\to yx→y 路径上点数量，将边权设置为边的编号，那么命题关系求两点路径最大权值最小值，容易想到 Kruskal 重构树，且这题限制了经过点的个数要恰好为 zzz，不能大也不能小，所以二分是一个比较好的解决方案。时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
总结：大/最小边权问题考虑 kruskal 重构树。
 P3684 [CERC2016] 机棚障碍 Hangar Hurdles
先考虑我们初始点最大能放多少，由于是一个正方形，我们考虑前缀和预处理这个网格图，然后二分求出最大长度。这样我们就能得出每一个点所能容纳的最大正方形长度 ddd。利用这个 ddd 我们对于正方形每一个点向四周连边，边权设置为 min⁡(du,dv)\min(d_{u},d_{v})min(du​,dv​)，那么命题转化为求起点到终点的路径上边的权值最小值的最大值，用 Kruskal 重构树即可解决，但是为题在于连边过多，我们考虑对于 ddd 相同的点缩点即可，时间复杂度 O(n2log⁡n)O(n^2 \log n)O(n2logn)。在实现细节方面，我们注意到，由于障碍的存在，所以可能最后得到的是森林而不是一棵树。考虑到树与树之间是不连通的，所以我们完全可以新建一个节点连向这些树，并把点权设为 0，就可以直接按照普通一棵树的情况来做了。
码力题不写。
 AT_arc098_d [ARC098F] Donation
牛牛牛
首先不难发现一个性质就是如果我们在某个地方给塞钱了之后我们肯定之后就不回来这里。同时发现答案必定 ≥∑Bi\ge \sum\limits B_{i}≥∑Bi​，考虑到给钱很难想，正难则反考虑倒着走领钱，设 ci=max⁡(ai−bi,0)c_{i}=\max(a_{i}-b_{i},0)ci​=max(ai​−bi​,0)，不难发现题目的条件就是要求满足到达点 iii 的时候满足 val≥cival\ge c_{i}val≥ci​，如果不满足就补充即可。如果是第一次经过令 val←val+bival\leftarrow val+b_{i}val←val+bi​。
这玩意怎么做？考虑最小生成树，令边权为 max⁡(cu,cv)\max(c_{u},c_{v})max(cu​,cv​)，表示经过这条边当前钱数的最小值。但是我们发现这玩意很难搞，因为边权是乱序的，如果暴力枚举起点走的话是 O(n2)O(n^2)O(n2) 的，但是我们发现我们肯定是贪心的走边权最小的。考虑这玩意我们可以在建树的时候求得，考虑 Kruskal 重构树表述建树这一过程。然后再树上 DP，设 f(u)f(u)f(u) 表示 uuu 子树内都经过后最小领到的前，叶子节点即为 ci+bic_{i}+b_{i}ci​+bi​，对于非叶子节点枚举从哪里最后进入出来即可，有 f(u)=min⁡v{su−sv+max⁡(cu,fv)}f(u)=\min\limits_{v}\{ s_{u}-s_{v}+\max(c_{u},f_{v})\}f(u)=vmin​{su​−sv​+max(cu​,fv​)}。其中 sus_{u}su​ 表示 uuu 为根的子树内节点的 ∑b\sum\limits b∑b，由于重构树显然是二叉树可以直接展开 min⁡\minmin，但是如果你写多叉树那我没啥好说的，时间复杂度 O(mlog⁡m+nlog⁡∣V∣)O(m\log m+n\log |V|)O(mlogm+nlog∣V∣)。
总结：本题通过发掘性质将这个不塞钱操作简化问题，同时正难则反是重要的思维技巧。
借助 Kruskal 重构树，通过合理的赋值边权我们可以满足题目中的限制，难点就是在于我们如何发掘边权所表示的意义。
 CF1628E Groceries in Meteor Town
首先看到简单路径上求经过边权最大值不难想到利用 Kruskal 重构树，查询操作就转化成了重构树上， xxx 点与所有关键点的 lca 的权值。
那么现在为题转化为如何求一个点集合的 LCA，如果你做过树上查询你可能会以为是区间 LCA 直接一个一个维护，但是显然不是这样的，这是点集不是区间。答案是点集中 dfn 最大点和 dfn 最小点的 lca，所以直接维护区间最大最小 DFN 即可。
总结：学会了新的 LCA 方式！求一个点集合的 LCA 答案是点集中 dfn 最大点和 dfn 最小点的 lca。边权最大最小问题考虑 Kruskal重构树。
 P3679 [CERC2016] 二分毯 Bipartite Blanket - 洛谷
呃呃
注意到 n,m≤20n,m\le 20n,m≤20，考虑状压选取的点集合，但是我们只能状压一个不能状压另一个，如果直接做将会达到 O(nm22n)O(nm 2^{2n})O(nm22n) 无法通过，复杂度启示 O(n22n)O(n^22^n)O(n22n) 也就是说我们只能状压一个点集，考虑到我们还没有分析性质，分析性质。
现在的问题就是我们只能状压二分图中一部的点集，考虑到上面算法的瓶颈在于我们必须知道我们和哪些点匹配了。联想到 Hall 定理可以帮助我们在只有点集合大小的情况下完成匹配，题目要求就是两个选取出来的点集 A′A&#x27;A′ 和 B′B&#x27;B′ 有完美匹配，但是点集合大小我们只能知道一个集合的大小，如何推出是否有完美匹配呢？
考虑拆分法，由于二分图两部点之间是独立的，我们只需要算一部的选取点集合所有点匹配（如果存在无法匹配我们可以去掉，这个状态在之后一定会枚举到），这种情况下是否能够凑出 B′B&#x27;B′ 即可，那么根据 Hall 定理不难发现一个结论：由于点集要求全部都选，而且只要求一个匹配覆盖即可而不是点集之间两两覆盖，那么也就是说点集合只要能够完美匹配即可。而对于左部点集 A′A&#x27;A′ 和右部点集 B′B&#x27;B′，只要两者 A′A&#x27;A′ 和 B′B&#x27;B′ 都对其能够到达的点完美匹配即可满足两者必定存在一个匹配覆盖。
考虑证明必要性：显然若有覆盖 A∪BA\cup BA∪B 的匹配，显然能分别覆盖 AAA 和 BBB。充分性：AAA 与覆盖 BBB 的匹配，则对任意 S⊆A∪BS\subseteq A\cup BS⊆A∪B 都满足 Hall 条件（因为 SSS 来自两侧，邻居落在不同的两侧，不会重叠），从而存在匹配覆盖 A∪BA\cup BA∪B。
那么只需要状压点集合即可，分别状压，将合法方案存储下来，最后统计答案的时候用二分求出有多少个合法点即可，时间复杂度 O(n22n+m22m)O(n^2 2^n+m^2 2^m)O(n22n+m22m)。
总结：二分图的独立性（只需要考虑某一部的具体情况）
 [AGC032E] Modulo Pairing
将 (x+y)(x+y)(x+y) 分为 (x+y)&lt;M(x+y)&lt; M(x+y)&lt;M 和 (x+y)≥M(x+y) \ge M(x+y)≥M。如果我们只有单独一类的话我们显然可以通过将 aaa 排序后贪心即可，然而问题在于这是一个混合在一起的。
我们考虑能否融合这些贪心方法，那么必然存在一个分界点 ppp，使得 ppp 左边第一种贪心，ppp 右边用第二种贪心。下图的蓝线表示一类匹配，红线表示二类匹配：

证明可以考虑调整法：

左边一列的调整是平凡的，右边一类的调整可以考虑：蓝色匹配的代价必然 ≥ 右端点，红色匹配的代价必然 &lt; 左端点，那么不难发现调整之后最大代价都是变小了的。
但是分界点怎么求呢，根据调整的过程，我们可以考虑二分求出分界点 ppp，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：
混合多种方法的思路十分重要，例如根号分治。对于贪心问题，混合贪心可以让局部最优，我们再考虑怎么从局部最优拓展到整体最优即可；
 CF1131G Most Dangerous Shark
想起来一些不好的回忆，想起来 ARC 的某个题了呜呜呜呜呜。
首先，不难发现倒下骨牌的过程中，其骨牌高度 hhh 单调不降。也就是说我们可以通过单调栈来预处理每个骨牌所能向左向右倒影响的最远位置 LiL_{i}Li​ 和 RiR_{i}Ri​，具体如何计算见代码。
这样你就得到了一些区间，现在问题转化为要求选取一些区间使得能够覆盖所有点（覆盖的点不能再选）。考虑 DP，根据 CF1476F 灯塔题不难想到设 f(i)f(i)f(i) 表示前 iii 骨牌被推倒的最小代价，转移：
fi←{fj+ciLi−1≤j&lt;ii 骨牌向左倒fj−1+cjj&lt;i≤rjj 骨牌向右倒f_{i}\leftarrow 
\begin{cases}
f_{j}+c_{i} &amp; L_{i}-1\le j &lt; i &amp; i \text{ 骨牌向左倒} \\ \\
f_{j-1}+c_{j} &amp; j&lt;i\le r_{j} &amp; j \text{ 骨牌向右倒}
\end{cases}
fi​←⎩⎪⎪⎨⎪⎪⎧​fj​+ci​fj−1​+cj​​Li​−1≤j&lt;ij&lt;i≤rj​​i 骨牌向左倒j 骨牌向右倒​
第一种根据贪心显然只需要考虑 j=Li−1j=L_{i}-1j=Li​−1 的转移就可以了，第二个可以通过线段树优化，时间复杂度 O(mlog⁡m)O(m\log m)O(mlogm) 无法通过，考虑优化，但是发现这玩意不太好搞因为是一个区间查询。
考虑进一步对区间发掘性质，我们根据上面骨牌高度 hhh 单调不降，那么同时也能不难发现区间范围也是单调不降的，进一步推论：每个骨牌的覆盖范围要么包含，要么相离。考虑单调栈优化 DP，每次新加入的点就放在栈顶，每次只需要考虑栈顶得覆盖范围够不够，不够直接弹出，然后维护一个栈的前缀最小值就可以转移了。时间复杂度 O(n)O(n)O(n)。
总结：对于数列覆盖问题，常有的结论是两个点的覆盖范围要么包含、要么相离，这时候可以选择用单调数据结构维护（因为覆盖范围单调），而不是带 log 的数据结构。
 P2305 [NOI2014] 购票
首先有一个及其显然的 DP，设 f(i)f(i)f(i) 表示 iii 点向上跳祖先的最小花费，有转移：
f(u)=min⁡v∈fauf(v)+(depu−depv)⋅pu+qudepu−depv≤lu\begin{aligned} f(u) &amp; =\min_{v\in fa_{u}} f(v)+(dep_{u}-dep_{v})\cdot p_{u}+q_{u} &amp; dep_{u}-dep_{v}\le l_{u} \end{aligned}  
f(u)​=v∈fau​min​f(v)+(depu​−depv​)⋅pu​+qu​​depu​−depv​≤lu​​
直接做，时间复杂度 O(n2)O(n^2)O(n2)。考虑转化 DP 形式，不难有：
f(u)=(depu⋅pu+qu)×min⁡v∈fau{−depv⋅pu+fv}depu−depv≤lu\begin{aligned} f(u) &amp; = (dep_{u}\cdot p_{u}+q_{u})\times\min_{v\in fa_{u}} \{-dep_{v}\cdot p_{u}+f_{v}\} &amp; dep_{u}-dep_{v}\le l_{u} \end{aligned}  
f(u)​=(depu​⋅pu​+qu​)×v∈fau​min​{−depv​⋅pu​+fv​}​depu​−depv​≤lu​​
不难发现后面是一次函数，在没有转移限制情况下用李超线段树维护即可，但是问题在于有了限制怎么办。发现考虑上距离的限制其实就是多加了一维偏序关系，所以我们可以用树套树。一种空间消耗较小的树套树方法是，我们预处理出每个点的欧拉出序，外层线段树以欧拉出序来建立。询问时先二分出可以到达的最浅祖先，然后可以得到一个欧拉出序的区间，这个区间只包含这个点到祖先的路径，因为还没访问到的点没被加入到李超树中，那么插入的时候不用回撤，直接插入即可。时间复杂度 O(nlog⁡2n)O(n\log^2  n)O(nlog2n)。
总结：发现题目有不可解决的维度时，要敢于使用数据结构。但是此时空间消耗特别重要，注意处理 dp 的顺序，才能时数据结构的使用简单化，并且减少常数的消耗。
这里出栈序的应用也十分经典，引用了欧拉出序的区间，区间只包含这个点到祖先的路径这个优美的性质来防止李超树的回退，将一段具有祖孙关系的点对之间的路径直接映射到了序列上的一段区间从而将树上问题转化成了序列上的问题。
 CF303E Random Ranking

除了序列大小转 01 之外序列我是真不知道还能这么玩！
对区间离散化，然后呢？
首先考虑一个简单的问题，如果所有人选取的值域区间一致，那么一个人获得 1∼n1\sim n1∼n 的排名概率都是 1n\dfrac{1}{n}n1​。
那么我们考虑对于离散化后端点所构成的每一个小段 [pi,pi+1)[p_{i},p_{i+1})[pi​,pi+1​)，我们把一些人分配到小段的左边，把一些人分配到小段的右边，并钦定某个值在里面。然后来统计答案：
设 f(i,j)f(i,j)f(i,j) 表示 iii 个数所在区间比它小，jjj 个数所在区间比它大，剩下的人都在小段中的概率。一个人的概率可以通过讨论线段关系简单计算，那么这就变成一个背包问题了。时间复杂度是 O(n5)O(n^5)O(n5) 的。统计答案时枚举 (i,j)(i,j)(i,j)，对于这 (i,j)(i,j)(i,j)，可能的排名为 [i+1,i+j+1][i+1,i+j+1][i+1,i+j+1]，这些排名一定是等概率的，因为区间 [pi,pi+1)[p_{i},p_{i+1})[pi​,pi+1​) 内的这些值是全是随机的，iii 在每个排名的概率是相同的，精髓就是我们通过合理的状态设计将复杂问题划归为简单的问题。直接做是 O(n5)O(n^5)O(n5)。可以用 CDQ 分治优化，时间复杂度 O(n4log⁡n)O(n^4\log n)O(n4logn)。
总结：
很多实数概率题的技巧通常是，先解决一个能用概率简单计算的子问题，然后把原问题化归到这个简单问题上，想本题所使用的划归思想。
种不太好记录之前的值的信息，不好考虑完整的大小关系的随机问题一种套路做法是考虑枚举一个值，作为最终取的值或是前几大的分界线考虑，再来统计其他值和这个值的相对大小关系。
 AT_abc219_h
没法记录时间，这不是矩阵快速幂，不知道蜡烛具体长度，是我们知道每一秒蜡烛会减少 1 的长度，所以应用费用提前计算的思想，我们可以计算有多少个以后吹熄的蜡烛受到了这次减少的影响。
发现走的过程必定是一个区间，要么拓展当前位置一步，要么走到另一头。考虑区间 DP，设 f(l,r,0/1)f(l,r,0/1)f(l,r,0/1) 表示 [l,r][l,r][l,r] 区间，在 lll 还是 rrr 的方案，转移考虑向左向右或者从一端走到一端决策即可。但是我们没有办法算代价，因为蜡烛可能燃烧完毕，我们发现，相当于选择一些蜡烛不去选择，最优情况下一定是都选择会产生正贡献的蜡烛，错解不优。
所以加一维度 kkk 表示还有 kkk 个需要选择，答案就是 f(1,n,0,0/1)f(1,n,0,0/1)f(1,n,0,0/1)，时间复杂度 O(n3)O(n^3)O(n3)。
总结：如果当前状态不好知道，但你清楚代价的变化规则时，可以费用提前计算。
 P6847 [CEOI 2019] Magic Tree
今天没有什么太好的性质，考虑 DP，设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内断边在 ≤j\le j≤j 的时间断开，转移：

不获取 u 点的果汁：f(u,i)=∑vf(v,i)f(u,i)=\sum\limits_{v}f(v,i)f(u,i)=v∑​f(v,i)
断开父边，获取 u 点的果汁：f(u,x)=wu+∑vf(v,du)f(u,x)=w_{u}+\sum\limits_{v}f(v,d_{u})f(u,x)=wu​+v∑​f(v,du​)，其中 x≥dux\ge d_{u}x≥du​。
线段树合并来优化，第一种转移就直接线段树合并，第二种转移不能维护区间最值标记。而且合并不太好维护，考虑分析性质，发现 f(u,∗)f(u,*)f(u,∗) 随 iii 增加而单调，那么第二种转移可以考虑成区间赋值。实现中区间赋值不打标记，而是线段树上的点维护 min,max，如果 min=max 的时候就说明这个区间是一个值，线段树合并的时候如果遇到区间同值的情况就打加法标记，修改的时候如果区间同值就新开儿子节点，上传的时候如果发现区间同值可以把儿子节点删掉，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。

更 nb 的，因为 dp 值单调所以可以考虑差分，那么第一种转移就能直接启发式合并，第二种转移是增加 wuw_{u}wu​ 的差分值，直接插入 set 中，这其实是取 max 操作，所以要从后面删除一些差分标记，时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
 [ARC120F] Wine Thief
可怜的 PPM 从暑假到做这个题之前都不知道学长口中所说的环上每个位置是等价的到底指的是是什么？做完这个题后 PPM 直接星宇大发！
上来直接拆贡献，然后问题在于你不会算合法的方案数，对于每个位置的方案数几乎是本质不同的。如果直接去算的话你还需要枚举选择大小时间复杂度是 O(nk)O(nk)O(nk) 的没法搞（其实可以）。
先考虑简单一点的，如果没有 kkk 的限制，就是单纯的让你链上选择独立集，根据插板法不难得出答案即为 f(n,k)=(n−k+1k)f(n,k)=\dbinom{n-k+1}{k}f(n,k)=(kn−k+1​)。现在我们考虑如何处理每个位置的方案数，由于我们不可能枚举选了多少个不然复杂度还是 O(nk)O(nk)O(nk) 的，考虑到如果我们不去枚举那么这个序列要求我们枚举的位置必须等价，考虑链上的位置是不等价，但是环上的位置是等价的。所以考虑转为环，此时方案数为 f(n−3,k−1)f(n-3,k-1)f(n−3,k−1)，如果位置在 111 和 nnn 的时候就是 F(n−2,k−1)F(n-2,k-1)F(n−2,k−1)。是此时 (1,n)(1,n)(1,n) 都选的方案是没有算上的。不过我们发现当钦定 1,n 都选时我们进入了一个子问题，子问题仍然可以放在一起处理，也就是说方案数是以一种 ∑i=0f(n−3−4i,k−2i−1)\sum\limits_{i=0} f(n-3-4i,k-2i-1)i=0∑​f(n−3−4i,k−2i−1) 的形式出现，前缀和维护即可，时间复杂度 O(n)O(n)O(n)。
 CF1528F AmShZ Farm
哦我的天啊这简直简直了。
两个限制，我们先单独讨论一个限制如何满足，比如说 aaa 的限制。我们发现限制可以如下转化：有 nnn 个凳子，nnn 个人手里拿着一个位置编号排队就座。第 iii 个人如果当前位置没有人坐就坐，如果有人就往后找到第一个没有人的凳子坐下来，合法当且仅当每个人都能找到座位。这个性质也很好，但是问题如何快速判断每个人能否找到座位？我们可以在最后一个位置加一个哨兵座位 n+1n+1n+1，如果排完座位后 n+1n+1n+1 没人的话那么就是合法的。
但是 bbb 相等限制怎么处理，上面这个操作很不方便我们进行计数，原因就是在于我们选位置每个节点都只能向右选，位置是不等价的，不方便我们进行计数。我们发现如果我们将首尾相接，形成一个环，环上位置就是等价的就方便我们计数。
考虑进一步发掘点有用的，我们发现 bbb 的组合意义其实就是就是一个 aia_{i}ai​ 的贡献是其中每种数数量的 kkk 次方的和。同时发现这个环如果我们钦定一个点为 n+1n+1n+1，断环为链，而 [1,n][1,n][1,n] 中合法元素因为只要出现次数满足可以分配，即设 cnticnt_{i}cnti​ 表示 iii 数出现次数，满足 ∑j=incntj≤n−i+1\sum\limits_{j=i}^n cnt_{j}\le n-i+1j=i∑n​cntj​≤n−i+1 的话就可以了。所以 [1,n][1,n][1,n] 都是循环同构的，而这些组中 aaa 的贡献都是一致的。我们可以对所有的 aaa 进行计算后除掉 n+1n+1n+1 即为答案。
现在考虑每个元素的贡献，答案需要乘上 (n+1)(n+1)(n+1) 发现消掉了，太好了，那么直接通过 bbb 来卡 aaa 的限制，枚举该元素出现次数，那么答案为：
∑i=0n(ni)iknn−i\sum\limits_{i=0}^n \binom{n}{i}i^k n^{n-i}
i=0∑n​(in​)iknn−i
由于 kkk 较小，考虑斯特林反演有：
∑i=0n(ni)⋅nn−i∑j=0kS(k,j)⋅(ij)⋅j!\sum_{i=0}^n{n\choose i}\cdot n^{n-i}\sum_{j=0}^kS(k,j)\cdot {i\choose j}\cdot j!
i=0∑n​(in​)⋅nn−ij=0∑k​S(k,j)⋅(ji​)⋅j!
注意到：(ni)(ij)=(nj)(n−ji−j)\dbinom{n}{i}\dbinom{i}{j}=\dbinom{n}{j}\dbinom{n-j}{i-j}(in​)(ji​)=(jn​)(i−jn−j​)，有：
∑j=0kS(k,j)⋅(nj)⋅j!⋅(∑i=jn(n−ji−j)⋅nn−i)\sum_{j=0}^kS(k,j)\cdot \binom{n}{j} \cdot j!\cdot (\sum_{i=j}^n{n-j\choose i-j}\cdot n^{n-i})
j=0∑k​S(k,j)⋅(jn​)⋅j!⋅(i=j∑n​(i−jn−j​)⋅nn−i)
可以二项式反演，答案即为：
∑j=0kS(k,j)⋅(nj)⋅j!⋅(n+1)n−j\sum_{j=0}^kS(k,j)\cdot \binom{n}{j}\cdot j!\cdot(n+1)^{n-j}
j=0∑k​S(k,j)⋅(jn​)⋅j!⋅(n+1)n−j
用第二类斯特林数·行的技巧算一下就可以啦，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
总结：等概率环是一个很重要的玩意，链上的位置是不等价的，但是环上是等价的，所以我们可以考虑。
 CF512D Fox And Travelling
首先可以将标记看作删除，其次根据题目限制不难发现合法的删除操作必定每次删除的点度数都 ≤1\le 1≤1。然后我们发现满足这个性质的只有树，环是没有用的，说严谨点将原图去掉环后合法的都是森林。
那先考虑树怎么做，显然飞上去一个树形 DP 设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内选了 jjj 个点的方案数，转移枚举合并上来，还要乘上一个 (j+kj)\dbinom{j+k}{j}(jj+k​) 的组合数，时间复杂度 O(n2)O(n^2)O(n2)。
注意到我在玩文字游戏，上面只是说树了没说是有根树还是无根树，显然无根树有一堆重复方案，我们考虑这些重复方案有什么性质，发现无根树定根时做 DP 每种选择 iii 个点的方案会被多算 siz−isiz-isiz−i 次，其中 sizsizsiz 为这棵无根树的大小，那么除掉即可，时间复杂度 O(n3)O(n^3)O(n3)。
 CF914F Substrings in a String
bitset 好神秘！
对 26 个字母各开一个 bitset，存这个字母出现的位置。
对于询问，新建一个 bitset。从前到后枚举询问串的每个位置 yi​，和这个字母对应的 bitset 右移 i 位取 and。
最终得到的 bitset 中 1 的个数即为询问串在原串出现次数。
 P5355 [Ynoi Easy Round 2017] 由乃的玉米田
bitset 神秘密！
首先飞一个莫队上去，考虑加法操作如何解决，显然只要存在 x+y=kx+y=kx+y=k 即可满足，而题目只要求可行性而非要求个数，故考虑 bitset 维护值域数是否出现，那么加法操作就是 (s1&amp;(s1&lt;&lt;qry[i].x)).any()，其中 s1s1s1 表示值域维护。
然后考虑减法，显然减法可以维护一个 105−x10^5 -x105−x 的 bitset，设为 s2s2s2，那么判断方法就是：(s1&amp;(s2&gt;&gt;(1e5-qry[i].x))).any()。然后考虑乘法，枚举约数 O(nn)O(n\sqrt{n})O(nn​) 做。问题在于除法很难维护，考虑根号分治，&gt;n&gt;\sqrt{n}&gt;n​ 的暴力找。但是问题在于 ≤n\le \sqrt{n}≤n​ 怎么做？
先将询问按左端点降序排列。然后取一个指针，一开始指向 nnn。若当前询问的左端点为 lll，则将 [l,j][l,j][l,j] 上所有元素的贡献插入树状数组中，并使 j=l−1j=l-1j=l−1，完成后直接在树状数组上获取当前询问的答案，时间复杂度 O(nmax⁡iailog⁡n)O(n \sqrt{\max_i a_i}\log n )O(nmaxi​ai​​logn)，直接做即可。
 P4465 [国家集训队] JZPSTR
bitset，bitset，bitset！
虽然标程是分块加 SAM， 但是显然大家都不喜欢这么毒瘤的。注意到插入删除询问次数独立的都很少，并且字符集很少，考虑 bitset。我们维护每个字符在哪些位置上出现过，记 iii 字符出现在 bib_{i}bi​ 集合的位置，现有匹配串 ststst，维护当前仍然合法的起始点集合 pospospos，则有 pos=pos∧(bsti&gt;&gt;i)pos=pos \land (b_{st_i}&gt;&gt;i)pos=pos∧(bsti​​&gt;&gt;i)。
讲完了就好说了，强两个操作显然可以用位运算暴力，第二个就用我们上面的操作，时间复杂度是 O(nTw+nlw)O(\dfrac{nT}{w}+\dfrac{nl}{w})O(wnT​+wnl​) 其中 l=max⁡ilen⁡(zi)l=\max\limits_{i} \operatorname{len}(z_{i})l=imax​len(zi​)。
轻松最优解第二位，不知道第一位如何做到？
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>优化建图技巧</title>
    <url>/posts/5c86f54/</url>
    <content><![CDATA[ 0. 前言
会添加的吧，会添加的吧？一定会添加的吧！
 1. 线段树优化建图
CF786B Legacy
区间向区间连边，我们可以利用线段树的优秀区间特性来进行连边。具体来说，我们建立两颗线段树，一颗专门管入边，一颗管出边入边的树父节点向子节点连边（如果子节点向父节点连边，会导致本来只连向该区间的边通过子节点向父节点连的边连向了更大的区间），同理出边的子节点向父节点连边。父子节点之间的边，边权为 0。

总边复杂度大约在 O(mlog⁡n)O(m \log n)O(mlogn) 级别。
例如上图，本题代码如下：
#include&lt;bits/stdc++.h&gt;#define int long long#define ls (p&lt;&lt;1)#define rs (p&lt;&lt;1|1)#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=4e6+15,K=6e5;struct Edge&#123;    int v,w;&#125;;int n,q,s,dis[MN],pos[MN];vector&lt;Edge&gt; adj[MN];bool vis[MN];inline void add(int u,int v,int w)&#123;    adj[u].push_back(&#123;v,w&#125;);&#125;void build(int p,int l,int r)&#123;    if(l==r)&#123;        pos[l]=p;        return;    &#125;    add(p,ls,0);    add(p,rs,0);    add(ls+K,p+K,0);    add(rs+K,p+K,0);    int mid=(l+r)&gt;&gt;1;    build(ls,l,mid);    build(rs,mid+1,r);&#125;void updatetoqj(int p,int l,int r,int fl,int fr,int u,int w)&#123;    if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;        add(u+K,p,w);        return;    &#125;    int mid=(l+r)&gt;&gt;1;    if(mid&gt;=fl) updatetoqj(ls,l,mid,fl,fr,u,w);    if(mid&lt;fr) updatetoqj(rs,mid+1,r,fl,fr,u,w);&#125;void updatefromqj(int p,int l,int r,int fl,int fr,int u,int w)&#123;    if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;        add(p+K,u,w);        return;    &#125;    int mid=(l+r)&gt;&gt;1;    if(mid&gt;=fl) updatefromqj(ls,l,mid,fl,fr,u,w);    if(mid&lt;fr) updatefromqj(rs,mid+1,r,fl,fr,u,w);&#125;void dijk(int begin)&#123;    memset(dis,0x3f,sizeof(dis));    priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt;q;    q.push(pir(0,begin));    dis[begin]=0;    while(!q.empty())&#123;        int u=q.top().second;        q.pop();        if(vis[u]) continue;        vis[u]=1;        for(auto e:adj[u])&#123;            int v=e.v,w=e.w;            if(dis[v]&gt;w+dis[u])&#123;                dis[v]=w+dis[u];                if(!vis[v]) q.push(pir(dis[v],v));            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;    build(1,1,n);    for(int i=1;i&lt;=n;i++)&#123;        add(pos[i],pos[i]+K,0);        add(pos[i]+K,pos[i],0);    &#125;    while(q--)&#123;        int op,u,fl,fr,w,v;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;            add(pos[u]+K,pos[v],w);        &#125;else if(op==2)&#123;            cin&gt;&gt;u&gt;&gt;fl&gt;&gt;fr&gt;&gt;w;            updatetoqj(1,1,n,fl,fr,pos[u],w);        &#125;else if(op==3)&#123;            cin&gt;&gt;u&gt;&gt;fl&gt;&gt;fr&gt;&gt;w;            updatefromqj(1,1,n,fl,fr,pos[u],w);        &#125;    &#125;    dijk(pos[s]+K);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;(dis[pos[i]]&lt;0x3f3f3f3f3f3f3f3f?dis[pos[i]]:-1)&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;
 2. 前后缀优化建图
可以用于连边区间序列的前后缀或树上根链的情况。
这一部分优化的是一个点向一整个前缀或后缀连边，暴力连边数可达到惊人的 O(n2)O(n^2)O(n2)，无法承受。

我们通过对于每一个节点 iii 建立两个复制节点：prei,sufipre_{i},suf_{i}prei​,sufi​。连边为 i→prei,prei−1→preii \to pre_{i},pre_{i-1} \to pre_{i}i→prei​,prei−1​→prei​。同理于 sufsufsuf。

对于树上根链，直接建内向树，连根链末尾即可。
Luogu-P6378 PA 2010 Riddle
2-sat 加优化建图：
// 注释：DeepseekR1 and V3,WJY// 可以线段树优化，但是问题是你要开好多个线段树来存储[1,x-1],[x,n]的节点信息，空间很炸裂，但也能做#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=8e6+15;int n,m,k,dfn[MN],low[MN],vdcc[MN],tot,dcc; // dfn: DFS序, low: Tarjan算法中的low值, // vdcc: 强连通分量编号, tot: dfn时间戳, dcc: 强连通分量计数器vector&lt;int&gt; adj[MN],gp[MN]; //gp: 存储每个部分(题意中的部分)的点bool vis[MN];int s[MN],top;void tarjan(int u)&#123;    // tarjan求强联通    low[u]=dfn[u]=++tot;    s[++top]=u;    vis[u]=1;    for(auto v:adj[u])&#123;        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;else if(vis[v])&#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(low[u]==dfn[u])&#123;        dcc++;        int p;        do        &#123;            p=s[top--];            vdcc[p]=dcc;            vis[p]=0;        &#125; while (p!=u);    &#125;&#125;// 以下注释中// ¬u表示u的否定，即u+n// u的前缀辅助点，即u+2n// u的后缀辅助点，即u+3nint main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        int fu=u+n,fv=v+n;        adj[fu].push_back(v); // 添加边¬u → v        adj[fv].push_back(u); // 添加边¬v → u    &#125;    for(int i=1;i&lt;=k;i++)&#123;        int num;        cin&gt;&gt;num;        for(int j=1;j&lt;=num;j++)&#123;            int p;            cin&gt;&gt;p;            gp[i].push_back(p);            adj[p].push_back(p+2*n); // 添加边 p → p+2n（前缀变量）            adj[p+3*n].push_back(p+n); // 添加边 p+3n → ¬p（后缀变量）        &#125;        for(int j=1;j&lt;gp[i].size();j++)&#123;            int d1=gp[i][j-1],d2=gp[i][j]; // 前一个点和当前点            adj[d1+2*n].push_back(d2+2*n); // 添加边 d1+2n → d2+2n（前缀传递）            adj[d2+3*n].push_back(d1+3*n); // 添加边 d2+3n → d1+3n（后缀传递，可以看图理解）            adj[d1+2*n].push_back(d2+n); // 添加边 d1+2n → ¬d2（前缀已选，d2不可选）            adj[d2].push_back(d1+3*n); // 添加边 d2 → d1+3n（选d2，后缀必须选到d1）        &#125;    &#125;    for(int i=1;i&lt;=n*4;i++)&#123;        if(!dfn[i]) tarjan(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(vdcc[i]==vdcc[i+n] || vdcc[i+2*n]==vdcc[i+3*n])&#123;             // 如果i和¬i在同一分量，或前缀和后缀变量在同一分量则环无解            cout&lt;&lt;&quot;NIE&quot;;            return 0;        &#125;    &#125;    cout&lt;&lt;&quot;TAK&quot;;    return 0;&#125;
P3783 [SDOI2017] 天才黑客 - 洛谷
首先这个字典树的边权没有任何卵用，因为题目中已经给出边上的 did_{i}di​ 了。
其次这个题一眼最短时间，说人话就是最短路，考虑 Dijkstra 求最短路，因为这里 SPFA 显然已死（你真的要卡 O(nm)O(nm)O(nm)？）。问题转化为如何取去建图，根据题意，通过一条边的边权是如下构成的：
w(u,v)=c(u,v)+LCP⁡(dnow,di)w_{(u,v)} = c_{(u,v)} + \operatorname{LCP}(d_{now}, d_{i})
w(u,v)​=c(u,v)​+LCP(dnow​,di​)
不难注意到题目中慷慨的给我们了字典树，根据字典树上的性质，任意两个点之间的 LCA 节点的深度大小就是这两点的所构成字符串的最长公共前缀长度，那么边权转化为：
w(u,v)=c(u,v)+dep{LCA⁡(dnow,di}w_{(u,v)} = c_{(u,v)} + dep\left\{\operatorname{LCA}(d_{now}, d_{i}\right\}
w(u,v)​=c(u,v)​+dep{LCA(dnow​,di​}
但是这里面有一个棘手的地方就是这个 dnowd_{now}dnow​，因为如果我们真的要在 Dijkstra 上跑的话这个 dnowd_nowdn​ow 是不太好处理的。考虑题目的性质，注意到题目中的点几乎没有任何卵用，因为所有信息都在有向图的边上，那么我们考虑怎么从边上下手。考虑点边互换，将边拆成入点和出点，连边 in→outin \to outin→out，边权为 cec_{e}ce​。让后考虑这个 LCA 怎么处理，其实很简单，我们对于第一个边的出点，我们向第二个边的入点连上边权为两个边上的 LCA 权，即 dep{LCA⁡(d(u,v),d(v,t))}dep\left\{ \operatorname{LCA}(d_{(u,v)},d_{(v,t)}) \right\}dep{LCA(d(u,v)​,d(v,t)​)}。
注意到节点 111 向哪里走都是无代价的，所以对于所有 1→a1 \to a1→a 的边，我们建超级源点 SSS，让 S→aS \to aS→a，边权为 000 即可。
让后输出最短路长度的时候，答案即为 min⁡be=idisout\min\limits_{b_{e}=i} dis_{out}be​=imin​disout​，正确性是显然的。
写完交上去，恭喜你 MLE+TLE。为什么？因为边数最高可到达 O(m2)O(m^2)O(m2) 啊，这个时候又要开始优化建图了（悲）。

首先原来的 in→outin \to outin→out 显然是不能动的，我们考虑对 LCA 上下手，注意到我们对于 LCA 上都是一个一个连边的，而 LCA 对于大多数对节点是相同的，这是什么，虚树啊！我们考虑虚树的大小能否支持我们操作，不妨设 S={di∣bi=u,ai=u}S=\left\{ d_{i}| b_{i}=u,a_{i}=u \right\}S={di​∣bi​=u,ai​=u}，那么这些边的边权只能是 SSS 中任意两点 LCA 的深度，根据虚树特性理论，SSS，中任意两点的 LCA 总共只有 O(∣S∣)O(|S|)O(∣S∣) 个，对于所有点，∑u∣Su∣=m\sum\limits_{u} |S_u|=mu∑​∣Su​∣=m，边复杂度 O(m)O(m)O(m)，可以接受。
我们考虑把 LCA 这个点拿出来建虚点，在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，让后在利用虚树进行建边，但是这样边数是 O(n)O(n)O(n) 的，总边数还是 O(n2)O(n^2)O(n2) 的，还是会被卡，考虑怎么优化。
注意到，我们实际上连边都是在子树中的节点连一个 LCA 的虚点，让后在从这个虚点连向另外一个虚点，考虑这个怎么优化。子树的性质，DFN连续。那么，问题转化为 DFS 序上的区间向点连边，点向另外一个连续区间连边，这是什么，线段树优化建图啊！让后就做完了，时间复杂度因为连边是 O(log⁡n)O(\log n)O(logn) 的，所以总复杂度是 O(nlog⁡2m)O(n \log^2 m)O(nlog2m)，我没写因为我有卡常黑历史 www。
能不能再给力一点啊？
可以的！上述过程我们是在暴力枚举 LCA 的，事实上，如果两点间连了一堆的边，但是只有代价最小的边是有用的，剩下都是没太大啥用的，连了也不影响。
我们先把 SSS 集合求出来，连边的话我们从 [1,i][1,i][1,i] 的出点向 [i+1,t][i+1,t][i+1,t] 入点，[i+1,t][i+1,t][i+1,t] 出点向 [1,i][1,i][1,i] 入点连边，其中 t=∣S∣t=|S|t=∣S∣，这个可以用线段树也可以用神秘的前缀后缀优化建图来做。让后根据上面所说的，只有代价最小的边有用，也就是说对于一个子树区间，只有 min⁡x,ydep[lca⁡(x,y)]\min_{x,y} dep[ \operatorname{lca}(x,y)]minx,y​dep[lca(x,y)] 才有用，我们考虑这个代价最小的边怎么连，注意到每次都是某个前缀向后缀连边，或者后缀向前缀连边，为什么，你思考上面线段树的做法。那么，我们建立四个数组：前缀入点、前缀出点、后缀入点、后缀出点。这样的建边是 O(1)O(1)O(1) 的，时间复杂度是 O(nlog⁡m)O(n \log m)O(nlogm)。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+15,MLOG=20;struct Edge&#123;    int v,w;&#125;;struct EDGE&#123;    int a,b,c,d;&#125;e[MN];int n,m,K,S,ans[MN],hlca[MN],ntot,prein[MN],preout[MN],sufin[MN],sufout[MN];vector&lt;int&gt; out[MN],in[MN];vector&lt;Edge&gt; adj[MN];vector&lt;pir&gt; vt; // 这是集合 Snamespace Trie&#123;    vector&lt;int&gt; g[MN];    int fa[MN][30],dep[MN],dfn[MN],dfntot;    void triedfs(int u,int pre)&#123;        dfn[u]=++dfntot;        fa[u][0]=pre;        dep[u]=dep[pre]+1;        for(int i=1;i&lt;=MLOG;i++)&#123;            fa[u][i]=fa[fa[u][i-1]][i-1];        &#125;        for(auto v:g[u])&#123;            triedfs(v,u);        &#125;    &#125;    int lca(int x,int y)&#123;        if(dep[x]&gt;dep[y]) swap(x,y);        for(int i=MLOG;i&gt;=0;i--)&#123;            if(dep[fa[y][i]]&gt;=dep[x]) y=fa[y][i];        &#125;        if(x==y) return x;        for(int k=MLOG;k&gt;=0;k--)&#123;            if(fa[x][k]!=fa[y][k])&#123;                x=fa[x][k],y=fa[y][k];            &#125;        &#125;        return fa[x][0];    &#125;&#125;using namespace Trie;namespace Dijkstra&#123;    int dis[MN];    bool vis[MN];    void dijk(int st)&#123;        memset(dis,0x3f,sizeof(dis));        memset(vis,0,sizeof(vis));        priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;        dis[st]=0;        q.push(pir(0,st));        while(!q.empty())&#123;            int u=q.top().second;            q.pop();            if(vis[u]) continue;            vis[u]=1;            for(auto e:adj[u])&#123;                int v=e.v;                if(dis[v]&gt;dis[u]+e.w)&#123;                    dis[v]=dis[u]+e.w;                    q.push(pir(dis[v],v));                &#125;            &#125;        &#125;    &#125;&#125;using namespace Dijkstra;bool cmp(pir x,pir y)&#123;    return dfn[x.first]&lt;dfn[y.first];&#125;void clear()&#123;    S=MN-3;    ntot=dfntot=0;    memset(dfn,0,sizeof(dfn));    memset(dep,0,sizeof(dep));    memset(fa,0,sizeof(fa));    for(int i=0;i&lt;MN;i++)&#123;        in[i].clear();        out[i].clear();        g[i].clear();        adj[i].clear();    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;K;    clear();    ntot=m&lt;&lt;1;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;e[i].a&gt;&gt;e[i].b&gt;&gt;e[i].c&gt;&gt;e[i].d;        out[e[i].a].push_back(i);        in[e[i].b].push_back(i);    &#125;    for(int i=1;i&lt;K;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        g[u].push_back(v);    &#125;    triedfs(1,0);    for(int i=1;i&lt;=m;i++)&#123;        adj[i].push_back(&#123;i+m,e[i].c&#125;);        if(e[i].a==1) adj[S].push_back(&#123;i,0&#125;);    &#125;        // 以上都是常规建边    for(int i=1;i&lt;=n;i++)&#123;        vt.clear();        for(auto p:in[i]) vt.push_back(pir(e[p].d,p+m));        for(auto p:out[i]) vt.push_back(pir(e[p].d,p));        sort(vt.begin(),vt.end(),cmp);        for(int j=0;j&lt;vt.size();j++)&#123; //新建前缀后缀节点            prein[j]=++ntot;            preout[j]=++ntot;            sufin[j]=++ntot;            sufout[j]=++ntot;        &#125;        for(int j=0;j+1&lt;vt.size();j++)&#123;            hlca[j]=lca(vt[j].first,vt[j+1].first); // 求出 dfn 排序后的任意两个节点的LCA            adj[prein[j+1]].push_back(&#123;prein[j],0&#125;); // 前缀后缀初始化建图            adj[preout[j]].push_back(&#123;preout[j+1],0&#125;);            adj[sufin[j]].push_back(&#123;sufin[j+1],0&#125;);            adj[sufout[j+1]].push_back(&#123;sufout[j],0&#125;);        &#125;        for(int j=0;j&lt;vt.size();j++)&#123;            // 前缀建图要分类，别建炸缸了            if(vt[j].second&lt;=m)&#123;                adj[sufin[j]].push_back(&#123;vt[j].second,0&#125;);                adj[prein[j]].push_back(&#123;vt[j].second,0&#125;);            &#125;            else&#123;                adj[vt[j].second].push_back(&#123;sufout[j],0&#125;);                adj[vt[j].second].push_back(&#123;preout[j],0&#125;);            &#125;        &#125;        for(int j=0;j+1&lt;vt.size();j++)&#123;            // 连边，这里dep-1是因为根节点dep=1，而lcp是根节点到            // 当前节点的距离，dep[rt]=1，所以要-1            adj[sufout[j+1]].push_back(&#123;prein[j], dep[hlca[j]]-1&#125;);            adj[preout[j]].push_back(&#123;sufin[j+1], dep[hlca[j]]-1&#125;);        &#125;    &#125;    dijk(S);    memset(ans,0x3f,sizeof(ans));    for(int i=1;i&lt;=m;i++)&#123;        // 暴力枚举        ans[e[i].b]=min(ans[e[i].b],dis[i+m]);    &#125;    for(int i=2;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0; // byebye程序&#125;
 3. 后缀树上优化建图
P5284 [十二省联考2019]字符串问题
当然是 SAM 做法啦，首先为了求前缀信息直接对反串求后缀自动机。
不难注意到这个支配关系很想一个图中的边，我们思考能不能进行图论建模，但是前缀全部建图是很难受的，但是一个性质，link 树上的祖先在反串上都是它的前缀。
我们记录一下反串每一个位置在后缀自动机上的位置，然后在 link 树上倍增上去找 s[l,r]s[l,r]s[l,r] 对应的节点。我们对于后缀自动机上每一个节点开一个 vector，按照子串长度为第一关键字，是否为 A 类串为第二关键字排序，然后依次连边。让后把后缀自动机父亲结点挂下来的结点向当前结点连一条边。
然后问题就是在 DAG 上求最长路！
其实就是综合利用 link 树上的祖先在反串上都是它的前缀的特性。
大约是 O(Tnlog⁡n)O(Tn \log n)O(Tnlogn)
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int n,na,nb,m,in[MN],tot,dis[MN],a[MN],b[MN],last[MN],fa[MN],pre[31][MN],pos[MN];long long ans;bool isa[MN];string s;vector&lt;int&gt; adj[MN],g[MN];struct SAM&#123;    int nxt[MN][26],len[MN],stot,lst;    void init()&#123;        for(int i=0;i&lt;=stot;i++)&#123;            fa[i]=len[i]=0;            for(int j=0;j&lt;=30;j++) pre[j][i]=0;            memset(nxt[i],0,sizeof(nxt[i]));        &#125;        stot=lst=1;    &#125;    void expand(int c)&#123;        int cur=++stot;        len[cur]=len[lst]+1;        int p=lst;        while(p&amp;&amp;!nxt[p][c]) nxt[p][c]=cur,p=fa[p];        if(!p)&#123;            fa[cur]=1;        &#125;else&#123;            int q=nxt[p][c];            if(len[q]==len[p]+1)&#123;                fa[cur]=q;            &#125;else&#123;                int nq=++stot;                len[nq]=len[p]+1;                fa[nq]=fa[q];                memcpy(nxt[nq],nxt[q],sizeof(nxt[q]));                fa[q]=fa[cur]=nq;                while(p&amp;&amp;nxt[p][c]==q)&#123;                    nxt[p][c]=nq;                    p=fa[p];                &#125;            &#125;        &#125;        lst=cur;    &#125;    void initpre()&#123;        for(int i=1;i&lt;=stot;i++) pre[0][i]=fa[i];        for(int i=1;i&lt;=30;i++)&#123;            for(int j=2;j&lt;=stot;j++)&#123;                pre[i][j]=pre[i-1][pre[i-1][j]];            &#125;        &#125;    &#125;&#125;sam;bool cmp(int x,int y)&#123;    if(sam.len[x]==sam.len[y])&#123;        return isa[x]&gt;isa[y];    &#125;    return sam.len[x]&gt;sam.len[y];&#125;void init()&#123;    sam.init();    for(int i=1;i&lt;=tot;i++) in[i]=dis[i]=isa[i]=pos[i]=0,g[i].clear(),adj[i].clear();    ans=0;&#125;int toposort()&#123;    queue&lt;int&gt; q;    for(int i=1;i&lt;=tot;i++) if(!in[i]) q.push(i);    while(!q.empty())&#123;        int u=q.front();        q.pop();        ans=max(ans,1ll*dis[u]+sam.len[u]);        for(auto v:adj[u])&#123;            dis[v]=max(dis[v],dis[u]+sam.len[u]);            in[v]--;            if(!in[v])&#123;                q.push(v);            &#125;        &#125;    &#125;    bool flag=0;    for(int i=1;i&lt;=tot;i++)&#123;        if(in[i]) flag=1;    &#125;    if(flag) return -1;    return ans;&#125;void solve()&#123;    init();    cin&gt;&gt;s;    n=s.length();    s=&quot; &quot;+s;    for(int i=n;i&gt;=1;i--)&#123;        sam.expand(s[i]-&#x27;a&#x27;);        pos[i]=sam.lst;    &#125;    sam.initpre();    cin&gt;&gt;na;    tot=sam.stot;    for(int i=1;i&lt;=na;i++)&#123;        int l,r;        cin&gt;&gt;l&gt;&gt;r;        int lenn=r-l+1,p=pos[r];        for(int i=30;i&gt;=0;i--)&#123;            if(pre[i][p]&amp;&amp;sam.len[pre[i][p]]&gt;=lenn) p=pre[i][p];         &#125;        isa[++tot]=1;        sam.len[tot]=lenn;        g[p].push_back(tot);        a[i]=tot;    &#125;    cin&gt;&gt;nb;    for(int i=1;i&lt;=nb;i++)&#123;        int l,r;        cin&gt;&gt;l&gt;&gt;r;        int lenn=r-l+1,p=pos[l];        for(int i=30;i&gt;=0;i--)&#123;            if(pre[i][p]&amp;&amp;sam.len[pre[i][p]]&gt;=lenn) p=pre[i][p];         &#125;        isa[++tot]=0;        sam.len[tot]=lenn;        g[p].push_back(tot);        b[i]=tot;    &#125;    for(int i=2;i&lt;=sam.stot;i++) sort(g[i].begin(),g[i].end(),cmp);    for(int i=1;i&lt;=sam.stot;i++)&#123;        int lst=i;        for(int j=g[i].size()-1;j&gt;=0;j--)&#123;            adj[lst].push_back(g[i][j]);            in[g[i][j]]++;            if(!isa[g[i][j]]) lst=g[i][j];        &#125;        last[i]=lst;    &#125;    for(int i=2;i&lt;=sam.stot;i++)&#123;        adj[last[fa[i]]].push_back(i);        in[i]++;    &#125;    for(int i=1;i&lt;=tot;i++)&#123;        if(!isa[i]) sam.len[i]=0;    &#125;    cin&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int x,y;        cin&gt;&gt;x&gt;&gt;y;        adj[a[x]].push_back(b[y]);        in[b[y]]++;    &#125;    cout&lt;&lt;toposort()&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 4. 倍增优化建图
区间向区间连边，可以转化为区间向虚点连边，再由虚点向区间连边。
和线段树建图极其相似，但是不同的是我们这里搬到了书上，我们同样要建出两个树，一个是出边树，一个是入边树，让后我们通过倍增求 LCA 的方法来建立：

每一次我们让 [u1,v1]→[u2,v2][u_1,v_{1}] \to [u_{2},v_{2}][u1​,v1​]→[u2​,v2​] 连边时，两个跳 LCA，[u1,v1]→out[u1,v1][u_{1},v_{1}] \to out_{[u_{1},v_{1}]}[u1​,v1​]→out[u1​,v1​]​，[u2,v2]→in[u2,v2][u_{2},v_{2}] \to in_{[u_{2},v_{2}]}[u2​,v2​]→in[u2​,v2​]​。让后 out[u1,v1]→in[u2,v2]out_{[u_1,v_{1]}\to}in_{[u_{2},v_{2}]}out[u1​,v1]​→​in[u2​,v2​]​。
时间复杂度在 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e7+15;constexpr int INF=0x3f3f3f3f;struct Query&#123;    int u1,v1,u2,v2,w;&#125;qry[MN];int n,m,st,qtot,dis[MN],pre[MN];bool vis[MN];vector&lt;pir&gt; adj[MN],g[MN];namespace Tree&#123;    int dep[MN],fa[MN][20],dtot;    int in[MN][20],out[MN][20];    void dfs(int u,int pre)&#123;        dep[u]=dep[pre]+1;        fa[u][0]=pre;        in[u][0]=++dtot;        adj[dtot].push_back(&#123;u,0&#125;);        adj[dtot].push_back(&#123;pre,0&#125;);        out[u][0]=++dtot;        adj[u].push_back(&#123;dtot,0&#125;);        adj[pre].push_back(&#123;dtot,0&#125;);        for(int j=0;j&lt;__lg(n);j++)&#123;            fa[u][j+1]=fa[fa[u][j]][j];            in[u][j+1]=++dtot;            adj[dtot].push_back(&#123;in[u][j],0&#125;);            adj[dtot].push_back(&#123;in[fa[u][j]][j],0&#125;);            out[u][j+1]=++dtot;            adj[out[u][j]].push_back(&#123;dtot,0&#125;);            adj[out[fa[u][j]][j]].push_back(&#123;dtot,0&#125;);        &#125;        for(auto e:g[u])&#123;            int v=e.first;            if(v==pre) continue;            dfs(v,u);        &#125;    &#125;    void lca1(int x,int y,int k)&#123;        if(dep[x]&lt;dep[y]) swap(x,y);        adj[y].push_back(&#123;k,0&#125;);        for(int i=__lg(n);i&gt;=0;i--)&#123;            if(dep[fa[x][i]]&gt;=dep[y])&#123;                adj[out[x][i]].push_back(&#123;k,0&#125;);                x=fa[x][i];            &#125;        &#125;        if(x==y) return;        for(int i=__lg(n);i&gt;=0;i--)&#123;            if(fa[x][i]!=fa[y][i])&#123;                adj[out[x][i]].push_back(&#123;k,0&#125;);                adj[out[y][i]].push_back(&#123;k,0&#125;);                x=fa[x][i];                y=fa[y][i];            &#125;        &#125;        adj[out[x][0]].push_back(&#123;k,0&#125;);    &#125;    void lca2(int x,int y,int k)&#123;        if(dep[x]&lt;dep[y]) swap(x,y);        adj[k].push_back(&#123;y,0&#125;);        for(int i=__lg(n);i&gt;=0;i--)&#123;            if(dep[fa[x][i]]&gt;=dep[y])&#123;                adj[k].push_back(&#123;in[x][i],0&#125;);                x=fa[x][i];            &#125;        &#125;        if(x==y) return;        for(int i=__lg(n);i&gt;=0;i--)&#123;            if(fa[x][i]!=fa[y][i])&#123;                adj[k].push_back(&#123;in[x][i],0&#125;);                adj[k].push_back(&#123;in[y][i],0&#125;);                x=fa[x][i];                y=fa[y][i];            &#125;        &#125;        adj[k].push_back(&#123;in[x][0],0&#125;);    &#125;&#125;using namespace Tree;int root(int x)&#123;    return pre[x]==x?x:pre[x]=root(pre[x]);&#125;void dijk(int st)&#123;    priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;    memset(dis,0x3f,sizeof(dis));    dis[st]=0;    q.push(&#123;0,st&#125;);    while(!q.empty())&#123;        int u=q.top().second;        q.pop();        if(vis[u]) continue;        vis[u]=1;        for(auto e:adj[u])&#123;            int v=e.first,w=e.second;            if(dis[v]&gt;dis[u]+w)&#123;                dis[v]=dis[u]+w;                q.push(&#123;dis[v],v&#125;);            &#125;        &#125;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st;    dtot=n;    for(int i=1;i&lt;=n;i++) pre[i]=i;    while(m--)&#123;        int op,u1,v1,u2,v2,w;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;u1&gt;&gt;v1&gt;&gt;u2&gt;&gt;v2&gt;&gt;w;            if(root(u1)!=root(v1)||root(u2)!=root(v2)) continue;            qry[++qtot]=&#123;u1,v1,u2,v2,w&#125;;        &#125;else&#123;            cin&gt;&gt;u1&gt;&gt;v1&gt;&gt;w;            int ru=root(u1),rv=root(v1);            if(ru==rv) continue;            g[u1].push_back(&#123;v1,w&#125;);            g[v1].push_back(&#123;u1,w&#125;);            adj[u1].push_back(&#123;v1,w&#125;);            adj[v1].push_back(&#123;u1,w&#125;);            pre[rv]=ru;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)        if(!dep[i]) dfs(i,0);    for(int i=1;i&lt;=qtot;i++)&#123;        lca1(qry[i].u1,qry[i].v1,++dtot);        lca2(qry[i].u2,qry[i].v2,++dtot);        adj[dtot-1].push_back(&#123;dtot,qry[i].w&#125;);    &#125;    dijk(st);    for(int i=1;i&lt;=n;i++)        cout&lt;&lt;(dis[i]==INF?-1:dis[i])&lt;&lt;&quot; &quot;;    return 0;&#125;
 5. 虚点连边
区间向区间连边，可以转化为区间向虚点连边，再由虚点向区间连边。
这个话还是比较管用的，这样复杂度可以大大降低。
但是我题丢了，所以只能放一句话 www。
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>分块九讲</title>
    <url>/posts/ea3fa6a/</url>
    <content><![CDATA[这里是块状数组

 1.引入
分块是一种思想，把一个整体划分为若干个等长的小块，对整块整体处理，打标记。零散块暴力处理。可以做到均摊O(n)O(\sqrt{n})O(n​)的询问时间复杂度，总时间复杂度O(nn)O(n\sqrt{n})O(nn​)的一个优雅的暴力思想
我们将一个长度为nnn的数组分成lenlenlen个块，那么每个块的长度就是nlen\frac{n}{len}lenn​，一般来说这个lenlenlen取n\sqrt{n}n​,是需要自己用基本不等式去算出来的，但是一般比赛中手算一下理论复杂度，只要块长n\sqrt{n}n​能过就行。
为啥非要取n\sqrt{n}n​？因为nn=n\frac{n}{\sqrt{n}}=\sqrt{n}n​n​=n​,显然用基本不等式可以证明
以下是对1~16进行分块，分块实质上就是3层树，第二层就是块，每个块的子树共有n\sqrt{n}n​个孩子节点。只不过，块状数组最顶层的信息不用维护。

我们对于一次区间操作，可能有如下的可能

我们所操作的区间左右端点刚好在一个块里，这时候我们就可以暴力操作。但是我们要注意如果所修改的信息对块整体有影响块也要更新（例如求和），如下图。但是问题我们怎么左右端点是否在一个区间里呢。很简单我们只需要在预处理每个块的时候记录一下各个端点所属于的块的id就行
![[粘贴的图像 (4).png]]
当然下面这个情况也是属于第一种情况的，这种情况也可以保证复杂度是O(n)O(\sqrt{n})O(n​)


2. 我们所操作的区间左右端点不在一个块，如下图

这种情况我们根据上面所说的定义，散块暴力，大块打tag，橙色就是打tag,绿色代表暴力处理，打tag显然复杂度O(1)O(1)O(1)，两边暴力加起来也不会绿色总长度超过2n2\sqrt{n}2n​

优雅的暴力，虽然他的时间复杂度干不过O(nlog2n)O(nlog_2n)O(nlog2​n)的算法，但是他有一个好处，就是他的信息不需要满足结合律，也不需要一层层地传递标记，它具有更高的灵活性。
根据定义就能够写出以下建块的代码，这里我们以P3374——单点加区间和为例子，我们用sum[i]sum[i]sum[i]数组表示第i个块维护的数字和
void init()&#123;    len=sqrt(n);//块长为根号n    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;//新块的左端点就是上一个块右端点+1        r[i]=i*len;//处理右端点    &#125;    if(r[len]&lt;n)&#123;//如果长度不够就在建一个块        r[++len]=n;        l[len]=r[len-1]+1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;//注意这里len不在代表块长而是代表块的个数        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;//处理每个点对应块的id            sum[i]+=a[j];//处理区间和，前缀和的思想        &#125;    &#125;&#125;
单点加如下，要注意对点修改也会对块维护的信息产生影响
void add(int x,ll k)&#123;    a[x]+=k;    sum[pos[x]]+=k;&#125;
询问如下
ll query(int fl,int fr)&#123;    int ql=pos[fl],qr=pos[fr];//获取左右端点的对应块id    ll ret=0;    if(ql==qr)&#123;//如果在一个块里，就情况1暴力处理        for(int i=fl;i&lt;=fr;i++)&#123;            ret+=a[i];        &#125;        return ret;    &#125;    //情况二，分散块暴力，整块看tag    for(int i=fl;i&lt;=r[ql];i++)&#123;//对左端点的分散块暴力        ret+=a[i];    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;//对右端点分散块暴力        ret+=a[i];    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;//对整块直接加tag        ret+=sum[i];    &#125;    return ret;&#125;
AC代码如下
#include&lt;iostream&gt;#include&lt;cmath&gt;#define endl &#x27;\n&#x27;#define ll long longusing namespace std;const int MN=5e5+15;int n,m;int l[MN],r[MN],pos[MN];ll a[MN],sum[MN],len;void add(int x,ll k)&#123;    a[x]+=k;    sum[pos[x]]+=k;&#125;void init()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    if(r[len]&lt;n)&#123;        r[++len]=n;        l[len]=r[len-1]+1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;            sum[i]+=a[j];        &#125;    &#125;&#125;ll query(int fl,int fr)&#123;    int ql=pos[fl],qr=pos[fr];    ll ret=0;    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            ret+=a[i];        &#125;        return ret;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        ret+=a[i];    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        ret+=a[i];    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        ret+=sum[i];    &#125;    return ret;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    init();    while (m--)    &#123;        int op;        ll x,y;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==1)&#123;            add(x,y);        &#125;else cout&lt;&lt;query(x,y)&lt;&lt;endl;    &#125;        return 0;&#125;
 2.数列分块
成功解锁了分块，那么现在就来开始做题吧

单点加，区间求值，就是P3369

#include&lt;iostream&gt;#include&lt;cmath&gt;#define endl &#x27;\n&#x27;#define ll long longusing namespace std;const int MN=5e5+15;int n,m;int l[MN],r[MN],pos[MN];ll a[MN],sum[MN],len;void add(int x,ll k)&#123;    a[x]+=k;    sum[pos[x]]+=k;&#125;void init()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    if(r[len]&lt;n)&#123;        r[++len]=n;        l[len]=r[len-1]+1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;            sum[i]+=a[j];        &#125;    &#125;&#125;ll query(int fl,int fr)&#123;    int ql=pos[fl],qr=pos[fr];    ll ret=0;    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            ret+=a[i];        &#125;        return ret;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        ret+=a[i];    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        ret+=a[i];    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        ret+=sum[i];    &#125;    return ret;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    init();    while (m--)    &#123;        int op;        ll x,y;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==1)&#123;            add(x,y);        &#125;else cout&lt;&lt;query(x,y)&lt;&lt;endl;    &#125;        return 0;&#125;

区间加，区间查询小于等于某个数

显然这个我们入手角度就是对于整个块怎么进行处理，我们显然可以发现。“小于等于”，如果暴力就是O(n)O(n)O(n),但是如果我们以有序数组二分那就是O(log2n)O(log_2n)O(log2​n)。思想就是对于块要维护有序。对于区间加，对于情况1和情况2的散列块我们需要重新建块进行sort排序。对于查询，我们可以对散列块暴力找，整块二分找。区间加对于大块来说是都加上一个数，不会改变相对大小的顺序所以只需要打tag就可以啦
代码如下
#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int MN=5e4+15,MQ=700;int n;vector&lt;int&gt; bl[MQ];int l[MQ],r[MQ],pos[MN],tag[MQ],a[MN],len;void init()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    if(r[len]&lt;n)&#123;        r[++len]=n;        l[len]=r[len-1]+1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;            bl[i].push_back(a[j]);        &#125;        sort(bl[i].begin(),bl[i].end());//处理完后要排序    &#125;&#125;void bladd(int fl,int fr,int k)&#123;//暴力加    int ql=pos[fl];    for(int i=fl;i&lt;=fr;i++)&#123;        a[i]+=k;    &#125;    bl[ql].clear();    for(int i=l[ql];i&lt;=r[ql];i++)&#123;        bl[ql].push_back(a[i]);    &#125;    sort(bl[ql].begin(),bl[ql].end());&#125;void add(int fl,int fr,int k)&#123;//区间加操作    int ql=pos[fl],qr=pos[fr];    if(ql==qr)&#123;        bladd(fl,fr,k);        return;    &#125;    bladd(fl,r[ql],k);    bladd(l[qr],fr,k);    for(int i=ql+1;i&lt;qr;i++)&#123;        tag[i]+=k;    &#125;&#125;int query(int fl,int fr,int k)&#123;    int ql=pos[fl],qr=pos[fr],ret=0;    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            if(a[i]+tag[ql]&lt;k)&#123;                ret++;            &#125;        &#125;        return ret;    &#125;    //两边暴力大块二分    //分块九讲对于暴力写的是推到一个数组排序后二分，但是直接暴力也是可以的吧    for(int i=fl;i&lt;=r[ql];i++)&#123;        if(a[i]+tag[ql]&lt;k)&#123;            ret++;        &#125;    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        if(a[i]+tag[qr]&lt;k)&#123;            ret++;        &#125;    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        ret+=lower_bound(bl[i].begin(),bl[i].end(),k-tag[i])-bl[i].begin();    &#125;    return ret;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    init();    while (n--)    &#123;        int op,l,r,k;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;k;        if(op==0)&#123;            add(l,r,k);        &#125;else cout&lt;&lt;query(l,r,k*k)&lt;&lt;endl;    &#125;        return 0;&#125;

区间加，查询某个数的前继

这个其实和2是一样的，也是二分查找，这里贴一下他人的代码
const int inf=1e5+7;int n,len,a[inf];int bel[inf],L[400],R[400];int tag[400];vector&lt;int&gt;h[400];void baoli(int l,int r,int k)&#123;	int in=bel[l];	for(int i=l;i&lt;=r;i++)		a[i]+=k;	h[in].clear();	for(int i=L[in];i&lt;=R[in];i++)		h[in].push_back(a[i]);	sort(h[in].begin(),h[in].end());&#125;void update(int l,int r,int k)&#123;	int lin=bel[l],rin=bel[r];	if(lin==rin)	&#123;		baoli(l,r,k);		return;	&#125;	baoli(l,R[lin],k);	baoli(L[rin],r,k);	for(int i=lin+1;i&lt;rin;i++)		tag[i]+=k;&#125;int query(int l,int r,int k)&#123;	vector&lt;int&gt;ls;	for(int i=l;i&lt;=r;i++)		ls.push_back(a[i]+tag[bel[l]]);	sort(ls.begin(),ls.end());	vector&lt;int&gt;::iterator ret=lower_bound(ls.begin(),ls.end(),k);	if(ret==ls.begin())return -1;	return *--ret;&#125;int ask(int l,int r,int k)&#123;	int lin=bel[l],rin=bel[r];	if(lin==rin)return query(l,r,k);	int ans=-1;	ans=max(ans,query(l,R[lin],k));	ans=max(ans,query(L[rin],r,k));	for(int i=lin+1;i&lt;rin;i++)	&#123;		vector&lt;int&gt;::iterator ls=lower_bound(h[i].begin(),h[i].end(),k-tag[i]);		if(ls==h[i].begin())ans=max(ans,-1);		else ans=max(ans,*--ls+tag[i]);	&#125;	return ans;&#125;int main()&#123;	n=re();len=sqrt(n);	for(int i=1;i&lt;=n;i++)		a[i]=re();	for(int i=1;i&lt;=len;i++)		L[i]=R[i-1]+1,R[i]=i*len;	R[len]=n;	for(int i=1;i&lt;=len;i++)	&#123;		for(int j=L[i];j&lt;=R[i];j++)			bel[j]=i,h[i].push_back(a[j]);		sort(h[i].begin(),h[i].end());	&#125;	for(int i=1;i&lt;=n;i++)	&#123;		int op=re(),l=re(),r=re(),k=re();		if(op)wr(ask(l,r,k)),putchar(&#x27;\n&#x27;);		else update(l,r,k);	&#125;	return 0;&#125;

区间加，区间求和

我会线段树！！！！
用分块也是可以做的，与第一类型的相比来说只需要维护两个tag，一个区间加tag，一个区间和tag就可以啦
#include&lt;iostream&gt;#include&lt;cmath&gt;#define int long longusing namespace std;const int MN=1e5+15,MQ=700;int l[MQ],r[MQ],pos[MN],sum[MQ],tag[MQ],a[MN],n,len;void init()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    if(r[len]&lt;n)&#123;        r[++len]=n;        l[len]=r[len-1]+1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;            sum[i]+=a[j];        &#125;    &#125;&#125;void add(int fl,int fr,int k)&#123;    int ql=pos[fl],qr=pos[fr];    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            a[i]+=k;            sum[ql]+=k;        &#125;        return;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        a[i]+=k;        sum[ql]+=k;    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        a[i]+=k;        sum[qr]+=k;    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        tag[i]+=k;        sum[i]+=(r[i]-l[i]+1)*k;    &#125;&#125;int query(int fl,int fr,int k)&#123;    int ql=pos[fl],qr=pos[fr],ans=0;    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            ans=(ans+a[i]+tag[ql])%k;        &#125;        return ans;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        ans=(ans+a[i]+tag[ql])%k;    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        ans=(ans+a[i]+tag[qr])%k;    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        ans=(ans+sum[i])%k;    &#125;    return ans;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    init();    while (n--)    &#123;         int op,l,r,k;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;k;        if(op==0)&#123;            add(l,r,k);        &#125;else cout&lt;&lt;query(l,r,k+1)&lt;&lt;endl;    &#125;        return 0;&#125;

区间开方，区间求和

唉这个题不还是线段树么
P4145
这个题我们不要被101210^{12}1012吓到了，对其一直开根号，操作次数显然可证明为log2log2nlog_2log_2{n}log2​log2​n,计算一下大约一个2642^{64}264的数开7次就可以开到1或0。解题的关键就是1=1\sqrt{1}=11​=1,0=0\sqrt{0}=00​=0，只要对块进行检测，如果都是1或都是0就打个tag，之后就不用处理啦
代码如下
#include&lt;iostream&gt;#include&lt;cmath&gt;#define ll long longusing namespace std;const int MN=1e5+15,MQ=710;bool isok[MQ];int l[MQ],r[MQ],pos[MN],n,len,m;ll a[MN],sum[MQ];void build()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    if(r[len]&lt;n)&#123;        len++;        l[len]=r[len-1]+1;        r[len]=n;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;            sum[i]+=a[j];        &#125;    &#125;&#125;void kuaikai(int x)&#123;    if(isok[x]) return;    sum[x]=0;    isok[x]=1;    for(int i=l[x];i&lt;=r[x];i++)&#123;        a[i]=sqrt(a[i]);        sum[x]+=a[i];        if(a[i]&gt;1) isok[x]=0;    &#125;&#125;void kai(int fl,int fr)&#123;    int ql=pos[fl],qr=pos[fr];    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            sum[ql]-=a[i];            a[i]=sqrt(a[i]);            sum[ql]+=a[i];        &#125;        return;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        sum[ql]-=a[i];        a[i]=sqrt(a[i]);        sum[ql]+=a[i];    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        sum[qr]-=a[i];        a[i]=sqrt(a[i]);        sum[qr]+=a[i];    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        kuaikai(i);    &#125;&#125;ll ask(int fl,int fr)&#123;    ll ans=0;    int ql=pos[fl],qr=pos[fr];    if(ql==qr)&#123;        for(int i=fl;i&lt;=fr;i++)&#123;            ans+=a[i];        &#125;        return ans;    &#125;    for(int i=fl;i&lt;=r[ql];i++)&#123;        ans+=a[i];    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        ans+=a[i];    &#125;    for(int i=ql+1;i&lt;qr;i++)&#123;        ans+=sum[i];    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    build();    cin&gt;&gt;m;    while (m--)    &#123;        int op,x,y;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(x&gt;y) swap(x,y);        if(op==0) kai(x,y);        else cout&lt;&lt;ask(x,y)&lt;&lt;endl;    &#125;        return 0;&#125;

单点修改，单点查询

考虑用vector存块，vector在中间插入的时间复杂度是O(len)O(len)O(len)，但是长度是n\sqrt{n}n​,所以修改复杂度其实也是O(n)O(\sqrt{n})O(n​)
代码如下（粘贴自分块九讲)
const int inf=1e5+7;int n,len,a[inf];int L[400],R[400];vector&lt;int&gt;h[inf];void insert(int id,int k)&#123;	for(int i=1;i&lt;=len;i++)	&#123;		if(id&lt;=h[i].size())		&#123;			vector&lt;int&gt;::iterator ls=h[i].begin()+id-1;			h[i].insert(ls,k);			return;		&#125;		id-=h[i].size();	&#125;&#125;int ask(int id)&#123;	for(int i=1;i&lt;=len;i++)	&#123;		if(id&lt;=h[i].size())			return *(h[i].begin()+id-1);		id-=h[i].size();	&#125;&#125;int main()&#123;	n=re();len=sqrt(n);	for(int i=1;i&lt;=n;i++)		a[i]=re();	for(int i=1;i&lt;=len;i++)		L[i]=R[i-1]+1,R[i]=i*len;	R[len]=n;	for(int i=1;i&lt;=len;i++)		for(int j=L[i];j&lt;=R[i];j++)			h[i].push_back(a[j]);	for(int i=1;i&lt;=n;i++)	&#123;		int op=re(),l=re(),r=re(),k=re();		if(op)wr(ask(r)),putchar(&#x27;\n&#x27;);		else insert(l,r);	&#125;	return 0;&#125;

区间众数问题 P4168

我们显然可以考虑用桶来去计数，但是问题是只知道一个块的众数很显然没有用是吧。
这里我们考虑众数的性质本身就是统计数字出现的个数，也就是说对于询问[L,R][L,R][L,R]区间的众数，其本质可以用[1,R][1,R][1,R]的数字个数减去[1,L−1][1,L-1][1,L−1]的数字个数
那么就很简单了，我们开一个二位数组定义为zs，zsi,jzs_{i,j}zsi,j​表示第i个块到第j个块的众数
我们可以使用O(nn)O(n\sqrt{n})O(nn​)的复杂度预处理众数
既然大块的众数已经解决，那么零散块如何处理，我们显然可以发现众数只会有两种情况，第一种就是在中间的大块，第二种就是在零散块中。
暴力找数可以，但是我们需要找出现次数的话，我们可以考虑用vector存储点的出现顺序，显然这个序列满足单调递增的顺序，我们就可以对左端点进行二分，右端点进行二分，右减去左就能够得到顺序啦
注意数据过大，由于二分我们需要经过离散话才可以
#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int MN=1e5+15,MQ=420;unordered_map&lt;int,int&gt; um,fum;//存离散化后的值，通过离散化的值找原数int ls=0;//zs数字表示从第i个块到第j个块的众数编号int n,zs[MQ][MQ],l[MQ],r[MQ],pos[MN],a[MN],len,bok[MN];int tong[MN]&#123;&#125;;vector&lt;int&gt; numpos[MN];void build()&#123;    len=sqrt(n);    for(int i=1;i&lt;=len;i++)&#123;        l[i]=r[i-1]+1;        r[i]=i*len;    &#125;    r[len]=n;    for(int i=1;i&lt;=len;i++)&#123;        for(int j=l[i];j&lt;=r[i];j++)&#123;            pos[j]=i;        &#125;    &#125;    for(int i=1;i&lt;=len;i++)&#123;//找众数，用桶计数        memset(tong,0,sizeof(tong));        int zsnum=0,maxx=0;        for(int j=l[i];j&lt;=n;j++)&#123;            tong[a[j]]++;            if(maxx&lt;tong[a[j]]||(maxx==tong[a[j]]&amp;&amp;zsnum&gt;a[j]))&#123;//第一个是找到一个出现次数更多的，第二个是要求众数编号最小                zsnum=a[j];                maxx=tong[a[j]];            &#125;            zs[i][pos[j]]=zsnum;        &#125;    &#125;&#125;//获取这个数在[l,r]区间内出现次数（即众数），使用二分int getcishu(int fl,int fr,int k)&#123;    auto start=lower_bound(numpos[k].begin(),numpos[k].end(),fl);    auto end=upper_bound(numpos[k].begin(),numpos[k].end(),fr);    return end-start;&#125;int query(int fl,int fr)&#123;    int ql=pos[fl],qr=pos[fr];    int zsnum=0,maxx=0;    if(ql==qr)&#123;        //暴力找        memset(tong,0,sizeof(tong));        for(int i=fl;i&lt;=fr;i++)&#123;            tong[a[i]]++;            if(maxx&lt;tong[a[i]]||(maxx==tong[a[i]]&amp;&amp;zsnum&gt;a[i]))&#123;                zsnum=a[i];                maxx=tong[zsnum];            &#125;        &#125;        return bok[zsnum];//反向查找直接返回答案    &#125;    //先把答案设置在中间的块    //显然答案只能在中间块或左右两个块中（如果左中或右中合并最终答案还是中间的众数）    zsnum=zs[ql+1][qr-1];    maxx=getcishu(fl,fr,zsnum);    for(int i=fl;i&lt;=r[ql];i++)&#123;        int ret=getcishu(fl,fr,a[i]);        if(maxx&lt;ret||(maxx==ret&amp;&amp;zsnum&gt;a[i]))&#123;            zsnum=a[i];            maxx=ret;        &#125;    &#125;    for(int i=l[qr];i&lt;=fr;i++)&#123;        int ret=getcishu(fl,fr,a[i]);        if(maxx&lt;ret||(maxx==ret&amp;&amp;zsnum&gt;a[i]))&#123;            zsnum=a[i];            maxx=ret;        &#125;    &#125;    return bok[zsnum];&#125;int main()&#123;    int m;    ios::sync_with_stdio(0);    cin&gt;&gt;n&gt;&gt;m;    // for(int i=1;i&lt;=n;i++)&#123;    //     int p;    //     cin&gt;&gt;p;    //     if(um.find(p)==um.end())&#123;    //         um[p]=++ls;    //         fum[ls]=p;    //     &#125;    //     a[i]=um[p];    //     numpos[a[i]].push_back(i);//1~n保证内部单调递增不用sort降级nlogn（?）    // &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        bok[i]=a[i];    &#125;    sort(bok+1,bok+1+n);    int num=unique(bok+1,bok+1+n)-bok-1;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(bok+1,bok+1+num,a[i])-bok;        numpos[a[i]].push_back(i);    &#125;    build();    int bef=0;    for(int i=1;i&lt;=m;i++)&#123;        int fl,fr;        cin&gt;&gt;fl&gt;&gt;fr;        fl=(fl+bef-1)%n+1;        fr=(fr+bef-1)%n+1;        if(fl&gt;fr) swap(fl,fr);        bef=query(fl,fr);        cout&lt;&lt;bef&lt;&lt;endl;        // cout&lt;&lt;query(fl,fr)&lt;&lt;endl;    &#125;    // len=sqrt(n);    return 0;&#125;
 3.总结
分块是一种思想，不同的题目有不同的做法，具体情况具体分析。分块强调整块的统一处理，算法设计十分重要。
注意块长直接决定你的时间复杂度，如果根号被卡
可以考虑n+1\sqrt{n}+1n​+1, nlgn\sqrt{\frac{n}{lgn}}lgnn​​, n+常数\sqrt{n}+常数n​+常数
YNOI大分块之后再说

引用

Zvelig1205的分块九讲——link

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>分治fft</title>
    <url>/posts/b54c354b/</url>
    <content><![CDATA[ 0. 前言
你需要知道：

FFT 或 NTT。
CDQ 分治。

 1. 介绍
分治 FFT，用于解决这一个问题：

给定长为 n−1n-1n−1 的序列 ggg，求长为 n−1n-1n−1 的序列 fff，满足：
fi=∑j=1ifi−jgjf_i=\sum_{j=1}^i f_{i-j}g_jfi​=∑j=1i​fi−j​gj​，边界为 f0=1f_0=1f0​=1。
要求时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。

你可能会说：“这不就是卷积吗，FFT秒了！”但是你发现这玩意不太对劲，因为你卷积默认你是知道 fff，现在问题在于你不知道 fff，要一个一个求。
我们解决这个问题可以利用 CDQ 分治的思想，具体的，设 solve(l,r) 表示计算 g[l,r]g[l,r]g[l,r] 内这一段子问题的函数，注意这里算的不是 fif_ifi​，而是这一段自己对自己的贡献。为了我们 FFT 的方便，一开始肯定是调用 solve(0,1&lt;&lt;k) 的形式。
让后就是分治的部分，首先 midmidmid 劈成 [l,mid],[mid,r)[l,mid],[mid,r)[l,mid],[mid,r) 两段，令 len=r−llen=r-llen=r−l。左边一段我们可与i递归往下计算，但是对于右边我们需要计算左边对右边的贡献，因为 i−ji-ji−j 可能跑到 [l,mid][l,mid][l,mid] 里面。计算左侧 fff 的贡献，可以发现对右半边位置 xxx 的贡献为：
∑i=lmidfi×gx−i\sum_{i=l}^{mid} f_i \times g_{x-i}
i=l∑mid​fi​×gx−i​
故可以卷积快速计算，时间复杂度 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
以下为模板题代码：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e7+15;int f[MN],g[MN],ans[MN],len,n,m;namespace BJXPoly&#123;    constexpr int MOD=998244353,G=3,INVG=332748118;    int rev[MN],tmp[MN],ta[MN],tb[MN];    int ksm(int a,int b)&#123;        int ret=1;        while(b)&#123;            if(b&amp;1) ret=ret*a%MOD;            a=a*a%MOD;            b&gt;&gt;=1;        &#125;        return ret;    &#125;    void dorev(int f[],int len)&#123;        for(int i=0;i&lt;len;i++)&#123;            rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;            if(i&amp;1)&#123;                rev[i]|=len&gt;&gt;1;            &#125;        &#125;        for(int i=0;i&lt;len;i++)&#123;            if(i&lt;rev[i]) swap(f[i],f[rev[i]]);        &#125;    &#125;    void NTT(int f[],int len,int op)&#123;        dorev(f,len);        for(int i=1;i&lt;len;i&lt;&lt;=1)&#123;            int Wn=ksm((op==1?G:INVG),(MOD-1)/(i&lt;&lt;1));            for(int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123;                int w=1;                for(int k=0;k&lt;i;k++,w=(w*Wn)%MOD)&#123;                    int x=f[j+k],y=w*f[j+k+i]%MOD;                    f[j+k]=(x+y)%MOD;                    f[j+k+i]=(x-y+MOD)%MOD;                &#125;            &#125;        &#125;        if(op==-1)&#123;            int invlen=ksm(len,MOD-2);            for(int i=0;i&lt;len;i++) f[i]=f[i]*invlen%MOD;        &#125;    &#125;void Mul(int a[], int b[], int n, int m)&#123;    // 注意一定要复制一份再去做 NTT，不能覆盖原数组    int len=1;    while(len &lt; n+m-1) len &lt;&lt;= 1;    static int ta[MN], tb[MN];    for(int i=0;i&lt;len;i++) ta[i] = (i&lt;n ? a[i] : 0);    for(int i=0;i&lt;len;i++) tb[i] = (i&lt;m ? b[i] : 0);    NTT(ta, len, 1);    NTT(tb, len, 1);    for(int i=0;i&lt;len;i++) ta[i] = ta[i] * tb[i] % MOD;    NTT(ta, len, -1);    for(int i=0;i&lt;len;i++) a[i] = ta[i]; &#125;    void cdq(int l,int r)&#123;        if(l+1==r) return;        int mid=(l+r)&gt;&gt;1;        int len=r-l;        cdq(l,mid);        for(int i=0;i&lt;len*2;i++)&#123;            tmp[i]=0;        &#125;        for(int i=l;i&lt;mid;i++) tmp[i-l]=f[i];        Mul(tmp,g,len*2,len*2);        for(int i=mid;i&lt;r;i++) (f[i]+=tmp[i-l])%=MOD;        cdq(mid,r);    &#125;&#125;signed main()&#123;    read(n);    for(int i=1;i&lt;n;i++)&#123;        read(g[i]);    &#125;    int lim=n;    while(lim!=(1&lt;&lt;__lg(lim))) ++lim;    f[0]=1;    BJXPoly::cdq(0,lim);    for(int i=0;i&lt;n;i++)&#123;        put(f[i],0);    &#125;    return 0;&#125;
 2. 升级分治 FFT
我们思考，分治 FFT 的过程依赖于 CDQ 来计算贡献。回顾整个过程，它总是按照下标的顺序来一次一次计算出答案。

既然我们要升级，借助这个 CDQ 分治的结构树，我们思考，假设我们询问位置的值的时候，允许对值进行一些修改？
那么稍加分析，发现如果我们进行了修改，修改是有效的，因为我们 CDQ 在分治计算贡献的时候显然会把这个贡献在回溯分治树的时候依次计算到后面，大区间的贡献就包含了我们修改后的贡献。并且发现复杂度是正确的 O(log2n)O(log^2 n)O(log2n)。

也就是说，CDQ 递归的任意层，修改当前层左半区间的 fff 值，是有效且可行的，这样该层的卷积贡献会重新计算（局部 FFT），然后这个修改会继续往更上层递归传播，沿着递归树路径逐层更新。
更进一步！我们尝试把 ggg 也给修改！
发现不行，因为 ggg 的贡献一个一个改的话是让整个递归树贡献受到影响时间复杂度 O(n)O(n)O(n) 了。
不过还好，我们发现分治 FFT 可以通过小范围的修改来支持添加删除贡献的的操作，这个操作相当于将分治 FFT 进一步的升级了，恭喜你，你的分治 FFT 升级为了：半在线卷积。
半在线卷积的半在线是什么意思呢？回看我们的 CDQ 分治过程，前半段结果在递推时即时产生，后半段则依赖前半段，用分治+FFT一次性批量算出。所以叫“半在线”，是因为它的依赖关系是在线的（必须先知道前面的 fff 才能算后面的），但计算方式是批量的（一次 FFT 更新一大段），不像纯在线卷积那样每步只更新一个元素。
不叫在线，是因为 fif_ifi​ 仍然是按顺序被解锁的，在计算 fmidf_{mid}fmid​ 之前，f&lt;midf_{&lt;mid}f&lt;mid​ 已经全部算出来，可以被使用；但右半段的贡献是一次性批量算的，不是每次求一个 fif_ifi​ 就更新一次卷积结果，所以它不是完全在线的。
有一道 DP 例题，供大家练练手：CF553E。
 3. 例题
CF553E
考虑倒着 DP，设 f(i,j)f(i,j)f(i,j) 表示第 iii 个点走到 nnn，当前时间为 jjj 的期望。有转移：
f(u,j)=min⁡v∈son(i){∑kf(v,j+k)⋅pu,k}+wif(u,j)=\min_{v\in son(i)} \{ \sum_{k} f(v,j+k)\cdot p_{u,k} \}+w_i
f(u,j)=v∈son(i)min​{k∑​f(v,j+k)⋅pu,k​}+wi​
末状态 f(u,i)=dis(u,n)+x,i&gt;tf(u,i)=dis(u,n)+x,i&gt;tf(u,i)=dis(u,n)+x,i&gt;t，f(n,i)=0,i≤tf(n,i)=0,i\le tf(n,i)=0,i≤t
时间复杂度 O(nt2)O(nt^2)O(nt2)，无法通过，考虑优化，发现一堆优化板子都套不上去，但是发现 FFT 可以套上去。考虑 FFT 优化，但是注意到这个玩意差卷积不能卷因为这玩意是半在线的。考虑分治 FFT，但是对什么进行分治呢？考虑分析转移方程，注意到方程中时间的转移时具有顺序的，可以进行 CDQ。不妨对时间一维分治。
具体的，记 g(u,v),jg_{(u,v),j}g(u,v),j​ 来表示 ∑k=1tp(u,v),k×f(v,j+k)\sum_{k=1}^t p_{(u,v),k} \times f(v,j+k)∑k=1t​p(u,v),k​×f(v,j+k)，用 f→gf \to gf→g，在分治底层计算出 f(u,j)=min⁡v∈son(i){∑kf(v,j+k)⋅pu,k}+wif(u,j)=\min_{v\in son(i)} \{ \sum_{k} f(v,j+k)\cdot p_{u,k} \}+w_if(u,j)=minv∈son(i)​{∑k​f(v,j+k)⋅pu,k​}+wi​，时间复杂度 O(mtlog⁡2t)O(mt\log^2 t)O(mtlog2t)。
好消息是又学会了一个科技。
反思：DP 优化不仅仅可以从状态优化和一类特殊的转移优化，也可以通过转移的顺序进行优化。
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>区间前缀最大值（线段树）</title>
    <url>/posts/973cfd72/</url>
    <content><![CDATA[****# 0.前言

前缀最大值就是指从序列开头到某个位置，所有元素的最大值喵~    ——Deepseek

即如下
max⁡j=1iaj\max\limits_{j=1}^i a_j
j=1maxi​aj​
比如序列 [3,1,4,1,5][3, 1, 4, 1, 5][3,1,4,1,5]，它的前缀最大值序列就是 [3,3,4,4,5][3, 3, 4, 4, 5][3,3,4,4,5]。
 1.正文
看如下题
P4198

小A在平面上(0,0)点的位置，第i栋楼房可以用一条连接(i,0)和(i,Hi)的线段表示，其中Hi为第i栋楼房的高度。如果这栋楼房上任何一个高度大于0的点与(0,0)的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。
施工队的建造总共进行了M天。初始时，所有楼房都还没有开始建造，它们的高度均为0。在第i天，建筑队将会将横坐标为Xi的房屋的高度变为Yi(高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做)。请你帮小A数数每天在建筑队完工之后，他能看到多少栋楼房？

我们把样例画出来，左图任何情况下都只为1，第二种为2。

题目问的是线段不相交即可，而且又连向原点，我们可以考虑正比例函数的关系式$$y=kx$$
那么对于线段相交，只需要判断k1≥k2k_{1\ge}k_2k1≥​k2​是否成立即可（我们设1节点在2节点之前），若成立，则第二个点被覆盖不能看到。
那么我们可以将问题转化为求最长递增的斜率序列（注意这里不是最长上升子序列！），而且原题有单点修改斜率这一操作，并且求[1,n][1,n][1,n]的答案，我们显然可以想到线段树维护这一数据结构。
我们怎么设计呢，我们可以线段树节点维护2个信息，第一个显然是最长递增的斜率序列长度，第二个是当前序列的最大值。
建树和easy，但…pushup不会写啊！
如果直接合并2个区间，那么一定会炸。所有O(1)O(1)O(1)的合并肯定会爆炸。

我们如何合并最长递增序列？显然第一项肯定在这个序列里，区间最大值一定在这里面。
2个子区间的值已经处理好了，可知左儿子内序列每一项一定在这个大区间内（因为如果左边不选那么右边肯定都会被覆盖啊）所以只需要处理右儿子区间和左儿子区间最大值的关系。这个值（我们设lmaxlmaxlmax）当作右儿子区间选出的节点的值必须大于lmaxlmaxlmax。
我们设计一个queryqueryquery函数用于处理：

如果l==rl==rl==r，那么是叶子节点，如果val&gt;lmaxval&gt;lmaxval&gt;lmax，则返回1，否则返回0
劈2半，设lslsls区间与rsrsrs区间

如果ls.max&lt;lmaxls.max&lt;lmaxls.max&lt;lmax，那么左孩子肯定都被覆盖了，去右孩子找。
如果ls.max&gt;lmaxls.max&gt;lmaxls.max&gt;lmax，那么右孩子在序列中的值一定会被贡献上，递归左孩子。注意右孩子的贡献是root.len−ls.lenroot.len-ls.lenroot.len−ls.len，因为右孩子的最长序列中所有值不一定都在这个根节点的序列中存在。看下图：




那么query函数如下:
int query(int p,double maxx)&#123;    if(maxx&gt;=t[p].mk) return 0;    if(t[p].l==t[p].r)&#123;        return t[p].mk&gt;maxx;    &#125;    else if(t[ls].mk&lt;=maxx)&#123;        return query(rs,maxx);    &#125;else return query(ls,maxx)+t[p].sum-t[ls].sum;&#125;
pushup也就像上文那么写：
void pushup(int p)&#123;    t[p].mk=max(t[ls].mk,t[rs].mk);    t[p].sum=t[ls].sum+query(rs,t[ls].mk);&#125;
那么代码单点修改也很好写，那么所有代码也就如下，注意一下浮点数：
#include&lt;bits/stdc++.h&gt;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1using namespace std;const int MN=1e5+15;int n,m;struct segtree&#123;    int l,r,sum;    double mk;&#125;t[MN&lt;&lt;2];void build(int p,int l,int r)&#123;    t[p].l=l;    t[p].r=r;    if(l==r)&#123;        return;    &#125;    int mid=l+r&gt;&gt;1;    build(ls,l,mid);    build(rs,mid+1,r);&#125;int query(int p,double maxx)&#123;    if(maxx&gt;=t[p].mk) return 0;    if(t[p].l==t[p].r)&#123;        return t[p].mk&gt;maxx;    &#125;    else if(t[ls].mk&lt;=maxx)&#123;        return query(rs,maxx);    &#125;else return query(ls,maxx)+t[p].sum-t[ls].sum;&#125;void pushup(int p)&#123;    t[p].mk=max(t[ls].mk,t[rs].mk);    t[p].sum=t[ls].sum+query(rs,t[ls].mk);&#125;void change(int p,int pos,double k)&#123;    if(t[p].l==t[p].r)&#123;        t[p].sum=1;        t[p].mk=k;        return;    &#125;    int mid=t[p].l+t[p].r&gt;&gt;1;    if(mid&gt;=pos) change(ls,pos,k);    else change(rs,pos,k);    pushup(p);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    build(1,1,n);    int fl,fr;    while (m--)    &#123;        cin&gt;&gt;fl&gt;&gt;fr;        change(1,fl,(double)fr/fl);        cout&lt;&lt;t[1].sum&lt;&lt;&#x27;\n&#x27;;    &#125;        return 0;&#125;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>区间最大字段和问题（线段树）</title>
    <url>/posts/64da72f3/</url>
    <content><![CDATA[ 吉司机线段树
 0.吉司机的前言


 1.介绍
吉司机线段树主要用于2件事，一个是区间最值修改，一个是区间历史最值维护。
 2.区间最值

给定一个长度为n的数列A，接着有m次操作

区间[l,r]中所有数变为min(Ai,x)min(A_i,x)min(Ai​,x)
询问区间[l,r]和
使用O(nlog⁡n)数据结构O(n\log n)数据结构O(nlogn)数据结构


用线段树解题一般我们使用lazytag来实现高效的时间复杂度。但是本题怎么设计？如果用一个tag处理区间最值，另一个处理区间和，但是这个和修改区间最值没有任何直接关系，不能这么简单处理。
吉司机线段树将这一类区间最值进行了通用转化方法，时间复杂度达到了O(nlog⁡n)O(n\log n)O(nlogn)。首先维护如下标记

区间最大值mx
区间最大值出现次数mxcnt
区间次大值se
区间和sum

考虑区间最值修改操作，即用min(Ai,x)min(A_i,x)min(Ai​,x)替换区间[L,R][L,R][L,R]的每个节点aia_iai​，首先找到对应区间，让后暴力搜索，我们搜到某个节点时，会分成以下三种情况。

当x≥mxx\ge mxx≥mx，显然这次修改不影响该节点，return
当se&lt;x≤mxse&lt;x\le mxse&lt;x≤mx，这次操作影响她的最大值，那么sum=sum−(mx−x)×mxcntsum=sum-(mx-x)\times mxcntsum=sum−(mx−x)×mxcnt
当x≤sex\le sex≤se，这个时候就不能直接修改了，只能递归左右儿子，让后在pushup中解决

上述算法的关键就是次大值，起到了剪枝的关键作用。
这个的时间复杂度是O(nlog⁡n)O(n\log n)O(nlogn) 。
 3.历史最值

直接上板子题罢
线段树3——区间最值，区间历史最值

给出一个长度为 nnn 的数列 AAA，同时定义一个辅助数组 BBB，BBB 开始与 AAA 完全相同。接下来进行了 mmm 次操作，操作有五种类型，按以下格式给出：


1 l r k：对于所有的 i∈[l,r]i\in[l,r]i∈[l,r]，将 AiA_iAi​ 加上 kkk（kkk 可以为负数）。
2 l r v：对于所有的 i∈[l,r]i\in[l,r]i∈[l,r]，将 AiA_iAi​ 变成 min⁡(Ai,v)\min(A_i,v)min(Ai​,v)。
3 l r：求 ∑i=lrAi\sum_{i=l}^{r}A_i∑i=lr​Ai​。
4 l r：对于所有的 i∈[l,r]i\in[l,r]i∈[l,r]，求 AiA_iAi​ 的最大值。
5 l r：对于所有的 i∈[l,r]i\in[l,r]i∈[l,r]，求 BiB_iBi​ 的最大值。

对于前四种操作，我们完全可以和上面那个题写起来一模一样，而操作瓶颈在于5。
我们观察一下tag的变化，tag的变化可能变大也可能变小，但在下传的时候当前节点儿子的值是不会改变的。
那么也就是说：只有当tag达到最大的时候，下传才能让儿子达到最大
那么也就是说，我们可以记录一个最大的懒标记。
如何下传？我们应当先更新maxbmaxbmaxb再更新maxamaxamaxa，先更新最大懒标记在更新懒标记。
让后就没有让后了…
#include &lt;bits/stdc++.h&gt;#define ls p &lt;&lt; 1#define rs p &lt;&lt; 1 | 1#define ll long longusing namespace std;constexpr int MN = 5e6 + 15, NINF = -2e9;template &lt;typename type&gt;inline void read(type &amp;x)&#123;    x = 0;    bool flag(0);    char ch = getchar();    while (!isdigit(ch))        flag = ch == &#x27;-&#x27;, ch = getchar();    while (isdigit(ch))        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar();    flag ? x = -x : 0;&#125;int n, m;struct segtree&#123;    ll sum;    int l, r, maxa, maxb, se, mxcnt;    int add1, add2, mxadd1, mxadd2;&#125; t[MN &lt;&lt; 2];void pushup(int p)&#123;    t[p].sum = t[ls].sum + t[rs].sum;    t[p].maxa = max(t[ls].maxa, t[rs].maxa);    t[p].maxb = max(t[ls].maxb, t[rs].maxb);    if (t[ls].maxa == t[rs].maxa)    &#123;        t[p].se = max(t[ls].se, t[rs].se);        t[p].mxcnt = t[ls].mxcnt + t[rs].mxcnt;    &#125;    else if (t[ls].maxa &gt; t[rs].maxa)    &#123;        t[p].se = max(t[ls].se, t[rs].maxa);        t[p].mxcnt = t[ls].mxcnt;    &#125;    else    &#123;        t[p].se = max(t[ls].maxa, t[rs].se);        t[p].mxcnt = t[rs].mxcnt;    &#125;&#125;void build(int p, int l, int r)&#123;    t[p].l = l, t[p].r = r;    if (l == r)    &#123;        read(t[p].maxa);        t[p].sum = t[p].maxb = t[p].maxa;        t[p].se = NINF;        t[p].mxcnt = 1;        return;    &#125;    int mid = l + r &gt;&gt; 1;    build(ls, l, mid);    build(rs, mid + 1, r);    pushup(p);&#125;void doit(int k1, int k2, int k3, int k4, int p)&#123;    // 更新历史最大值    t[p].maxb = max(t[p].maxb, t[p].maxa + k3);    // 更新当前最大值    t[p].maxa += k1;    // 更新区间和    t[p].sum += 1ll * k1 * t[p].mxcnt + 1ll * k2 * (t[p].r - t[p].l + 1 - t[p].mxcnt);    // 更新次大值    if (t[p].se != NINF)        t[p].se += k2;    // 更新标记    t[p].mxadd1 = max(t[p].mxadd1, t[p].add1 + k3);    t[p].mxadd2 = max(t[p].mxadd2, t[p].add2 + k4);    t[p].add1 += k1;    t[p].add2 += k2;&#125;void pushdown(int p)&#123;    int maxn = max(t[ls].maxa, t[rs].maxa);    if (t[ls].maxa == maxn)    &#123;        doit(t[p].add1, t[p].add2, t[p].mxadd1, t[p].mxadd2, ls);    &#125;    else    &#123;        doit(t[p].add2, t[p].add2, t[p].mxadd2, t[p].mxadd2, ls);    &#125;    if (t[rs].maxa == maxn)    &#123;        doit(t[p].add1, t[p].add2, t[p].mxadd1, t[p].mxadd2, rs);    &#125;    else    &#123;        doit(t[p].add2, t[p].add2, t[p].mxadd2, t[p].mxadd2, rs);    &#125;    t[p].add1 = t[p].add2 = t[p].mxadd1 = t[p].mxadd2 = 0;&#125;void updateadd(int p, int fl, int fr, ll k)&#123;    if (t[p].l &gt;= fl &amp;&amp; t[p].r &lt;= fr)    &#123;        t[p].sum += 1ll * k * (t[p].r - t[p].l + 1);        t[p].maxa += k;        t[p].maxb = max(t[p].maxb, t[p].maxa);        if (t[p].se != NINF)            t[p].se += k;        t[p].add1 += k;        t[p].add2 += k;        t[p].mxadd1 = max(t[p].mxadd1, t[p].add1);        t[p].mxadd2 = max(t[p].mxadd2, t[p].add2);        return;    &#125;    pushdown(p);    int mid = t[p].l + t[p].r &gt;&gt; 1;    if (mid &gt;= fl)        updateadd(ls, fl, fr, k);    if (mid &lt; fr)        updateadd(rs, fl, fr, k);    pushup(p);&#125;void updatemin(int p, int fl, int fr, int v)&#123;    if (v &gt;= t[p].maxa || t[p].l &gt; fr || t[p].r &lt; fl)        return;    if (t[p].l &gt;= fl &amp;&amp; t[p].r &lt;= fr &amp;&amp; v &gt; t[p].se)    &#123;        int k = t[p].maxa - v;        t[p].sum -= 1ll * k * t[p].mxcnt;        t[p].maxa = v;        t[p].maxb = max(t[p].maxb, v); // 更新历史最大值        t[p].add1 -= k;        return;    &#125;    pushdown(p);    updatemin(ls, fl, fr, v);    updatemin(rs, fl, fr, v);    pushup(p);&#125;ll querysum(int p, int fl, int fr)&#123;    if (t[p].l &gt;= fl &amp;&amp; t[p].r &lt;= fr)    &#123;        return t[p].sum;    &#125;    pushdown(p);    int mid = t[p].l + t[p].r &gt;&gt; 1;    ll res = 0;    if (mid &gt;= fl)        res += querysum(ls, fl, fr);    if (mid &lt; fr)        res += querysum(rs, fl, fr);    return res;&#125;int querymaxa(int p, int fl, int fr)&#123;    if (t[p].l &gt;= fl &amp;&amp; t[p].r &lt;= fr)    &#123;        return t[p].maxa;    &#125;    pushdown(p);    int res = NINF;    int mid = t[p].l + t[p].r &gt;&gt; 1;    if (mid &gt;= fl)        res = querymaxa(ls, fl, fr);    if (mid &lt; fr)        res = max(res, querymaxa(rs, fl, fr));    return res;&#125;int querymaxb(int p, int fl, int fr)&#123;    if (t[p].l &gt;= fl &amp;&amp; t[p].r &lt;= fr)    &#123;        return t[p].maxb;    &#125;    pushdown(p);    int res = NINF;    int mid = t[p].l + t[p].r &gt;&gt; 1;    if (mid &gt;= fl)        res = querymaxb(ls, fl, fr);    if (mid &lt; fr)        res = max(res, querymaxb(rs, fl, fr));    return res;&#125;int main()&#123;    read(n);    read(m);    build(1, 1, n);    int op, x, y, z;    while (m--)    &#123;        read(op);        read(x);        read(y);        if (op == 1)        &#123;            read(z);            updateadd(1, x, y, z);        &#125;        else if (op == 2)        &#123;            read(z);            updatemin(1, x, y, z);        &#125;        else if (op == 3)        &#123;            cout &lt;&lt; querysum(1, x, y) &lt;&lt; &#x27;\n&#x27;;        &#125;        else if (op == 4)        &#123;            cout &lt;&lt; querymaxa(1, x, y) &lt;&lt; &#x27;\n&#x27;;        &#125;        else if (op == 5)        &#123;            cout &lt;&lt; querymaxb(1, x, y) &lt;&lt; &#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列优化DP</title>
    <url>/posts/d87cf644/</url>
    <content><![CDATA[ 0.前言
本文章例题出自于蓝书，优化方案来自许多博客（但我忘了呜呜呜）
 1.单调队列概念与怎么优化
单调队列，我们先来看他是用来干什么的。

单调队列主要用于维护两端指针单调不减的区间最值。  ——oiwiki

对于一般的特殊DP方程，我们可以进行优化。
他优化的是下面的一类DP方程，其中：
得到的方程：f[i]=min⁡L(i)≤j≤R(i)(f[j]+a[i]+b[j])\text{得到的方程：}  f[i]=\min\limits_{L(i)\le j \le R(i)}{(f[j]+a[i]+b[j])} 
得到的方程：f[i]=L(i)≤j≤R(i)min​(f[j]+a[i]+b[j])
因为i是外层循环定值，变形为：f[i]=min⁡L(i)≤j≤R(i)(f[j]+b[j])+a[i]\text{因为i是外层循环定值，变形为：} f[i]=\min\limits_{L(i)\le j \le R(i)}(f[j]+b[j])+a[i]
因为i是外层循环定值，变形为：f[i]=L(i)≤j≤R(i)min​(f[j]+b[j])+a[i]
其中min可以替换为max
设ds[j]=f[j]+b[j]ds[j]=f[j]+b[j]ds[j]=f[j]+b[j]，因为ds[j]ds[j]ds[j]与 iii 完全无关，所以有下式：
f[i]=min⁡L(i)≤j≤R(i)(ds[j])+a[i]f[i]=\min\limits_{L(i)\le j \le R(i)}(ds[j])+a[i]
f[i]=L(i)≤j≤R(i)min​(ds[j])+a[i]
由于ds[j]ds[j]ds[j]仅与jjj有关，与iii无关，那么我们只需要算一遍ds[j]ds[j]ds[j]就可以用于全部的f[i]f[i]f[i]计算，不用一个一个去枚举。
朴素的想法是每一次遍历iii的时候取计算min⁡L(i)≤j≤R(i)(ds[j])\min\limits_{L(i)\le j \le R(i)}(ds[j])L(i)≤j≤R(i)min​(ds[j])，但是这里有大量的重复计算，我们可以用单调队列优化这个计算，可以观察到j∈[L(i),R(i)]j\in [L(i),R(i)]j∈[L(i),R(i)]是一个滑动窗口，我们可以维护滑动窗口上的最值。

如果是求最小，我们应维护的是ds[j]ds[j]ds[j]单调上升的单调队列
如果是求最大，我们应维护的是ds[j]ds[j]ds[j]单调下降的单调队列

如何维护？我们把计算出来的值一个一个压进单调队列，

如果是当前的最值，前面计算和不在范围的我们要全部弹走。
若要最值，队首就是最值。
加入新决策时，先检查加入后是否满足单调性，处理完后那我们放进队尾

这样，队首即为我们想要的ds[j]ds[j]ds[j]。让后就可以更新f[i]f[i]f[i]，这样，我们从朴素的O(n2)O(n^2)O(n2)变为了O(n)O(n)O(n)。
ds[j]ds[j]ds[j]的值计算必须与iii完全无关！
第二个就是方程中某些具有单调性，可以根据性质发掘出来。
我们来看例题
 1.例题引入
P10978

有一段长度为 nnn 的序列和 mmm 个人，每个位置只能染色一次，每个人都有一个位置。这些人可以选择一段长度不超过 LiL_iLi​ 并且包括自己位置SiS_iSi​的一段区间进行染色。每个人对一个位置的贡献是 PiP_iPi​ 。求最大贡献。
数据范围：1≤n≤100,1≤m≤160001\le n\le 100,1\le m\le 160001≤n≤100,1≤m≤16000

我们先根据SiS_iSi​进行排序，这样的话每个人染色的区间一定在上一个工匠粉刷的区间之后，这样就可以线性DP了！
不难有状态f(i,j)f(i,j)f(i,j)表示前iii个人染色[1,j][1,j][1,j]（可以有空着不刷，没说必须刷完）能获得的最大报酬。
不难有转移方程：

不染色罚坐，有f(i,j)=f(i−1,j)f(i,j)=f(i-1,j)f(i,j)=f(i−1,j)
第jjj个点可以不刷，有f(i,j)=f(i,j−1)f(i,j)=f(i,j-1)f(i,j)=f(i,j−1)
第iii个人刷[k+1,j][k+1,j][k+1,j]，根据题目条件有区间长度len≤Lilen\le L_ilen≤Li​且Si∈[k+1,j]S_{i }\in[k+1,j]Si​∈[k+1,j]。也就是说k+1≤Si≤j并且j−k≤Lik+1\le S_{i}\le j \text{并且} j-k\le L_ik+1≤Si​≤j并且j−k≤Li​ ，我们变变形，就有如下转移方程：

f(i,j)=max⁡j−Li≤k≤Si−1f(i−1,k)+Pi×(j−k),其中j≥Sif(i,j)=\max\limits_{j-L_{i} \le k \le S_i-1}{f(i-1,k)+P_{i}\times (j-k)},\text{其中}j\ge S_i
f(i,j)=j−Li​≤k≤Si​−1max​f(i−1,k)+Pi​×(j−k),其中j≥Si​
我们观察第三个式子，我们和上面的式子来做个比较：
f[i]=min⁡L(i)≤j≤R(i)(f[j]+a[i]+b[j])f[i]=\min\limits_{L(i)\le j \le R(i)}{(f[j]+a[i]+b[j])}
f[i]=L(i)≤j≤R(i)min​(f[j]+a[i]+b[j])
我们发现这个式子十分甚至九分的详细，我们可以仿照上面把Pi×jP_{i} \times jPi​×j提出来，因为在这里我们朴素用3层循环，在循环kkk的时候jjj是不变的，故可以提出来。
变形后：f(i,j)=Pi×j+max⁡j−Li≤k≤Si−1(f(i−1,k)−Pi×k),其中j≥Si\text{变形后：}f(i,j)=P_{i} \times j + \max\limits_{j-L_{i} \le k \le S_i-1}{(f(i-1,k)-P_{i}\times k}),\text{其中}j\ge S_i
变形后：f(i,j)=Pi​×j+j−Li​≤k≤Si​−1max​(f(i−1,k)−Pi​×k),其中j≥Si​
当jjj增大时，kkk的上界Si−1S_i-1Si​−1不变，下界j−Lij-L_ij−Li​变大。那么这个就很像一个滑动窗口，特殊点就在于是一个左端点不断减小，右端点不变的滑动窗口。我们可以维护一个kkk单调递增，f(i−1,k)−Pi×kf(i-1,k)-P_{i}\times kf(i−1,k)−Pi​×k单调递减的一个
如何维护？

当jjj变大，检查队头，把之前计算过的小于j−Lij-L_ij−Li​的决策出队。
查询最优的f(i−1,k)−Pi×kf(i-1,k)-P_{i}\times kf(i−1,k)−Pi​×k，我们只需要查队头就行，因为维护的是单调递减的滑动窗口。
当要添加新决策，在队尾先检查f(i−1,k)−Pi×kf(i-1,k)-P_{i}\times kf(i−1,k)−Pi​×k单调性让后在加入

很开头我们提出的维护单调队列的方法十分的相似。
对于本题来说，当开始循环jjj的时候，建立一个空单调队列，先把[max(Si−Li)，Si−1][max(S_i-L_i)，S_i-1][max(Si​−Li​)，Si​−1]的决策依次加入候选集合，让后检查决策合法性，取队头转移，每个决策至多进入弹出1次，故时间复杂度均摊O(1)O(1)O(1)，故时间复杂度O(nm)O(nm)O(nm)。
代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=16005;struct node&#123;    int l,p,s;&#125;a[MN];int n,m;int f[MN][MN],q[MN];bool cmp(node x,node y)&#123;    return x.s&lt;y.s;&#125;int calc(int i,int k)&#123;    return f[i-1][k]-a[i].p*k;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;a[i].l&gt;&gt;a[i].p&gt;&gt;a[i].s;    &#125;    sort(a+1,a+1+m,cmp);//先排序    for(int i=1;i&lt;=m;i++)&#123;        int l=1,r=0;        for(int k=max(0,a[i].s-a[i].l);k&lt;=a[i].s-1;k++)&#123;            // 加决策并维护里面的单点递减            while(l&lt;=r&amp;&amp;calc(i,q[r])&lt;=calc(i,k)) r--;            q[++r]=k;        &#125;        for(int j=1;j&lt;=n;j++)&#123;            f[i][j]=max(f[i-1][j],f[i][j-1]);//罚坐与不涂            if(j&gt;=a[i].s)&#123;//如果当前j可以进行第三个转移方程                while(l&lt;=r&amp;&amp;q[l]&lt;j-a[i].l)&#123;//排除过时决策                    l++;                &#125;                if(l&lt;=r)&#123;//如果队不为空，转移                    f[i][j]=max(f[i][j],calc(i,q[l])+a[i].p*j);                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;f[m][n];    return 0;&#125;
请读者阅读完本题题解后和最开始我们提出的优化方法进行比较，观察其思想是如何体现的。
 2.单调队列优化多重背包
是是是我知道你会二进制优化，但是我要是限制复杂度O(nm)O(nm)O(nm)你又不会了。
这一部分教学借鉴了知乎宫水三叶的讲解

给定nnn种物品，第iii种物品的体积为ViV_iVi​，价值为WiW_iWi​，并且有CiC_iCi​个，背包容积MMM，要求选若干个物品进背包，确保背包不会炸掉的情况下价值总和最大。

首先还是用类似于01背包单维空间的定义：f[i]f[i]f[i]代表容量不超过iii的最大价值
目标：f[m]f[m]f[m]
朴素的转移想法，我们遍历当前容量能够装多少件该物品，让后从所有情况中取最优。

但事实上，转移只会发生在「对当前物品体积取余相同」的状态之间。——宫水三叶

例如我们遍历1→101\rightarrow 101→10，物品价值和体积均为2，数量为3，发现有如下规律：

f[10]f[10]f[10]由f[8],f[6],f[4]f[8],f[6],f[4]f[8],f[6],f[4]转移过来
f[9]f[9]f[9]由f[7],f[5],f[3]f[7],f[5],f[3]f[7],f[5],f[3]转移过来
…\dots…
f[5]f[5]f[5]由f[3],f[1]f[3],f[1]f[3],f[1]转移过来
f[3]f[3]f[3]由f[1]f[1]f[1]转移过来
f[2]f[2]f[2]由f[0]f[0]f[0]转移过来

即某个状态f[x]f[x]f[x]由Vimod  xV_{i}\mod xVi​modx转移过来（ViV_iVi​为体积，xxx即背包容量），并且比iii小，数量不超过物品个数的状态值所更新。
那么，我们可以把倒序循环jjj改为对每个余数u∈[0,Vi−1]u\in[0,V_i-1]u∈[0,Vi​−1]，倒序循环p=⌊(M−u)/Vi​⌋→0p=⌊(M-u)/V_i​⌋\rightarrow 0p=⌊(M−u)/Vi​​⌋→0，对应的状态就是j=u+p×Vij=u+p\times V_ij=u+p×Vi​，不难有状态转移方程
f[j]=max⁡p−Ci≤k≤p−1(f[u+k×Vi]+(p−k)×Wi)f[j]=\max\limits_{p-C_{i} \le k \le p-1}(f[u+k\times V_i]+(p-k)\times W_i)
f[j]=p−Ci​≤k≤p−1max​(f[u+k×Vi​]+(p−k)×Wi​)
不难发现这个转移方程和上一题几乎一模一样，处理方法也是同理的，那么细节就不说了，代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=150,MM=1e5+15;int n,m;int v[MN],w[MN],c[MN];int q[MM],f[MM];int clac(int i,int u,int k)&#123;    return f[u+k*v[i]]-k*w[i];&#125;int main()&#123;    memset(f,128,sizeof(f));    f[0]=0;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;c[i];        for(int u=0;u&lt;v[i];u++)&#123;            int l=1,r=0;            int maxp=(m-u)/v[i];            for(int k=maxp-1;k&gt;=max(maxp-c[i],0);k--)&#123;                while(l&lt;=r&amp;&amp;clac(i,u,q[r])&lt;=clac(i,u,k)) r--;                q[++r]=k;            &#125;            for(int k=maxp;k&gt;=0;k--)&#123;                while(l&lt;=r&amp;&amp;q[l]&gt;k-1)l++;                if(l&lt;=r) f[u+k*v[i]]=max(f[u+k*v[i]],clac(i,u,q[l])+k*w[i]);                if(k-c[i]-1&gt;=0)&#123;                    while(l&lt;=r&amp;&amp;clac(i,u,q[r])&lt;=clac(i,u,k-c[i]-1))r--;                    q[++r]=k-c[i]-1;                &#125;            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=m;i++)&#123;        ans=max(ans,f[i]);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 3.另一道例题洛谷P2569

通过一段时间的观察，lxhgww\text{lxhgww}lxhgww 预测到了未来 TTT 天内某只股票的走势，第 iii 天的股票买入价为每股 APiAP_iAPi​，第 iii 天的股票卖出价为每股 BPiBP_iBPi​（数据保证对于每个 iii，都有 APi≥BPiAP_i \geq BP_iAPi​≥BPi​），但是每天不能无限制地交易，于是股票交易所规定第 iii 天的一次买入至多只能购买 ASiAS_iASi​ 股，一次卖出至多只能卖出 BSiBS_iBSi​ 股。
另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 WWW 天，也就是说如果在第 iii 天发生了交易，那么从第 i+1i+1i+1 天到第 i+Wi+Wi+W 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 MaxP\text{MaxP}MaxP。
在第 111 天之前，lxhgww\text{lxhgww}lxhgww 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，TTT 天以后，lxhgww\text{lxhgww}lxhgww 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？

不难有状态f(i,j)f(i,j)f(i,j)表示到了第iii天，手上持有第jjj份股票赚到最多的钱数。
目标：max⁡j=1maxpf[n][j]\max\limits_{j=1}^{maxp}f[n][j]j=1maxmaxp​f[n][j]
考虑1天共有4个决策，分别是凭空买（之前没买过股票），今天不交易，凭之前的基础买入和卖出。
那么状态转移方程也就如下：

凭空买：f(i,j)= −APi×j其中j≤ASif(i,j)=\,-AP_{i}\times j \quad \text{其中}j\le AS_if(i,j)=−APi​×j其中j≤ASi​
不交易：f(i,j)=max(f(i−1,j))其中j≤maxpf(i,j)=max(f(i-1,j))\quad \text{其中}j\le maxpf(i,j)=max(f(i−1,j))其中j≤maxp
买入：f(i,j)=max⁡j−ASi≤k≤jf(i−w−1,k)−APi×(j−k)其中j≤maxpf(i,j)=\max\limits_{j-AS_{i}\le k \le j}f(i-w-1,k)-AP_{i}\times (j-k) \quad \text{其中}j\le maxpf(i,j)=j−ASi​≤k≤jmax​f(i−w−1,k)−APi​×(j−k)其中j≤maxp
卖出：f(i,j)=max⁡j≤k≤j+BSif(i−w−1,k)+BPi×(j−k)其中j≤maxpf(i,j)=\max\limits_{j \le k \le j+BS_{i}}f(i-w-1,k)+BP_{i}\times (j-k) \quad \text{其中}j\le maxpf(i,j)=j≤k≤j+BSi​max​f(i−w−1,k)+BPi​×(j−k)其中j≤maxp

初始化全部为负无穷。
我们观察方程式，不难发现和之前还是一样的处理逻辑，把jjj提出来，里面的式子就变为了只和kkk有关的量，用单调队列优化即可。
故代码如下，想必你一定借助上面的代码能看懂，这里将不用提供注释了。
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=2015;struct youaremyidolQUEUE&#123;    int ap,bp,as,bs;&#125;d[MN];int f[MN][MN],n,m,w,q[MN],ql,qr;bool isnotokap(int i,int j,int k)&#123;    return f[i-w-1][k]+d[i].ap*k&lt;=f[i-w-1][j]+d[i].ap*j;&#125;bool isnotokbp(int i,int j,int k)&#123;    return f[i-w-1][k]+d[i].bp*k&lt;=f[i-w-1][j]+d[i].bp*j;&#125;int main()&#123;    memset(f,128,sizeof(f));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;//m为maxp    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;d[i].ap&gt;&gt;d[i].bp&gt;&gt;d[i].as&gt;&gt;d[i].bs;    &#125;    for(int i=1;i&lt;=n;i++)&#123;                for(int j=0;j&lt;=d[i].as;j++)&#123;            f[i][j]= -1*d[i].ap*j;                    &#125;        for(int j=0;j&lt;=m;j++)&#123;            f[i][j]=max(f[i][j],f[i-1][j]);        &#125;        if(i&lt;=w) continue;        ql=1,qr=0;        for(int j=0;j&lt;=m;j++)&#123;            while(ql&lt;=qr&amp;&amp;q[ql]&lt;j-d[i].as) ql++;            while(ql&lt;=qr&amp;&amp;isnotokap(i,j,q[qr]))&#123;                qr--;            &#125;            q[++qr]=j;            if(ql&lt;=qr)&#123;                f[i][j]=max(f[i-w-1][q[ql]]+q[ql]*d[i].ap-d[i].ap*j,f[i][j]);            &#125;        &#125;        ql=1,qr=0;        for(int j=m;j&gt;=0;j--)&#123;            while(ql&lt;=qr&amp;&amp;q[ql]&gt;j+d[i].bs) ql++;            while(ql&lt;=qr&amp;&amp;isnotokbp(i,j,q[qr]))&#123;                qr--;            &#125;            q[++qr]=j;            if(ql&lt;=qr)&#123;                f[i][j]=max(f[i-w-1][q[ql]]+q[ql]*d[i].bp-d[i].bp*j,f[i][j]);            &#125;        &#125;    &#125;    int ans=-2e9;    for(int i=0;i&lt;=m;i++)&#123;        ans=max(ans,f[n][i]);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 4.总结
在第一部分中我们提到的模型，实际上就是1D1D动态规划模型，就是类似于如下：
f(i)=min/max(g(j)+w(i,j))1≤j&lt;if(i)=min/max(g(j)+w(i,j))\quad 1\le j &lt; i
f(i)=min/max(g(j)+w(i,j))1≤j&lt;i
如果w(i,j)w(i,j)w(i,j)为一次函数，那么我们可以用单调队列进行优化。或者不是多项式但有单调性，我们也可以进行优化。
回忆LIS，我们发现他们有着类似的结构，但是为什么LIS不能用单调队列进行求解呢？这是因为其中有一个关系在a[j]&lt;a[i]a[j]&lt;a[i]a[j]&lt;a[i]，这个关系在成立的时候w=1w=1w=1否则w=0w=0w=0，不难看出违反了上面的最重要的一条，www必须与iii无关。
那么这个题怎么解呢，我们可以使用DP+二分的方法进行求解，这样的时间复杂度就是O(nlogn)O(nlogn)O(nlogn)，感兴趣可以回看NOIP1999导弹拦截这道题，观察第一问的转移方程，思考为什么不能用单调队列求解，为什么使用二分，会有新收获。
在某些题中，1D/1D模型不在适用，就要自行取挖掘性质进行优化，例如P10977，就要发掘性质用堆（或multiset）和单调队列优化，可以看zhouruoheng的题解来理解发掘单调性的奥妙。
完结撒AC！
]]></content>
      <categories>
        <category>DP优化</category>
      </categories>
      <tags>
        <tag>DP优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论半家桶——从入门到门入从</title>
    <url>/posts/d788aa88/</url>
    <content><![CDATA[可能更洛谷的阅读体验
2025.6.27 花了一上午增添了新内容，翻新了威佐夫博弈证明。大幅更新了自己理解下的 SG 函数，添加了自己 yy 的 trick。

 0. 前言
对于在信息学竞赛中的博弈论，我们研究的是组合博弈问题。在实际考察中会结合其他知识点考察，例如动态规划或者贪心等，建立模型来解决问题。
本文建议读者看到模型后可以停下来思考思考，让后再看证明。
说半家桶是因为内容还不全，不能作为 OI 中的全家桶，但是足以应付一部分问题了。
而对于例题讲解来说，我更喜欢的方式就是在许多不同的题目中总结模型出来，并且会结合之前的知识点来进行讲解，所以建议是都研读 www。
有谁注意到标题其实有一个回文串了。
 1. 组合博弈与博弈基础
对于组合博弈，我们用两种类型：公平组合游戏和非公平组合游戏来区别，定义如下：
 1.1 公平组合与非公平组合
公平组合游戏：

由两名玩家交替行动；
任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；
游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

例如取数游戏，Nim 游戏等，是公平组合游戏，我们下文会提到。
而非公平组合游戏，即在某一确定状态下作出的决策集合与游戏者有关。例如国际象棋，五子棋等是非公平组合游戏，因为双方不能使用对方的棋子。
以上是 Oi-Wiki 的内容，可能很抽象，但是提取重点的来说：

公平组合游戏：可允许的操作和当前局面状态有关，而不和玩家有关（这样就很公平，因为和玩家无关啦）。
非公平组合游戏：可允许的操作与当前操作的玩家有关（因为和玩家有关，我不能动你的棋子，这显然很不公平 www）。

 1.2 先手，后手，必胜必输局面
本手，妙手，俗手。
接下来我们定义几个名词：

局面：我们把游戏过程中面临的状态我们称作为 “局面”。
先手：整局游戏第一个行动的。
后手：整局游戏第二个行动的。

这几个名词还是比较简单的。

必败局面：即无论采取任何行动都无法胜利，都会输掉游戏。
必胜局面：即在某一局面下存在某种行动，使得后手行动陷入必败局面。

注意其中名词加粗的部分。
 1.3 先手必胜与先手必败

先手必胜状态 ： 先手行动以后，可以让剩余的状态变成必败状态 留给对手。(即可以走到某一个必败状态)
先手必败状态 ： 不管怎么操作，都达不到必败状态，换句话说，如果无论怎么行动都只能达到一个先手必胜状态留给对手，那么对手（后手）必胜，先手必败。（即走不到任何一个必败状态）

有如下定理：

没有后继状态的状态是必败状态。
一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。
一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。

 1.4 必胜点与必败点
必败点，又称 PPP 点，表示前一个选手将取胜的点称作必败点。
必胜点，又称 NNN 点，表示下一个选手将取胜的点称作必胜点。

所有终结点都是必败点。
从任何必胜点操作，至少存在一种方案可以进入必败点。
无论如何操作，必败点只能进入必胜点（不然先手怎么赢）。

 2. 基本公平组合游戏
接下来我们看见一堆取东西的游戏 www。
 2.1 Nim 游戏

给定 nnn 堆物品，第 iii 堆物品有 aia_{i}ai​ 个。两名玩家分别行动，每次可以任选一堆，取出任意多个物品，可以一把取光但是不能不取。取走最后一个物品的人胜利。

Vim 游戏？
Nim 游戏没有平局，只有先手必胜和先手必败两种情况。我们有如下的判定定理来判定：

Nim 博弈先手必胜，当且仅当 a1xor⁡a2xor⁡…xor⁡an≠0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} \neq 0a1​xora2​xor…xoran​=0。

其中 xor⁡\operatorname{xor}xor 代表异或操作。
证明如下：
我们考虑，所有物品都被取光当然是一个必败局面（对手取走最后一件物品，已经取得胜利），此时 a1xor⁡a2xor⁡…xor⁡an=0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} = 0a1​xora2​xor…xoran​=0。
对于一个局面如果 a1xor⁡a2xor⁡…xor⁡an≠0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} \neq 0a1​xora2​xor…xoran​=0，那么设 xxx 二进制表示下最高位的 111 在第 kkk 位，那么至少存在一堆物品使得它的第 kkk 位为 111。显然 aixor⁡x&lt;aia_{i} \operatorname{xor} x &lt; a_{i}ai​xorx&lt;ai​，我们就从 aia_{i}ai​ 堆中取走若干物品，使其变为 aixor⁡xa_{i} \operatorname{xor} xai​xorx，这个操作我们就是尝试将局面变为 a1xor⁡a2xor⁡…xor⁡an=0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} = 0a1​xora2​xor…xoran​=0，容易证明这是最优策略。
对于任意一个局面，若 a1xor⁡a2xor⁡…xor⁡an=0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} = 0a1​xora2​xor…xoran​=0，容易证明无论如何取物品，最后的局面异或起来都无法不等于 000，那么综上所述 a1xor⁡a2xor⁡…xor⁡an≠0a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n} \neq 0a1​xora2​xor…xoran​=0，一定是必胜局面，一定存在一个情况让对手面临各堆物品异或起来为 000 的局面，证毕。
P2197 NIM游戏
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e5+15;int T,n;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        int ans=0;        for(int i=1;i&lt;=n;i++)&#123;            int x;            cin&gt;&gt;x;            ans^=x;        &#125;        if(ans) cout&lt;&lt;&quot;Yes\n&quot;;        else cout&lt;&lt;&quot;No\n&quot;;    &#125;    return 0;&#125;
 2.2 Nim升级版——NimK

nnn 堆石子，每次从不超过 kkk 堆中取任意多个石子，取走最后一个物品的人胜利。

结论如下：
把 nnn 堆石子用二进制数表示，统计二进制数上 111 的个数，若每一位上 111 的个数 num1 mod (k+1)num_{1} \bmod (k+1)num1​mod(k+1) 全部为 000，则先手必胜，否则先手必败。
证明还是类似于 Nim 游戏：

所有物品都被取光当然是一个必败局面，即全为 000。
任意一个先手必败状态，一次操作后必然会到达必胜状态（因为游戏是交替进行的。）在某一次移动中，至少有一堆被改变，也就是说至少有一个二进制位被改变。因为最多动 kkk 堆，所以对于任意一个二进制位，111 的个数最多改变 kkk。而由于原先的总数为 k+1k+1k+1 的整数倍，那么改变后必然不可能是 k+1k+1k+1 的整数倍。所以在必败状态下必然能转移到必胜状态。
而对于先手必胜，总有一种操作使其走到必败状态，即证明有一种方法让第 iii 位回到 k+1k+1k+1 的整数倍。有一个比较显然的性质，对于那些已经改变的 mmm 堆，当前位可以自由选择 1 或 0。我们设除去已经更改的 mmm 堆，剩下堆 iii 位上 111 的总和为 sumsumsum。考虑分类讨论：

sum≤k−msum\le k-msum≤k−m，此时我们可以将堆上的 111 全部拿掉，让后让拿 mmm 堆得 iii 位全部为 0。
sum&gt;k−msum&gt;k-msum&gt;k−m，此时我们在之前改变的 mmm 堆中选择 k+1−sumk+1-sumk+1−sum 堆，将他们的第 iii 位设置成 1。剩下的设置成 0。由于 k+1−sum&lt;k+1−(k−m)&lt;m+1k+1-sum&lt;k+1-(k-m)&lt;m+1k+1−sum&lt;k+1−(k−m)&lt;m+1,也就是说 k+1−sum≤mk+1-sum\le mk+1−sum≤m，故这是可以达到的。



故存在，证毕。
例题：SDOI2011黑白棋
 2.3 阶梯 Nim 游戏

nnn 堆石子，编号 1 到 nnn。初始第 nnn 堆石子数为 aia_{i}ai​，保证单调不降。轮流取石子，每次从任意一堆拿走任意个，要求取完后每一堆剩余石子个数单调不降（没有石子的记为 0 个），先不能行动者败。

或者换一种表述：

有 nnn 堆石子。除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作。每次操作可以从一堆石子中移走任意多颗石子，但是要保证操作后仍然满足初始时的条件。没有石子可移动的人就输掉了游戏。

因为堆数是单调递增的，像一个阶梯，我们在阶梯取石子。所以叫阶梯 Nim 游戏。
结论：

阶梯 nim 的游戏结果与只看奇数堆的石子数的普通 nim 结果一致。

考虑证明：
首先末态一定是 a1 xor⁡ a3 xor⁡ a5⋯=0a_{1} \operatorname{xor} a_{3} \operatorname{xor} a_{5}\dots=0a1​ xor a3​ xor a5​⋯=0， 那么如果初态 a1 xor⁡ a3 xor⁡ a5⋯=0a_{1} \operatorname{xor} a_{3} \operatorname{xor} a_{5}\dots=0a1​ xor a3​ xor a5​⋯=0，就一定存在一种方式将某奇数台阶的石子移动到偶数台阶上使得异或和为 0 。这样，不管后手的人是把奇数台阶的移动到偶数台阶还是相反，先手都一定存在一种方案使得异或和为 0 ,这样就一定能转移到末态，先手就赢了！
板题：
P3480
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1520;int T,n,a[MN],b[MN];void solve()&#123;    cin&gt;&gt;n;    int x=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        b[i]=a[i]-a[i-1];    &#125;    for(int i=n;i&gt;=1;i-=2) x^=b[i];    if(x) cout&lt;&lt;&quot;TAK\n&quot;;    else cout&lt;&lt;&quot;NIE\n&quot;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 2.4 巴什博弈 Bash Game
Bash 命令行？

只有一堆石子，个数为 nnn 个，两名玩家轮流在石子堆中拿石子，每次至少取 1 个，至多取 mmm 个，最后一个取走石子的玩家为胜者。

结论如下：
若 (m+1)∣n(m+1)|n(m+1)∣n，则先手必败，否则先手必胜。
证明如下：

当 n≤mn\le mn≤m 时，显然先手必胜。
当 n=m+1n=m+1n=m+1 时，先手最多取走 mmm 个，无论取走多少个后手必胜。
若 (m+1)∣n(m+1)|n(m+1)∣n，假设先手拿走 xxx 个，那么后手一定可以拿走 (m+1)−x(m+1)-x(m+1)−x 个，这样无论怎么拿剩下的石头个数都是 (m+1)(m+1)(m+1) 的倍数，那么最后一次取的石头一定还剩下 m+1m+1m+1 个，显然必败。否则，先手取走模 (m+1)(m+1)(m+1) 的手头，此时转化为 (m+1)∣n(m+1)|n(m+1)∣n，那么后手必败。

得证。
有板题：HDU4764
 2.5 威佐夫博弈

有两堆石子，石子数可以不同。两人轮流取石子，每次可以在一堆中取，或者从两堆中取走相同个数的石子，数量不限，取走最后一个石头的人获胜。判定先手是否必胜。

同步发表于：P2252题解
威佐夫博弈不同于Nim游戏与巴什博奕，它的特殊之处在于不能将两堆石子分开分析。
证明可以不看的 www。
因为只有两堆石子，先进行一步转化给他丢到二维坐标系上，那么坐标 (x,y)(x,y)(x,y) 就表示两堆的石子数量。
我们考虑观察性质，我们可以枚举几个必败状态，例如 (0,0),(1,2),(3,5),(4,7)……
我们观察状态，可以发现两个规律，我们假设从小到大排的第 kkk 个必败状态是 (x,y)(x,y)(x,y)，并且 x&lt;yx&lt;yx&lt;y。并且我们发现 y=x+ky=x+ky=x+k。这个说明的就是必败状态两个数的差值是递增的，所以也就说明了每一个必败状态的差值都各不相同。证明我们待会在来看。
那么原来的问题，我们可以把游戏转化为，棋盘上有一个点，每个人可以将棋子往下，向左或向左下移动若干的棋子，不能移动的人。能够一步移动到原点的点显然就是必胜点，假设我们给这些所有必胜点都染色的话，剩下的的没当中横纵坐标和最小的点就是下一个必败点，因为无论如何移动都会给对手留下一个必胜点。
我们借用梁唐的知乎博客的图，将必败点染色可以得到如下图：

从图中不难看出，必败点之间是无法一次移动就能得到的，换句话说可以一次移动到必败点的点都是必胜点，那么上图中除了必败点之外的点都是必胜点，并且每一个自然数必然只会被包含在一个必败状态之中。
那么根据图的一些奇妙性质，我们定义，先手必输的局势为奇异局势。不妨设 (x,y)(x,y)(x,y) 为第 kkk 个奇异局势。那么有如下性质：

xxx 为前 kkk 个奇异局势中最小没有出现过的正整数，y=x+ky=x+ky=x+k。
任何一个自然数都包含在有且仅有一个奇异局势中。
任何操作都会将奇异局势变成非奇异局势。（必胜必然走向必败）
可以采取适当的方法让非奇异局势变成奇异局势。（即必败走向必胜点）

第一个，考虑反证法，假设 (a,a+k),(b,b+k)(a,a+k),(b,b+k)(a,a+k),(b,b+k) 是必败状态，并且 a&lt;ba&lt;ba&lt;b。那么先手面临 (b,b+k)(b,b+k)(b,b+k) 的时候，只需要在两堆当中同时取走 b−ab-ab−a 个石子，那么给后手的局面就是 (a,a+k)(a,a+k)(a,a+k)。但是对于后手来说，这是一个必败的局面，那么 (b,b+k)(b,b+k)(b,b+k) 不就是必胜状态了吗，矛盾，所以不存在两个必败局面的差值相等。
第二个个证明考虑反证法，我们需要证明两点：

任意自然数都出现过。
任意自然数只出现一次。

证明如下：

反证法，如果 vvv 没有出现过，那么 vvv 显然可以做一个新奇异局势的 xxx。
反证法，假设 vvv 出现了两次，那么 vvv 一定不是所在奇异局势的 xxx，那么 vvv 只能同时是两个奇异局势的 yyy，但因为任意一个奇异局势的差值不相同，所以 vvv 不可能存在。

第三个，我们考虑若取走一堆中的石子，那么两对石子的差值会改变，必将成为非奇异局势。若同时取走，因为同一个差值只会对应一种奇异局势，必将成为非奇异局势。
第四个是显然的，不证明。
那么现在问题在于我们如何快速找出一个通项公式使得对于第 kkk 个必败局面，它的坐标是 (xk,yk)(x_{k},y_{k})(xk​,yk​) 呢？
我们有 Betty 定理！

设 a,ba,ba,b 是两个正无理数，且 1a+1b=1\dfrac{1}{a}+\dfrac{1}{b}=1a1​+b1​=1。
记 P={⌊a×n⌋∣n∈N+},Q={⌊b×n⌋∣n∈N+}P=\left\{ \lfloor a\times n \rfloor|n \in \mathbb{N}^{+} \right\},Q=\left\{ \lfloor b\times n \rfloor|n \in \mathbb{N}^{+} \right\}P={⌊a×n⌋∣n∈N+},Q={⌊b×n⌋∣n∈N+}，则 P∩Q=∅,P∪Q=N+P \cap Q=\varnothing,P \cup Q =\mathbb{N}^{+}P∩Q=∅,P∪Q=N+。

证明可以去网上看。
那不对啊，我们是自然数你这是无理数，你这八杆子打不着的东西拿出来用干啥啊。因为我们发现必败状态的通项和Betty定理序列很像。
我们不妨假设存在这样的 a,ba,ba,b 同时满足 Betty 定理和必败状态的性质，当然无理数不可能作为坐标出现啦，我们当然要让它变为整数。
那怎么办，Betty 有一个推论就是：

任何正整数都可刚好以一种形式表示为不大于其中一个无理数的正整数倍的最大整数。

从定理直接推，那么有如下式子：
{⌊a×n⌋+n=⌊b×n⌋1a+1b=1\begin{cases}
\lfloor a\times n\rfloor +n = \lfloor b\times n \rfloor \\
\frac{1}{a}+\frac{1}{b}=1
\end{cases}
{⌊a×n⌋+n=⌊b×n⌋a1​+b1​=1​
解第一个方程：
⌊b×n⌋=⌊a×n⌋+n=⌊a×n+n⌋=⌊(a+1)×n⌋∴b=a+1\begin{aligned}
\lfloor b\times n \rfloor  &amp; = \lfloor a\times n\rfloor +n \\

&amp; = \lfloor a\times n +n \rfloor \\
&amp; = \lfloor (a+1) \times n\rfloor \\

\therefore b &amp;= a+1
\end{aligned}
⌊b×n⌋∴b​=⌊a×n⌋+n=⌊a×n+n⌋=⌊(a+1)×n⌋=a+1​
那么代入第二个方程有：
1a+1a+1=1\frac{1}{a}+\frac{1}{a+1}=1
a1​+a+11​=1
开解！
1a+1a+1=11a=a+1a(a+1)1a+1=aa(a+1)∴a+1a(a+1)+aa(a+1)=1→2a+1a(a+1)=1∴2a+1=a(a+1)=a2+a∴2a+1−a2−a=0∴a2−a−1=0\begin{aligned}

&amp; \frac{1}{a} + \frac{1}{a+1}  = 1 \\
&amp; \frac{1}{a}  =\frac{a+1}{a(a+1)} \\
&amp; \frac{1}{a+1} = \frac{a}{a(a+1)} \\
&amp; \therefore \frac{a+1}{a(a+1)}+\frac{a}{a(a+1)}=1 \\

&amp; \to \frac{2a+1}{a(a+1)}=1 \\

&amp; \therefore 2a+1=a(a+1)=a^2 +a \\

&amp; \therefore 2a+1-a^2 -a =0 \\

&amp; \therefore a^2-a-1=0 

\end{aligned}
​a1​+a+11​=1a1​=a(a+1)a+1​a+11​=a(a+1)a​∴a(a+1)a+1​+a(a+1)a​=1→a(a+1)2a+1​=1∴2a+1=a(a+1)=a2+a∴2a+1−a2−a=0∴a2−a−1=0​
利用初中知识不难得出 a=1+52a=\dfrac{1+\sqrt{5}}{2}a=21+5​​ 或 1−52\dfrac{1-\sqrt{5}}{2}21−5​​。
完了吗？敢说完了的扣 114514 分 (≧m≦)

设 a,ba,ba,b 是两个正无理数，且 1a+1b=1\dfrac{1}{a}+\dfrac{1}{b}=1a1​+b1​=1。

正无理数！所以解为 a=1+52a=\dfrac{1+\sqrt{5}}{2}a=21+5​​。
综上，假设两堆石子为 (x,y),x&lt;y(x,y),x&lt;y(x,y),x&lt;y。
那么先手必败，当且仅当：
(y−x)×5+12=x(y-x) \times \frac{\sqrt{5}+1}{2}=x
(y−x)×25​+1​=x
其中，5+12\dfrac{\sqrt{5}+1}{2}25​+1​ 就是黄金分割数，很神奇的。
题目：P2252
#include&lt;bits/stdc++.h&gt;#define double long longusing namespace std;const double hjfg=((1.0+sqrt(5.0))/2.0);double a,b;int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    if(a&gt;b) swap(a,b);    double ans=(b-a)*((1.0+sqrtl(5.0))/2.0);    if(ans==a) cout&lt;&lt;0;    else cout&lt;&lt;1;    return 0;&#125;
 2.6 斐波那契博弈
有一堆个数为 n,(n≥2)n,(n\ge 2)n,(n≥2) 的石子，游戏双方轮流取石子，规则如下：

先手不能第一次全取完，至少取 111 颗。
之后每次取的石子个数至少为 111，至多为对手所取的石子数的 222 倍。

还是最后一个取走石子的为赢家。
先手必败，当且仅当石子数为斐波那契数
先证明必要性，斐波那契数一定先手必败，可以用数学归纳法，大致思路就是一定能拆成两堆斐波那契数，不论先手怎样取，后手总能取到最后一颗
然后证明充分性，由齐肯多夫定理定理：

任何正整数可以表示为若干个不连续的斐波那契数之和

那么这样就回到了斐波那契数列里，可以证明。
考虑最优决策：

若正整数 nnn 不为斐波那契数，那么用上述定理表示后，最小的那一堆个数即为答案。

证明因为不存在相邻的斐波那契数，那么显然有 fj&gt;2×fif_{j}&gt;2 \times f_{i}fj​&gt;2×fi​，只要我取第一个，那么对手一定取不完下一个，让后我捡漏，以此类推，一定能取道最后一个石子。
板题：P6847
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main()&#123;    int n;    cin&gt;&gt;n;    while(n)&#123;        if(n==1)&#123;            cout&lt;&lt;1;            break;        &#125;        if(n==2)&#123;            cout&lt;&lt;2;            break;        &#125;        int a=1,b=2,c=3;        while(c&lt;n) a=b,b=c,c=a+b;        if(c==n)&#123;            cout&lt;&lt;n;            break;        &#125;        n-=b;    &#125;    return 0;&#125;
 2.7 总结
有一张来自HansLimon的好图：

以上都是一些基本公平组合游戏，我们通过分析必胜状态与必败状态的位置来计算。接下来我们会介绍公平组合游戏的万能工具，SG 函数。
 3. SG与有向图游戏
 3.1 有向图游戏
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。 转化为有向图游戏，也称绘制了它的博弈状态图（简称博弈图或游戏图）。
而对于有向图游戏中的每一个节点，都代表当前子游戏的状态。
 3.2 Mex 运算
设 SSS 表示一个非负整数集合。定义 mex⁡(S)\operatorname{mex}(S)mex(S) 为求出不属于集合S的最小非负整数的运算，即：
mex⁡(S)=min⁡{x},x∈N+,x∉S\operatorname{mex}(S)=\min \left\{ x \right\},x\in \mathbb{N}^{+},x\notin S
mex(S)=min{x},x∈N+,x∈/S
mex⁡(S)\operatorname{mex}(S)mex(S) 的求法我们在做题中一般推式子用。如果真要单纯考，还真考过，可以考虑用 set 来实现，把 SSS 中的数都放入 set 中，维护两个操作：

加入 xxx 操作：在 set 删除 xxx，前提是 xxx 这个数出现第一次。
删除 xxx 操作：在 set 加入 xxx，前提是 xxx 是剩下的唯一一个 xxx。
查询操作：查询 setsetset 里的第一个数。

例题：abc330e
 3.3 SG 函数
在有向图游戏中，对于每个节点 xxx，设从 xxx 除法共有 kkk 条有向边，分别到达节点 y1,y2,…,yky_{1},y_{2},\dots ,y_{k}y1​,y2​,…,yk​，定义 SG⁡(x)\operatorname{SG}(x)SG(x) 表示为 xxx 的后继节点 y1,y2,…,yky_{1},y_{2},\dots ,y_{k}y1​,y2​,…,yk​ 的 SG⁡\operatorname{SG}SG 函数值所构成的集合再执行 mex⁡\operatorname{mex}mex 运算的结果，即：
SG⁡(x)=mex⁡({SG⁡(y1),SG⁡(y2),…,SG⁡(yk)})\operatorname{SG}(x)=\operatorname{mex}(\left\{ \operatorname{SG}(y_{1}),\operatorname{SG}(y_{2}),\dots,\operatorname{SG}(y_{k}) \right\})
SG(x)=mex({SG(y1​),SG(y2​),…,SG(yk​)})
特别的，整个有向图游戏 GGG 的 SG⁡\operatorname{SG}SG 函数值定义为有向图起点 sss 的 SG⁡\operatorname{SG}SG 函数值，即 SG⁡(G)=SG⁡(s)\operatorname{SG}(G)=\operatorname{SG}(s)SG(G)=SG(s)。
没错，你是不是发现了，SG 函数其实是递归求解的，，计算一个位置的 SG 值需要知道其所有后继位置的 SG 值。
 3.4 必胜与必败判定,SG 定理
判定法则（同时也是定义）如下：

有向图某个局面必胜，当且仅当该局面对应节点的 SG⁡\operatorname{SG}SG 函数值大于 000。
有向图某个局面必胜，当且仅当该局面对应节点的 SG⁡\operatorname{SG}SG 函数值等于 000。

凭什么我们这么规定！
那我们把前面我们所说的必胜点和必败点联系起来，对于 SG 函数的定义有：

终止状态（无合法移动）：SG⁡=0\operatorname{SG}=0SG=0（必败点，P-position）。
非终止状态：SG⁡(x)=mex⁡({SG⁡(y1),SG⁡(y2),…,SG⁡(yk)})\operatorname{SG}(x)=\operatorname{mex}(\left\{ \operatorname{SG}(y_{1}),\operatorname{SG}(y_{2}),\dots,\operatorname{SG}(y_{k}) \right\})SG(x)=mex({SG(y1​),SG(y2​),…,SG(yk​)})。

那么显然有：

SG⁡=0\operatorname{SG}=0SG=0：所有后续都是必胜点（都可以不走到终止状态），当前玩家无法避免失败。因此是必败点。
SG⁡≠0\operatorname{SG} \neq 0SG=0：至少有一个移动可使对手进入必败点，因为根据 mex⁡\operatorname{mex}mex 运算的性质 SG⁡=0\operatorname{SG}=0SG=0 出现了。因此是必胜点。

同时思考我们上面所说的 SG 函数的递归性质的计算，你有没有发现什么？
而根据上面我们所说的，有向图游戏是一个 DAG，并且节点状态唯一确定不重叠的。我们有没有想到什么，没错，动态规划的转移也是这样的！
动态规划当前问题由子问题确定当前解，而 SG 函数由子游戏的 SG 确定当前的解；SG 计算利用 DAG 的拓扑序计算（从终止反向递推），而动态规划状态转移也是 DAG 上的转移。当前节点的 SG
函数只依赖后续状态，而不依赖历史，也就是无后效性，这个 DP 同样也满足！
那么我们怎么利用 DP 的思想定义 SG 函数呢？

状态：就是有向图游戏上的一个局面。
转移：有向图游戏上的合法移动。
答案：即当前局面在最优策略下的的博弈论特征值（即 SG 函数或其他）

其实，SG函数的递归计算本质上就是在动态地判断每个状态是必胜还是必败，类似于在 DAG 上的动态规划过程，我们利用 mex⁡\operatorname{mex}mex 运算来保证 SG 函数的求解正确性。我们通过终止向前递推我们游戏的过程。
那么，根据上面我们所说的，SG 函数可以通过记忆化搜索避免重复计算（类似 DP 的记忆化搜索写法），或者通过常规的动态规划我们可以求解。那么，也就是说，通过动态规划的方法我们也是可以求解出博弈论的解，这个可是一大考点，我们把两大很难的内容融合到一起就会出现很多的考点，在接下来的博弈论应用这我们会详细的提到。
接下来我们来看有向图游戏的和，即 SG 定理，我们这么定义：
设 G1,G2,…,GmG_{1},G_{2},\dots,G_{m}G1​,G2​,…,Gm​ 是 mmm 个子有向图游戏。定义有向图游戏 GGG，它的行动规则是任选某个有向图游戏 GiG_{i}Gi​，并在 GiG_{i}Gi​ 上行动一步。GGG 被称为有向图游戏 G1,G2,…,GmG_{1},G_{2},\dots,G_{m}G1​,G2​,…,Gm​ 的和。
有向图游戏的和的 SG⁡\operatorname{SG}SG 函数值等于它包含的各个子游戏 SG⁡\operatorname{SG}SG 函数值的异或和，即：
SG⁡(G)=SG⁡(G1)xor⁡SG⁡(G2)xor⁡…SG⁡(Gm)\operatorname{SG}(G)= \operatorname{SG} (G_{1}) \operatorname{xor}  \operatorname{SG} (G_{2})\operatorname{xor} \dots \operatorname{SG} (G_{m})
SG(G)=SG(G1​)xorSG(G2​)xor…SG(Gm​)
这里给出一个性质，由 mex⁡\operatorname{mex}mex 得出某个状态的 SG 值一定在 O(m)O(\sqrt{m})O(m​) 以内，其中 mmm 为有向图游戏的边数。
 3.5 公平组合游戏为何结局注定？
下面的芝士了解即可。
你有没有好奇过，我们上面讲了那么多的基本公平组合游戏，为什么我们明明还没开始玩这个游戏，结局却已经命中注定了呢？
回顾我们之前所讲的公平组合游戏定义：

由两名玩家交替行动；
任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；
游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

为何公平？在我们组合游戏理论中，“公平” 指的是：

规则对称：双方玩家在同一个游戏状态下可用的移动完全相同（不像象棋或围棋，双方棋子不同）。
无随机性：游戏过程有玩家决策决定，没有抽牌的随机因素。
终止性：游戏必然在有限步数内结束，不会无限循环。
完全信息：没有隐藏信息，双方对游戏状态完全知晓。

而我们上面一直所提到的最优策略，采取最优策略其实决定了你的结局走向。那么最优策略到底是什么？为什么先手有必胜必输这种状态？这里我们揭秘：

策梅洛定理：在有限步、无随机性、完全信息的两人博弈中，必然存在一个确定的最优策略，使得先手或后手一方有必胜策略，或双方至少能强制平局。

证明？
考虑数学归纳法，设 nnn 是某一游戏的最大步长，比如我们下棋，玩很多很多次，其中最多回合的一次，是大战300回合后我赢了，那么 n=600n=600n=600 因为我们下了 600 次棋。对 nnn 进行数学归纳法：

当 n=1n=1n=1，显然，只用走一步，就可决定输赢。按照游戏的规定，也许有胜负和三种，那么玩家 1 显然选择胜的走法，于是满足玩家 1 有必胜策略。
假设当 i≤ni\le ni≤n 时命题成立，考虑 n+1n+1n+1 时的子游戏，除去玩家 1 走的第一步以后的游戏部分。玩家1第一步的每一种走法都会产生一个新游戏起始状态，它的最大步长是 ≤n\le n≤n 的，而根据我们的假设，每个子游戏有唯一确定的结果，玩家 1 必然会赢、输或者和。于是等价于 n=1n=1n=1 的情况了！相当于玩家 1 在第一步的时候来选择进入哪个游戏，是自己必赢还是必输还是必和。

综上，该结论对于所有正整数成立，证毕。
由于公平组合游戏通常没有平局（游戏以某一方无法移动结束），所以每个状态要么是必胜点，要么是必败点，我们的最优策略就是确保自己始终处于必胜点。，而我们通过 SG 函数和必胜必败点分析就能得出计算胜负的数学方法。

必胜策略：如果当前玩家处于 必胜点（N-position），则存在至少一个移动，使得对手进入 必败点（P-position）。那么我们始终选择让对手进入必败点的移动，即可确保胜利。
必败策略：- 如果当前玩家处于 必败点（P-position），则无论怎么移动，对手都能采取最优策略获胜。此时，最优策略是尽量拖延游戏，或希望对手犯错。

那么，根据定理，只要玩家遵循最优策略，结局就已被初始状态决定。奇怪的宿命论出现了！而最优策略就是利用 SG 函数或必胜/必败点分析，确保对手始终处于劣势。然而，理论上我们固定了，但是实际对局中玩家可能犯错，这个时候就要重新计算了，正如我们上面所提到的必胜点：存在至少一个。所以必胜点也可以走向必败点的。
综上，我们分析了为什么公平组合游戏结局注定，必胜必输状态是怎么出现的以及公平组合游戏的性质。
 3.6 NIM 游戏与 SG 函数的结合
对于单堆的 Nim 游戏，我们很容易计算它的 SG⁡\operatorname{SG}SG 值，设 SG⁡(m)\operatorname{SG}(m)SG(m) 表示剩余 mmm 个式子状态的函数值，显然 SG⁡(0)=0\operatorname{SG}(0)=0SG(0)=0，那么以此类推，SG⁡(1)=1,SG⁡(2)=2,…,SG⁡(n)=n\operatorname{SG}(1)=1,\operatorname{SG}(2)=2,\dots,\operatorname{SG}(n)=nSG(1)=1,SG(2)=2,…,SG(n)=n。因此，当石子数不为 000 时为必胜态。
而对于更多的，它们所有的堆都可以划分为一个单独的有向图游戏，而每一个有向图游戏的 SG⁡\operatorname{SG}SG 函数值就是上面所以到的。那么，我们可以根据 SG⁡\operatorname{SG}SG 定理，将它们给和起来，那么答案就是：
SG⁡(G)=SG⁡(G1)xor⁡SG⁡(G2)xor⁡…xor⁡SG⁡(Gn)=a1xor⁡a2xor⁡…xor⁡an\begin{aligned}
\operatorname{SG}(G) &amp; =\operatorname{SG}(G_{1}) \operatorname{xor} \operatorname{SG}(G_{2)} \operatorname{xor} \dots \operatorname{xor} \operatorname{SG}(G_{n}) \\

&amp; = a_{1} \operatorname{xor} a_{2} \operatorname{xor} \dots \operatorname{xor}  a_{n}
\end{aligned}
SG(G)​=SG(G1​)xorSG(G2)​xor…xorSG(Gn​)=a1​xora2​xor…xoran​​
那么，我们就得到的 Nim 游戏的经典结论，是不是很神奇。
对于博弈的大部分问题，只要SG值相同，就可以互相转化，而对于 SG 函数来说，其求解依靠将一个总游戏划分成几个子游戏，简化问题逐个击破，通过定理就可以把他们的结果结合起来。
 3.7 SG例题与复杂博弈论技巧
在实际应用方面，我们介绍的是子游戏的划分以及 SG 函数状态刻画，以及求解。照应我们上面所说的内容,**对于博弈的大部分问题，只要SG值相同，就可以互相转化，而对于 SG 函数来说，其求解依靠将一个总游戏划分成几个子游戏，简化问题逐个击破，通过定理就可以把他们的结果结合起来。
P1290
显然是公平组合游戏。
对于这种没有明显结论的博弈论题，我们先处理出特殊情况。
而对于本题来说，显然我们划分的子游戏就是每个人手里握的求。
我们考虑最终情况：一个数是 xxx，而另一个是 0，那么先手必败（因为游戏已经结束了）。
剩下的情况就是握着两个数，不妨设为 x,yx,yx,y，其中 x&gt;yx&gt;yx&gt;y。
那么根据题意有：
SG⁡(n,m)=mex⁡({SG⁡(n−m,m),SG⁡(n−2m,m),…,SG⁡(m,n mod m)})\operatorname{SG}(n,m)=\operatorname{mex}(\left\{ \operatorname{SG}(n-m,m),\operatorname{SG}(n-2m,m),\dots,\operatorname{SG}(m,n \bmod m) \right\})
SG(n,m)=mex({SG(n−m,m),SG(n−2m,m),…,SG(m,nmodm)})
考虑里面怎么求，注意到：
SG⁡(n−m,m)=mex⁡({SG⁡(n−2m,m),SG⁡(n−3m,m),…,SG⁡(m,n mod m)})\operatorname{SG}(n-m,m)=\operatorname{mex}(\left\{ \operatorname{SG}(n-2m,m),\operatorname{SG}(n-3m,m),\dots,\operatorname{SG}(m,n \bmod m) \right\})
SG(n−m,m)=mex({SG(n−2m,m),SG(n−3m,m),…,SG(m,nmodm)})
同理可以迭代下去，所以除了 SG⁡(m,n mod m)\operatorname{SG}(m,n \bmod m)SG(m,nmodm) 以外其他都可以由他迭代出来，考虑如何求出来：
假设 SG⁡(m,n mod m)=0\operatorname{SG}(m,n \bmod m)=0SG(m,nmodm)=0，设 k=nmk=\dfrac{n}{m}k=mn​，那么有 SG⁡(n−(k−1)×m,m)=mex⁡{SG⁡(m,n mod m)}\operatorname{SG}(n-(k-1)\times m,m)=\operatorname{mex}\left\{ \operatorname{SG}(m,n \bmod m) \right\}SG(n−(k−1)×m,m)=mex{SG(m,nmodm)} 成立。
假设 SG⁡(m,n mod m)=1\operatorname{SG}(m,n \bmod m)=1SG(m,nmodm)=1，那么 SG⁡(n−(k−1)×m,m)=mex⁡{SG⁡(m,n mod m)}\operatorname{SG}(n-(k-1)\times m,m)=\operatorname{mex}\left\{ \operatorname{SG}(m,n \bmod m) \right\}SG(n−(k−1)×m,m)=mex{SG(m,nmodm)} 不成立。
由此可以看出，若 k=1,SG⁡(n,m)=[SG⁡(m,n mod m)=0]k=1,\operatorname{SG}(n,m)=[\operatorname{SG}(m,n \bmod m)=0]k=1,SG(n,m)=[SG(m,nmodm)=0]，否则是 1。
一般来说，我们对于 SG 函数的求解，最常规的套路就是：暴力，找规律。或者打表。 大部分题都可以这么进行操作，有的时候需要进一步转化模型，当然那就是后面再说了。
这是标准的辗转相除的递推式子，用 gcd⁡\gcdgcd 的写法即可实现：
#include&lt;bits/stdc++.h&gt;using namespace std;int T;int dfs(int x,int y,int p)&#123;    if(x==y) return p;    if(y/x&gt;=2) return p;    return dfs(y-x,x,p^1);&#125;void solve()&#123;    int m,n;    cin&gt;&gt;m&gt;&gt;n;    if(m&gt;n) swap(m,n);    if(dfs(m,n,0)==0) cout&lt;&lt;&quot;Stan wins\n&quot;;    else cout&lt;&lt;&quot;Ollie wins\n&quot;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
P3179
对不起对不起忘放这个题了 (๑• . •๑)。
而本题，我们和上面，首先我们要分解出子游戏，这样我们才能利用 SG 函数求解。若我们无法分解为子游戏，我们需要考虑其他方法求解。
结论就是，每一个白色格子都是独立的，即一个白色格子处的决策与其他格子的状态无关，这样我们就划分出来子游戏了。
等等等等，你咋证明这个满足我们上面所说的有向图游戏的性质啊！
我们考虑，因为一个白格子可能会影响其他白格的情况，当且仅当这个白格翻转后有产生与其他白格重合的白格。这个时候我们应当把重合格子视为黑色格子，但是如果我们认为他们是两个独立的白格子，这显然是等价的，根据 SG 游戏和是异或的，异或和为 0，所以对这两个白色格子操作没有任何意义，得证。
感性理解就是一方操作了这两个白格中的一个，另一方可以立刻操作另一个，局势不发生变化。
我们对于翻棋子游戏，解法就是把初始状态的 SG 值即所有棋子的 SG 值异或和求出来，为 0 则必败否则必胜。
简单暴力，我们从后往前进行卡搜绿，求出每一个白色格子出现在每一个位置的 SG 值，对于每一个白色格子，考虑枚举 kkk 的值，这个时候新状态的 SG 值是 SG⁡(x+ix)\operatorname{SG}(x+ix)SG(x+ix)，的异或和，其中 (1≤i≤k−1)(1 \le i \le k-1)(1≤i≤k−1)。最后再求出所有转移到的状态 SG 值加上一个 0 的 mex。复杂度是 ∑i=1n⌊ni⌋=O(nlog⁡n)\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloor =O(n \log n)i=1∑n​⌊in​⌋=O(nlogn)。
不难注意到是整除分块，考虑只维护 ⌊nx⌋\lfloor \dfrac{n}{x} \rfloor⌊xn​⌋ 个不同的根号个 xxx 的 SG 函数，仍然按 xxx 从大到小考虑。对于每一个 xxx 考虑它的所有转移到的状态 SG 值仍然有如上性质，可以考虑 ⌊nx⌋\lfloor \dfrac{n}{x} \rfloor⌊xn​⌋ 相同的一起计算，这是整除分块，时间复杂度是 O(n34)O(n ^{\frac{3}{4}})O(n43​)，可以通过。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e6+15;int sg[2][MN],rt[MN],pos[MN],tot,n,n2,T;inline int SG(int x)&#123;	return ((x=n/(n/x))&gt;n2)?sg[1][n/x]:sg[0][x];&#125;void init()&#123;    for(int l=1,r;l&lt;=n;l=r+1)&#123;        r=n/(n/l);        rt[++tot]=r;    &#125;    ++tot;    while(--tot)&#123;        int x=rt[tot],y=0,z=1;        pos[y]=tot;        for(int i=x*2,j;i&lt;=n;i=j+x)&#123;            j=n/(n/i)/x*x,pos[y^SG(j)]=tot;            ((j-i)/x&amp;1^1)&amp;&amp;(y^=SG(j));        &#125;        while(pos[z]==tot) ++z;        (x&gt;n2)?sg[1][n/x]=z:sg[0][x]=z;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;T;    while(n2*n2&lt;=n) ++n2;    n2--;    init();    while(T--)&#123;        int w,x=0;        cin&gt;&gt;w;        for(int i=1;i&lt;=w;i++)&#123;            int awa;            cin&gt;&gt;awa;            x^=SG(awa);        &#125;        cout&lt;&lt;(x?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
agc017d
还是我们的思路，分解子游戏。
首先源命题删边的操作，我们转化为删一个子树的操作（不能删整棵树），显然这个游戏是公平组合游戏，问我们初始状态，考虑利用 SG 函数求解。
首先，刻画游戏，我们终止状态是什么，显然当这个一个几点没有孩子节点的时候就是终止节点，那么 SG 函数为 0。
让后考虑我们怎么进行转移，还是上面我们所提到过的，对于这种没有明显结论的博弈论题，我们先处理出特殊情况。

xxx 没有儿子，显然 SG 为 0。
xxx 有一个儿子，设为 yyy，我们考虑证明 SG⁡(x)=SG⁡(y)+1\operatorname{SG}(x)=\operatorname{SG}(y)+1SG(x)=SG(y)+1。

删除以 yyy 为根的子树，显然 SG 为 0。
删除其他子树，显然这个子树在以 yyy 为根的子树内，根据数学归纳法，SG 中 0,1,…,SG⁡(y)−10,1,\dots,\operatorname{SG}(y)-10,1,…,SG(y)−1 都出现了，则 SG⁡(x)=mex⁡{1,2,…,SG⁡(y)}=SG⁡(y)+1\operatorname{SG}(x)=\operatorname{mex}\left\{  1,2,\dots,\operatorname{SG}(y) \right\}=\operatorname{SG}(y)+1SG(x)=mex{1,2,…,SG(y)}=SG(y)+1。


若 xxx 有多个儿子，此时可以继续划分为好几个子游戏，根据 SG 定理结合起来即使答案。
所以，SG 函数求解如下：

SG⁡(x)={0x has no sonxor⁡y∈son(x)SG⁡(y)+1otherwise\operatorname{SG}(x)=
\begin{cases}
0 &amp; \text{x has no son} \\ \\
\operatorname{xor}_{y\in son(x)} \operatorname{SG}(y)+1  &amp; \text{otherwise}
\end{cases}
SG(x)=⎩⎪⎪⎨⎪⎪⎧​0xory∈son(x)​SG(y)+1​x has no sonotherwise​
时间复杂度 O(n)O(n)O(n)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e5+15;int f[MN],n;vector&lt;int&gt; adj[MN];void dfs(int u,int pre)&#123;    f[u]=0;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs(v,u);        f[u]^=f[v]+1;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs(1,0);    cout&lt;&lt;(f[1]?&quot;Alice&quot;:&quot;Bob&quot;);    return 0;&#125;
P7864
还是上面我们所提到过的，但是我们在增广一下，对于这种没有明显结论的博弈论题，我们先处理出特殊情况。在从特殊情况推广到一般情况。这也是大部分 OI 题的常规思路。
首先，树是一条链怎么做，经过手模显然在两端取，那么为偶数的时候先手必胜，反之为奇数的时候先手必败。
其次，我们考虑存在一个父节点，该节点存在多个叶子节点的形式，最经典的就是菊花图，那么有：

若只有一个叶子，显然先手必败。
若有多个叶子，那么先手可以把叶子节点拿到只剩下一个，那么就把必败的局面传给对方，因此先手必胜。

考虑推广但一般情况，就是将根几点当成树的一部分结构，那么结构因为是公平组合游戏，那么一定是 P 点或者 N 点，若是 P 状态，我们直接把叶子节点全部拿完，如果是 N 状态，我们就只剩下一个叶子节点。但是对于局面来说，先手都是具有操控全的。
最后，我们推广到一般性情况。对于所有的第二种情况，先手都可以操纵，也就是说情况 2 是必胜态。如果否则一定存在若干个链条使得所有叶子节点都没有兄弟。这样的话我们需要判断的链条的长度，也就是从该叶子节点出发到达的第一个不是只有一个子节点的父节点，也就是直到一种情况 2 出现。因此我们计算出所有链条的长度，如果存在奇数，先手必胜；如果全是偶数，则后手必胜。
时间复杂度 O(n)O(n)O(n)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int T,n,fa[MN],dg[MN];void clear()&#123;    for(int i=1;i&lt;=n;i++) dg[i]=fa[i]=0;&#125;void solve()&#123;    cin&gt;&gt;n;    clear();    for(int i=2;i&lt;=n;i++)&#123;        cin&gt;&gt;fa[i];        dg[fa[i]]++;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(dg[i]) continue;        int pre=fa[i],len=0;        while(dg[pre]==1)&#123;            pre=fa[pre];            len++;        &#125;        len++;        if(len&amp;1)&#123;            cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;            return;        &#125;    &#125;    cout&lt;&lt;&quot;0\n&quot;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 4. 反常游戏与反SG游戏
 4.1 Anti-Nim游戏
是这样的：

有 nnn 堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败`。

不难发现和 Nim 游戏不同的一点就是胜利条件变了，不过条件还是可以推的。
先手必胜有两种情况：

对于所有石子都只有一个，且游戏的 SG⁡\operatorname{SG}SG 值为 0。
至少一堆石子多于一个，且游戏的 SG⁡\operatorname{SG}SG 不为 0。

游戏分为三种情况：

当每堆只有一个石子
异或值为 0 时，先手必胜。
异或值不为 0 时，先手必败。
只有一堆石子数大于 1，先手必胜。

先手我们可以考虑对数量大于 1 的那对堆石子下手脚，从而构造出后手必败的状态：

存在至少两堆石子数大于1
当异或和为0时，先手必败
当异或和不为0时，先手必败

证明和 Nim 游戏是相似的，可以自行证明或网上搜索，这里就不给出了。
例题：SHOI2008 小约翰的游戏
#include&lt;bits/stdc++.h&gt;using namespace std;int T,n;void solve()&#123;    cin&gt;&gt;n;    int ans=0;    bool flag=0;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin&gt;&gt;x;        ans^=x;        if(x&gt;1) flag=1;    &#125;    if(!flag&amp;&amp;!ans) cout&lt;&lt;&quot;John\n&quot;;    else if(flag&amp;&amp;ans) cout&lt;&lt;&quot;John\n&quot;;    else cout&lt;&lt;&quot;Brother\n&quot;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 4.2 反 SG 游戏
我们根据 Anti-Nim 游戏能否推广到一般性情况呢？有的兄弟有的，反 SG 游戏就是。
我们定义：

Anti-SG游戏：决策集合为空的游戏者赢，剩下规则与 SG 游戏相同。

那么，如何判断能否赢呢？
对于 Anti-SG 游戏，如果我们规定当局面单一游戏的 SG⁡\operatorname{SG}SG 值为 0 时，游戏结束，则先手必胜当且仅当：

游戏的 SG⁡\operatorname{SG}SG 函数不为0且游戏中某个单一游戏的 SG⁡\operatorname{SG}SG 函数值大于 1。
游戏的 SG⁡\operatorname{SG}SG 函数为0且游戏中没有某个单一游戏的 SG⁡\operatorname{SG}SG 函数值大于 1。

证明和 SG⁡\operatorname{SG}SG 函数类似。
 5. 博弈论及与其他知识结合
 5.0 操作手册
博弈论确实可以和其他芝士一起结合起来一块考。
一般我们拿到一个看起来像是博弈论的题，我们需要确定题目的类型，可以通过几个操作手册来：

确定博弈：大部分的博弈论题都是假博弈论，有可能是贪心什么的。需要自行观察以下，尤其警惕标题带博弈论的 www。
思考模型：大部分博弈都有基础模型，我们通过基础模型来构建起问题的 “整体”，这也是为什么我们上面给出那么多的组合游戏模型。
落实限制：我们找到模型后，题目一般都会给予你几个限制。现在就是发挥你实力的时候了，通过知识点的综合运用，将模型转化到一些知识点上去。
分类讨论：这个时候就是通过限制来进行分类讨论，不做过多介绍，可以做题体会。
写代码

 5.1 例题
这里举几个比较简单的例题。DP 与博弈论的考察一般考察方案数的选取，或带有特殊限制的博弈问题。或者通过 DP 来求解博弈论所需要的信息。
GZOI2017 取石子游戏
不难发现这是一个带特殊限制的 NIM 游戏。
让 Alice 必败就是让其选择的石子堆中的数量异或为 0，要么无法在这一堆中足够的石子使得剩下的异或为 0，所以给定 Alice 选择的石子数量一定要大于等于其他选择的堆的数异或值。
考虑枚举 Alice 选哪一堆，让后对于其他石子堆用 DP 求出前 iii 堆中任意选择一些使得异或值为 jjj 的方案数，直接统计即可，时间复杂度 O(n2×256)O(n^2 \times 256)O(n2×256)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=520,MOD=1e9+7;int f[MN][MN],ans,n,a[MN];void solvedp(int x)&#123;    memset(f,0,sizeof(f));    f[0][0]=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=0;j&lt;256;j++)&#123;            if(i==x) f[i][j]=f[i-1][j];            else f[i][j]=(f[i-1][j]+f[i-1][j^a[i]])%MOD;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        solvedp(i);        for(int j=a[i];j&lt;256;j++)&#123;            (ans+=f[n][j])%=MOD;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
USACO09NOV A Coin Game S
注意到是题目中的关键信息，取的硬币数和上一步取的操作有关，这个直接思考不太好，我们考虑进行 DP 求解。
设 f(i,j)f(i,j)f(i,j) 表示取到第 iii 个金币，取金币的上限为 jjj 先手取的最大价值，转移是显然的，考虑记忆化搜索实现比较好些，但是转移是 O(n3)O(n^3)O(n3) 的。
考虑优化，注意到我们 f(i,j)f(i,j)f(i,j) 在记忆化搜索是 1→n1 \rightarrow n1→n 取搜索的，那么我们 f(i,j)f(i,j)f(i,j) 的答案其实包含了 f(i,j−1)f(i,j-1)f(i,j−1)，那么我们可以直接搜 f(i,j−1)f(i,j-1)f(i,j−1) 没有的部分，即 (x+lim,lim×2)(x+lim,lim\times 2)(x+lim,lim×2)，其中 limlimlim 为金币上限，那么这样搜索复杂度就是 O(n2)O(n^2)O(n2) 的了。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e3+15;int f[MN][MN],n,s[MN],c[MN];int dfs(int x,int y)&#123;    y=min(y,n-x+1);    if(~f[x][y]) return f[x][y];    if(x+y&gt;n) return s[x];    if(!y) return 0;    int ans=dfs(x,y-1);    ans=max(ans,s[x]-dfs(x+y,y&lt;&lt;1));    return f[x][y]=ans;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(f,-1,sizeof(f));    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;c[i];    &#125;    for(int i=n;i&gt;=1;i--) s[i]=s[i+1]+c[i];    cout&lt;&lt;dfs(1,2);    return 0;&#125;
ZJOI2009 取石子游戏
神题：
再次复读：

神仙题.jpg。ZJOI 是真的神仙。
发现 SG 函数等东西完全找不到规律，无奈只能翻题解。

看 wsyhb的题解吧，他说的肯定比我好 www。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1520;int L[MN][MN],R[MN][MN],n,a[MN];void solve()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        L[i][i]=R[i][i]=a[i];    &#125;    for(int len=2;len&lt;=n;len++)&#123;        for(int l=1;l+len-1&lt;=n;l++)&#123;            int r=l+len-1;            int x=a[r],xl=L[l][r-1],xr=R[l][r-1];            if(x==xr) L[l][r]=0;            else if(x&gt;=xl&amp;&amp;x&lt;xr) L[l][r]=x+1;            else if(x&gt;xr&amp;&amp;x&lt;=xl) L[l][r]=x-1;            else L[l][r]=x;            x=a[l],xl=L[l+1][r],xr=R[l+1][r];            if(x==xl) R[l][r]=0;            else if(x&gt;=xr&amp;&amp;x&lt;xl) R[l][r]=x+1;            else if(x&gt;xl&amp;&amp;x&lt;=xr) R[l][r]=x-1;            else R[l][r]=x;        &#125;    &#125;    if(L[2][n]==a[1]) cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;;    else cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
P4363
对于这种博弈论的题，基本上理解就能想到了把状态压出来，然后做记忆化搜索。
对于落子的限制条件是，上方和左方的格子要么是棋子要么是边界。
我们可以考虑直接状压落子的状态，存每一行铺到了哪个位置，这个方法的复杂度显然为 O(nm)O(n^m)O(nm) 的。
我们发现，一个棋子想要存在的条件是上方和左方的所有格子全部被棋子填满。
那么，对于任意时刻，棋盘上的棋子构成一个锯齿形。
那有用的情况有多少种呢，我们考虑从锯齿状的起点开始走，我们最多往右走 nnn 步，往下走 mmm 步，路径数论是多少？显然为 (n+mn)\dbinom{n+m}{n}(nn+m​) 种。
算出来就是 184756184756184756 中，考虑暴力 11 进制状压，让后用 map 存就可以了。
注意开 long long。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=15,INF=1e18;int a[MN][MN],b[MN][MN],ed,n,m;map&lt;int,int&gt; ans,vis;int dfs(int x,int y)&#123;    if(x==ed) return 0;    if(vis[x]==1) return ans[x];    vis[x]=1;    int p=1,sum=y?INF:-INF,tmp=x;    int c[MN]&#123;&#125;;    c[0]=INF;    for(int i=1;i&lt;=n;i++) c[i]=tmp%11,tmp/=11;    if(y)&#123;        for(int i=1;i&lt;=n;i++)&#123;            if(c[i]&lt;min(c[i-1],m)) sum=min(sum,dfs(x+p,y^1)-b[i][c[i]+1]);            p*=11;        &#125;    &#125;    else &#123;        for(int i=1;i&lt;=n;i++)&#123;            if(c[i]&lt;min(c[i-1],m)) sum=max(sum,dfs(x+p,y^1)+a[i][c[i]+1]);            p*=11;        &#125;    &#125;    ans[x]=sum;    return ans[x];&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;b[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++) ed=ed*11+m;    cout&lt;&lt;dfs(0,0);    return 0;&#125;
HNOI2010 取石头游戏
这种题的模型就是：“我可以死，但你要死的更惨！”。
由于得分之和是定值，且双方都想让自己分数最大，我们不妨令 valvalval 表示先手得分与后手得分的差，类似于对抗搜索，那么先手要让 valvalval 尽可能大，而后手尽量让 valvalval 小。
而取石子，可以转化为两端分别有一个栈，可以从栈顶取石子，中间有若干个双端队列，可以从其两端取石子。
让后我们对连续的三个元素进行分类讨论，分别有：

递增
递减
先增后减
先减后增

因为我们取的方向是从外到内的，我们接下来分类讨论。

递增：我们肯定要放到后面选择，因为一旦先手选择，后手一定能够选择比他大的数的。
递减：优先选择递减里面最大的。
先增后减与先减后增：到了这个情况的化，后手肯定选择中间的情况，先手肯定会选择左后两个。考虑证明：

如果先手发现选取最优的话，他会选走这个。由于先增加后减少，所以当前对于后手而言，选取比上一次最优还优秀的点肯定是最佳的，随意肯定会选中间那个。
若不一定最优秀，那么可能会选取其他更优的决策点。但是最终还是要选择这个剩下的点。我们直接把这个情况压成一个点的情况，这样所有的双段队列和栈就不会出现任何线增加后减少的情况了。



贪心即可：
#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template &lt; typename T &gt; inline void read(T &amp; x) &#123;    x = 0;    char c = getchar();    bool flag = false;    while (!isdigit(c)) &#123;        if (c == &#x27;-&#x27;) flag = true;        c = getchar();    &#125;    while (isdigit(c)) &#123;        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);        c = getchar();    &#125;    if (flag) x = -x;&#125;ll n, sum, val, s, L, R, tot;ll l[maxn], r[maxn], v[maxn];bool tag[maxn];bool cmp(const ll &amp; a,    const ll &amp; b) &#123;    return a &gt; b;&#125;int main() &#123;    read(n), r[0] = 1, l[n + 1] = n;    for (int i = 1; i &lt;= n; ++i)        read(v[i]), sum += v[i], l[i] = i - 1, r[i] = i + 1, tag[i] = (v[i] != 0);    for (int i = 3; i &lt;= n; i = r[i])        while (tag[l[l[i]]] &amp;&amp; tag[l[i]] &amp;&amp; tag[i] &amp;&amp; v[l[i]] &gt;= v[l[l[i]]] &amp;&amp; v[l[i]] &gt;= v[i])            v[i] = v[l[l[i]]] + v[i] - v[l[i]], r[l[l[l[i]]]] = i, l[i] = l[l[l[i]]];    L = r[0], R = l[n + 1];    while (v[L] &gt;= v[r[L]] &amp;&amp; tag[L] &amp;&amp; tag[r[L]]) s += v[r[L]] - v[L], L = r[r[L]];    while (v[R] &gt;= v[l[R]] &amp;&amp; tag[R] &amp;&amp; tag[l[R]]) s += v[l[R]] - v[R], R = l[l[R]];    for (int i = L; i &lt;= R; i = r[i])        if (tag[i])            v[++tot] = v[i];    sort(v + 1, v + tot + 1, cmp), v[++tot] = s;    for (int i = 1; i &lt;= tot; ++i) &#123;        if (i &amp; 1) val += v[i];        else val -= v[i];    &#125;    printf(&quot;%lld %lld&quot;, (sum + val) / 2, (sum - val) / 2);    return 0;&#125;
 6. 后言
蒟蒻博弈论就学到这里了，如果还有后面的进一步学习，还是会更新内容了。
这篇文章，我感觉还是欠缺一部分 SG 解题的部分。见的题还是不太多，坑还是要补的 www。
看在这么用心的份上，不要脸的求赞 www。
 参考

Vatyr的阶梯 Nim 题解
繁凡さん的博弈论全家桶
自为风马月前卒的博弈论总结
clover_hxy的Nim 游戏及其变形
Wolfycz的洛谷日报
Oi-Wiki
CoCo_T_ 的树上删边游戏及其拓展
bloodstalk的博弈论
拉姆已经够可爱了的OI复习笔记
mex 经典求法
Pecco的 SG函数
crpboy 的P2964 题解

]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>卡特兰数与反射容斥</title>
    <url>/posts/6c261b84/</url>
    <content><![CDATA[ 0. 前言
本文章介绍内容难度不超过提高组难度，属于笔者提高组复习计划的一部分。
 1. 卡特兰数
 1.1 介绍
卡特兰数作为广泛出现在OI中的一类特殊数列，第 iii 项改为 CiC_{i}Ci​，其拥有广泛的意义。数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862。
这些特殊的数字，在信息学竞赛里许多题目都有这个数列的存在，可以在打表找规律时激发灵感。
我们通过一个经典例子来说明，即折线问题，如下图：

在平面上从 (0,0)(0,0)(0,0) 走到 (n,n)(n,n)(n,n)，每次只能向上或者向右走，不穿过 y=xy=xy=x 这条直线有多少种方案。
 1.2 朴素解法
我们考虑枚举最后一个 y=xy=xy=x 上的点 (i,i)(i,i)(i,i)，可以把问题规模缩小。

我们强制钦定最后一段不碰到 y=xy=xy=x，我们在 (i,i)(i,i)(i,i) 继续向终点走去的过程中，第一步只能向右走，到 (n,n)(n,n)(n,n) 的最后一步只能向上走，中间的问题我们可以视作从 (i,i+1)→(n,n−1)(i,i+1)\to (n,n-1)(i,i+1)→(n,n−1) 不穿过 y=(x−1)y=(x-1)y=(x−1) 的直线方案数，平移有：

中间这段答案就是 Cn−i−1C_{n-i-1}Cn−i−1​，故可以求出 Cn=∑i=0n−1CiCn−i−1C_{n}=\sum\limits_{i=0}^{n-1} C_{i}C_{n-i-1}Cn​=i=0∑n−1​Ci​Cn−i−1​。
在众多卡特兰数所对应的题目如出栈顺序，括号匹配中，缩小问题规模是一个很经典的做法。
但是这样的时间复杂度为 O(n2)O(n^2)O(n2)，我们考虑能否得到一个 O(n)O(n)O(n) 或者 O(1)O(1)O(1) 的过程。
 1.3 容斥解法
本解法请仔细理解，因为会涉及到第二章的讲解。
正难则反，我们考虑用所有路径数减去不合法路径的数量。总的是 (2nn)\dbinom{2n}{n}(n2n​)，我们思考不合法路径的数量，考虑把一条不合法路径进行操作：  把一条不合法路径在第一次触碰到 y=x+1y=x+1y=x+1 的这条线的点设为 ppp，我们在 ppp 右侧的在 y=x+1y=x+1y=x+1 以下的部分全部沿 对称到上方，我们发现这样翻转之后，所有可能出现的不合法路径，和 (0,0)→(n−1,n+1)(0,0)\to (n-1,n+1)(0,0)→(n−1,n+1) 的路径产生了一一映射的关系。


所以我们就有 Cn=(2nn)−(2nn−1)=1n+1(2nn)C_{n}=\dbinom{2n}{n}-\dbinom{2n}{n-1}=\dfrac{1}{n+1}\dbinom{2n}{n}Cn​=(n2n​)−(n−12n​)=n+11​(n2n​)。
 1.4 总结与经典应用
CnC_{n}Cn​ 共两个公式，一个 Cn=∑i=0n−1CiCn−i−1C_{n}=\sum\limits_{i=0}^{n-1} C_{i}C_{n-i-1}Cn​=i=0∑n−1​Ci​Cn−i−1​，一个 Cn=(2nn)−(2nn−1)=1n+1(2nn)C_{n}=\dbinom{2n}{n}-\dbinom{2n}{n-1}=\dfrac{1}{n+1}\dbinom{2n}{n}Cn​=(n2n​)−(n−12n​)=n+11​(n2n​)。
一些等价模型：

由 nnn 对左右括号构成的合法的括号序列数。
栈（无穷大）的进栈序列 {1,2,…,n−1,n}\{1,2,\dots,n-1,n\}{1,2,…,n−1,n} 由多少个不同的出栈顺序。
nnn 个 111 和 nnn 个 −1-1−1 构成 2n2n2n 项 a1,a2,…,ana_1,a_2,\dots,a_{n}a1​,a2​,…,an​ 的任意前缀和 ≥0\ge 0≥0 的序列数量个数。
nnn 个节点可以构造出多少个不同的二叉树。
圆上选择 2n2n2n 个点，将这些点成对连接起来使得所得到的 nnn 条线段不相交的方法数？

有经验的不难发现前四个性质是完全一致的，而最后一个可以进一步推论。
而卡特兰数计数的本质，是任何前缀中总存在某种约束的不可逆平衡（如左括号数 ≥\ge≥ 右括号数）。
 1.5 例题
例题是多的，这里举例几个经典应用。
 P2532 [AHOI2012] 树屋阶梯
我们思考要求强制使用 nnn 个举行有没有什么特殊性质，我们发现一个矩形，其左下角这个矩形，一定右上角是某个拐点，否则我们会发现，我们需要额外使用一个矩形去覆盖这个拐点。
那么我们可以缩小问题规模，每次对这个阶梯状物，进行一个枚举覆盖左下角这个矩形的右上角是哪一个拐点，不妨设为第 xxx 个拐点，那么上面就是一个 x−1x-1x−1 的子问题，下面为 n−x−1n-x-1n−x−1 的子问题，不难发现答案就是 Cn=∑i=0n−1CiCn−i−1C_{n}=\sum\limits_{i=0}^{n-1} C_{i}C_{n-i-1}Cn​=i=0∑n−1​Ci​Cn−i−1​，即卡特兰数。
 P3978 [TJOI2015] 概率论
期望是困难的，我们直接考虑统计 nnn 个点可能的二叉树数量 fnf_{n}fn​ 和其叶子总数 gng_{n}gn​。注意到 fnf_nfn​ 就是卡特兰数，而 gng_{n}gn​ 如何计算呢？打表发现 gn=nfn−1g_{n}=nf_{n-1}gn​=nfn−1​，证明太长了不想过多证明（逃）。
答案就是 gnfn=n(n+1)4n−2\dfrac{g_n}{f_n}=\dfrac{n(n+1)}{4n-2}fn​gn​​=4n−2n(n+1)​。
 P4769 [NOI2018] 冒泡排序
众所周知的是，冒泡排序的交换次数就是排列的逆序对数。
首先不考虑字典序（即特殊性质），我们如何计算有多少个排列满足逆序对数等于 12∑i=1n∣i−pi∣\dfrac{1}{2} \sum\limits_{i=1}^n |i-p_{i}|21​i=1∑n​∣i−pi​∣。我们考虑原式子为 cnt=12∑i=1n∣i−pi∣cnt=\dfrac{1}{2} \sum\limits_{i=1}^n |i-p_{i}|cnt=21​i=1∑n​∣i−pi​∣，变形有 2⋅cnt=∑i=1n∣i−pi∣2\cdot cnt=\sum\limits_{i=1}^n |i-p_{i}|2⋅cnt=i=1∑n​∣i−pi​∣，其中后面的式子我们考虑用图论刻画，即 i→pii\to p_{i}i→pi​ 进行连边，那么 ∣i−pi∣|i-p_{i}|∣i−pi​∣ 就表示跨过的距离，那么合法当且仅当每条边穿过的格子正好对应它参与的逆序对的个数，即所有逆序对两两配对成边的端点，且没有多余交叉。
也就是说，逆序对必须两两配对，不可能出现一个位置被两个人抢走配对的情况。
等价的转化提议，即不存在三元即以上的序列满足 i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k 使 pi&gt;pj&gt;pkp_{i}&gt;p_{j}&gt;p_{k}pi​&gt;pj​&gt;pk​。即不存在三元即以上的下降子序列。
那么这样如何刻画呢？我们发现这玩意由于没有一元子序列这一说法，那么必定为二元下降子序列，我们用图来表示合法序列数变化这一过程：

我们发现拐点必然是当前时刻序列的最大值然后接一个较小值，然后再继续上升。
故有一个 DP，设 f(i,j)f(i,j)f(i,j) 表示前 iii 个数构成的排列最大值为 jjj 的方案数，转移为 f(i,j)=f(i−1,j)+f(i,j−1)f(i,j)=f(i-1,j)+f(i,j-1)f(i,j)=f(i−1,j)+f(i,j−1)，要求 j≤ij\le ij≤i。这玩意是搞笑的 O(n2)O(n^2)O(n2)，但是不难发现这玩意就是格路计数但是有 j≤ij\le ij≤i 的限制，可以转化为卡特兰数，可以 O(1)O(1)O(1) 计算，或者公式为 (i+ji)−(i+jj+1)\dbinom{i+j}{i}-\dbinom{i+j}{j+1}(ii+j​)−(j+1i+j​)。
现在考虑有字典序的限制，这个限制我们可以转化为至少一个位置满足 pi&gt;qip_{i}&gt; q_{i}pi​&gt;qi​，其余任意。我们考虑枚举法确定这个位置什么，我们钦定一个位置 iii，前面的和 qiq_{i}qi​ 一致，第 iii 个必须大于 pip_{i}pi​。令 mx=max⁡j=1i−1qjmx=\max_{j=1}^{i-1} q_{j}mx=maxj=1i−1​qj​，mnmnmn 为最小可以填的数。
由于我们强制钦定之后从 (1,1)→(n,n)(1,1) \to (n,n)(1,1)→(n,n) 的 fff 的计算就不再适用了，我们将其定义为从 (i,j)(i,j)(i,j) 走到 (n,n)(n,n)(n,n) 的方案数。
接下来我们考虑如何计算方案数，考虑分类讨论：

若 pi=mnp_{i}=mnpi​=mn，那么我们显然只能填写 x&gt;mxx&gt;mxx&gt;mx 的方案，即 f(i,mx+1)f(i,mx+1)f(i,mx+1)。
若 mn&lt;pi&lt;mxmn&lt;p_{i}&lt;mxmn&lt;pi​&lt;mx，显然只能填写 x&gt;mxx&gt;mxx&gt;mx，但是显然这样构成不合法排列了，故无解。
若 pi≥mxp_{i}\ge mxpi​≥mx，只需要填写一个 x&gt;pix&gt;p_{i}x&gt;pi​ 的数就可以了，即 f(i,pi+1)f(i,p_{i}+1)f(i,pi​+1)。

时间复杂度 O(n)O(n)O(n)。
 2. 反射容斥
 2.1 反射法介绍与卡特兰三角
有些人会将反射法叫做映射法，这里本文章称作反射法。
回看 1.3 的解法，我们通过构造 y=x+1y=x+1y=x+1 的直线，然后将终点进行对称构造双射。我们将这种通过构造直线然后对称构造的类似方案,把每一条第一次越界的坏对象反射为一个更容易计数的对象，从而用总数减去反射得到的坏数得到合法对象数。我们称作反射法。
我们来介绍一个经典应用，当然不是卡特兰数因为介绍过了，我们介绍卡特兰三角。
定义 C(n,k)C(n,k)C(n,k) 表示由 nnn 个 111，kkk 个 −1-1−1 构成的序列中，前缀和不小于零的序列数。说人话就是还有 y=xy=xy=x 的限制，但是是从 (0,0)(0,0)(0,0) 走到 (n,k)(n,k)(n,k)。
通过上面 1.3 的方法我们当然可以构造一个直线 y=x−1y=x-1y=x−1 来构造双射：

那么原命题类似的，可以转化为从 (0,0)→(k−1,n+1)(0,0)\to (k-1,n+1)(0,0)→(k−1,n+1) 的自由路双射，原命题即为 (n+kk)−(n+kk−1)\dbinom{n+k}{k}-\dbinom{n+k}{k-1}(kn+k​)−(k−1n+k​)。
同时不难有性质：C(n,k)=∑i=0kC(n−1,i)=∑i=knC(i,k−1)C(n,k)=\sum\limits_{i=0}^k C(n-1,i)=\sum\limits_{i=k}^n C(i,k-1)C(n,k)=i=0∑k​C(n−1,i)=i=k∑n​C(i,k−1)。
例题：P1641 [SCOI2010] 生成字符串
 2.2 双线反射容斥
而多数时候，限制条件不仅仅想卡特兰数中 y=xy=xy=x 一条直线的约数，可能是多重约数。例如纵坐标必须限定在 [0,m][0,m][0,m] 的范围内。换句话说，也就是不仅仅由一条死线的限制，可能有多个死线的限制，在 OI 中一般涉及到的是两个死线的问题。以下我们令两条线分别为 A:y=x+aA:y=x+aA:y=x+a 和 B:y=x+bB:y=x+bB:y=x+b，默认 b&lt;ab&lt;ab&lt;a 即 A 在 B 上方。
简单一点，如果限制只有一个形如 y=x+ay=x+ay=x+a，终点是 (n,m)(n,m)(n,m) 那么如何满足，当然还是用我们的反射法，第一次触碰开始反转，终点就是变成关于 y=x+ay=x+ay=x+a 对称的点 (m−a,n+a)(m-a,n+a)(m−a,n+a)。那么直接求解自由路即可。

简化问题做完了，我们原命题如何做，对于一条线的容斥，我们相当于去掉了所有包含 A 的串和包含 B 的串。 所以如果对两条线分别跑一次容斥，包含 AB 和 BA 这些串会被去掉两次。
我们要再把先触碰 A 再触碰 B 的方案数加回来，再把先触碰 B 再触碰 A 的方案数加回来。 然后此时包含 ABA 和 BAB 的串又被多加了一次，以此类推。显然碰线的上限次数是确定的，只需要展开有限项即可。
但是难点在于两个都经过的方案，我们考虑两个都经过的方案数怎么算

我们思考能否类似于上面的反射法，将路线反射呢，我们考虑，如果先对 y=x+ay=x+ay=x+a 翻折，然后对 y=x+(2a−b)y=x+(2a-b)y=x+(2a−b) 进行翻折，这个 y=x+(2a−b)y=x+(2a-b)y=x+(2a−b) 表示 B 直线通过 A 翻折上去后的直线，会变成：

那么方案数就可以通过组合数进行计算了。通过上述我们容斥的过程不断计算即可。注意到每一次反射至少减少一个坐标。所以我们可以在 O(n+ma+b)O(\dfrac{n+m}{a+b})O(a+bn+m​) 的时间复杂度内完成这一操作。
请注意这个特殊的复杂度，这个复杂度可以和一个神秘知识点叫做根号分治结合考察。
 2.3 例题
 P3266 [JLOI2015] 骗我呢
骗你呢。
省流：

f(1,0/1/2/…/m)=1f(1,0/1/2/\dots/m)=1f(1,0/1/2/…/m)=1，f(i,j)=∑k=0j−1f(i−1,k)f(i,j)=\sum\limits_{k=0}^{j-1}f(i-1,k)f(i,j)=k=0∑j−1​f(i−1,k)。
求 ∑i=0mf(n,i)\sum\limits_{i=0}^m f(n,i)i=0∑m​f(n,i)，其中 n,m≤106n,m\le 10^6n,m≤106。

先考虑改写 DP 式子，不难改写为 f(i,j)=f(i,j−1)+f(i−1,j+1)f(i,j)=f(i,j-1)+f(i-1,j+1)f(i,j)=f(i,j−1)+f(i−1,j+1)，当 j=0j=0j=0 时 f(i,j)=f(i−1,j)+f(i−1,j+1)f(i,j)=f(i-1,j)+f(i-1,j+1)f(i,j)=f(i−1,j)+f(i−1,j+1)。时间复杂度 O(n2)O(n^2)O(n2)。
这种方程是典型的格路计数类方程，考虑将转移图画出来，发现两个移动方向，一个往左上，一个往右。坐标轴一侧变为向上和向右。考虑到左上很难搞，考虑拉伸坐标轴，将左上方向拉伸为和正上方，变为：

把左边的箭头改一改，改成往上后往右即可，根据 DP 性质不难发现两个不能经过的线：y=x+2y=x+2y=x+2 和 y=x−(m+1)y=x-(m+1)y=x−(m+1)，直接反射 DP 即可，以下为参考：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e6+15,MOD=1e9+7;int n,m,x,y,pw[MN],inv[MN],ans;int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void flipa()&#123;    swap(x,y);    x--;    y++;&#125;void flipb()&#123;    swap(x,y);    x+=m+2;    y-=m+2;&#125;void initpw()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++)&#123;        pw[i]=pw[i-1]*i%MOD;    &#125;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b||b&lt;0) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;int calc(int x,int y)&#123;    if(x&lt;0||y&lt;0) return 0;    return getC(x+y,x);&#125;signed main()&#123;    initpw();    cin&gt;&gt;n&gt;&gt;m;    x=n+m+1,y=n;    ans=calc(x,y);    while(x&gt;=0&amp;&amp;y&gt;=0)&#123;        flipa();        ans=(ans-calc(x,y)+MOD)%MOD;        flipb();        ans=(ans+calc(x,y))%MOD;    &#125;    x=n+m+1,y=n;    while(x&gt;=0&amp;&amp;y&gt;=0)&#123;        flipb();        ans=(ans-calc(x,y)+MOD)%MOD;        flipa();        ans=(ans+calc(x,y))%MOD;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 Gym 104053J
首先 i=1i=1i=1 的时候容易有 a1=1a_{1}=1a1​=1，对于 i&gt;1i&gt;1i&gt;1 有：
4Si=ai2+2ai+14Si−1+4ai=ai2+2ai+14Si−1=ai2−2ai+14Si−1=(ai−1)2∴ai=1±2Si−1\begin{aligned}
4S_{i} &amp; =a_{i}^2+2a_{i}+1 \\
4S_{i-1}+4a_{i}&amp;=a_{i}^2+2a_{i}+1 \\
4S_{i-1}&amp;=a_{i}^2-2a_{i}+1 \\
4S_{i-1}&amp;=(a_{i}-1)^2 \\
\therefore a_{i}&amp;=1\pm 2\sqrt{S_{i-1}}
\end{aligned}
4Si​4Si−1​+4ai​4Si−1​4Si−1​∴ai​​=ai2​+2ai​+1=ai2​+2ai​+1=ai2​−2ai​+1=(ai​−1)2=1±2Si−1​​​
注意到 Si=Si−1+ai=Si−1±2Si−1+1=(Si−1±1)2S_{i}=S_{i-1}+a_{i}=S_{i-1}\pm 2\sqrt{S_{i-1}}+1=(\sqrt{S_{i-1}}\pm 1)^2Si​=Si−1​+ai​=Si−1​±2Si−1​​+1=(Si−1​​±1)2。设 xi=Six_{i}=\sqrt{S_{i}}xi​=Si​​，那么拆括号后会变号，那么 b1=1b_{1}=1b1​=1，bi=bi−1=±1b_i=b_{i-1}=\pm 1bi​=bi−1​=±1。
考虑值域限制：

若 bi=bi−1+1b_{i}=b_{i-1}+1bi​=bi−1​+1，那么要求 ai=1+2bi−1=2bi−1a_{i}=1+2b_{i-1}=2b_{i}-1ai​=1+2bi−1​=2bi​−1，即 bi≤m+12b_{i}\le \dfrac{m+1}{2}bi​≤2m+1​。
若 bi=bi−1−1b_{i}=b_{i-1}-1bi​=bi−1​−1，那么显然 bi≥0b_{i}\ge 0bi​≥0。

相当于在平面直角坐标系上每一次向右上或右下走一步，初始在 (1,1)(1,1)(1,1)，走 n−1n-1n−1 步后要求纵坐标在 [0,m+12][0,\dfrac{m+1}{2}][0,2m+1​] 范围内的方案数，反射容斥即可。
 CF1967E1 Again Counting Arrays
先考虑发掘一些性质：

每一列至多一个障碍。
障碍会导致方向出现三种选择情况：上下、只上、只下。不可能出现无法选择的情况，因为每一列至多一个障碍。
当我们走到 y=my=my=m 的时候无敌，因为 ai∈[1,m]a_{i}\in [1,m]ai​∈[1,m]，可以一直往上走。

我们考虑给定障碍的点，即给定 aaa 我们应该如何判定是否合法，有一个想法就是我们贪心的能往上走就尽量往上走到 y=my=my=m 的位置。因为根据性质 2 障碍只可能限制至多一个方向的前进，分类讨论不难有往上走是最优解。
我们现在有了决策，现在我们考虑如何计数上述合法的 aaa。考虑 DP，注意到决策只与当前所处的最后一个位置纵坐标有关，故设 f(i,j)f(i,j)f(i,j) 表示决策到第 iii 个数，最后一个的位置纵坐标为 jjj 的 aaa 方案数，转移分类讨论有：

f(i+1,j+1)←(m+1)f(i,j)f(i+1,j+1)\leftarrow (m+1)f(i,j)f(i+1,j+1)←(m+1)f(i,j)；
f(i+1,j−1)←f(i,j)f(i+1,j-1)\leftarrow f(i,j)f(i+1,j−1)←f(i,j)，当且仅当 j&lt;mj&lt;mj&lt;m。
f(i+1,m)←f(i,m)⋅mf(i+1,m)\leftarrow f(i,m)\cdot mf(i+1,m)←f(i,m)⋅m。

转移是 O(nm)O(nm)O(nm) 的就很难泵，考虑优化，发现这玩意是一个 O(1)O(1)O(1) 递推式子，而且发现这玩意及其类似格路计数问题。考虑转化问题，我们从 (0,b0)(0,b_{0})(0,b0​) 开始走，每次可以选择右上和右下走，我们有两个限制，一个是碰到 y=−1y=-1y=−1 就寄了，一个是碰到 y=my=my=m 的时候就结束了。显然我们不难发现这是双线限制问题，可以考虑反射容斥，但是问题在于反射容斥双线是死线是不能碰，这里出现的是一个死线一个活线。
我们可以考虑枚举结束位置 (i,m)(i,m)(i,m)，在这个位置之前都不能碰到 y=my=my=m 不然就非法，这样就能套上反射容斥了。特别的，枚举 (n,i)(n,i)(n,i) 作为结束位置，这个时候 y=my=my=m 就全部都是死线。然后就可以做了，具体实现由于我不会右上右下的反射容斥，我们可以考虑反向旋转 45 度给回归到往右走和往上走，这样就可以套上 P3266 的做法了。
等会！我们还没有处理 DP 中的系数呢，首先将 (i,m)(i,m)(i,m) 和 (n,i)(n,i)(n,i) 旋转之后变为 (i−m+b02,i+m−b02−1)(\frac{i-m+b_{0}}{2},\frac{i+m-b_{0}}{2}-1)(2i−m+b0​​,2i+m−b0​​−1) 和 (n−i2,n+i2)(\frac{n-i}{2},\frac{n+i}{2})(2n−i​,2n+i​)。对于 (i,m)(i,m)(i,m) 求解的我们乘上 (m−1)i+m−b02mn−i(m-1)^{\frac{i+m-b_{0}}{2}}m^{n-i}(m−1)2i+m−b0​​mn−i 的系数，后面乘上 (m−1)n+i2(m-1)^{\frac{n+i}{2}}(m−1)2n+i​即可。
搞笑的，这玩意是 O(n2m+n)O(\dfrac{n^2}{m}+n)O(mn2​+n) 的，但是注意到我们有两个做法，一个是 O(nm)O(nm)O(nm)，一个是 O(n2m+n)O(\dfrac{n^2}{m}+n)O(mn2​+n) 的，直接考虑根号分治，设定阈值 BBB，满足 m≤Bm\le Bm≤B 用 DP，否则用计数，时间复杂度 O(nn)O(n\sqrt{n})O(nn​)。
番外：CatPTG 告诉我说不能用 P3266 的维护方法给我了个直接维护右上右下。我真信了，我调不出来然后我去自己写旋转坐标系的出来了搞笑了。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e6+15,MM=2e5+15,MOD=998244353;int pw[MN],inv[MN],n,m,b0,ppm[MN],ppm1[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void initpw()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++)&#123;        pw[i]=pw[i-1]*i%MOD;    &#125;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b||b&lt;0) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;namespace SUB1&#123; //dp 要开滚动数组    constexpr int MQ=3520;    int f[2][MQ],ret;    void init()&#123;        ret=0;        for(int i=0;i&lt;=m;i++)&#123;            f[0][i]=0;        &#125;    &#125;    void initdp(int f[])&#123;        for(int i=0;i&lt;=m;i++) f[i]=0;    &#125;    int solve()&#123;        init();        f[0][b0]=1;        int now=0,nxt=1;        for(int i=0;i&lt;n;i++,nxt^=1,now^=1)&#123;            initdp(f[nxt]);            for(int j=0;j&lt;m;j++)&#123;                if(!f[now][j]) continue;                if(j)&#123;                    f[nxt][j-1]=(f[nxt][j-1]+f[now][j])%MOD;                &#125;                if(j+1&lt;m)&#123;                    f[nxt][j+1]=(f[nxt][j+1]+f[now][j])%MOD;                &#125;else ret=(ret+f[now][j]%MOD*(m-1)%MOD*ppm[n-i-1]%MOD*ppm1[(i+j-b0)/2]%MOD)%MOD;//这里应该时 ppm[n-i] ppm1[(i+j-b0-1)]，但是因为 i 从 0 开始枚举的搞笑了            &#125;        &#125;        for(int i=0;i&lt;m;i++)&#123;            if(f[now][i])&#123;                ret=(ret+f[now][i]*ppm1[(i+n-b0)/2]%MOD)%MOD;// 同理            &#125;        &#125;        return ret;    &#125;&#125;namespace SUB2&#123; // rong chi    void flip(pir &amp;x,int k)&#123;        swap(x.first,x.second);        x.first-=k;        x.second+=k;    &#125;    int calc(pir x)&#123;        if(x.first&lt;0||x.second&lt;0) return 0;        return getC(x.first+x.second,x.first);    &#125;    int sol(int x,int y,int fl,int fr)&#123;         // from (0,0) to (x,y),y must in [fl,fr]        // maybe fl&gt;fr,But this is reflective inclusion-exclusion,I don&#x27;t care ¯\_(ツ)_/¯        pir pos=pir(x,y);        int ret=calc(pos);        while(pos.first&gt;=0&amp;&amp;pos.second&gt;=0)&#123;            flip(pos,fl);            ret=(ret-calc(pos)+MOD)%MOD;            flip(pos,fr);            ret=(ret+calc(pos))%MOD;        &#125;        pos=pir(x,y);        while(pos.first&gt;=0&amp;&amp;pos.second&gt;=0)&#123;            flip(pos,fr);            ret=(ret-calc(pos)+MOD)%MOD;            flip(pos,fl);            ret=(ret+calc(pos))%MOD;        &#125;        return ret;    &#125;    int solve()&#123;        int x=b0,y=0,ret=ksm(m,n);        for(int i=b0;i&lt;n;i+=2,x++,y++)&#123;            ret=(ret-sol(x,y,m-b0,-1-b0)*ppm[n-i-1]%MOD*ppm1[y]%MOD+MOD)%MOD;        &#125;        return ret;    &#125;&#125;void init()&#123;    ppm[0]=ppm1[0]=1;    for(int i=1;i&lt;=n;i++)&#123;        ppm[i]=ppm[i-1]*m%MOD;        ppm1[i]=ppm1[i-1]*(m-1)%MOD;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;b0;    if(b0&gt;=m)&#123;        cout&lt;&lt;ksm(m,n)&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    init();    if(m*m&lt;=n)&#123;        cout&lt;&lt;SUB1::solve()&lt;&lt;&#x27;\n&#x27;;    &#125;else cout&lt;&lt;SUB2::solve()&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    initpw();    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 2.4 一点小感想
反射容斥源于卡特兰数的组合意义技巧，即我们一开始说的反射法。是反射法和容斥法的有机结合，更多地运用了容斥思想，用满足部分条件的集合的交并刻画我们 需要的集合。
在遇到有限制的格路计数问题中，我们可以通过反射容斥来进行操作。
至于 Dyck 路，先咕咕咕吧。
 3. 参考
图源：

第一章图出处：浅谈卡特兰数 - fhq_treap 和我。
2.1 图出处：StayAlone 的文章。
2.2 图出处：格路计数和反射容斥 - OIer某罗

参考：

浅谈卡特兰数 - fhq_treap。
StayAlone 的文章。
格路计数和反射容斥 - OIer某罗
格路计数与反射容斥 - yzy4090

]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>同余最短路</title>
    <url>/posts/c1d10176/</url>
    <content><![CDATA[ 0. 前言
本篇文章不发布于洛谷文章广场，因为我是在自己 yy，不保证正确。
 1. 介绍
同余最短路，用于解决完全背包计数问题，例如给你 nnn 个数，每个数可以选无限次，问你用这些数能够拼凑出的信息。
这里我们一般化，给定物品体积 aaa，每个物品可以选无数次，问是否存在一种选择方式，使得物品总体积恰好为 xxx。
考虑 DP，设 f(i)f(i)f(i) 表示能否拼凑出体积 xxx，转移方程是显然的：
f(x)=f(x)or⁡f(x−ai)f(x)=f(x) \operatorname{or} f(x-a_{i})
f(x)=f(x)orf(x−ai​)
这是一个有向无环图（DAG）上的动态规划，没有环，这样的时间复杂度是非常高，因为我们要枚举 xxx，当 xxx 非常大的时候是无法承受。
而同余最短路就是优化这一过程的，首先对于一个完全背包计数问题，如果 xxx 可以被凑出来，那么 x+ai,x+2ai,…x+a_{i},x+2a_{i},\dotsx+ai​,x+2ai​,… 是可以都能够凑出来的。即如果能凑出来 xxx，那么 x+k×ai(k≥0)x+k\times a_{i} (k\ge 0)x+k×ai​(k≥0) 是可以凑出的。
我们可以这样，我们设定一个基准物品 mmm，令 mmm 为它的体积。前面我们提到了这种凑的方案，考虑用基准物品表示这些。
我们用基准物品去表示，所有 kmkmkm 的都会被标记，最终 xxx 序列会剩下这样的集合没有被标记：{x+km∣x∈[0,m−1],k∈N}\left\{ x+km | x\in [0,m-1],k \in \mathbb{N}\right\}{x+km∣x∈[0,m−1],k∈N}。那这些怎么处理呢？我们有一个思路，我们不妨设 disidis_{i}disi​ 表示 iii 最小能够表示的数，那么所有更大的 disi+kmdis_{i}+kmdisi​+km 是可以标记，也就是说我们只需要求出最小标记的数即可，那么现在问题缩小到了 x∈[0,m−1]x\in [0,m-1]x∈[0,m−1] 的范围内，也就是 mmm 下的剩余类。
上面说这么多的话，只涉及到基准物品的刻画，但是其他的物品你可是一点都没有考虑！别急，我们现在就考虑这些物品带来的贡献，考虑现在我们需要求什么，我们需要求 disidis_{i}disi​ 即 iii 最小能够表示的数。这个时候我们就可以考虑 aia_{i}ai​ 这个跳板，我们利用这个跳板来求解 disidis_{i}disi​，对于每个其他物品 aia_{i}ai​，尝试将其加到当前已覆盖的数上，从而扩展剩余类的可表示范围。
具体的，对于每个 u∈[0,m−1]u\in[0,m-1]u∈[0,m−1]，计算 v=(u+ai) mod mv=(u+a_{i})\bmod mv=(u+ai​)modm（更新 disdisdis 的 i∈[0,m−1]i\in[0,m-1]i∈[0,m−1]），并更新：
disv=min⁡(disv,disu+ai)dis_{v}=\min (dis_{v},dis_{u}+a_{i})
disv​=min(disv​,disu​+ai​)
即若已知 x≡u(modm)x \equiv u \pmod mx≡u(modm) 的最小可表述数是 disudis_{u}disu​，那么 x+ai≡v(modm)x+a_{i} \equiv v \pmod mx+ai​≡v(modm) 也是一个可表示数，且可能成为 vvv 的更优解。
细心的读者可能已经发现这不就是最短路的形式吗！没错我们可以这么刻画，u→(u+ai) mod mu \to (u+a_{i})\bmod mu→(u+ai​)modm 连边，边权 aia_{i}ai​，因为没有负边权我们可以跑 Dijkstra 或 SPFA即可。
其实我们上述变化的本质，就是们钦定一个基准物品，现在我们有了基准物品所构成一个取数集合，让后让其他物品在基准物品上拓宽这个集合的选取范围，上述的最短路过程相当于就是过动态松弛，逐步探索如何组合不同的 aia_{i}ai​​ 来覆盖所有剩余类。最短路径长度 disrdis_{r}disr​ 给出了每个剩余类的最小可表示数，对应原问题就是可以将两次经过同一个点之间添加的所有物品换成若干基准物品。所以，我们可以将完全背包转化为类多重背包问题，从而解决了完全背包的计数问题。
至于类多重背包的解释就是：完全背包的 “无限” 选择被限制。-在同余最短路中，由于剩余类的周期性和最短路的最优性，每个物品 aia_{i}ai​ 在实际转移过程中最多使用有限次。如果在最短路中，某个物品 aia_{i}ai​​ 被多次使用（例如两次经过同一个剩余类），则中间的部分可以替换为若干基准物品 mmm。
一般的，我们基准物品 mmm 取 m=∑i=1naim=\sum\limits_{i=1}^n a_{i}m=i=1∑n​ai​。这样能保证点数尽量小，选取其他也是可以的。
同余最短路的本质：就是从完全背包的 DP 到模意义下的最短路。
 2. 一些例题
 P3403 跳楼机
显然操作 4 没有任何卵用，其实就是上面的问题板子，这里给出上面的一种实现。
#include&lt;bits/stdc++.h&gt;#define int long long#include &lt;float.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e5+15;struct Edge&#123;    int v,w;&#125;;int x,y,z,dis[MN],h;vector&lt;Edge&gt; adj[MN];bool vis[MN];void dij()&#123;    memset(dis,0x3f,sizeof(dis));    memset(vis,0,sizeof(vis));    priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;    q.push(pir(0,0));    dis[0]=0;    while(!q.empty())&#123;        int u=q.top().second;        q.pop();        if(vis[u]) continue;        vis[u]=1;        for(auto e:adj[u])&#123;            if(dis[e.v]&gt;dis[u]+e.w)&#123;                dis[e.v]=dis[u]+e.w;                q.push(&#123;dis[e.v],e.v&#125;);            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;h&gt;&gt;x&gt;&gt;y&gt;&gt;z;    if(x==1||y==1||z==1)&#123;        cout&lt;&lt;h;        return 0;    &#125;    h--;//注意从 0 开始    for(int i=0;i&lt;x;i++)&#123;        adj[i].push_back(&#123;(i+y)%x,y&#125;);        adj[i].push_back(&#123;(i+z)%x,z&#125;);    &#125;    dij();    int ans=0;    for(int i=0;i&lt;x;i++)&#123;        if(dis[i]&lt;=h) ans+=(h-dis[i])/x+1; //计算贡献    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P2371 [国家集训队] 墨墨的等式
将询问差分，现在问题转化为求 [1,n][1,n][1,n] 的问题，这个问题其实和上面是一个问题，只不过从 n=3n=3n=3 拓展了。
#include&lt;bits/stdc++.h&gt;#define int long long#include &lt;float.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=6e5+15;struct Edge&#123;    int v,w;&#125;;int n,ans1,ans2,fz=-1,a[MN],dis[MN],l,r;vector&lt;Edge&gt; adj[MN];bool vis[MN];void dij()&#123;    memset(dis,0x3f,sizeof(dis));    memset(vis,0,sizeof(vis));    priority_queue&lt;pir,vector&lt;pir&gt;,greater&lt;pir&gt;&gt; q;    q.push(pir(0,0));    dis[0]=0;    while(!q.empty())&#123;        int u=q.top().second;        q.pop();        if(vis[u]) continue;        vis[u]=1;        for(auto e:adj[u])&#123;            if(dis[e.v]&gt;dis[u]+e.w)&#123;                dis[e.v]=dis[u]+e.w;                q.push(&#123;dis[e.v],e.v&#125;);            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        if(a[i]==1)&#123;            cout&lt;&lt;r-l+1;            return 0;        &#125;        if(a[i]!=0&amp;&amp;fz==-1) fz=i;    &#125;    if(fz==-1)&#123;        cout&lt;&lt;0;        return 0;    &#125;    for(int i=0;i&lt;a[fz];i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            adj[i].push_back(&#123;(i+a[j])%a[1],a[j]&#125;);        &#125;    &#125;    dij();    l--;    for(int i=0;i&lt;a[fz];i++)&#123;        if(dis[i]&lt;=r) ans1+=((r-dis[i])/a[fz]+1);        if(dis[i]&lt;=l) ans2+=(l-dis[i])/a[fz]+1;    &#125;    cout&lt;&lt;ans1-ans2;    return 0;&#125;
 3. 最短路优化
最短路的时间复杂度有的时候比较高，不能承受，我们考虑能不能给他优化一下。
我们考虑，一个物品 aia_{i}ai​ 最多用几次就没有意义了，你可能认为是 ai−1a_{i}-1ai​−1，对也不对。其实更好的上限应该是 aigcd⁡(ai,m)−1\dfrac{a_{i}}{\gcd(a_{i},m)}-1gcd(ai​,m)ai​​−1，也就是说用 aigcd⁡(ai,m)\dfrac{a_{i}}{\gcd(a_{i},m)}gcd(ai​,m)ai​​ 次就会出现 aia_{i}ai​ 的倍数，为什么？
kai mod m=0m∣kai\begin{aligned}
ka_{i} \bmod m &amp; =0 \\
m &amp; | ka_{i}
\end{aligned}
kai​modmm​=0∣kai​​
不妨设 g=gcd⁡(ai,m)g=\gcd(a_{i},m)g=gcd(ai​,m)，那么有：
gn∣kgm,gcd(n,m)=1n∣km∵gcd(n,m)=1∴n∣k\begin{aligned}
gn|kgm,gcd(n,m) &amp;=1 \\
n | km \\
\because gcd(n,m)=1 \\
\therefore n|k
\end{aligned}
gn∣kgm,gcd(n,m)n∣km∵gcd(n,m)=1∴n∣k​=1
所以 kkk 最小取值就是 nnn，即 aigcd⁡(ai,m)\dfrac{a_{i}}{\gcd(a_{i},m)}gcd(ai​,m)ai​​。于是我们就可以涉及转移啦，这里借用 同余最短路 林晋堃 的图：

不难发现转移呈环状，考虑从这个环下手，我们把所有这个物品用的次数中相同余数的点缩成一个点，就变成了这样：

好像时间复杂度根本就没有任何变化，但是我们注意到前面的结论，我们从任何一个余数出发原本只能走 gcd⁡(m,ai)−1\gcd(m,a_{i})-1gcd(m,ai​)−1 就停了下来，但是转圈法，也就是我们对最短路的优化，就是不要停下来，继续走，那么每个点的状态如下：

这种转移方式和刚才的转移不太一样，但是因为每个点的答案起码都大于等于 3 了，由于超过 3 就没有用了所以说这个转移方法转移次数不仅更优，而且也不会影响到答案。  这就是——大名鼎鼎的转圈背包！至于为什么叫转圈背包，那是因为这个转移很像在转圈。
总的来说，就是模 mmm 意义下的完全背包，对于体积为 aia_{i}ai​ 的物品在长度为 mmm 的环上生成 d=gcd⁡(ai,m)d=\gcd(a_{i},m)d=gcd(ai​,m) 个子环从一个点出发，不可能绕着子环走一圈再转移回到该点，因为最短路不会经过同一个点两次，否则存在负环。如果重复经过同一个点，那么可以将这两次经过之间加入的所有物品替换为若干基准物品。
我们考虑添加 aia_{i}ai​ 的时候，至多加入 mgcd⁡(ai,m)−1\dfrac{m}{\gcd(a_{i},m)}-1gcd(ai​,m)m​−1 个。对于每个子环，我们绕子环转两圈即可更新到所有答案，若从最小点开始则一即可。
 4. 最短路优化例题
 P2371 墨墨的等式
来个模板！
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15;int n,m,l,r,ans,a[MN],b[MN],f[MN];signed main()&#123;    cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        if(!a[i]) n--,i--;    &#125;    if(!n) cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;,exit(0);    memset(f,0x3f,sizeof(f));    f[0]=0;    sort(a+1,a+1+n);    m=a[1];    for(int i=1;i&lt;=n;i++)&#123;        b[i]=a[i]%m;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=0,lim=__gcd(a[i],m);j&lt;lim;j++)&#123;            for(int k=j,c=0;c&lt;2;c+=k==j)&#123;                int p=k+b[i];                if(p&gt;=m) p-=m;                f[p]=min(f[p],f[k]+a[i]);                k=p;            &#125;        &#125;    &#125;    for(int i=0;i&lt;a[1];i++)&#123;        if(r&gt;=f[i]) ans+=max((r-f[i])/a[1]+1,0ll);        if(l&gt;f[i]) ans-=max((l-1-f[i])/a[1]+1,0ll);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 洛谷 P2662 牛场围栏
本质上就是将处理过后的 aia_{i}ai​ 跑上面的东西，代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;constexpr int INF=1e18;int f[MN],a[MN],b[MN],tot,n,m,ans,mod;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    sort(a+1,a+1+n);    mod=max(1ll,a[1]-m);    if(mod==1)&#123;        cout&lt;&lt;-1;        return 0;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        int lst=max(a[i-1]+1,a[i]-m);        for(int j=lst;j&lt;=a[i];j++)&#123;            if(j!=mod)&#123;                b[++tot]=j;            &#125;        &#125;    &#125;    sort(b+1,b+1+tot);    tot=unique(b+1,b+1+tot)-b-1;    memset(f,0x3f,sizeof(f));    f[0]=0;    for(int i=1;i&lt;=tot;i++)&#123;        for(int j=0,lim=__gcd(b[i],mod);j&lt;lim;j++)&#123;            for(int cur=j,c=0;c&lt;2;c+=cur==j)&#123;                int nxt=(cur+b[i])%mod;                f[nxt]=min(f[nxt],f[cur]+b[i]);                cur=nxt;            &#125;        &#125;    &#125;    for(int i=0;i&lt;mod;i++)&#123;        if(f[i]&gt;=0x3f3f3f3f3f3f3f3f)&#123;            cout&lt;&lt;-1;            return 0;        &#125;        ans=max(ans,f[i]-mod);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 「THUPC 2023 初赛」背包
这个题好，有助于我们完全理解同余最短路。
本题在完全背包的可行性基础上加入了权值这一维度。我们上面的题都是把 mmm 作为 aia_{i}ai​ 的最小值出现，而这里我们并不是要 aia_{i}ai​ 的最小值，而是将 civi\dfrac{c_{i}}{v_{i}}vi​ci​​ 最大的物品选座位基准物品，即把性价比最大的物品设置为基准物品。
如果你理解上述的过程，不难发现一个点就是实际上基准物品仍然在标记数字中占贡献的绝大部分，将一部分其它物品替换为若干基准物品，以最大化单位体积贡献的价值。所以如果题目中有限制，那么基准物品的选取将成为关键的地方。
容易发现对于一些总体积为 vkv_{k}vk​ 的物品不如换为 kkk，因为 kkk 是性价比最高的。但是对于总体积 vkv_{k}vk​ 来说就不一定，最优解可能比全部取 kkk 并空出剩下容量要优或劣。考虑求出两个背包方案的优劣之分。考虑 DP，设 VVV 为体积，CCC 为价值，设 f(i)f(i)f(i) 表示 i≡V(modvk)i \equiv V \pmod {v_{k}}i≡V(modvk​) 下最大的 C−⌊Vvk⌋×ckC-\lfloor \dfrac{V}{v_{k}} \rfloor \times c_{k}C−⌊vk​V​⌋×ck​，也就是最优解比全取 kkk 优劣多少。有转移：
fi=max⁡j=1nfj+cj−⌊i+vjvk⌋×ckf_{i}=\max_{j=1}^n f_{j}+c_{j}-\lfloor \dfrac{i+v_{j}}{v_{k}} \rfloor \times c_{k}
fi​=j=1maxn​fj​+cj​−⌊vk​i+vj​​⌋×ck​
转移有后效性，考虑跑最长路，这个图是负边权图，可以跑，用转圈时间复杂度 O(nm)O(nm)O(nm)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int f[MN],n,q,mv[MN],md[MN],v[MN],d[MN],c[MN],w,m=1;signed main()&#123;    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;v[i]&gt;&gt;c[i];        if(w*v[i]&lt;c[i]*m) w=c[i],m=v[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        mv[i]=v[i]%m;        md[i]=v[i]/m;    &#125;    for(int i=1;i&lt;m;i++)&#123;        f[i]=-1e18;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=0,lim=__gcd(v[i],m);j&lt;lim;j++)&#123;            for(int k=j,cy=0;cy&lt;2;cy+=k==j)&#123;                int p=k+mv[i],d=md[i];                if(p&gt;=m) p-=m,d++;                f[p]=max(f[p],f[k]+c[i]-d*w);                k=p;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=q;i++)&#123;        int V;        cin&gt;&gt;V;        int p=V%m;        if(f[p]&lt;-1e17) cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;        else cout&lt;&lt;f[p]+V/m*w&lt;&lt;&#x27;\n&#x27;;    &#125;        return 0;&#125;
 5. 总结
同余最短路，其实就是对于完全背包计数问题的一种解决方案，通过模意义与基准物品的选取优化。
放点同类的题？
ARC084B Small Multiple
「NOIP2018」货币系统
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组全家桶-从哈希乱搞到入门</title>
    <url>/posts/469b7eaa/</url>
    <content><![CDATA[可能更洛谷的阅读体验
 0. 前言
后缀数组是信息学竞赛中解决字符串匹配的一大利器，其思想和实现非常简单。虽然倍增加排序的思想很简单，但是它的拓展 hththt 数组功能及其强大并且适用性广，在 OI 范围内广泛应用。
以下应用魏老师的一句话：

几乎所有字符串算法都存在一个共性：基于所求信息的特殊性质与已经求出的信息，使用增量法与势能分析求得所有信息。这体现了动态规划思想。—— Alex_Wei

希望读者也能好好利用这句话来理解字符串算法。
本文章包含后缀数组入门，以及应用，以及技巧及其好题选讲大礼包！
但是作为本蒟蒻第一个写的算法全家桶，为了考虑到读者感受，写了一大堆没用的废话导致文章及其的长 ( •́ὤ•̀)，本文章共 2.1 万字，感谢管理员付出时间来进行审核。
一些基本约定：

本文章默认字符串下表从 111 开始。
我们用打字机字体表示字符串的内容，如：s=wjyppm1403s=\texttt{wjyppm1403}s=wjyppm1403。
拼接：s+ts+ts+t 表示将 ttt 拼接 sss 后。
字符集：即构成字符串中字符的集合。
空串：不含任何字符的字符串称为空串。
子串：在 sss 开头或末尾删去若干字符得到的字符串称作为 sss 的子串，sss 本身和空串也是 sss 的子串。我们定义 s[l,r]s[l,r]s[l,r] 表示 l→rl \to rl→r 上所有字符链接而成子串。
匹配：称 ttt 匹配 sss 当且仅当 ttt 在 sss 中出现。
字符串长度：我们用 ∣s∣|s|∣s∣ 来表示 sss 的长度。

前后缀：

前缀：在 sss 末尾删除若干字符得到的字符串称作 sss 的前缀，记为 preprepre。
后缀：在 sss 开头删除若干字符得到的字符串称作 sss 的后缀，记为 sufsufsuf。
最长公共前缀：LCP⁡(s,t)\operatorname{LCP}(s,t)LCP(s,t)，表示 s,ts,ts,t 的最长公共前缀，即最长的 uuu 使得 uuu 为 s,ts,ts,t 的前缀。最长公共后缀同理，我们称为 LCS⁡(s,t)\operatorname{LCS}(s,t)LCS(s,t)。LCP 的长度格式为：∣LCP⁡(s,t)∣|\operatorname{LCP}(s,t)|∣LCP(s,t)∣。
字典序：定义空字符小于任何字符。称 sss 的 字典序 小于 ttt 当且仅当去掉 LCP⁡(s,t)\operatorname{LCP}(s,t)LCP(s,t) 后，sss 的第一个字符小于 ttt 的第一个字符。等价于以第 iii 个字符作为第 iii 关键字比较。

我们先从概念讲起。
 1. 后缀树与后缀数组
 1.1 朴素后缀树
一个字符串的后缀是指从某个位置开始到结尾的一个子串，即 sufi=s[i→len]suf_{i}=s[i \to len]sufi​=s[i→len]。例如字符串 s=&quot;vamamadn&quot;s=\texttt{&quot;vamamadn&quot;}s=&quot;vamamadn&quot;，它的后缀有 888 个，suf0=&quot;vamamadn&quot;,suf1=&quot;amamadn&quot;,suf2=&quot;mamadn&quot;suf_{0}=\texttt{&quot;vamamadn&quot;},suf_{1}=\texttt{&quot;amamadn&quot;},suf_{2}=\texttt{&quot;mamadn&quot;}suf0​=&quot;vamamadn&quot;,suf1​=&quot;amamadn&quot;,suf2​=&quot;mamadn&quot; 等。
而后缀树，就是把字符串所有后缀子串通过字典树的方法建立的一颗树。如下图：

若要在字符串上找一个子串是否出现，如 &quot;mam&quot;\texttt{&quot;mam&quot;}&quot;mam&quot;，只需要在后缀树上查找就可以啦。
但是，问题在于，你全部显式的建出来那你空间不就炸掉了吗。我们思考这样的朴素后缀树的问题在哪里，这种方法的本质就是把一个长度为 nnn 的字符串拆成 nnn 个后缀子串，让后按照字典树来进行构造。但问题在于这样构建下来，每一次插入都是 O(n)O(n)O(n) 的时间复杂度，而遍历同样。并且当最坏情况下字符串字符互不相同的时候时间复杂度和空间复杂度都退化到 O(n2)O(n^2)O(n2)，一般情况下我们是无法接受的，那有没有什么好用的呢？
 1.2 后缀数组
由于不方便直接对后缀树进行构造，我们利用后缀数组这种简单的方法来替代它，我们定义：saisa_{i}sai​ 表示将所有后缀排序后第 iii 小的后缀的位置。这也就是我们所说的后缀数组。
那么将上面后缀树的例子，我们用后缀数组来表示一下：



后缀 sufisuf_isufi​
下表 iii

字典序
后缀数组 sajsa_jsaj​
下表 jjj




&quot;vamamadn&quot;\texttt{&quot;vamamadn&quot;}&quot;vamamadn&quot;
1

&quot;adn&quot;\texttt{&quot;adn&quot;}&quot;adn&quot;
6
1


&quot;amamadn&quot;\texttt{&quot;amamadn&quot;}&quot;amamadn&quot;
2

&quot;amadn&quot;\texttt{&quot;amadn&quot;}&quot;amadn&quot;
4
2


&quot;mamadn&quot;\texttt{&quot;mamadn&quot;}&quot;mamadn&quot;
3

&quot;amamadn&quot;\texttt{&quot;amamadn&quot;}&quot;amamadn&quot;
2
3


&quot;amadn&quot;\texttt{&quot;amadn&quot;}&quot;amadn&quot;
4

&quot;dn&quot;\texttt{&quot;dn&quot;}&quot;dn&quot;
7
4


&quot;madn&quot;\texttt{&quot;madn&quot;}&quot;madn&quot;
5

&quot;madn&quot;\texttt{&quot;madn&quot;}&quot;madn&quot;
5
5


&quot;adn&quot;\texttt{&quot;adn&quot;}&quot;adn&quot;
6

&quot;mamadn&quot;\texttt{&quot;mamadn&quot;}&quot;mamadn&quot;
3
6


&quot;dn&quot;\texttt{&quot;dn&quot;}&quot;dn&quot;
7

&quot;n&quot;\texttt{&quot;n&quot;}&quot;n&quot;
8
7


&quot;n&quot;\texttt{&quot;n&quot;}&quot;n&quot;
8

&quot;vamamadn&quot;\texttt{&quot;vamamadn&quot;}&quot;vamamadn&quot;
1
8



很明显，后缀数组的下表对应的就是后缀子串的字典顺序，记录的子串的有序排列。例如 sa1=5sa_{1}=5sa1​=5 表示排名为 111（即字典序最小）的后缀是源字符串从第 555 个位置开始的后缀子串。
上面是一个例子，下面是 OI-Wiki 的例子：

我们定义另外一个数组 rkrkrk 表示 sufisuf_{i}sufi​ 在字符串所有后缀的字典序排名，我们称作排名数组。显然，rkrkrk 与 sasasa 是互为逆运算的：

sasasa：将排名映射到源字符串的位置。
rkrkrk：将位置映射到源字符串的字典序排名。

那么有 sa(rk[i])=i,rk(sa[i])=isa(rk[i])=i,rk(sa[i])=isa(rk[i])=i,rk(sa[i])=i。
那么现在问题在于如何给这些后缀通过排序求出排名。有一个显而易见的想法是从最后一位开始枚举后缀，然后每次存下当前枚举到的字符串，最后排序并输出就 OK 辣！
但是这样显然复杂度起步就是 O(n2)O(n^2)O(n2)，排序复杂度就能够达到恐怖的 O(n2log⁡n)O(n^2 \log n)O(n2logn)，是无法接受的。
但是我们考虑，我们每一次都是一位一位比较的，我们能不能多位进行比较呢。这个时候我们就要用到倍增的思想：
首先对字符串 sss 长度为 111 的子串，即每个字符进行排序，得到排序后的编号数组 saisa_{i}sai​ 和排名数组 rkirk_{i}rki​，如下 OI-Wiki 的图：

第二次，我们根据倍增向后移 20=12^0=120=1 位，因为已经根据首字母排了一次序，所以现在就根据后面的排序。我们让第一关键字设置为上一次我们求得的 rankrankrank，第二关键字设置为下一位的字符：

第三次，移 21=22^1=221=2 位，还是根据我们上面的思路，让第一关键字设置为上一次我们求得的 rankrankrank，第二关键字设置为下一位的字符：

第四次：

唉？我们好像倍增完了，这样的话我们就求得了所有的 rankrankrank，接下来根据后缀数组性质：sa(rk[i])=isa(rk[i])=isa(rk[i])=i，就能够求出来 sasasa 啦。这样的时间复杂度，排序贡献 O(nlog⁡n)O(n \log n)O(nlogn)，倍增贡献 O(log⁡n)O(\log n)O(logn)，这样的时间复杂度就是 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
再看一遍整体的过程：

但是这样显然过不去我们可爱的 P3809，因为它要求 O(nlog⁡n)O(n\log n)O(nlogn)，我们考虑刚才的做法，排序是 O(nlog⁡n)O(n \log n)O(nlogn) 的，我们能不能从这里下手呢？我们可以考虑利用基数排序，这样我们就能做到 O(n)O(n)O(n) 啦，代码如下：
void getsa()&#123;    for(int i=1;i&lt;=n;i++)&#123;        x[i]=s[i];// x 就是        c[x[i]]++; //桶排    &#125;    for(int i=1;i&lt;=m;i++)&#123;        c[i]+=c[i-1];        //做一个前缀和。这样字典序越大，所对应的的 c 越大。    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sa[c[x[i]]--]=i;        //为何要减呢？若c[x[i]]&gt;1表示有重复的，要保证排序不一样。    &#125;    for(int len=1;len&lt;=n;len&lt;&lt;=1)&#123;// 倍增        int num=0;        for(int i=n-len+1;i&lt;=n;i++)&#123;            y[++num]=i;            //n-len+1已经排序完因为它们再倍增就倍增到空气啦。我们直接存在 y 中。        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(sa[i]&gt;len) y[++num]=sa[i]-len;        // 若 i 可作其他位置的第二关键字，我们把他放在对应的第一关键字        &#125;        for(int i=1;i&lt;=m;i++) c[i]=0;        for(int i=1;i&lt;=n;i++) c[x[i]]++;        for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=n;i&gt;=1;i--)&#123;            sa[c[x[y[i]]]--]=y[i];            y[i]=0;            // 注意, 倒序枚举保证计数排序的稳定性. 基数排序的正确性基于内层计数排序的稳定性.        &#125;        //和以前一样更新sa，但是排序是y[i]        swap(x,y);        num=1;        x[sa[1]]=1;        for(int i=2;i&lt;=n;i++)&#123;            if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+len]==y[sa[i-1]+len]) x[sa[i]]=num;            else x[sa[i]]=++num;        &#125;        //以上都是在更新 x        if(num==n) break;// n 个排名互不相同, 排序完成.        m=num;    &#125;&#125;
关于成熟的模板我们之后再说。对于上面的内容其实都比较还算简单，但是 SA 真正的神就在于 Height 数组，我们这里简称为 hththt。
 1.3 Height 数组
回顾 LCP 的定义：

最长公共前缀：LCP⁡(s,t)\operatorname{LCP}(s,t)LCP(s,t)，表示 s,ts,ts,t 的最长公共前缀，即最长的 uuu 使得 uuu 为 s,ts,ts,t 的前缀。

而 Height 数组的定义就是：ht[i]=LCP⁡(sa[i],sa[i−1])ht[i]=\operatorname{LCP}(sa[i],sa[i-1])ht[i]=LCP(sa[i],sa[i−1])，就是第 iii 名的后缀与它前一名的后缀的最长公共前缀。特别的，我们记 ht[1]=0ht[1]=0ht[1]=0。
绝大多数 SA 的应用都需要 hththt，很少见只用 sa,rksa,rksa,rk 就能解决的题目。不过分地说，后缀数组求 sasasa 就是为了求 hththt。
那么怎么求？有一个朴素的想法就是哈希加二分，这个想必读者在做哈希题经常会见到这种操作。不然为什么我们标题叫哈希乱搞到入门，我们有一个结论：

若 rki&lt;rkj&lt;rkkrk_{i}&lt;rk_{j}&lt;rk_{k}rki​&lt;rkj​&lt;rkk​，则 ∣LCP⁡(i,j)∣|\operatorname{LCP}(i,j)|∣LCP(i,j)∣ 和 ∣LCP⁡(j,k)∣|\operatorname{LCP}(j,k)|∣LCP(j,k)∣，均不小于 ∣LCP⁡(i,k)∣|\operatorname{LCP}(i,k)|∣LCP(i,k)∣。

证明？设 t=∣LCP⁡(i,k)∣t=|\operatorname{LCP}(i,k)|t=∣LCP(i,k)∣，因为 sufjsuf_{j}sufj​ 的字典序在 sufi,sufksuf_{i},suf_{k}sufi​,sufk​ 之间，所以 sufjsuf_{j}sufj​ 的前 ttt 个字符必然与 sufi,sufksuf_{i},suf_{k}sufi​,sufk​ 相等。这个还是比较容易理解的，因为字典序距离越近，LCP 越长吗。
若我们希望不要 O(nlog⁡n)O(n \log n)O(nlogn) 的求 hththt 的话，我们自然考虑其性质：
假设 htiht_ihti​ 已知，则 ∣LCP⁡(sai,sai−1)∣=hti|\operatorname{LCP}(sa_{i},sa_{i-1})|=ht_{i}∣LCP(sai​,sai−1​)∣=hti​。考虑 suf(sai−1+1),suf(sai+1)suf(sa_{i-1}+1),suf(sa_{i}+1)suf(sai−1​+1),suf(sai​+1)。当 hti&gt;0ht_{i}&gt;0hti​&gt;0，显然有 ∣LCP⁡(sai+1,sai−1+1)∣=hti−1|\operatorname{LCP}(sa_{i}+1,sa_{i-1}+1)|=ht_{i}-1∣LCP(sai​+1,sai−1​+1)∣=hti​−1，且根据 rk(sai−1)&lt;rk(sai)rk(sa_{i-1})&lt;rk(sa_{i})rk(sai−1​)&lt;rk(sai​)，容易证明 rk(sai−1+1)&lt;rk(sai+1)rk(sa_{i-1}+1)&lt;rk(sa_{i}+1)rk(sai−1​+1)&lt;rk(sai​+1)。
令 p=sai+1,q=sai−1+1p=sa_{i}+1,q=sa_{i-1}+1p=sai​+1,q=sai−1​+1，我们尝试求出 rkprk_{p}rkp​ 所对应的 hththt，我们现在有如下性质：

∣LCP⁡(p,q)∣=hti−1|\operatorname{LCP}(p,q)|=ht_{i}-1∣LCP(p,q)∣=hti​−1。
rk(q)&lt;rk(p)rk(q)&lt;rk(p)rk(q)&lt;rk(p)。

我们考虑，排名为 rkp−1rk_{p}-1rkp​−1 的后缀 sufrsuf_rsufr​ 的排名它要么等于 rkqrk_qrkq​，那么 q=rq=rq=r。要么夹在 rkq,rkprk_q,rk_prkq​,rkp​ 之间，因为 rkrrk_rrkr​ 是小于 rkprk_prkp​ 的最大正整数 rkp−1rk_{p}-1rkp​−1，而 rkqrk_qrkq​ 小于 rkprk_prkp​。那么根据上面结论，有 ht(rkp)≥hti−1ht(rk_{p})\ge ht_{i}-1ht(rkp​)≥hti​−1。我们考虑把 rkprk_{p}rkp​ 换一下，有 ht(rk(sai+1))≥ht(rk(sai))−1ht(rk(sa_{i}+1))\ge ht(rk(sa_{i}))-1ht(rk(sai​+1))≥ht(rk(sai​))−1，那么令 u=sai+1u=sa_{i}+1u=sai​+1，那么我们就有的 hththt 数组的核心性质：
ht(rku)≥ht(rku−1)−1ht(rk_{u})\ge ht(rk_{u-1})-1
ht(rku​)≥ht(rku−1​)−1
我们这里引用 Alex_Wei 的图：

通过这个性质，我们可以通过类似于双指针的性质来暴力求解 hththt，以下为代码：
for(int i=1;i&lt;=len;i++) rk[sa[i]]=i;for(int i=1,k=0;i&lt;=len;i++)&#123;    if(rk[i]==1) continue;    if(k) k--;    int j=sa[rk[i]-1];    while(i+k&lt;=len&amp;&amp;j+k&lt;=len&amp;&amp;s[i+k]==s[j+k]) k++;    ht[rk[i]]=ST[0][rk[i]]=k;&#125;
下面是一个完整的模板，但是里面有一些函数还没有讲解，在应用中我们会逐个讲解：
namespace SA&#123;    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN],ST[30][MN];    // 接受 string 和 vector_int 输入，其他输入不保证正确性    // ST表需要手动初始化调用initst函数    template&lt;typename vct&gt;    void getsa(vct &amp;s)&#123;        int m=400000;        len=s.size();        s.insert(s.begin(),&#x27; &#x27;);        for(int i=1;i&lt;=len;i++)&#123;            x[i]=s[i];            ++c[x[i]];        &#125;        for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=len;i&gt;=1;i--) sa[c[x[i]]--]=i;        for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123;            int num=0;            for(int i=len-k+1;i&lt;=len;i++) y[++num]=i;            for(int i=1;i&lt;=len;i++)&#123;                if(sa[i]&gt;k) y[++num]=sa[i]-k;            &#125;            for(int i=1;i&lt;=m;i++) c[i]=0;            for(int i=1;i&lt;=len;i++) c[x[i]]++;            for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];            for(int i=len;i&gt;=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;            swap(x,y);            num=1,x[sa[1]]=1;            for(int i=2;i&lt;=len;i++)&#123;                if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;                else x[sa[i]]=++num;            &#125;            if(num==len) break;            m=num;        &#125;        for(int i=1;i&lt;=len;i++) rk[sa[i]]=i;        for(int i=1,k=0;i&lt;=len;i++)&#123;            if(rk[i]==1) continue;            if(k) k--;            int j=sa[rk[i]-1];            while(i+k&lt;=len&amp;&amp;j+k&lt;=len&amp;&amp;s[i+k]==s[j+k]) k++;            ht[rk[i]]=ST[0][rk[i]]=k;        &#125;    &#125;    // ST表初始化    void initst()&#123;        for(int i=1;i&lt;30;i++)&#123;            for(int j=1;j+(1&lt;&lt;i)-1&lt;=len;j++)&#123;                ST[i][j]=min(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]);            &#125;        &#125;    &#125;    // 查询位置为 i 和 位置为 j 的后缀的 LCP    int querylcp(int i,int j)&#123;        if((i=rk[i])&gt;(j=rk[j])) swap(i,j);        int d=__lg(j-(i++));        return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);    &#125;    // 手动查询 ST 表    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(ST[d][l],ST[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;
 2. 后缀数组的应用
后缀数组有着许许多多的应用，但是由于对应的例题过于杂且用到的芝士较多，我们的顺序是先讲解技巧，先认识，让后我们在最后一部分的习题环节进行练习。有一些应用是对应少见的例题，所以这里会直接进行讲解而不会放在习题。
 2.1 寻找最小的循环移动位置
循环移动位置实际上就是将字符串排为一个环，让后旋转这个环，我们先要断环成链将给定字符串复制一遍放在后面，这样就变为了后缀排序问题。
 JSOI2007字符加密
我们发现，循环移动位置实际上就是将字符串排为一个环，让后旋转这个环，我们先要断环成链。把给定字符串复制一遍放在后面。让后你发现题目其实就是把这个改变后的字符串进行后缀排序，我们根据后缀排序的数组让后输出对应最后一位就可以了：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=8e5+15;int x[MN],n,m,y[MN],c[MN],sa[MN];string s;void getsa()&#123;    for(int i=1;i&lt;=n;i++)&#123;        x[i]=s[i];        c[x[i]]++;    &#125;    for(int i=2;i&lt;=m;i++)&#123;        c[i]+=c[i-1];    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sa[c[x[i]]--]=i;    &#125;    for(int len=1;len&lt;=n;len&lt;&lt;=1)&#123;        int num=0;        for(int i=n-len+1;i&lt;=n;i++)&#123;            y[++num]=i;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(sa[i]&gt;len)&#123;                y[++num]=sa[i]-len;            &#125;        &#125;        for(int i=1;i&lt;=m;i++)&#123;            c[i]=0;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            c[x[i]]++;        &#125;        for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=n;i&gt;=1;i--)&#123;            sa[c[x[y[i]]]--]=y[i];            y[i]=0;        &#125;        swap(x,y);        num=1;        x[sa[1]]=1;        for(int i=2;i&lt;=n;i++)&#123;            if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+len]==y[sa[i-1]+len])&#123;                x[sa[i]]=num;            &#125;else x[sa[i]]=++num;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;s;    n=s.length()*2;    m=300000;    s=&#x27; &#x27;+s+s;    getsa();    for(int i=1;i&lt;=n;i++)&#123;        if(sa[i]&lt;=n/2) cout&lt;&lt;s[sa[i]+n/2-1];    &#125;    return 0;&#125;
 2.2 在字符串中寻找最长公共子串
细节我给同学讲解 Trie 习题后教练考我这个问题，还好我即会后缀数组也会哈希做法 www。
同学问我哈希怎么做，显然最长公共子串的长度满足可二分性，考虑二分最长公共子串长度 LLL ，现在问题转化为判定性问题。我们考虑最简单的情况：两个串。我们对第一个串拿长度为 LLL 的滑块在上面滑，过程中把哈希值存下来到哈希表，第二个串同样，但我们判断哈希值是否出现过即可，这个情况可以拓展到一般串的情况，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn) 但常数极大！这是一个滑块思想的应用。
如何用 SA 做呢？现在我们要求在主串 TTT 中寻找子串 SSS，我们先建出 TTT 的后缀数组，让后查找子串 SSS。若子串在 TTT 中出现，它必定是 TTT 的一些后缀的前缀，我们可以通过在后缀数组中二分 SSS 来实现。比较子串 SSS 和后缀的时间复杂度是 O(∣S∣)O(|S|)O(∣S∣) 的，那么总时间复杂度是 O(∣S∣log⁡∣T∣)O(|S| \log |T|)O(∣S∣log∣T∣) 的，注意，如果该子串在 TTT 中出现了多次，每次出现都是在后缀数组数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。
这一部分主要考察二分的操作使用，在下面的例题中我们也会详细的进行讲解。
 2.3 从字符串首尾取字符最小化字典序
给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。
例题：「USACO07DEC」Best Cow Line。
一个暴力的想法就是 O(n)O(n)O(n) 判断取首还是取尾，我们现在只需要优化即可，因为取尾实际上就是在反串中取，我们可以将原串后缀和反串后缀构成的集合比较大小，可以将反串拼接在原串后，并在中间加上分隔符，求后缀数组，即可 O(1)O(1)O(1) 判断：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e6+15;int x[MN],y[MN],rk[MN],sa[MN],c[MN],n,sn,m;string s,revs;void getsa()&#123;    for(int i=1;i&lt;=n;i++)&#123;        x[i]=s[i];        c[x[i]]++;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        c[i]+=c[i-1];    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sa[c[x[i]]--]=i;    &#125;    for(int len=1;len&lt;=n;len&lt;&lt;=1)&#123;        int num=0;        for(int i=n-len+1;i&lt;=n;i++)&#123;            y[++num]=i;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(sa[i]&gt;len)&#123;                y[++num]=sa[i]-len;            &#125;        &#125;        memset(c,0,sizeof(c));        for(int i=1;i&lt;=n;i++)&#123;            c[x[i]]++;        &#125;        for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=n;i&gt;=1;i--)&#123;            sa[c[x[y[i]]]--]=y[i];            y[i]=0;        &#125;        swap(x,y);        num=1;        x[sa[1]]=1;        for(int i=2;i&lt;=n;i++)&#123;            if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+len]==y[sa[i-1]+len])&#123;                x[sa[i]]=num;            &#125;else x[sa[i]]=++num;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        rk[sa[i]]=i;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    m=5e5;    for(int i=1;i&lt;=n;i++)&#123;        char awa;        cin&gt;&gt;awa;        s.push_back(awa);    &#125;    for(int i=s.length()-1;i&gt;=0;i--)&#123;        revs.push_back(s[i]);    &#125;    sn=n;    // cout&lt;&lt;s&lt;&lt;&#x27;\n&#x27;&lt;&lt;revs&lt;&lt;&#x27;\n&#x27;;    s=&#x27; &#x27;+s+(char)0+revs;    n=(n*2+1);    getsa();    int tot=0;    for(int l=1,r=sn;l&lt;=r;)&#123;        if(rk[l]&lt;rk[n+1-r])&#123;            cout&lt;&lt;s[l++];        &#125;else cout&lt;&lt;s[r--];        if((++tot)%80==0) cout&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 2.4 与贪心与 DP 的结合
对于后缀数组，在贪心和 DP 中一般不作为主角出现，多用于字符串加速匹配的问题或者利用其性质进行求解。
 2.5 与线段树等一类数据结构结合
某些题目让你求满足条件的前若干个数，而这些数又在后缀排序中的一个区间内。这时我们可以用归并排序的性质来合并两个结点的信息，利用线段树维护和查询区间答案。
同时后缀数组会根据题目的不同结合一系列数据结构算法，如莫队，扫描线等。在习题部分我们会单独开讲。
 3. Height 数组的应用
 3.1 任意两个后缀的 LCP
有了 hththt 数组，我们可以快速求出一个字符串 sss 的 iii 后缀和 jjj 后缀的最长公共前缀 LCP⁡(i,j)\operatorname{LCP}(i,j)LCP(i,j)。
结论如下：

若 rki&lt;rkjrk_{i}&lt;rk_{j}rki​&lt;rkj​，则 ∣LCP⁡(i,j)∣=min⁡p=rki+1rkjhtp|\operatorname{LCP}(i,j)|=\min\limits_{p=rk_{i}+1}^{rk_{j}}ht_p∣LCP(i,j)∣=p=rki​+1minrkj​​htp​。

感性理解以下，如果 HeightHeightHeight 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。
严格证明可以参考[2004] 后缀数组 by. 许智磊。那么通过这样，求两子串最长公共前缀就转化为了 RMQ 问题，这也就是对应了我们模板中的 ST 表，实现如下：
// ST表初始化void initst()&#123;    for(int i=1;i&lt;30;i++)&#123;        for(int j=1;j+(1&lt;&lt;i)-1&lt;=len;j++)&#123;            ST[i][j]=min(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]);        &#125;    &#125;&#125;// 查询位置为 i 和 位置为 j 的后缀的 LCPint querylcp(int i,int j)&#123;    if((i=rk[i])&gt;(j=rk[j])) swap(i,j);    int d=__lg(j-(i++));    return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);&#125;
我们这里引用 Alex_wei 的图：

上图就是对 aabaaaab\texttt{aabaaaab}aabaaaab 进行后缀排序后的结果以及 hththt 数组，由矩形框起来的两个字符串相等。那么根据上面的图也能理解两个后缀之间的 LCP 就是它们排名之间所有矩形宽度的最小值，即 hththt 的最小值。
但是，如果我们将整张图逆着旋转 909090 的话，那么有：

我们得到了一个矩形柱状图！hththt 恰好表示了每个矩形的高度，这也可能就说明了为什么名字叫做 Height 数组。观察这个图你有没有想到什么？

没错，这个玩意我们还是可以和单调栈结合起来一起考的！众所周知，单调栈可以求出柱状图中面积最大的矩形。
例如我们求所有后缀两两 LCP 长度之和，考虑按排名顺序加入所有后缀并实时维护 F(i)=∑p=1i−1∣LCP⁡(sap,sai)∣F(i)=\sum\limits_{p=1}^{i-1}|\operatorname{LCP}(sa_{p},sa_{i})|F(i)=p=1∑i−1​∣LCP(sap​,sai​)∣，那么其实就是在维护 ∑p=1i−1min⁡q=p+1ihtq\sum\limits_{p=1}^{i-1} \min\limits_{q=p+1}^{i} ht_{q}p=1∑i−1​q=p+1mini​htq​，可以视为把单调栈加入高 htiht_{i}hti​，宽 111 的矩形后，单调栈内矩形面积之和。
 3.2 求本质不同子串数
可以用 sss 所有后缀的前缀表示所有子串，我们考虑每次添加一个后缀，并删去这个后缀与已经添加的后缀的所有重复前缀，而前缀总数就是子串个数，为 n(n+1)2\dfrac{n(n+1)}{2}2n(n+1)​，如果按后缀排序的顺序枚举后缀，每次新增的子串就是除了与上一个后缀的 LCP 剩下的前缀。这些前缀一定是新增的，否则会破坏 ∣LCP⁡(i,j)∣=min⁡p=rki+1rkjhtp|\operatorname{LCP}(i,j)|=\min\limits_{p=rk_{i}+1}^{rk_{j}}ht_p∣LCP(i,j)∣=p=rki​+1minrkj​​htp​ 的性质。只有这些前缀是新增的，因为 LCP 部分在枚举上一个前缀时计算过了。那么答案就是 n(n+1)2−∑i=2nhti\dfrac{n(n+1)}{2}-\sum\limits_{i=2}^n ht_{i}2n(n+1)​−i=2∑n​hti​。
上面的做法我们求得了 sss 所有后缀本质不同的前缀数量。我们可以拓展到求 sss 某个后缀集合 SSS 所有本质不同前缀数量！
设 SSS 的所有位置按排名从小到大排名后的位置分别为 p1,p2,…,p∣S∣p_1,p_2,\dots,p_{|S|}p1​,p2​,…,p∣S∣​，答案就是：
(∑i=1∣S∣n−pi+1)−(∑i=1∣S∣−1∣LCP⁡(pi,pi+1)∣)\left( \sum\limits_{i=1}^{|S|} n-p_{i}+1 \right)-\left(\sum\limits_{i=1}^{|S|-1} |\operatorname{LCP}(p_{i},p_{i+1})| \right)
⎝⎛​i=1∑∣S∣​n−pi​+1⎠⎞​−⎝⎛​i=1∑∣S∣−1​∣LCP(pi​,pi+1​)∣⎠⎞​
其中后面能够 ST 表预处理后 O(∣S∣)O(|S|)O(∣S∣) 求出。
 3.3 多个串的最长公共子串
给出 nnn 个字符串，求 s1,s2,…,sns_{1},s_{2},\dots,s_{n}s1​,s2​,…,sn​ 的最长公共子串。
首先我们先把这个字符串给拼接起来，格式入 t=s1+c1+s2+c2+⋯+cn−1+snt=s_{1}+c_{1}+s_{2}+c_{2}+\dots +c_{n-1}+s_{n}t=s1​+c1​+s2​+c2​+⋯+cn−1​+sn​，其中 ci=’z’+ic_{i}=\texttt{&#x27;z&#x27;}+ici​=’z’+i，即分隔符，但要求互不相同不然就会出现影响答案的情况啦。
让后我们对 ttt 建出 SA 数组，问题转化为求 max⁡1≤l≤r≤∣t∣min⁡p=l+1r∣LCP⁡(p,p−1)∣\max\limits_{1\le l \le r \le |t|} \min_{p=l+1}^r |\operatorname{LCP}(p,p-1)|1≤l≤r≤∣t∣max​minp=l+1r​∣LCP(p,p−1)∣，其中这个区间 [l,r][l,r][l,r] 合法当且仅当对于每一个字符串 sis_isi​ 的后缀都落在这个区间内。
容易发现 lll 增大的时候 rrr 是单调不降的，我们可以考虑双指针维护整个过程。此外，我们还需要维护区间最小值，可以考虑利用单调队列就可以维护啦，时间复杂度 O(n+nlog⁡n)O(n+n \log n)O(n+nlogn)。
 3.4 结合并查集
某些题目求解时要求你将后缀数组划分成若干个连续 LCP 长度大于等于某一值的段，我们可以考虑根据 hththt 的性质，当我们给定一个长度阀值 LLL 的时候，我们把所有 &lt;L&lt;L&lt;L 的 hththt 去掉，让后 hththt 将区间划分为若干个子区间，同一子区间任意两个后缀的 LCP 长度均大于 LLL。将询问离线，我们从大到小考虑所有 htiht_{i}hti​，每次在 sai−1,saisa_{i-1},sa_{i}sai−1​,sai​，之间连边利用数据结构如并查集加启发式合并维护这一过程，就可以得到每个后缀的 LCP 长度 ≥L\ge L≥L 所有后缀的信息。
对 htiht_{i}hti​ 建立笛卡尔树的效果是同样的。
 3.5 连续的若干个相同子串
如果题目中出现一些构造字符串循环构成的问题，我们可以不妨考虑枚举这个循环的长度 LLL，让后按照 LLL 将字符串划分关键点分块（即按照 LLL 的倍数分块）利用分块和字符串的重复性质，将看似全局的问题局部化解决。对应到后缀数组上就是对相邻两块的块进行 LCP 和 LCS 查询，具体如何操作我们下面会讲解。
 4. 例题
 4.1 并查集技巧
 P2852 [USACO06DEC] Milk Patterns G
呃其实就是板子题，这个真没有什么好说的，考虑从从大到小添加每个 htiht_{i}hti​，等价于每次在 sai−1,saisa_{i-1},sa_{i}sai−1​,sai​之间连边，当出现大小为 kkk 的联通块时 htiht_{i}hti​ 即为所求。如果你非要说 Oi-Wiki 的做法的话也是可以的吧……
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,k;string a;multiset&lt;int&gt; tt;namespace SA&#123;// 省略&#125;using namespace SA;int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    k--;    for(int i=1;i&lt;=n;i++)&#123;        int c;        cin&gt;&gt;c;        a.push_back(c);    &#125;    getsa(a);    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        tt.insert(ht[i]);        if(i&gt;k) tt.erase(tt.find(ht[i-k]));        ans=max(ans,*tt.begin());    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P2178 [NOI2015] 品酒大会
若 rrr 相似成立，那么对于 r′(1≤r′&lt;r)r&#x27;(1\le r&#x27; &lt; r)r′(1≤r′&lt;r) 相似也是成立的。若我们考虑 ≥L\ge L≥L 的 htiht_{i}hti​，将 sai−1,saisa_{i-1},sa_{i}sai−1​,sai​ 之间连边，若 p,qp,qp,q 在一个联通块，那么根据我们上面所说的，则 p,qp,qp,q 是 LLL 相似的。
我们考虑从大到小处理 htiht_{i}hti​，使用并查集与启发式合并维护每个联通块的大小以及所有权值，用最大值乘次大值，最小值乘次小值（有负数）更新当前合并后 LLL 的答案，时间复杂度为 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)，当然我们可以只维护最大，次大，最小，次小，这样就能做到 O(nlog⁡n)O(n \log n)O(nlogn) 啦。其实这才是我们并查集技巧的题。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=6e5+15;int n,m,x[MN],y[MN],cnt[MN],pre[MN],sa[MN],rk[MN],h[MN],pos[MN];ll mx[MN],mn[MN],ans1[MN],ans2[MN],ans[MN],a[MN],siz[MN];string s;namespace SA&#123;// 省略&#125;using namespace SA;void geth()&#123;    for(int i=1,k=0;i&lt;=n;i++)&#123;        if(!rk[i]) continue;        if(k) k--;        while(s[i+k]==s[sa[rk[i]-1]+k]) k++;        h[rk[i]]=k;    &#125;&#125;void init()&#123;    memset(ans2,128,sizeof(ans2));    for(int i=1;i&lt;=n;i++)&#123;        pre[i]=i;        pos[i]=i;        mx[i]=mn[i]=a[i];        ans[i]=-1e18;        siz[i]=1;    &#125;&#125;int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);&#125;void merge(int x,int y,int len)&#123;    x=root(x),y=root(y);    pre[y]=x;    ans1[len]+=(ll)siz[x]*siz[y];    siz[x]+=siz[y];    ans[x]=max(&#123;ans[x],ans[y],mx[x]*mx[y],mx[x]*mn[y],mn[x]*mx[y],mn[x]*mn[y]&#125;);    mx[x]=max(mx[x],mx[y]);    mn[x]=min(mn[x],mn[y]);    ans2[len]=max(ans2[len],ans[x]);&#125;bool cmp(int x,int y)&#123;    return h[x]&gt;h[y];&#125;int main()&#123;    cin&gt;&gt;n;    m=3e5;    cin&gt;&gt;s;    s=&#x27; &#x27;+s;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    getsa();    geth();    init();    sort(pos+2,pos+1+n,cmp);    // for(int i=1;i&lt;=n+1;i++)&#123;    //     cout&lt;&lt;sa[i]&lt;&lt;&quot; &quot;;    // &#125;    // cout&lt;&lt;&#x27;\n&#x27;;    for(int i=2;i&lt;=n;i++)&#123;        merge(sa[pos[i]],sa[pos[i]-1],h[pos[i]]);    &#125;    for(int i=n;i&gt;=0;i--) ans1[i]+=ans1[i+1];    for(int i=n;i&gt;=0;i--) ans2[i]=max(ans2[i],ans2[i+1]);    for(int i=0;i&lt;n;i++)&#123;        cout&lt;&lt;ans1[i]&lt;&lt;&quot; &quot;&lt;&lt;(ans1[i]?ans2[i]:0)&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 P6793 [SNOI2020] 字符串
我们考虑，每一次修改修改的都是一段后缀，启发我们对 a+ba+ba+b 拼接后形成的字符串进行后缀数组操作。我们有一个贪心的想法，我们每次修改两个 LCP 尽量长的子串，这个贪心显然正确的，证明考虑反证法即可。
那么，我们利用上面的思路，从大到小将 htiht_{i}hti​ 插入，实质上就是在从大到小枚举 LCP 进行贪心，每次贪心的消除当前联通块尽可能多的 a,ba,ba,b 后缀对，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int n,ans,K,as[MN],bs[MN],pre[MN];string a,b,s;vector&lt;int&gt; pos[MN];namespace SA&#123;	// 省略&#125;using namespace SA;int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);&#125;void merge(int x,int y,int lcpl)&#123;    int rx=root(x),ry=root(y);    if(rx==ry) return;    int tmp=min(as[rx],bs[ry]);    ans+=max(0ll,K-lcpl)*tmp;    as[rx]-=tmp;    bs[ry]-=tmp;    tmp=min(bs[rx],as[ry]);    ans+=max(0ll,K-lcpl)*tmp;    bs[rx]-=tmp;    as[ry]-=tmp;    as[ry]=as[rx]+as[ry],bs[ry]=bs[rx]+bs[ry];    pre[rx]=ry;&#125;signed main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    cin&gt;&gt;n&gt;&gt;K&gt;&gt;a&gt;&gt;b;    s=a+&#x27;#&#x27;+b;    for(int i=1;i&lt;=n;i++)&#123;        as[i]=(i+K-1&lt;=n);    &#125;    for(int i=n+2;i&lt;=2*n+1;i++)&#123;        bs[i]=(i-n-1+K-1&lt;=n);    &#125;    for(int i=0;i&lt;=2*n+1;i++)&#123;        pre[i]=i;    &#125;    getsa(s);    initst();    for(int i=n;i&gt;=0;i--)&#123;        for(auto p:pos[i])&#123;            merge(sa[p],sa[p-1],i);        &#125;    &#125;    put(ans);    return 0;&#125;
 P7361 「JZOI-1」拜神
形式化题面如下：

给定一个长为 nnn 的字符串，询问次数为 qqq，多次询问区间 [l,r][l,r][l,r] 内最长重复子串的长度。
1≤n≤5×104,1≤q≤1051\le n \le 5\times 10^4,1\le q \le 10^51≤n≤5×104,1≤q≤105。

没有形式化题面感觉都想不出来怎么做 www。
肯定没有那么菜啦，首先考虑二分长度，问题转化为区间内是否存在一个长为 midmidmid 的最长重复子串。
接下来我们考虑这个最长重复子串怎么求，一个比较明显的想法就是后缀数组的 LCP 功能，原命题询问的实质就问是否存在 i,j∈[l,r−mid+1],LCP⁡(i,j)≥midi,j \in [l,r-mid+1],\operatorname{LCP}(i,j)\ge midi,j∈[l,r−mid+1],LCP(i,j)≥mid。看到后面这个式子，回忆起品酒大会的思路：从大到小将 Height 数组插入，若仅考虑 ≥L\ge L≥L 的 Height，将 sai−1,saisa_{i-1},sa_{i}sai−1​,sai​ 之间连边，那么若 p,qp,qp,q 在同一联通块里，表明 LCP⁡(p,q)≥L\operatorname{LCP}(p,q)\ge LLCP(p,q)≥L。我们通过并查集和启发式合并就可以做到 O(log⁡n)O(\log n)O(logn) 的优秀复杂度啦。
但是有点问题啊，如果我们直接这么做我们并没有考虑区间位置，也就是说在两个联通块启发式合并的时候我们必须要记录区间的位置。我们不妨考虑对于联通块内每一个位置，我们维护它在当前联通块内上一个元素的位置，记作 preipre_{i}prei​，那么区间限制转化为 max⁡i∈set(L),i∈[l,r−L+1]prei≥l\max\limits_{i\in set(L),i\in [l,r-L+1]} pre_{i}\ge li∈set(L),i∈[l,r−L+1]max​prei​≥l。我们可以通过对每一个联通块开主席树来辅助查询，这样就能够做到优秀的 O(qlog⁡2nO(q \log^2 nO(qlog2n) 的查询啦，其中两个 log⁡\loglog 由二分和主席树查询贡献。
问题转化为如何维护 preprepre 的合并。首先，唯一确定一个联通块的信息就是所对应的 LCP 长度 LLL（具体见上面品酒大会思路），根据品酒大会启发式合并的思路，一次启发式 preprepre 的变化最多只有 O(log⁡n)O(\log n)O(logn) 个，考虑用 set 把联通块内的元素存下来，启发式合并的时候暴力单点修改 preprepre，这样处理的复杂度是 O(nlog⁡2n)O(n \log^2 n)O(nlog2n) 的，可以过。故总时间复杂度为 O(qlog⁡2n+nlog⁡2n)O(q\log^2 n + n \log^2 n)O(qlog2n+nlog2n)。
请注意二分的实现：
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e4+15;int n,q,pre[MN];vector&lt;int&gt; vht[MN];set&lt;int&gt; st[MN];string s;struct Segment&#123;#define ls t[p].lson#define rs t[p].rson    struct Node&#123;        int lson,rson,val;    &#125;t[MN&lt;&lt;9];    int tot,rt[MN];        void pushup(int p)&#123;        t[p].val=max(t[ls].val,t[rs].val);    &#125;    void modfiy(int &amp;p,int lst,int l,int r,int pos,int v)&#123;        p=++tot;        t[p]=t[lst];        if(l==r)&#123;            t[p].val=max(t[p].val,v);            return;        &#125;        int mid=(l+r)&gt;&gt;1;        if(mid&gt;=pos) modfiy(ls,t[lst].lson,l,mid,pos,v);        else modfiy(rs,t[lst].rson,mid+1,r,pos,v);        pushup(p);    &#125;    int query(int p,int l,int r,int fl,int fr)&#123;        if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;            return t[p].val;        &#125;        int mid=(l+r)&gt;&gt;1,ret=0;        if(mid&gt;=fl) ret=max(ret,query(ls,l,mid,fl,fr));        if(mid&lt;fr) ret=max(ret,query(rs,mid+1,r,fl,fr));        return ret;    &#125;#undef ls#undef rs&#125;sg;namespace SA&#123;// 省略&#125;using namespace SA;int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);  // 这里用这种合并方式而不是按秩合并  // 是因为并查集维护的是联通块所属的集合，不用考虑形态变化。&#125;void merge(int x,int y,int L)&#123;    int rx=root(x),ry=root(y);    if(rx==ry) return;    if(st[rx].size()&lt;st[ry].size()) swap(rx,ry);    pre[ry]=rx;    for(auto p:st[ry])&#123;        auto it=st[rx].lower_bound(p);        if(it!=st[rx].end())&#123;            sg.modfiy(sg.rt[L],sg.rt[L],1,n,*it,p);        &#125;        if(it!=st[rx].begin())&#123;            it--;            sg.modfiy(sg.rt[L],sg.rt[L],1,n,p,*it);        &#125;    &#125;    for(auto p:st[ry]) st[rx].insert(p);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;    getsa(s);    for(int i=2;i&lt;=n;i++)&#123;        vht[ht[i]].push_back(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        pre[i]=i;        st[i].insert(i);    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sg.rt[i]=sg.rt[i+1];        for(auto p:vht[i])&#123;            merge(sa[p],sa[p-1],i);        &#125;    &#125;    while(q--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        int l=0,r=R-L+1;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(sg.query(sg.rt[mid],1,n,L,R-mid+1)&gt;=L)&#123;                l=mid;            &#125;else r=mid;        &#125;        cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 4.2 单调栈技巧
 P4248 [AHOI2013] 差异
前面两个都好说，关键字与后面这个每一个区间 LCP 之和怎么求回顾我们后缀数组求解 LCP 的式子：

若 rki&lt;rkjrk_{i}&lt;rk_{j}rki​&lt;rkj​，则 ∣LCP⁡(i,j)∣=min⁡p=rki+1rkjhtp|\operatorname{LCP}(i,j)|=\min\limits_{p=rk_{i}+1}^{rk_{j}}ht_p∣LCP(i,j)∣=p=rki​+1minrkj​​htp​。

那么现在问题转化为求每个区间的区间最小值之和，我们利用单调栈，考虑按排名顺序加入所有后缀并实时维护 F(i)=∑p=1i−1∣LCP⁡(sap,sai)∣F(i)=\sum\limits_{p=1}^{i-1}|\operatorname{LCP}(sa_{p},sa_{i})|F(i)=p=1∑i−1​∣LCP(sap​,sai​)∣，那么其实就是在维护 ∑p=1i−1min⁡q=p+1ihtq\sum\limits_{p=1}^{i-1} \min\limits_{q=p+1}^{i} ht_{q}p=1∑i−1​q=p+1mini​htq​，可以视为把单调栈加入高 htiht_{i}hti​，宽 111 的矩形后，单调栈内矩形面积之和。后面的答案就是 n(n+1)(n−1)2−2×F(i)\dfrac{n(n+1)(n-1)}{2}-2\times F(i)2n(n+1)(n−1)​−2×F(i)：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+51;int top,sta[MN],L[MN],R[MN],ans;string s;namespace SA&#123;// 省略&#125;using namespace SA;signed main()&#123;    cin&gt;&gt;s;    getsa(s);    sta[top=1]=1;    for(int i=2;i&lt;=len;i++)&#123;        while(top&amp;&amp;ht[sta[top]]&gt;ht[i]) R[sta[top--]]=i;        L[i]=sta[top];        sta[++top]=i;    &#125;    while(top) R[sta[top--]]=len+1;    ans=len*(len-1)*(len+1)/2;    for(int i=2;i&lt;=len;i++)&#123;        ans-=2*(R[i]-i)*(i-L[i])*ht[i];    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P7409 SvT
问题即求：
∑i=1K∑j=i+1KLCP⁡(sufi,sufj)\sum_{i=1}^{K} \sum_{j=i+1}^{K} \operatorname{LCP}\left(suf_{i}, suf_{j}\right)
i=1∑K​j=i+1∑K​LCP(sufi​,sufj​)
其中 KKK 为后缀集合长度，显然有：
∑i=1K∑j=i+1KLCP⁡(si,sj)=∑i=1K∑j=i+1Kmin⁡ri+1≤k≤rj{ htk}\sum_{i=1}^{K} \sum_{j=i+1}^{K} \operatorname{LCP}\left(s_{i}, s_{j}\right)=\sum_{i=1}^{K} \sum_{j=i+1}^{K} \min _{r_{i}+1 \leq k \leq r_{j}}\left\{\text { ht}_{k}\right\}
i=1∑K​j=i+1∑K​LCP(si​,sj​)=i=1∑K​j=i+1∑K​ri​+1≤k≤rj​min​{ htk​}
直接单调栈做就可以了，但是记得要去重哦，因为给出的有重复的。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=1e6+15;constexpr ll MOD=23333333333333333;int n,m,sta[MN],top,a[MN],w[MN],L[MN],R[MN];namespace SA&#123;// 省略    int lcp(int i,int j)&#123;        if((i=rk[i])&gt;(j=rk[j])) swap(i,j);        int d=__lg(j-(i++));        return min(st[d][i],st[d][j-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;bool cmp(int x,int y)&#123;    return rk[x]&lt;rk[y];&#125;int main()&#123;    string s;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    getsa(s);    initst();    while(m--)&#123;        int t;        ll ans=0;        cin&gt;&gt;t;        for(int i=1;i&lt;=t;i++)&#123;            cin&gt;&gt;a[i];        &#125;        sort(a+1,a+1+t);        t=unique(a+1,a+1+t)-a-1;        sort(a+1,a+1+t,cmp);        w[1]=0;        for(int i=2;i&lt;=t;i++)&#123;            w[i]=lcp(a[i-1],a[i]);        &#125;        sta[top=0]=0;        for(int i=1;i&lt;=t;i++)&#123;            while(top&amp;&amp;w[sta[top]]&gt;w[i]) top--;            L[i]=sta[top];            sta[++top]=i;        &#125;        sta[top=0]=t+1;        for(int i=t;i&gt;=1;i--)&#123;            while(top&amp;&amp;w[sta[top]]&gt;=w[i]) top--;            R[i]=sta[top];            sta[++top]=i;        &#125;        for(int i=2;i&lt;=t;i++)&#123;            ans=(ans+1ll*w[i]*(R[i]-i)%MOD*(i-L[i])%MOD)%MOD;        &#125;        cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 P5161 WD 与数列
做这个题之前请先解锁：关键点 Trick。
一个序列整体加一个数后与另一个序列相同，其实就是差分数组相同，原因自行思考。
那么源问题去掉限制就是裸的单调栈，但是问题在于要求不相交的，我们可以考虑容斥，总方案数减去相交的方案。总方案单调栈做，问题在于相交如何求解？
但是若求不相交的两个区间信息，请注意在差分数组上求时应当是相隔一个位置。差分数组中相交或相邻的串在原串中都是相交的。
我们考虑相交怎么做，我们可以考虑枚举长度 kkk，每隔一个 kkk 放一个关键点的套路。这里我们枚举两个字符串偏移的距离，若一个字符串的开头位置为 ppp，那么第二个串的开头为 p+kp+kp+k，第一个串的结束位置必须要满足 q≥p+k−1q\ge p+k-1q≥p+k−1，发现 ppp 每次向右移动，qqq 的取值减小 111，等差数列求解即可。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+15;int n,ans,a[MN],b[MN],top,tot;pir st[MN];struct SA&#123;// 省略。。。&#125;A,B;int clac(int x,int y)&#123;    return (x+y)*(y-x+1)/2;&#125;signed main()&#123;    vector&lt;int&gt; s,t;    cin&gt;&gt;n;    --n;    for(int i=0;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=n;i&gt;=1;i--)&#123;        a[i]-=a[i-1];        b[++tot]=a[i];    &#125;    sort(b+1,b+1+tot);    tot=unique(b+1,b+1+tot)-b-1;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;        s.push_back(a[i]);        t.push_back(a[i]);    &#125;    A.getsa(s);    reverse(t.begin(),t.end());    B.getsa(t);    A.initst();    B.initst();    int sum=0;    for(int i=n;i&gt;=1;i--)&#123;        ans+=sum;        int now=1;        while(top&amp;&amp;st[top].first&gt;=A.ht[i])&#123;            sum-=st[top].first*st[top].second;            now+=st[top--].second;        &#125;        st[++top]=pir(A.ht[i],now);        sum+=now*A.ht[i];    &#125;    for(int k=1;k&lt;n;k++)&#123;        for(int i=1;i&lt;=n/k-1;i++)&#123;            int x1=i*k,y1=x1+k,x2=n-y1+2,y2=n-x1+2;            int lcs=min(k-1,B.querylcp(x2,y2)),lcp=A.querylcp(x1,y1);            if(lcs+lcp-k+1&lt;0) continue;            ans-=clac(max(lcp-k+1,0ll),lcs+lcp-k+1);        &#125;    &#125;    cout&lt;&lt;ans+n*(n+1)/2;    return 0;&#125;
 P5115 Check, Check, Check one two!
前面两问都比较好说，问题在于后面的限制，它是两个限制。我们考虑只有一个限制，比如说 LCP 的限制，显然我们可以根据之前我们提到的，并查集的思路，从小往大插，就可以满足 LCP⁡(i,j)≤k1\operatorname{LCP}(i,j) \le k1LCP(i,j)≤k1，升级版之后我们又多了一个限制，这种限制在询问上表现的是一个范围，我们可以对第二个限制离线下来扫描线加并查集启发式合并做，这样做是 O(nlog⁡3n)O(n \log^3 n)O(nlog3n) 而且不用说就能感觉非常难写，有没有什么好用的性质来简化问题呢？
观察 LCP⁡(i,j),LCS⁡(i,j)\operatorname{LCP}(i,j),\operatorname{LCS}(i,j)LCP(i,j),LCS(i,j) 的性质，拼接起来形成长为 LCP⁡(i,j)+LCS⁡(i,j)−1\operatorname{LCP}(i,j)+\operatorname{LCS}(i,j)-1LCP(i,j)+LCS(i,j)−1 的相同子串，我们考虑关键点 Trick，我们在 (i−LCP⁡(i,j)+1,j−LCS⁡(i,j)+1)(i-\operatorname{LCP}(i,j)+1,j-\operatorname{LCS}(i,j)+1)(i−LCP(i,j)+1,j−LCS(i,j)+1) 统计贡献。因为相同子串要求极长，考虑枚举 i,ji,ji,j，若 si−1≠sj−1s_{i-1}\neq s_{j-1}si−1​=sj−1​，则 s[i,i+LCP⁡(i,j)−1]s[i,i+\operatorname{LCP}(i,j)-1]s[i,i+LCP(i,j)−1] 产生贡献。我们发现因为我们在枚举，其实这个和 LCP 是无关了，不妨设 f(x)=∑i=1xi(x−i+1)[i≤k1][j≤k2]f(x)=\sum\limits_{i=1}^x i(x-i+1)[i \le k1][j\le k2]f(x)=i=1∑x​i(x−i+1)[i≤k1][j≤k2]，那么拆贡献有：
ans=∑1≤i≤j≤n[si−1≠sj−1]f(LCP⁡(rki,rkj))=∑k=1nf(k)∑1≤i&lt;j≤n[LCP⁡(rki,rkj)=k,si−1≠j−1]=∑k=1nf(k)∑1≤i&lt;j≤n[LCP⁡(i,j)=k,ssai−1≠saj−1]\begin{aligned}
ans&amp;  = \sum_{1\le i \le j \le n}[s_{i-1}\neq s_{j-1}]f(\operatorname{LCP}(rk_i,rk_j)) \\
 
&amp; = \sum_{k=1}^n f(k)\sum_{1\le i &lt; j \le n}[\operatorname{LCP}(rk_i,rk_j)=k,s_{i-1}\neq _{j-1}] \\
&amp; = \sum_{k=1}^n f(k)\sum_{1\le i &lt; j \le n}[\operatorname{LCP}(i,j)=k,s_{sa_i-1}\neq _{sa_j -1}] \\
\end{aligned}
ans​=1≤i≤j≤n∑​[si−1​=sj−1​]f(LCP(rki​,rkj​))=k=1∑n​f(k)1≤i&lt;j≤n∑​[LCP(rki​,rkj​)=k,si−1​=j−1​]=k=1∑n​f(k)1≤i&lt;j≤n∑​[LCP(i,j)=k,ssai​−1​=saj​−1​]​
前面和后面都很好处理，中间的 LCP 用单调栈即可。
#include&lt;bits/stdc++.h&gt;#define int long long#define ull unsigned long longusing namespace std;constexpr int MN=1e6+15;int k1,k2,n,st[MN],top,w[MN];ull ans,f[MN];string s;namespace SA&#123;    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN];    template&lt;typename vct&gt;    void getsa(vct &amp;s)&#123;        int m=40000;        len=s.size();        s.insert(s.begin(),0);        for(int i=1;i&lt;=len;i++)&#123;            x[i]=s[i];            ++c[x[i]];        &#125;        for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=len;i&gt;=1;i--) sa[c[x[i]]--]=i;        for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123;            int num=0;            for(int i=len-k+1;i&lt;=len;i++) y[++num]=i;            for(int i=1;i&lt;=len;i++)&#123;                if(sa[i]&gt;k) y[++num]=sa[i]-k;            &#125;            for(int i=1;i&lt;=m;i++) c[i]=0;            for(int i=1;i&lt;=len;i++) c[x[i]]++;            for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];            for(int i=len;i&gt;=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;            swap(x,y);            num=1,x[sa[1]]=1;            for(int i=2;i&lt;=len;i++)&#123;                if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;                else x[sa[i]]=++num;            &#125;            if(num==len) break;            m=num;        &#125;        for(int i=1;i&lt;=len;i++) rk[sa[i]]=i;        for(int i=1,k=0;i&lt;=len;i++)&#123;            if(k) k--;            int j=sa[rk[i]-1];            while(i+k&lt;=len&amp;&amp;j+k&lt;=len&amp;&amp;s[i+k]==s[j+k]) k++;            ht[rk[i]]=k;        &#125;    &#125;&#125; using namespace SA;ull calc1(int x)&#123;    return x*(x+1)/2;&#125;ull calc2(int x)&#123;    return x*(x+1)*(x+x+1)/6;&#125;ull solve(char lim) &#123;    ull cur = 0, ans = 0;    top=0;    memset(w,0,sizeof(w));    for(int i = 2; i &lt;= n; i++) &#123;        int wid = lim ? s[sa[i - 1] - 1] == lim : 1;        while(top &amp;&amp; st[top] &gt;= ht[i]) &#123;            cur -= 1ull * w[top] * f[st[top]];            wid += w[top--];        &#125;        st[++top] = ht[i];        w[top] = wid;        cur += 1ull * wid * f[ht[i]];        if(lim ? s[sa[i] - 1] == lim : 1) &#123;            ans += cur;        &#125;    &#125;    return ans;&#125;signed main()&#123;    cin&gt;&gt;s&gt;&gt;k1&gt;&gt;k2;    n=s.length();    for(int i=1;i&lt;=n;i++)&#123;        int l=max(1ll,i-k2+1),r=min(i,k1);        if(l&gt;r) break;        f[i]=(calc1(r)-calc1(l-1))*(i+1)-(calc2(r)-calc2(l-1));    &#125;    getsa(s);    ans+=solve(0);    for(int i=0;i&lt;26;i++) ans-=solve(&#x27;a&#x27;+i);    cout&lt;&lt;ans;    return 0;&#125;
 练习
CF1073G
[HAOI2016]找相同字符
 4.3 SA加速匹配和查询子串
 P3763 [TJOI2017] DNA
由于不重合的字符很少，考虑暴力枚举不重合的子串起始位置，让后从这个位置往后跳最长公共前缀的长度，这样如果枚举的位置正确也能保证后续位置也能递推正确。现在问题转化为如何快速求解 LCP，用二分加哈希或 SA 加 ST 表即可实现。
二分加哈希：
#include&lt;bits/stdc++.h&gt;#define ull unsigned long longusing namespace std;constexpr ull base=13131;constexpr int MN=1e5+15;int lena,lenb;ull a[MN],b[MN],pw[MN];string sa,sb;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++) pw[i]=pw[i-1]*base;&#125;ull hsha(int l,int r)&#123;    return a[r]-a[l-1]*pw[r-l+1];&#125;ull hshb(int l,int r)&#123;    return b[r]-b[l-1]*pw[r-l+1];&#125;bool binfind(int x)&#123;    int st=1,r=x+lenb-1,ed=lenb;    for(int i=1;i&lt;=3;i++)&#123;        int lt=-1,rt=ed-st+2,ret=0;        while(lt+1&lt;rt)&#123;            int mid=(lt+rt)&gt;&gt;1;            if(hsha(x,x+mid-1)==hshb(st,st+mid-1)) lt=mid;            else rt=mid;        &#125;        x+=lt+1;        st+=lt+1;        if(st&gt;ed) return 1;    &#125;    return hsha(x,x+lenb-st)==hshb(st,ed);&#125;void solve()&#123;    cin&gt;&gt;sa&gt;&gt;sb;    lena=sa.length(),lenb=sb.length();    if(lena&lt;lenb)&#123;        cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    sa=&quot; &quot;+sa;    sb=&quot; &quot;+sb;    for(int i=1;i&lt;=lena;i++)&#123;        a[i]=a[i-1]*base+sa[i];    &#125;    for(int i=1;i&lt;=lenb;i++)&#123;        b[i]=b[i-1]*base+sb[i];    &#125;    int ans=0;    for(int i=1;i&lt;=lena-lenb+1;i++)&#123;        if(binfind(i)) ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    init();    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
SA：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,m;string s,t;namespace SA&#123;// 省略    int lcp(int i,int j)&#123;        if((i=rk[i])&gt;(j=rk[j])) swap(i,j);        int d=__lg(j-(i++));        return min(st[d][i],st[d][j-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;void solve()&#123;    cin&gt;&gt;s&gt;&gt;t;    n=s.length(),m=t.length();    s=&quot; &quot;+s,t=&quot; &quot;+t;    string sst;    for(int i=1;i&lt;=n;i++)&#123;        sst.push_back(s[i]);    &#125;    sst.push_back(&#x27;#&#x27;);    for(int i=1;i&lt;=m;i++)&#123;        sst.push_back(t[i]);    &#125;    getsa(sst);    initst();    int ret=0;    for(int i=1;i&lt;=n-m+1;i++)&#123;        int curs=i,curt=1;        for(int j=1;j&lt;=4;j++)&#123;            if(curt&lt;=m)&#123;                int lcpl=lcp(curs,curt+n+1);                curs+=lcpl+(j&lt;4);                curt+=lcpl+(j&lt;4);            &#125;        &#125;        ret+=curt&gt;m;    &#125;    cout&lt;&lt;ret&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 SP1812 LCS2
2.2 有讲两种做法。
现在我们要求在主串 TTT 中寻找子串 SSS，我们先建出 TTT 的后缀数组，让后查找子串 SSS。若子串在 TTT 中出现，它必定是 TTT 的一些后缀的前缀，我们可以通过在后缀数组中二分 SSS 来实现。比较子串 SSS 和后缀的时间复杂度是 O(∣S∣)O(|S|)O(∣S∣) 的，那么总时间复杂度是 O(∣S∣log⁡∣T∣)O(|S| \log |T|)O(∣S∣log∣T∣) 的，注意，如果该子串在 TTT 中出现了多次，每次出现都是在后缀数组数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。以下是 SA 的实现：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e6+15;int col[MN],vis[MN],L[MN],R[MN],sum,tot,ans;string s,str;deque&lt;int&gt; q;namespace SA&#123;// 省略&#125;using namespace SA;void add(int x)&#123;    if(col[x]==0) return;    vis[col[x]]++;    if(vis[col[x]]==1) sum++;&#125;void del(int x)&#123;    if(col[x]==0) return;    vis[col[x]]--;    if(vis[col[x]]==0) sum--;&#125;int main()&#123;    while(cin&gt;&gt;s)&#123;        tot++;        L[tot]=str.length()+1;        str=str+s;        R[tot]=str.length();        str.push_back(tot);    &#125;    getsa(str);    for(int i=1;i&lt;=tot;i++)&#123;        for(int j=L[i];j&lt;=R[i];j++)&#123;            col[rk[j]]=i;        &#125;    &#125;    add(1);    for(int r=2,l=1;r&lt;=len;r++)&#123;        while(!q.empty()&amp;&amp;ht[q.back()]&gt;=ht[r]) q.pop_back();        q.push_back(r);        add(r);        if(sum==tot)&#123;            while(tot==sum&amp;&amp;l&lt;r) del(l++);            add(--l);        &#125;        while(!q.empty()&amp;&amp;q.front()&lt;=l) q.pop_front();        if(tot==sum) ans=max(ans,ht[q.front()]);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P5028 Annihilate
把字符串加分隔符连接在一起，让后跑后缀数组求 hththt，原本命题我们可以直接建立 st 秒了，但是空间炸缸了。但是时间复杂度启示我们 O(nm)O(nm)O(nm)？
考虑计算 LCP 的过程就是一段 hththt 求最小值的过程，考虑贪心，越近越优，每一个不同的字符串只需要保存目前 hththt 的最小值即可，这个值即是最近也是最小值中最大的。
放这个题就是为了看见 SA 不要僵化思路，这种一般是学多做题多了导致的 www。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e6+15,MK=55;int n,pos[MN],minn[MK],ans[MK][MK];vector&lt;int&gt; str;namespace SA&#123;// 省略&#125;using namespace SA;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        for(auto c:s)&#123;            str.push_back(c);            pos[str.size()]=i;        &#125;        str.push_back(1000+i);    &#125;    getsa(str);    for(int i=2;i&lt;=len;i++)&#123;        for(int j=1;j&lt;=n;j++) minn[j]=min(minn[j],ht[i]);        minn[pos[sa[i-1]]]=ht[i];        for(int j=1;j&lt;=n;j++)&#123;            ans[pos[sa[i]]][j]=ans[j][pos[sa[i]]]=max(ans[pos[sa[i]]][j],minn[j]);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(i!=j) cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 P2463 [SDOI2008] Sandy 的卡片
一个序列整体加一个数后与另一个序列相同，其实就是差分数组相同，原因自行思考。
但是若求不相交的两个区间信息，请注意在差分数组上求时应当是相隔一个位置。差分数组中相交或相邻的串在原串中都是相交的。
那么先求差分数组，让后两个差分数组中间加分隔符连起来建立 SA，让后问题转化为求所有子串最长公共子串，考虑二分，只要有 nnn 个 ≥L\ge L≥L 的 hththt 并且这几个都属于不同的串就可以啦。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,lenn[MN],sta[MN],top,a[1145][1145];int pos[MN];bool vis[MN];string s;namespace SA&#123; // 省略&#125;using namespace SA;bool check(int x)&#123;    while(top) vis[sta[top--]]=0;    for(int i=1;i&lt;=len;i++)&#123;        if(ht[i]&lt;x) while(top) vis[sta[top--]]=0;        if(!vis[pos[sa[i]]])&#123;            vis[pos[sa[i]]]=1;            sta[++top]=pos[sa[i]];            if(top==n) return 1;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin&gt;&gt;n;    int l=0,r=1e6,ans=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;lenn[i];        for(int j=1;j&lt;=lenn[i];j++)&#123;            cin&gt;&gt;a[i][j];        &#125;        r=min(r,lenn[i]-1);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=2;j&lt;=lenn[i];j++)&#123;            s.push_back(a[i][j]-a[i][j-1]);            pos[s.length()]=i;        &#125;        s.push_back(&#x27;#&#x27;);    &#125;    getsa(s);        while(l&lt;=r)&#123;        int mid=(l+r)&gt;&gt;1;        if(check(mid))&#123;            l=mid+1;            ans=mid;        &#125;else r=mid-1;    &#125;    cout&lt;&lt;ans+1;    return 0;&#125;
 SP220 PHRASES - Relevant Phrases of Annihilation
划分为 2 个子问题：

最长公共子串。
最长且不重叠出现两次及以上的子串。

第一问我们不说，我们考虑第二问如何求解，我们可以对于 hththt 分组，求除在原串中最大坐标和最小左边，判断差值是否大于 lenlenlen 即可。
结合起来就可以啦，时间复杂度 O(Slog⁡S)O(S \log S)O(SlogS)，其中 S=∑∣si∣S=\sum\limits|s_{i}|S=∑∣si​∣。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e6+15;int n,L[MN],R[MN];string s;vector&lt;int&gt; vct;namespace SA&#123;    void clear()&#123;        memset(sa,0,sizeof(sa));        memset(rk,0,sizeof(rk));        memset(ork,0,sizeof(ork));        memset(buc,0,sizeof(buc));        memset(id,0,sizeof(id));        memset(ht,0,sizeof(ht));        memset(st,0,sizeof(st));    &#125;// 省略&#125;using namespace SA;bool check(int x)&#123;    vct.clear();    for(int i=1;i&lt;=len;i++)&#123;        if(ht[i]&lt;x)&#123;            bool flag=true;            for(int j=1;j&lt;=n;j++)&#123;                int mn=MN,mx=0;                for(int p:vct)&#123;                    if(p&lt;L[j]||p&gt;R[j]) continue;                    mn=min(mn,p);                    mx=max(mx,p);                &#125;                if(mx-mn&lt;x)&#123;                    flag=false;                    break;                &#125;            &#125;            if(flag) return true;            vct.clear();        &#125;        vct.push_back(sa[i]);    &#125;    bool flag=true;    for(int j=1;j&lt;=n;j++)&#123;        int mn=MN,mx=0;        for(int p:vct)&#123;            if(p&lt;L[j]||p&gt;R[j]) continue;            mn=min(mn,p);            mx=max(mx,p);        &#125;        if(mx-mn&lt;x)&#123;            flag=false;            break;        &#125;    &#125;    return flag;&#125;void solve()&#123;    cin&gt;&gt;n;    s.clear();    for(int i=1;i&lt;=n;i++)&#123;        string st;        cin&gt;&gt;st;        L[i]=s.length()+1;        R[i]=s.length()+st.length();        s+=st;        s.push_back(&#x27;#&#x27;);        &#125;    getsa(s);    int l=1,r=len,ans=0;    while(l&lt;=r)&#123;        int mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,l=mid+1;        else r=mid-1;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    ios::sync_with_stdio(0);cin.tie(0);    int T;cin&gt;&gt;T;    while(T--) solve();    return 0;&#125;
 P4143 采集矿石
第一眼看上去好像没什么思路啊 www。考虑发掘性质，从大到小的话，如果我们选取的子串在不断扩大的话，排名会逐渐下降，但重要度因为是求和，所以是单调不减，我们考虑利用冰火战士的思路，两次二分出这个排名和重要度之和的交点，让后我们检查是否符合要求。
现在问题在于如何求某个子串在所有字符串本质不同子串的排名。所有本质不同子串的计算我们之前提到过，也就是：(∑i=1∣S∣n−pi+1)−(∑i=1∣S∣−1∣LCP⁡(pi,pi+1)∣)\left( \sum\limits_{i=1}^{|S|} n-p_{i}+1 \right)-\left(\sum\limits_{i=1}^{|S|-1} |\operatorname{LCP}(p_{i},p_{i+1})| \right)(i=1∑∣S∣​n−pi​+1)−(i=1∑∣S∣−1​∣LCP(pi​,pi+1​)∣)，但是如何求排名，我们考虑对于两个子串 s,ts,ts,t，对于 ttt 其字典序不大于 sss 当且仅当 ttt 是 sss 的前缀或者在去掉 LCP 后第一个字符大于后者。
两个条件，第一个条件对应的后缀排名是一段排名区间 [L,R],(L≤rkl≤R)[L,R],(L\le rk_{l}\le R)[L,R],(L≤rkl​≤R)，满足第二种条件对应的就是 [R+1,n][R+1,n][R+1,n]。因此，求出排名为 [L,n][L,n][L,n] 的后缀本质不同的前缀数量，减去 r−lr-lr−l 重复算上的答案即为所求。求 LLL 考虑二分答案，找不大于 rklrk_{l}rkl​ 的最小排名，使得排名在 [L,rkl][L,rk_{l}][L,rkl​] 之间所有后缀的 LCP 不小于 r−l+1r-l+1r−l+1。通过 SA 加 ST 表即可做到 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+15;int n,v[MN],sumh[MN],sumsa[MN];vector&lt;pir&gt; ans;string s;namespace SA&#123; // 省略     // 查询位置为 i 和 位置为 j 的后缀的 LCP    int querylcp(int i,int j)&#123;        int d=__lg(j-(i++));        return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);    &#125;    // 手动查询 ST 表    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(ST[d][l],ST[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;int clac(int x,int y)&#123;    int l=1,r=x=rk[x]+1;    while(l+1&lt;r)&#123;        int mid=(l+r)&gt;&gt;1;        if(querylcp(mid,x)&gt;=y) r=mid;        else l=mid;    &#125;    return sumsa[l]-sumh[l+1]-y+1;&#125;signed main()&#123;    cin&gt;&gt;s;    n=s.length();    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;v[i];    &#125;    getsa(s);    initst();    for(int i=n;i&gt;=1;i--)&#123;        sumh[i]=sumh[i+1]+ht[i];        sumsa[i]=sumsa[i+1]+n-sa[i]+1;    &#125;    for(int i=1;i&lt;=n;i++) v[i]+=v[i-1];    for(int i=1;i&lt;=n;i++)&#123;        int l=1,r=n-i+2;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(clac(i,mid)&gt;=v[i+mid-1]-v[i-1]) l=mid;            else r=mid;        &#125;        if(clac(i,l)==v[i+l-1]-v[i-1])&#123;            ans.push_back(pir(i,i+l-1));        &#125;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;&#x27;\n&#x27;;    for(auto p:ans) cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 练习
P4081 [USACO17DEC] Standing Out from the Herd P
P6640 [BJOI2020] 封印
P2408 不同子串
P5431
 4.4 对串进行分块操作
 P1117 [NOI2016] 优秀的拆分
显然 AABB 由两个形如 AA 的串拼接起来的，考虑维护两个数组 ai,bia_{i},b_{i}ai​,bi​。其中 aia_{i}ai​ 表示以 iii 结尾有多少个 AA 串，bib_{i}bi​ 表示以 iii 开头有多少个 AA 串，通过乘法原理不难得出 ans=∑i=1n−1aibi+1ans=\sum\limits_{i=1}^{n-1}a_{i}b_{i+1}ans=i=1∑n−1​ai​bi+1​。
现在问题在于如何求解 ai,bia_{i},b_{i}ai​,bi​，这里有一个很妙的 Trick 就是枚举长度，设置关键点求解 a,ba,ba,b。
对于固定的 LLL，若每间隔 LLL 放置一个关键点，则 AA 必然必然恰好经过两个关键点。让后考虑，我们只需要相邻两个关键点往前的 LCS 和往后的 LCP，若 LCS+LCP≥lenLCS+LCP\ge lenLCS+LCP≥len，那么就表示一定存在长度为 lenlenlen 的 AA 串。不难发现，所有经过这两个关键点长度为 lenlenlen 的 AA 串一定是连续的！我们可以找到这个区间，让后用前缀和差分，就可以避免区间修改了。现在问题转化为如何求解 LCS 和 LCP，正反串建立 SA 让后跑 ST 表就可以啦，时间复杂度是枚举 lenlenlen 的调和级数，为 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
从这道题开始，设置关键点变成了经典套路。
下列代码 f→a,g→bf\to a,g\to bf→a,g→b。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int T,f[MN],g[MN];string s;struct SA&#123;    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN],ST[30][MN]; // 省略    // ST表初始化    void initst()&#123;        for(int i=1;i&lt;30;i++)&#123;            for(int j=1;j+(1&lt;&lt;i)-1&lt;=len;j++)&#123;                ST[i][j]=min(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]);            &#125;        &#125;    &#125;    // 查询位置为 i 和 位置为 j 的后缀的 LCP    int querylcp(int i,int j)&#123;        if((i=rk[i])&gt;(j=rk[j])) swap(i,j);        int d=__lg(j-(i++));        return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);    &#125;    // 手动查询 ST 表    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(ST[d][l],ST[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;A,B;void solve()&#123;    cin&gt;&gt;s;    int n=s.length();    A.getsa(s);    A.initst();    reverse(s.begin(),s.end());    B.getsa(s);    B.initst();    for(int i=1;i&lt;=n;i++)&#123;        f[i]=g[i]=0;    &#125;    for(int len=1;len&lt;=(n&gt;&gt;1);len++)&#123;        for(int l=len;l&lt;=n;l+=len)&#123;            int r=l+len,lcp=min(len,A.querylcp(l,r)),lcs=min(len-1,B.querylcp(n-(l-1)+1,n-(r-1)+1));            if(lcp+lcs&gt;=len)&#123;                int cov=lcp+lcs-len+1;                f[r+lcp-cov]++;                f[r+lcp]--;                g[l-lcs+cov]--;                g[l-lcs]++;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++) f[i]+=f[i-1],g[i]+=g[i-1];    long long ans=0;    for(int i=1;i&lt;n;i++) ans+=1ll*f[i]*g[i+1];    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 SP687 REPEATS - Repeats
借助上面的套路，考虑枚举循环节长度 LLL，每相邻 LLL 个位置放置一个关键点。若某个长度为 kkk 的子串出现 kkk 次，那么恰好跨过 kkk 个关键点。
我们考虑二分 kkk，考虑所有连续 kkk 个关键点 p,p+L,p+2×L,…,p+(k−1)Lp,p+L,p+2\times L,\dots,p+(k-1)Lp,p+L,p+2×L,…,p+(k−1)L，若这些位置的 LCP 加上它们对应所有前缀的 LCS 减去同时覆盖关键点后的长度不小于 LLL，即 LCS+LCP−1≥LLCS+LCP-1\ge LLCS+LCP−1≥L，那么表示出现重复，考虑从小到大用长为 kkk 的块滑字符串，用单调队列维护排名最大值和最小值方便求解 LCS 与 LCP，时间复杂度 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)。
还可以更优化，我们当 LLL 固定的时候，一个大区间一定比任何子区间更优，那么也就表明右指针增加的时候左指针单调不降，考虑双指针代替二分，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
Alex_wei 的 Sol 3 看不懂 Orz。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN = 5e4 + 5;int n;struct SA &#123;    int len, sa[MN], x[MN], y[MN], rk[MN], c[MN], ht[MN], ST[16][MN];// 省略    int querylcp(int i, int j) &#123;        if((i = rk[i]) &gt; (j = rk[j])) swap(i, j);        int d = __lg(j - (i++));        return min(ST[d][i], ST[d][j - (1 &lt;&lt; d) + 1]);    &#125;&#125; A, B;void solve() &#123;    cin &gt;&gt; n;    string str;    for(int i = 1; i &lt;= n; i++) &#123;        char x;        cin &gt;&gt; x;        str.push_back(x);    &#125;    A.getsa(str);    A.initst();    reverse(str.begin(), str.end());    B.getsa(str);    B.initst();        int ans = 1;    for(int len = 1; len &lt;= n; len++) &#123;        for(int l = len, r = len + len; r &lt;= n; l += len, r += len) &#123;            int lcp = A.querylcp(l, r);            int lcs = B.querylcp(n - r + 1, n - l + 1);            ans = max(ans, (lcp + lcs - 1) / len + 1);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int T;    cin &gt;&gt; T;    while(T--) &#123;        solve();    &#125;    return 0;&#125;
 4.5 与DP贪心结合
这里我们是单独介绍一些利用贪心思路和 DP 思路求解的问题。一般来说，这里的问题 SA 不是主角，是起到一个打辅助的作用的。
 CF822E Liar
一个显然的贪心，我们在新选择一个字符串并起来的时候应当尽可能的进行匹配，我们一定会匹配到第一个 kkk 使得 si+k≠tj+ks_{i+k} \neq t_{j+k}si+k​=tj+k​，证明考虑反证法和调整法。
字符串匹配，之前做过一堆 KMP 的题，这里肌肉记忆设 f(i,j)f(i,j)f(i,j) 表示在 sss 匹配前 iii 个字符，匹配 ttt 到 jjj 的位置，选出最少的子串数量。根据数据范围显然会炸缸，注意到 x≤30x\le 30x≤30，考虑经典 Trick：状态互换，设 f(i,j)f(i,j)f(i,j) 表示在 sss 匹配前 iii 个字符，选出子串数 jjj，最多能匹配到 ttt 的哪个位置。对于每个 f(i,j)f(i,j)f(i,j) 可以转移到 f(i+1,j)f(i+1,j)f(i+1,j) 表示不开启匹配，若开启匹配，根据贪心思路，则需要找到 s[i+1,n]s[i+1,n]s[i+1,n] 和 t[f(i,j−1)+1,m]t[f(i,j-1)+1,m]t[f(i,j−1)+1,m] 的最长公共前缀 LLL，令 f(i+L,j)←max⁡(f(i+L,j),f(i,j−1)+L)f(i+L,j) \leftarrow \max(f(i+L,j),f(i,j-1)+L)f(i+L,j)←max(f(i+L,j),f(i,j−1)+L)，求后缀的最长公共前缀是 SA 的拿手好戏，时间复杂度 O(nx+nlog⁡n)O(nx+n \log n)O(nx+nlogn)。
DP 加贪心加 SA，很好的题啊！
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e5+15,MK=35;int f[MN][MK],X,n,m;string s,t,sst;namespace SA&#123;// 省略    int lcp(int i,int j)&#123;        if((i=rk[i])&gt;(j=rk[j])) swap(i,j);        int d=__lg(j-(i++));        return min(st[d][i],st[d][j-(1&lt;&lt;d)+1]);    &#125;    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(st[d][l],st[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;int lcpst(int i,int j)&#123;    if(i&gt;n||j&gt;m) return 0;    j+=n+1;    return lcp(i,j);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;s&gt;&gt;m&gt;&gt;t;    sst=s+&#x27;#&#x27;+t;    getsa(sst);    initst();    cin&gt;&gt;X;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=X;j++)&#123;            int L=lcpst(i,f[i][j-1]+1);            f[i+L][j]=max(f[i+L][j],f[i][j-1]+L);            f[i+1][j]=max(f[i+1][j],f[i][j]);        &#125;    &#125;    if(f[n+1][X]==m) cout&lt;&lt;&quot;YES&quot;;    else cout&lt;&lt;&quot;NO&quot;;    return 0;&#125;
 P6095 [JSOI2015] 串分割
有一个贪心的想法就是我们贪心让最大位数最小。那么答案串的长度最多就是 L=⌈nk⌉L=\lceil \dfrac{n}{k} \rceilL=⌈kn​⌉。贪心思路就是能断为 ⌈nk⌉\lceil \dfrac{n}{k} \rceil⌈kn​⌉ 尽量断为 ⌈nk⌉\lceil \dfrac{n}{k} \rceil⌈kn​⌉，不然就断成 ⌈nk⌉−1\lceil \dfrac{n}{k} \rceil-1⌈kn​⌉−1，证明考虑反证法即可。
让后我们考虑如何比较字符串大小，考虑二分排名 rkrkrk，那么从 iii 开始为 ⌈nk⌉/⌈nk⌉−1\lceil \dfrac{n}{k} \rceil / \lceil \dfrac{n}{k} \rceil-1⌈kn​⌉/⌈kn​⌉−1 的串即为后缀 iii 的前缀，又因为前缀的排名严格不大于原串，所以直接比较原后缀的排名与二分的排名即可。
最后要求输出最大值数字串，考虑存下排名的值输出这个排名的后缀长为 ⌈nk⌉\lceil \dfrac{n}{k} \rceil⌈kn​⌉ 的前缀就可以了。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int n,K;string s;namespace SA&#123;// 省略&#125;using namespace SA;bool check(int mid)&#123;    int len=n/K;    for(int i=1;i&lt;=len;i++)&#123;        int st=i,cnt=0;        for(int j=1;j&lt;=K;j++)&#123;            if(cnt&lt;(n%K)&amp;&amp;rk[st]&lt;=mid)&#123;                st+=len+1;                cnt++;            &#125;else st+=len;        &#125;        if(st-i==n) return 1;    &#125;    return 0;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;K&gt;&gt;s;    if(n%K==0)&#123;        cout&lt;&lt;8;        return 0;    &#125;    s=s+s;    getsa(s);    int l=1,r=2*n;    while(l+1&lt;r)&#123;        int mid=(l+r)&gt;&gt;1;        if(check(mid)) r=mid;        else l=mid;    &#125;    for(int i=1;i&lt;=ceil(n*1.0/K);i++)&#123;        cout&lt;&lt;s[sa[l]+i-1];    &#125;    return 0;&#125;
 4.6 与数据结构或离线算法结合
 SP8093 莫队
先解决如何查一个查询串是多少个模板串的子串。我们考虑将所有模板串用分隔符连接起来跑 SA，那么查询串是一个模板串的子串，在 SA 上的范围表示的是一个区间的形式，这个区间的性质表示为 LCP⁡(si,sj)=len\operatorname{LCP}(s_{i},s_{j})=lenLCP(si​,sj​)=len，这个区间我们可以通过二分找出来左端点右端点。
让后第二个，查询区间颜色数，既然我们已经有了每一个查询串对应的 SA 区间，考虑莫队维护区间颜色数，让后就做完了。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;struct Query&#123;    int l,r,id;&#125;qry[MN];int n,m,qtot,qlen,col[MN],sumc,cnt[MN],ans[MN];vector&lt;int&gt; str;namespace SA&#123;// 省略    // 查询位置为 i 和 位置为 j 的后缀的 LCP    int querylcp(int i,int j)&#123;        int d=__lg(j-(i++));        return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);    &#125;    // 手动查询 ST 表    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(ST[d][l],ST[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;bool cmp(Query x,Query y)&#123;    if(x.l/qlen!=y.l/qlen) return x.l&lt;y.l;    return x.r&lt;y.r;&#125;void add(int x)&#123;    cnt[col[x]]++;    if(cnt[col[x]]==1) sumc++;&#125;void del(int x)&#123;    cnt[col[x]]--;    if(!cnt[col[x]]) sumc--;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin&gt;&gt;s;        for(auto c:s)&#123;            str.push_back(c);            col[str.size()]=i;        &#125;        str.push_back(&#x27;z&#x27;+i);    &#125;    getsa(str);    for(int i=1;i&lt;=m;i++)&#123;        int slen,L=1,R=len;        string s;        cin&gt;&gt;s;        slen=s.length();        s=&quot; &quot;+s;        for(int j=1;j&lt;=slen;j++)&#123;            int l=L,r=R;            while(l&lt;=r)&#123;                int mid=(l+r)&gt;&gt;1;                if(str[sa[mid]+j-1]&lt;s[j]) l=mid+1;                else r=mid-1;            &#125;            swap(l,L);            r=R;            while(l&lt;=r)&#123;                int mid=(l+r)&gt;&gt;1;                if(str[sa[mid]+j-1]&lt;=s[j]) l=mid+1;                else r=mid-1;            &#125;            R=r;        &#125;        if(L&lt;=R)&#123;            qry[++qtot]=&#123;L,R,i&#125;;        &#125;    &#125;    qlen=sqrt(len);    sort(qry+1,qry+1+qtot,cmp);    int l=1,r=0;    for(int i=1;i&lt;=qtot;i++)&#123;        while(l&lt;qry[i].l) del(sa[l++]);        while(l&gt;qry[i].l) add(sa[--l]);        while(r&lt;qry[i].r) add(sa[++r]);        while(r&gt;qry[i].r) del(sa[r--]);        ans[qry[i].id]=sumc;    &#125;    for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 CF1608G Alphabetic Tree

哈哈其实没有那么多啦，我实现的时候其实也就不到 300 行吧，其实就是板子加板子，只是不过我是晚上写的太困了调了一万年。
因为信息具有可减性，战术将询问差分扫描线，即 Q(u,v,l,r)Q(u,v,l,r)Q(u,v,l,r) 拆为 Q(u,v,1,r)−Q(u,v,1,l−1)Q(u,v,1,r)-Q(u,v,1,l-1)Q(u,v,1,r)−Q(u,v,1,l−1)。
对于后缀数组，查一个查询串是多少个模板串的子串。我们考虑将所有模板串用分隔符连接起来跑 SA，那么查询串是一个模板串的子串，在 SA 上的范围表示的是一个区间的形式，这个区间的性质表示为 LCP⁡(si,sj)=len\operatorname{LCP}(s_{i},s_{j})=lenLCP(si​,sj​)=len，这个区间我们可以通过二分找出来左端点右端点。
那么对于本题来说也是一样的，我们对 sis_isi​ 进行后缀排序，设当前扫描线扫到位置 ppp，则管用的只有 s1→ps_{1\to p}s1→p​ 的后缀。那么对于一次询问 Q(u,v,1,p)Q(u,v,1,p)Q(u,v,1,p) 我们只需要对 u→vu\to vu→v 形成的字符串 t(u,v)t(u,v)t(u,v) 进行上述操作即可，具体的，我们考虑二分排名 kkk，问题转化为判定性问题比较 t(u,v)t(u,v)t(u,v) 和排名为 kkk 的后缀 sss 的大小关系。一般的比较方法就是我们之前所以到过的：两个子串 s,ts,ts,t，对于 ttt 其字典序不大于 sss 当且仅当 ttt 是 sss 的前缀或者在去掉 LCP 后第一个字符大于后者。
但是本题上树了，我们必须要考虑哈希求解，那么这样的话我们必须求解出 s[1→len]s[1\to len]s[1→len] 的哈希值，以及 u→vu\to vu→v 长度为 lenlenlen 的前缀的哈希值，后者要树上倍增，树上倍增加二分时间复杂度 O(qlog⁡3n)O(q \log^3 n)O(qlog3n)，改造成倍增二分 O(qlog⁡2n)O(q \log^2 n)O(qlog2n) 即可通过。
巨大码农，代码。
 [P4094 HEOI2016字符串]
又是最长公共子串，好烦啊~
直接二分长度，让后问题转化为判定性问题，那么一个长度可行当且仅当：

开头在 [a,b−mid+1][a,b-mid+1][a,b−mid+1]
LCP(s,c)⁡≥mid\operatorname{LCP(s,c)}\ge midLCP(s,c)≥mid，其中 ccc 为题目中 s[c→d]s[c\to d]s[c→d]。

那么问题转化为询问满足以上两个条件的后缀 sufksuf_{k}sufk​ 的个数是否大于 000，同时子串出现次数前面提到好多次了，一定是在后缀数组上连续的区间，二分左端点右端点即可，现在两个问题都是静态区间询问，主席树做即可。
我主席树又写错了，希望大家认真实现，我已经做麻了呜呜呜。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int n,m;string s;struct Segment&#123;#define ls t[p].lson#define rs t[p].rson        struct Node&#123;        int lson,rson,val;    &#125;t[MN*20+1145];    int rt[MN],tot;    int insert(int lst,int l,int r,int x)&#123;        int p=++tot;        t[p]=t[lst];        t[p].val++;        if(l==r) return p;        int mid=(l+r)&gt;&gt;1;        if(x&lt;=mid) t[p].lson=insert(t[lst].lson,l,mid,x);        else t[p].rson=insert(t[lst].rson,mid+1,r,x);        return p;    &#125;    int query(int u,int v,int l,int r,int fl,int fr)&#123;        if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;            return t[v].val-t[u].val;        &#125;        int mid=(l+r)&gt;&gt;1,ret=0;        if(mid&gt;=fl) ret+=query(t[u].lson,t[v].lson,l,mid,fl,fr);        if(mid&lt;fr) ret+=query(t[u].rson,t[v].rson,mid+1,r,fl,fr);        return ret;    &#125;    int query(int u,int v,int l,int r)&#123;        return query(rt[u-1],rt[v],1,n,l,r);    &#125;#undef ls#undef rs&#125;sg;namespace SA&#123;    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN],ST[30][MN]; // 省略    // ST表初始化    void initst()&#123;        for(int i=1;i&lt;30;i++)&#123;            for(int j=1;j+(1&lt;&lt;i)-1&lt;=len;j++)&#123;                ST[i][j]=min(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]);            &#125;        &#125;    &#125;    // 查询位置为 i 和 位置为 j 的后缀的 LCP    int querylcp(int i,int j)&#123;        int d=__lg(j-(i++));        return min(ST[d][i],ST[d][j-(1&lt;&lt;d)+1]);    &#125;    // 手动查询 ST 表    int queryst(int l,int r)&#123;        int d=__lg(r-l+1);        return min(ST[d][l],ST[d][r-(1&lt;&lt;d)+1]);    &#125;&#125;using namespace SA;bool check(int x,int a,int b,int c)&#123;    int l=1,r=rk[c],L,R;    while(l&lt;r)&#123;        int mid=(l+r)&gt;&gt;1;        if(querylcp(mid,rk[c])&lt;x) l=mid+1;        else r=mid;    &#125;    L=r;    l=rk[c],r=n;    while(l&lt;r)&#123;        int mid=(l+r+1)&gt;&gt;1;        if(querylcp(rk[c],mid)&lt;x) r=mid-1;        else l=mid;    &#125;    R=r;    return sg.query(L,R,a,b-x+1)&gt;0;&#125;void solve(int a,int b,int c,int d)&#123;    int l=0,r=min(b-a+1,d-c+1);    while(l&lt;r)&#123;        int mid=(l+r+1)&gt;&gt;1;        if(check(mid,a,b,c)) l=mid;        else r=mid-1;    &#125;    cout&lt;&lt;r&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;;    getsa(s);    initst();    for(int i=1;i&lt;=n;i++)&#123;        sg.rt[i]=sg.insert(sg.rt[i-1],1,n,sa[i]);    &#125;    while(m--)&#123;        int a,b,c,d;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;        solve(a,b,c,d);    &#125;    return 0;&#125;
 P2336 [SCOI2012] 喵星球上的点名
将姓和名用分隔符连接，问题相当于给定 nnn 个文本串和 mmm 个模式串，对每个文本串求出作为其子串的模式串数量，这是 AC 自动机应用，但是字符集太大了不太好做。
将所有文本串用分隔符后建后缀数组，对每个模式串求出以其为前缀的排名区间，这个讲过 100 万遍了不再重复。第一位就是问区间颜色数，考虑离线下来跑莫队或者扫描线 BIT，第二问相当于对每种颜色查询与其有交的区间数。对每个区间和每个颜色在第一个位置统计答案，则每个位置对其颜色贡献在左端点落一个区间，右端点落另一端区间的区间数量，这是二位数点，还是扫描线 BIT。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int N=1e6+15, INF=1e9;int nn, q, n, m=400000;int sa[N], ra[N], h[N], t1[N], t2[N], c[N];int st[20][N], lg[N];int s[N], col[N], hd[N], len[N], bu[N];int pre[N], ans1[N], ans2[N];int lp[N]; struct Query &#123; int id, l, r; &#125; qry[N];struct BIT &#123;    int t[N];        void clear() &#123;        memset(t, 0, sizeof(t));    &#125;        void upd(int i, int v) &#123;        if (i) for (; i&lt;=n; i+=i&amp;-i) t[i] += v;    &#125;        int query(int i) &#123;        int res = 0;        for (; i; i-=i&amp;-i) res += t[i];        return res;    &#125;        int query(int l, int r) &#123;        return query(r) - query(l-1);    &#125;&#125; bit1, bit2;void getsa() &#123;// 省略&#125;void geth() &#123;// 省略&#125;void initST() &#123;// 省略&#125;int getmin(int a, int b) &#123;    if (a == b) return INF;    if (a &gt; b) swap(a, b);    int d = lg[b-(a++)];    return min(st[d][a], st[d][b-(1&lt;&lt;d)+1]);&#125;bool cmp(Query a, Query b) &#123;    return a.r &lt; b.r;&#125;int main() &#123;    ios::sync_with_stdio(0); cin.tie(0);    cin &gt;&gt; nn &gt;&gt; q;    int x, c = 10000;    for (int i=1; i&lt;=nn; ++i) &#123;        for (int j=0; j&lt;2; ++j) &#123;            int len; cin &gt;&gt; len;            while (len--) &#123;                cin &gt;&gt; x;                s[++n] = x;                col[n] = i;            &#125;            s[++n] = ++c;        &#125;    &#125;    for (int i=1; i&lt;=q; ++i) &#123;        cin &gt;&gt; len[n+1];        hd[n+1] = i;        for (int j=len[n+1]; j--; ) &#123;            cin &gt;&gt; x;            s[++n] = x;            col[n] = -i;        &#125;        s[++n] = ++c;    &#125;    getsa();    geth();    initST();    for (int i=1; i&lt;=n; ++i) &#123;        if (col[sa[i]] &gt; 0) &#123;            pre[i] = bu[col[sa[i]]];            bu[col[sa[i]]] = i;        &#125;        if (hd[i]) &#123;            qry[hd[i]].id = hd[i];            int l=1, r=ra[i];            while (l &lt; r) &#123;                int mi = (l+r)&gt;&gt;1;                if (getmin(mi, ra[i]) &gt;= len[i]) r = mi;                else l = mi+1;            &#125;            qry[hd[i]].l = lp[hd[i]] = l;            l = ra[i], r = n;            while (l &lt; r) &#123;                int mi = (l+r+1)&gt;&gt;1;                if (getmin(ra[i], mi) &gt;= len[i]) l = mi;                else r = mi-1;            &#125;            qry[hd[i]].r = r;        &#125;    &#125;    sort(qry+1, qry+q+1, cmp);    sort(lp+1, lp+q+1);    for (int i=1, j=1, k=1; i&lt;=n; ++i) &#123;        for (; j&lt;=q &amp;&amp; lp[j]==i; ++j) bit2.upd(i, 1);        if (col[sa[i]] &gt; 0) &#123;            ans2[col[sa[i]]] += bit2.query(i) - bit2.query(pre[i]);            bit1.upd(i, 1);            bit1.upd(pre[i], -1);        &#125;        for (; k&lt;=q &amp;&amp; qry[k].r==i; ++k) &#123;            ans1[qry[k].id] = bit1.query(qry[k].l, qry[k].r);            bit2.upd(qry[k].l, -1);        &#125;    &#125;    for (int i=1; i&lt;=q; ++i) cout &lt;&lt; ans1[i] &lt;&lt; &quot;\n&quot;;    for (int i=1; i&lt;=nn; ++i) cout &lt;&lt; ans2[i] &lt;&lt; &quot; &quot;;    return 0;&#125;
 4.7 与其他结合
 CF1654F Minimal String Xoration
关键性质：位运算在每一位独立。
设 f(i,d)f(i,d)f(i,d) 表示 sss 下表异或 iii 得到字符串的前 2d2^d2d 位，那么有 f(i,d+1)=f(i,d)+f(i⊕2d,d)f(i,d+1)=f(i,d)+f(i\oplus 2^d,d)f(i,d+1)=f(i,d)+f(i⊕2d,d)。类似于后缀排序，设 rk(i,d)rk(i,d)rk(i,d) 表示 f(i,d)f(i,d)f(i,d) 在所有 f(j,d)(0≤j≤2n)f(j,d)(0\le j \le 2^n)f(j,d)(0≤j≤2n) 中的排名，则 p(i,d+1)p(i,d+1)p(i,d+1) 就是二元组 (p(i,d),p(i⊕2d,d))(p(i,d),p(i\oplus 2^d ,d))(p(i,d),p(i⊕2d,d)) 在所有二元组 (p(j,d),p(j⊕2d,d))(p(j,d),p(j \oplus 2^d,d))(p(j,d),p(j⊕2d,d)) 中的排名。
倍增计数排序 O(2nn)O(2^n n)O(2nn) 即可。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,m,v,a[MN],b[MN],c[MN];string s;bool cmp(int x,int y)&#123;    if(b[x]==b[y]) return b[x^v]&lt;b[y^v];    return b[x]&lt;b[y];&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;s;    m=1&lt;&lt;n;    for(int i=0;i&lt;m;i++) a[i]=i,b[i]=s[i]-&#x27;a&#x27;;    sort(a,a+m,cmp);    for(int i=1;i&lt;=n;i++)&#123;        v=(1&lt;&lt;(i-1));        sort(a,a+m,cmp);        int cnt=0;        for(int j=0;j&lt;m;j++)&#123;            if(j==0||cmp(a[j-1],a[j])) c[a[j]]=++cnt;             else c[a[j]]=cnt;        &#125;        for(int j=0;j&lt;m;j++) b[j]=c[j];    &#125;    for(int i=0;i&lt;m;i++) cout&lt;&lt;s[i^a[0]];&#125;
 GYM102803E Everybody Lost Somebody
给同学做了，好题。
给出 SA 数组和 Height 数组我们能得到什么信息，具体来说：

对于 2≤i≤n2\le i \le n2≤i≤n，有 s[sai−1]≤s[sai]s[sa_{i-1}]\le s[sa_{i}]s[sai−1​]≤s[sai​]。更进一步，若 rksa(i−1)+1&gt;rksa(i)+1rk_{sa(i-1)+1}&gt;rk_{sa(i)+1}rksa(i−1)+1​&gt;rksa(i)+1​，则必须有 s[sai−1]&lt;s[sai]s[sa_{i-1}] &lt; s[sa_{i}]s[sai−1​]&lt;s[sai​]。
对于 2≤i≤n2\le i \le n2≤i≤n，对于 0≤j≤hti0\le j \le ht_{i}0≤j≤hti​，有 s[sai−1+j]≤s[sai+j]s[sa_{i-1}+j]\le s[sa_{i}+j]s[sai−1​+j]≤s[sai​+j]。更进一步，若 sai−1+hti≤nsa_{i-1}+ht_{i}\le nsai−1​+hti​≤n，则必须有 s[sai−1+hti]&lt;s[sai+hti]s[sa_{i-1}+ht_{i}] &lt; s[sa_{i}+ht_{i}]s[sai−1​+hti​]&lt;s[sai​+hti​]。

对于 hti≠−1ht_{i}\neq -1hti​=−1，枚举 j∈[0,hti)j\in [0,ht_{i})j∈[0,hti​)，则 s[sai+j]=s[sai+1+j]s[sa_{i}+j]=s[sa_{i+1}+j]s[sai​+j]=s[sai+1​+j] 且 s[sai+hti]&lt;s[sai+1+hti]s[sa_{i}+ht_{i}]&lt;s[sa_{i+1}+ht_{i}]s[sai​+hti​]&lt;s[sai+1​+hti​]。我们可以对于等于并查集缩点，小于连边跑拓扑即可。
现在考虑 hti=−1ht_{i}=-1hti​=−1 的情况，此时对于 sai,sai+1sa_{i},sa_{i+1}sai​,sai+1​ 的LCP 没有限制，而唯一的限制在于 sufsa(i)&lt;sufsa(i+1)suf_{sa(i)}&lt;suf_{sa(i+1)}sufsa(i)​&lt;sufsa(i+1)​，这对 s[sai],s[sai+1]s[sa_{i}],s[sa_{i+1}]s[sai​],s[sai+1​] 提出了要求。当 rk(sai+1)&lt;rk(sai+1+1)rk(sa_{i}+1)&lt;rk(sa_{i+1}+1)rk(sai​+1)&lt;rk(sai+1​+1) 时，s[sai]s[sa_i]s[sai​] 只要不大于 s[sai+1]s[sa_{i+1}]s[sai+1​]，否则 s[sai]s[sa_i]s[sai​] 需要小于s[sai+1]s[sa_{i+1}]s[sai+1​]。还是拓扑排序，时间复杂度 O(n2)O(n^2)O(n2)。
进一步可以发现，只要在合并的时候保持后缀大小顺序的连边，就可以通过了。时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)，魏老师有 O(n)O(n)O(n) 看不懂 qwq。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5200;int n,sa[MN],rk[MN],pre[MN],ht[MN];char ans[MN];vector&lt;int&gt; G[MN];int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;sa[i];        rk[sa[i]]=i;        pre[i]=i;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        cin&gt;&gt;ht[i];    &#125;    for(int i=2;i&lt;=n;i++)&#123;        if(ht[i]==-1)&#123;            int x=sa[i-1]+1,y=sa[i]+1;            if(rk[x]&gt;rk[y]) G[sa[i]].push_back(sa[i-1]);         &#125;        else&#123;            int x=sa[i-1],y=sa[i];            for(int j=1;j&lt;=ht[i];j++)&#123;                pre[root(x+j-1)]=pre[root(y+j-1)];            &#125;            if(x+ht[i]&lt;=n) G[y+ht[i]].push_back(x+ht[i]);        &#125;    &#125;    ans[sa[1]]=&#x27;a&#x27;;    for(int i=2;i&lt;=n;i++)&#123;        ans[sa[i]]=ans[sa[i-1]];        for(auto v:G[sa[i]])&#123;            if(ans[v]+1&gt;ans[sa[i]]) ans[sa[i]]=ans[v]+1;        &#125;        for(int j=1;j&lt;n;j++)&#123;            if(root(sa[j])==root(sa[i])) ans[sa[j]]=ans[sa[i]];        &#125;    &#125;    for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i];    return 0;&#125;
 5. 后缀数组变形-树上后缀数组
P5353
可以参考 STARSczy题解的思路，这里我就不再详细展开了（打字太累了）
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,fa[MN],rk[MN],c[MN],sa[MN],x[MN],y[MN],tmp[MN];string s;vector&lt;int&gt; adj[MN];namespace SAonTree&#123;    void dfs(int u)&#123;        rk[u]+=c[rk[u]]++;        sort(adj[u].begin(),adj[u].end());        for(int v:adj[u]) dfs(v);    &#125;    void getsa(string s)&#123;        int len=s.length();        memset(c,0,sizeof(c));        for(int i=1;i&lt;=len;i++) c[s[i-1]+1]++;        for(int i=1;i&lt;=1000;i++) c[i]+=c[i-1];        for(int i=1;i&lt;=len;i++) rk[i]=c[s[i-1]]+1;        for(int w=0;w&lt;=__lg(len);w++)&#123;            memset(c,0,sizeof(c));            memset(tmp,0,sizeof(tmp));            for(int i=1;i&lt;=len;i++)&#123;                x[i]=rk[i];                y[i]=rk[fa[i]];                c[y[i]+1]++;            &#125;            for(int i=1;i&lt;=len;i++) c[i]+=c[i-1];            for(int i=1;i&lt;=len;i++) tmp[++c[y[i]]]=i;            memset(c,0,sizeof(c));            for(int i=1;i&lt;=len;i++) rk[tmp[i]]+=c[x[tmp[i]]]++;            for(int i=1;i&lt;=len;i++) sa[rk[i]]=i;            for(int i=1;i&lt;=len;i++)&#123;                if(x[sa[i-1]]==x[sa[i]] &amp;&amp; y[sa[i-1]]==y[sa[i]])                    rk[sa[i]]=rk[sa[i-1]];            &#125;            for(int i=len;i&gt;=1;i--) fa[i]=fa[fa[i]];        &#125;                memset(c,0,sizeof(c));        dfs(1);        for(int i=1;i&lt;=len;i++) sa[rk[i]]=i;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(0);cin.tie(0);    cin&gt;&gt;n;    for(int i=2;i&lt;=n;i++)&#123;        cin&gt;&gt;fa[i];        adj[fa[i]].push_back(i);    &#125;    cin&gt;&gt;s;    SAonTree::getsa(s);    for(int i=1;i&lt;=n;i++) cout&lt;&lt;sa[i]&lt;&lt;&quot; &quot;;    return 0;&#125;
例题：
P5346
假设我们求出来了 nnn 个人的排名。

操作 1：O(1)O(1)O(1) 回答。
操作 2：考虑主席树求第 kkk 小，只需要在节点的父亲版本上更新即可。O(log⁡n)O(\log n)O(logn) 回答
操作 3：按照 DFN 序更新即可。O(log⁡n)O(\log n)O(logn) 回答。
而排名求解利用树上后缀数组即可：

#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e6+15;int n,q,fa[MN],a[MN],b[MN],tot;vector&lt;int&gt; adj[MN],s;struct Segment&#123;#define ls t[p].lson#define rs t[p].rson    struct Node&#123;        int lson,rson,val;    &#125;t[MN*20+1145];    int tot,rt[MN];    int insert(int lst,int l,int r,int x)&#123;        int p=++tot;        t[p]=t[lst];        t[p].val+=1;        if(l==r) return p;        int mid=(l+r)&gt;&gt;1;        if(mid&gt;=x) ls=insert(t[lst].lson,l,mid,x);        else rs=insert(t[lst].rson,mid+1,r,x);        return p;    &#125;    int query(int u,int v,int l,int r,int k)&#123;        if(l==r) return l;        int mid=(l+r)&gt;&gt;1;        int rz=t[t[v].rson].val-t[t[u].rson].val;        if(k&lt;=rz) return query(t[u].rson,t[v].rson,mid+1,r,k);        return query(t[u].lson,t[v].lson,l,mid,k-rz);    &#125;#undef ls#undef rs&#125;sg0,sg1;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;namespace SAonTree&#123;    int rk[MN],c[MN],tmp[MN],x[MN],y[MN],sa[MN];    void dfs(int u)&#123;        rk[u]+=c[rk[u]]++;        sort(adj[u].begin(),adj[u].end());        for(int v:adj[u]) dfs(v);    &#125;    void getsa(vector&lt;int&gt; s)&#123;        int len=s.size();        memset(c,0,sizeof(c));        for(int i=1;i&lt;=len;i++) c[s[i-1]+1]++;        for(int i=1;i&lt;=5e5;i++) c[i]+=c[i-1];        for(int i=1;i&lt;=len;i++) rk[i]=c[s[i-1]]+1;        for(int w=0;w&lt;=__lg(len);w++)&#123;            memset(c,0,sizeof(c));            memset(tmp,0,sizeof(tmp));            for(int i=1;i&lt;=len;i++)&#123;                x[i]=rk[i];                y[i]=rk[fa[i]];                c[y[i]+1]++;            &#125;            for(int i=1;i&lt;=len;i++) c[i]+=c[i-1];            for(int i=1;i&lt;=len;i++) tmp[++c[y[i]]]=i;            memset(c,0,sizeof(c));            for(int i=1;i&lt;=len;i++) rk[tmp[i]]+=c[x[tmp[i]]]++;            for(int i=1;i&lt;=len;i++) sa[rk[i]]=i;            for(int i=1;i&lt;=len;i++)&#123;                if(x[sa[i-1]]==x[sa[i]] &amp;&amp; y[sa[i-1]]==y[sa[i]])                    rk[sa[i]]=rk[sa[i-1]];            &#125;            for(int i=len;i&gt;=1;i--) fa[i]=fa[fa[i]];        &#125;                memset(c,0,sizeof(c));        dfs(1);        for(int i=1;i&lt;=len;i++) sa[rk[i]]=i;        for(int i=1;i&lt;=n;i++)&#123;            a[i]=rk[i];        &#125;    &#125;&#125;using namespace SAonTree;namespace Tree&#123;    int siz[MN],dfn[MN],dtot;    void dfsTree(int u)&#123;        dfn[u]=++dtot;        siz[u]=1;        sg1.rt[dfn[u]]=sg1.insert(sg1.rt[dfn[u]-1],1,n,a[u]);        for(auto v:adj[u])&#123;            sg0.rt[v]=sg0.insert(sg0.rt[u],1,n,a[v]);            dfsTree(v);            siz[u]+=siz[v];        &#125;    &#125;&#125;using namespace Tree;int main()&#123;    read(n,q);    for(int i=2;i&lt;=n;i++)&#123;        read(fa[i]);        adj[fa[i]].push_back(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        read(a[i]);        b[++tot]=a[i];    &#125;    sort(b+1,b+1+tot);    tot=unique(b+1,b+1+tot)-b-1;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;        s.push_back(a[i]);    &#125;    getsa(s);    sg0.rt[1]=sg0.insert(0,1,n,a[1]);    dfsTree(1);    while(q--)&#123;        int op,x,k;        read(op,x);        if(op==1)&#123;            put(n+1-a[x]);        &#125;else if(op==2)&#123;            read(k);            put(sa[sg0.query(0,sg0.rt[x],1,n,k)]);        &#125;else&#123;            read(k);            put(sa[sg1.query(sg1.rt[dfn[x]-1],sg1.rt[dfn[x]+siz[x]-1],1,n,k)]);        &#125;    &#125;    return 0;&#125;
 6. 后言
实际上，我们一些技巧基本都体现了我们开头所提到的增量法与势能分析，通过已求信息逐步推导新信息。一些技巧例如关键点思想或并查集块合并通过将全局问题转化为局部问题，动态问题转化为静态问题。
字符串后缀，是字符串的大杀器，在做题过程中，我们能够体会到后缀独特的性质，能够将我们必须暴力枚举的子串简单化，并且将它的对立面——前缀联系起来，后缀数组这一利器，能够解决大部分的问题，但是，有一些问题是后缀数组所不能解决的。这个时候，就要出动我们的 SAM 啦，敬请期待，字符串终极神器——后缀自动机 - 洛谷专栏。
UPD on 2025.7.7：孩子们，我题全部都做完了，结果练 SAM 发现题单里的题都用后缀数组实现过一遍了，充分证明了 SA 可以替代大部分 SAM。然而不是这样的。
完结撒花！
参考

Oi-Wiki
Alex_wei 的字符串基础及其题解
Hoks 的 P6095 题解
LostKeyToReach 的 P7409 题解
云浅知处的课件（保密）
罗勇军的算法竞赛书
算法竞赛进阶指南
chenly8128 的 P5028 题解
wjyppm1403的 P7361 题解
STARSczy树上后缀数组题解

]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>和哈希与随机赋权哈希</title>
    <url>/posts/c64445da/</url>
    <content><![CDATA[ 1. 定义
和哈希，又称集合哈希。
为什么叫集合哈希呢，集合与序列的不同点在于，集合是无序的，也就是说，序列要求每个位置一一相等，而集合只需要对应的元素出现次数相等即可。
我们引入一个问题：

给定一个长为 nnn 的序列 AAA，每次给出两个长度相等的区间 [l1,r1],[l2,r2][l_{1},r_{1}],[l_{2},r_{2}][l1​,r1​],[l2​,r2​] 里面的数排序后是否完全相等，我们就可以说 [2,3,1,4,5][2,3,1,4,5][2,3,1,4,5] 和 [5,4,3,2,1][5,4,3,2,1][5,4,3,2,1] 是相同的。

这种情况我们很难找到一个数据结构来支持这样的查询操作，我们发现如果称两个区间相同，那么这个区间里的每一个数的出现次数和另外一个区间中这个数的出现次数相同。
我们考虑，只需要次数相同就可以的话，那么也就是说，这哈希值之和我数值具体是多少，而和位置无关，那么两个区间相等的必要条件就是 h(l1,r1)=h(l2,r2)h(l_{1},r_{1})=h(l_{2},r_{2})h(l1​,r1​)=h(l2​,r2​)，现在问题在于如何设计函数使得冲突尽量小。
此时哈希函数以如下表示：
h({A})=∑i=1nh′(ax)h(\left\{ A \right\})=\sum\limits_{i=1}^n h&#x27;(a_{x})
h({A})=i=1∑n​h′(ax​)
那么我们有方法，就是给每一个元素赋值一个随机数 rxr_{x}rx​，让后 h({A})=∑i=1nraxh(\left\{ A \right\})=\sum\limits_{i=1}^n r_{a_{x}}h({A})=i=1∑n​rax​​。只要随机数质量高并且值域大，冲突的概率还是比较小的。当然有的时候会被卡，考虑多做几次即可。
 2. 例题
 Problem #115 - ECNU Online Judge

给一个长度为 nnn 的正整数数列 aia_{i}ai​，问有多少连续子数列，满足每个数字的出现次数均为偶数。

对于一个区间，如果每个出现次数为偶数，那么一定有 ⊕i=lrai=0\oplus_{i=l}^r a_{i}=0⊕i=lr​ai​=0，但是这并不代表出现次数一定为偶数，考虑给每个 aia_{i}ai​ 随机赋值，这样进行操作即可。
现在问题转化为当前位置 iii 有多少前缀异或和等于 preprepre，其中 preprepre 表示当前前缀异或，直接扫一遍就可以了。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e5+15;int n,a[MN],ans,st;mt19937 mt;map&lt;int,int&gt; mp,cnt;signed main()&#123;    mt.seed(time(0));    cin&gt;&gt;n;    st=mt();    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        if(!mp.count(a[i])) mp[a[i]]=(st+=mt());        a[i]=mp[a[i]];    &#125;    int pre=0;    cnt[0]=1;    for(int i=1;i&lt;=n;i++)&#123;        pre^=a[i];        ans+=cnt[pre];        cnt[pre]++;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 [CSP-S 2022] 星战
给定一个 nnn 个点 mmm 条边的有向图，支持四种操作：

删除某条边；
删除某个点的所有入边；
恢复某条边；
恢复某个点的所有入边。

每次操作后询问当前图是否满足：

所有点出度均为 1；
所有点都处于一个环中（即基环内向树森林，每个连通块恰有一个环）。

我们考虑，这个反击图是内向基环树森林，利用性质 所有点出度均为 1。那么既然是有向图，其实只要满足出度都为 1，就能判断。
暴力维护出度显然是 O(nm)O(nm)O(nm)。
我们发现，维护出度是很难受的，因为删入边你还需要把遍历边才能把入边全部标记上。但是维护入度很好做啊，我们不妨令原图节点 uuu 的入度为 g(u)g(u)g(u)，而修改后的出度为 c(u)c(u)c(u)，初始情况下 g(u)=c(u)g(u)=c(u)g(u)=c(u)，而对于这四种操作有：

op=1,c(u)←c(u)−1op=1,c(u)\leftarrow c(u)-1op=1,c(u)←c(u)−1。
op=2,c(u)←0op=2,c(u)\leftarrow 0op=2,c(u)←0。
op=3,c(u)←c(u)+1op=3,c(u)\leftarrow c(u)+1op=3,c(u)←c(u)+1。
op=4,c(u)←g(u)op=4,c(u)\leftarrow g(u)op=4,c(u)←g(u)。

可以发现，一张图中的出度之和与入度之和是相等的，问题转化为判断和入度和和出度和为 nnn，但是这是必要条件，我们不能推出每个节点的出度均为 111，但是我们利用和哈希就可以做到。
对于每一个节点 uuu，我们不妨给他随机赋值 h(u)h(u)h(u)，我们令 g(v)=∑(u,v)∈Eh(u)g(v)=\sum\limits_{(u,v)\in E} h(u)g(v)=(u,v)∈E∑​h(u)，我们可以有新的操作：

op=1,c(u)←c(u)−h(u)op=1,c(u)\leftarrow c(u)-h(u)op=1,c(u)←c(u)−h(u)。
op=2,c(u)←0op=2,c(u)\leftarrow 0op=2,c(u)←0。
op=3,c(u)←c(u)+h(u)op=3,c(u)\leftarrow c(u)+h(u)op=3,c(u)←c(u)+h(u)。
op=4,c(u)←g(u)op=4,c(u)\leftarrow g(u)op=4,c(u)←g(u)。

维护 ∑c(u)\sum\limits c(u)∑c(u) 即可，如果有 ∑c(u)=∑h(u)\sum\limits c(u)=\sum\limits h(u)∑c(u)=∑h(u)，那么原图很大概率是合法图：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15;int n,m,q,hsum,now,st,h[MN],g[MN],c[MN];mt19937 mt;signed main()&#123;    mt.seed(time(0));    cin&gt;&gt;n&gt;&gt;m;    st=mt();    for(int i=1;i&lt;=n;i++)&#123;        h[i]=(st+=mt());        hsum+=h[i];    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        g[v]+=h[u];        c[v]=g[v];        now+=h[u];    &#125;    cin&gt;&gt;q;    while(q--)&#123;        int op,u,v;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;u&gt;&gt;v;            now-=h[u];            c[v]-=h[u];        &#125;        if(op==2)&#123;            cin&gt;&gt;u;            now-=c[u];            c[u]=0;        &#125;        if(op==3)&#123;            cin&gt;&gt;u&gt;&gt;v;            now+=h[u];            c[v]+=h[u];        &#125;        if(op==4)&#123;            cin&gt;&gt;u;            now+=g[u]-c[u];            c[u]=g[u];        &#125;        if(now==hsum)&#123;            cout&lt;&lt;&quot;YES\n&quot;;        &#125;else cout&lt;&lt;&quot;NO\n&quot;;    &#125;    return 0;&#125;
 CF1746F
发现直接在线做真的很不好做，考虑离线下来。注意到源题目只关心出现次数，而不关心具体取值，考虑和哈希。给每一个元素赋一个随机权值，那么每次询问我们查询 sum=∑i=lrhisum=\sum\limits_{i=l}^r h_{i}sum=i=l∑r​hi​，若 k∣sk|sk∣s 那么一定不满足，但是对于 kkk 不整除 sss 这是一个必要条件，可能不成立，我们考虑多用随机值映射几次，那么成功概率就会非常高。
接下来我们只需要一个数据结构支持单调修改，区间和查询，树状数组即可，注意到答案和 aia_{i}ai​ 具体取值无关，考虑离散化防止爆炸：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e6+15,MOD=1e9+7;int n,q,a[MN],b[MN],c[MN],rd[MN],tot,op[MN],L[MN],R[MN],K[MN];bool ans[MN];mt19937 mt;unordered_map&lt;int,int&gt; mp;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;struct BIT&#123;    int t[MN];    int lowbit(int x)&#123; return x&amp;-x; &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    int query(int fl,int fr)&#123;        return query(fr)-query(fl-1);    &#125;    void modify(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    void clear()&#123;        memset(t,0,sizeof(t));    &#125;&#125;t;signed main()&#123;    mt.seed(time(0));    int tim=clock();    read(n,q);    for(int i=1;i&lt;=n;i++)&#123;        read(a[i]);        b[++tot]=a[i];    &#125;    for(int i=1;i&lt;=q;i++)&#123;        read(op[i],L[i],R[i]);        if(op[i]==1)&#123;            b[++tot]=R[i];        &#125;        else&#123;            read(K[i]);            ans[i]=(R[i]-L[i]+1)%K[i]==0;        &#125;    &#125;    sort(b+1,b+1+tot);    tot=unique(b+1,b+1+tot)-b-1;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;    &#125;    for(int i=1;i&lt;=q;i++)&#123;        if(op[i]==1) R[i]=lower_bound(b+1,b+1+tot,R[i])-b;    &#125;    for(;1.0*clock()-tim&lt;=2.8*CLOCKS_PER_SEC;)&#123;        t.clear();        for(int i=0;i&lt;=tot;i++)&#123;            mp[i]=mt()%MOD;        &#125;        for(int i=1;i&lt;=n;i++) c[i]=mp[a[i]];        for(int i=1;i&lt;=n;i++) t.modify(i,c[i]);        for(int i=1;i&lt;=q;i++)&#123;            if(op[i]==1)&#123;                t.modify(L[i],mp[R[i]]-c[L[i]]);                c[L[i]]=mp[R[i]];            &#125;else if(t.query(L[i],R[i])%K[i]) ans[i]=0;        &#125;    &#125;    for(int i=1;i&lt;=q;i++)&#123;        if(op[i]!=1)&#123;            put((ans[i]?&quot;YES&quot;:&quot;NO&quot;));        &#125;    &#125;    return 0;&#125;
 P3792 由乃与大母神原型和偶像崇拜
重排为值域上连续的一段其实就是数值相邻，那么实际上数值相邻我们不关心数值具体是什么，我们只需要考虑它们能不能相邻就可以了，考虑随机赋权哈希，那么在值域连续的情况下。假设我们查询的区间随机数为 p2,p3,p4p_2,p_3,p_4p2​,p3​,p4​，那么通过前缀异或和算出 p2⊕p3⊕p4p_{2}\oplus p_{3}\oplus p_{4}p2​⊕p3​⊕p4​，若区间三个随机数异或和等于 p2⊕p3⊕p4p_{2}\oplus p_{3}\oplus p_{4}p2​⊕p3​⊕p4​，我们就认为这个区间是连续的。前缀异或和和映射前缀异或和可以用树状数组维护。
首先要离散化，但是不能瞎离散化，因为离散化后的数是连续的，我们可以考虑将离散化的时候多把每个值加 1 的数放到离散化数组里，这样本来就不连续的数离散化之后也不连续。
让后映射的数最好用 unsigned long long 自然溢出，这样的情况下极其难被 hack。若被卡随机数种子，考虑利用 random_device 这个玩意，在 Linux 下实现是一个真随机数生成器，从系统的熵池获取数据，通常用于为其他随机数引擎提供种子。这样能被 hack 概率可以忽略。
推荐使用茅台 19937 产随机数和 time(0) 初始化种子。
#include&lt;bits/stdc++.h&gt;#define int long long#define ull unsigned long longusing namespace std;constexpr int MN=3e6+15;int n,m,tot,a[MN],b[MN],op[MN],x[MN],y[MN];ull rd[MN],pre[MN];mt19937 mt; // 茅台 19937 产struct BITsum&#123;    int t[MN];    int lowbit(int x)&#123;return x&amp;-x;&#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void modify(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;&#125;t1;struct BITXor&#123;    ull t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    ull query(int x)&#123;        int ret=0;        while(x)&#123;            ret^=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void modify(int x,ull k)&#123;        while(x&lt;MN)&#123;            t[x]^=k;            x+=lowbit(x);        &#125;    &#125;&#125;t2;signed main()&#123;    mt.seed(time(0));    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        b[++tot]=a[i];        b[++tot]=a[i]+1;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;op[i]&gt;&gt;x[i]&gt;&gt;y[i];        if(op[i]==1) b[++tot]=y[i]+1,b[++tot]=y[i];    &#125;    sort(b+1,b+tot+1);    tot=unique(b+1,b+1+tot)-b-1;    rd[0]=mt();    for(ull i=1,st=rd[0];i&lt;=tot;i++)&#123;        rd[i]=(st+=mt());        pre[i]=pre[i-1]^rd[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(b+1,b+1+tot,a[i])-b;        t1.modify(i,a[i]);        t2.modify(i,rd[a[i]]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        if(op[i]==1)&#123;            y[i]=lower_bound(b+1,b+1+tot,y[i])-b;            t1.modify(x[i],y[i]-a[x[i]]);            t2.modify(x[i],rd[y[i]]^rd[a[x[i]]]);            a[x[i]]=y[i];        &#125;else&#123;            int mid=(t1.query(y[i])-t1.query(x[i]-1))/(y[i]-x[i]+1);            int l,r;            l=mid-(y[i]-x[i])/2;            if((y[i]-x[i])&amp;1) r=mid+(y[i]-x[i])/2+1;            else r=mid+(y[i]-x[i])/2;            if(l&lt;=0||r&gt;=tot) cout&lt;&lt;&quot;yuanxing\n&quot;;            else if((t2.query(y[i])^t2.query(x[i]-1))==(pre[r]^pre[l-1]))&#123;                cout&lt;&lt;&quot;damushen\n&quot;;            &#125; else cout&lt;&lt;&quot;yuanxing\n&quot;;        &#125;    &#125;    return 0;&#125;
 3. 后言
属于是乱搞操作，但是又没有那么乱搞哈哈哈，学到也是赚到 lol。
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>四边形不等式优化DP</title>
    <url>/posts/ed03bc31/</url>
    <content><![CDATA[ 1.概念
四边形不等式是对一个二元函数定义：w(l,r)w(l,r)w(l,r)。这里的w(l,r)w(l,r)w(l,r)可以看作价值，权值或着价格都可以。
对于任意a≤b≤c≤da\le b\le c\le da≤b≤c≤d ，若都有w(a,d)+w(b,c)≥w(a,c)+w(b,d)w(a,d)+w(b,c)\ge w(a,c)+w(b,d)w(a,d)+w(b,c)≥w(a,c)+w(b,d)，我们就称w(l,r)w(l,r)w(l,r)满足四边形不等式，可以简单记为：”交叉小于包含“。
同时有结论，对于a≤ba\le ba≤b，有w(a,b−1)+w(a+1,b)≤w(a,b)+w(a+1,b−1)w(a,b-1)+w(a+1,b)\le w(a,b)+w(a+1,b-1)w(a,b−1)+w(a+1,b)≤w(a,b)+w(a+1,b−1)。
结论：若两个函数之间满足四边形不等式，那么和也满足四边形不等式。
话说为啥叫四边形不等式：

AD+BC≥AC+BDAD+BC\ge AC+BDAD+BC≥AC+BD，这个显然在初中是学过的。
反四边形不等式：
就是符号调换一下：w(a,d)+w(b,c)≤w(a,c)+w(b,d)w(a,d)+w(b,c)\le w(a,c)+w(b,d)w(a,d)+w(b,c)≤w(a,c)+w(b,d)
 2. 1D/1D优化
这里不是2.1
特征转移方程：
f(i)=min⁡1≤j&lt;if(j)+w(i,j)f(i)=\min_{1\le j &lt; i} f(j)+w(i,j)
f(i)=1≤j&lt;imin​f(j)+w(i,j)
如果www满足四边形不等式的话，我们就可以进行决策单调性优化。
f(i)=max⁡1≤j&lt;if(j)+w(i,j)f(i)=\max_{1\le j &lt; i} f(j)+w(i,j)
f(i)=1≤j&lt;imax​f(j)+w(i,j)
如果www满足反四边形不等式，我们也可以进行决策单调性优化。
啥是决策单调性？
 2.1 决策单调性
这个我们要好好说一说。
我们记pip_ipi​表示对于iii而言，枚举的jjj使得f(j)+w(i,j)f(j)+w(i,j)f(j)+w(i,j)最小的值，说人话就是f(i)f(i)f(i)从哪个jjj对应的值转移过来的。如果ppp在[1,n][1,n][1,n] 上单调不见，那么我们就称fff有决策单调性。
如果f(i)=min⁡1≤j&lt;if(j)+w(i,j)f(i)=\min_{1\le j &lt; i} f(j)+w(i,j)f(i)=min1≤j&lt;i​f(j)+w(i,j)中www满足四边形不等式，那么fff有决策单调性。

[!TIPS]
这个条件是充分条件，反过来不一定成立！

同理，如果f(i)=max⁡1≤j&lt;if(j)+w(i,j)f(i)=\max_{1\le j &lt; i} f(j)+w(i,j)f(i)=max1≤j&lt;i​f(j)+w(i,j)，其中www满足反四边形不等式，那么fff同样也有决策单调性。
那为什么叫决策单调性？其实四边形不等式你看着简单，实际上后面蕴含这导数和混合偏导数的关系，这里我不作解释，感兴趣去往上搜搜。
接下来我们说明的是四边形不等式，反四边形不等式与下面的完全相反，包括图形
事实上，当我们xxx越来越大的时候，w′w&#x27;w′即www的导数也越来越小。图像呈下面的样子。

当导数逐渐减少的时候，图形的斜率减少趋0，图像越来越平，获得的决策点pip_ipi​也越来越往后，也就是下图：

结论：
对于f(i)=min⁡1≤j&lt;if(j)+w(i,j)f(i)=\min_{1\le j &lt; i} f(j)+w(i,j)f(i)=min1≤j&lt;i​f(j)+w(i,j)，需要w(i,j)w(i,j)w(i,j)满足四边形不等式。
对于f(i)=max⁡1≤j&lt;if(j)+w(i,j)f(i)=\max_{1\le j &lt; i} f(j)+w(i,j)f(i)=max1≤j&lt;i​f(j)+w(i,j)，需要w(i,j)w(i,j)w(i,j)满足反四边形不等式。
根据图像也不难发现，pi−1≤pi≤pi+1p_{i-1}\le p_{i}\le p_{i+1}pi−1​≤pi​≤pi+1​，这就是决策单调性。
 2.2 单调队列+二分维护
若转移方程是fj+w→fif_{j} +w \rightarrow f_ifj​+w→fi​，前推后，那么我们称这个问题叫在线问题我们可以用单调队列+二分的思想。

观察图形，发现类易于一个凸壳的性质，我们可以类似于斜率优化一样来维护这个凸壳。但是有一个问题？这个是曲线又不是直线，不能判断斜率，怎么做？也就是不能简单地用队头队尾O(1)O(1)O(1)维护分界点，这个时候只能每次扫一遍凸壳确定。也就是二分。

检查队头，设队头为(j0,l0,r0)(j_0,l_0,r_0)(j0​,l0​,r0​)，若r0=i−1r_0=i-1r0​=i−1，删除队头否则令l0=il_0=il0​=i。
取队头决策，计算f[i]f[i]f[i]。
尝试插入iii。

取出队尾，记为(jt,lt,rt)(j_t,l_t,r_t)(jt​,lt​,rt​)。
若对于f[li]f[l_i]f[li​]来说，iii比jtj_tjt​更优，即f[i]+val(i,lt)≤f[jt]+val(jt,lt)f[i]+val(i,l_{t)} \le f[j_t]+val(j_t,l_t)f[i]+val(i,lt)​≤f[jt​]+val(jt​,lt​)，记pos=ltpos=l_tpos=lt​，删除队尾，回到取出队尾的步骤。
若对于f[ri]f[r_i]f[ri​]来说，iii比jtj_tjt​更优，即f[i]+val(i,rt)≤f[jt]+val(jt,rt)f[i]+val(i,r_{t)} \le f[j_t]+val(j_t,r_t)f[i]+val(i,rt)​≤f[jt​]+val(jt​,rt​)，记pos=ltpos=l_tpos=lt​，直接插入(i,pos,n)(i,pos,n)(i,pos,n)即可
否则，在[lt,rt][l_t,r_t][lt​,rt​]上二分，求出位置pospospos，在此之前决策jtj_tjt​更优，后面iii更优，让后令队尾的rt=posr_t=posrt​=pos，插入(i,pos,n)(i,pos,n)(i,pos,n)即可。



代码如下：
void insert(int x)&#123;    int pos=n+1;    while(ql&lt;=qr&amp;&amp;f[x]+w(x,q[qr].l)&lt;=f[q[qr].j]+w(q[qr].j,q[qr].l)) pos=q[qr--].l;    if(ql&lt;=qr&amp;&amp;f[x]+w(x,q[qr].r)&lt;=f[q[qr].j]+w(q[qr].j,q[qr].r))&#123;        int l=q[qr].l,r=q[qr].r;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(f[x]+w(x,mid)&lt;=f[q[qr].j]+w(q[qr].j,mid)) r=mid;            else l=mid;        &#125;        q[qr].r=r-1;        pos=r;    &#125;    if(pos!=n+1)&#123;        q[++qr]=&#123;pos,n,x&#125;;    &#125;&#125;
DP的时候正常取决策即可：
ql=1,qr=0;q[++qr]=&#123;1,n,0&#125;;for(int i=1;i&lt;=n;i++)&#123;    while(ql&lt;=qr&amp;&amp;q[ql].r&lt;i) ql++;    f[i]=f[q[ql].j]+w(q[ql].j,i);    ans[i]=ans[q[ql].j]+1;    insert(i);&#125;
 2.3 分治法
若转移方程是g+w→fg+w \rightarrow fg+w→f的转移，也就是说转移是由一个已知的函数或这fff的上一层转移过来，那么我们就可以用分治的方法，这种决策是离线的，我们不依赖fi−1f_{i-1}fi−1​来计算fif_ifi​，这时候就不必采用单调队列这种顺序计算fif_ifi​了，只需要分治就可以，编码更简单也更灵活。
算法步骤：

初始化：首先暴力遍历j∈[1,n/2)j\in[1,n/2)j∈[1,n/2)来计算pn/2p_{n/2}pn/2​，作为分治的中心点。
分治求解：接下来分别计算2个区间[1,n/2)[1,n/2)[1,n/2)和(n/2,2](n/2,2](n/2,2]的pip_ipi​。

对于前半段，最优决策点一定在[1,pn/2][1,p_{n/2}][1,pn/2​]之间。
对于后半段，最优决策点一定在[pn/2,pn][p_{n/2},p_n][pn/2​,pn​]之间。


递归处理即可。

代码实现如下：
int clac(int i,int j); //计算选择决策j的费用// l,r是决策区间，kl,kr是决策点的区间void dfs(int l,int r,int kl,int kr)&#123;	int mid=(l+r)&gt;&gt;1,k=kl;	for(int i=kl;i&lt;=min(kr,mid-1);i++)&#123;		//求费用最少的f[mid]最优决策点		if(clac(mid,i)&lt;clac(mid,k)) k=i;		f[mid]=clac(mid,k);	&#125;	if(l&lt;mid) dfs(l,mid-1,kl,k);	if(r&gt;mid) dfs(mid+1,r,k,kr);&#125;//ans=f[n];
复杂度分析：
递归树深度log⁡n\log nlogn，递归执行一个元素至多被扫2次，时间复杂度即为O(nlog⁡n)O(n\log n)O(nlogn)。
空间复杂度显然O(log⁡n)O(\log n)O(logn)。
分治法的优点：
如果w(i,j)w(i,j)w(i,j)不能O(1)O(1)O(1)计算但是可以从w(i±1,j±1)w(i\pm 1,j\pm 1)w(i±1,j±1)来O(1)O(1)O(1)递推，此时分治法就能够以均摊O(1)O(1)O(1)的速度来计算，因为在暴力遍历循环中w(i,j)w(i,j)w(i,j)的区间是顺序扩大的，而单调队列计算w(i,j)w(i,j)w(i,j)是乱跳的。下面会有例题来解释。
 2.4 决策单调性1D1D例题
1.[单调队列二分] P1912 诗人小G

一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 PPP 次方，而一个排版的不协调度为所有行不协调度的总和。
小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。
给定诗句数nnn，行标准长度LLL与题目描述的PPP，如果不协调度大于101810^{18}1018输出&quot;Too hard to arrange&quot;。

不妨设f[i]f[i]f[i]为前iii个句子的最小不协调度，记长度为aia_iai​，sumisum_isumi​为aia_iai​的前缀和，不难有转移方程：
f[i]=min⁡j=0i−1f[j]+∣sum[i]−sum[j]+(i−j−1)−L∣Pf[i]=\min_{j=0}^{i-1}f[j]+|sum[i]-sum[j]+(i-j-1)-L|^P
f[i]=j=0mini−1​f[j]+∣sum[i]−sum[j]+(i−j−1)−L∣P
就是将[j+1,i][j+1,i][j+1,i]作为最后一行，前面照常排。
这里PPP不固定不能考虑斜率优化，考虑四边形不等式，这个证明起来比较难，实在不行可以打表看看。
故代码如下：
#include&lt;bits/stdc++.h&gt;#define ld long double#define ll long longusing namespace std;const int MN=1e5+15;struct node&#123;    int c,l,r;&#125;q[MN];int T;int n,ql,qr,L,P,a[MN],pre[MN];ld f[MN],s[MN];string st[MN];vector&lt;int&gt; ans;ld qpow(ld a,ll b)&#123;    ld ans=1;    while (b)    &#123;        if(b&amp;1)&#123;            ans*=a;        &#125;        b&gt;&gt;=1;        a*=a;    &#125;    return ans;&#125;ld clac(int x,int y)&#123;    return f[x]+qpow(fabs(s[y]-s[x]-L-1),P);&#125;void insert(int x)&#123;    int pos=n+1;    while(ql&lt;=qr&amp;&amp;clac(x,q[qr].l)&lt;=clac(q[qr].c,q[qr].l))&#123;        pos=q[qr--].l;    &#125;    if(ql&lt;=qr&amp;&amp;clac(x,q[qr].r)&lt;=clac(q[qr].c,q[qr].r))&#123;        int l=q[qr].l,r=q[qr].r;        while(l+1&lt;r)&#123;            int mid=l+r&gt;&gt;1;            if(clac(x,mid)&lt;=clac(q[qr].c,mid)) r=mid;            else l=mid;        &#125;        q[qr].r=r-1;        pos=r;    &#125;    if(pos!=n+1)&#123;        q[++qr]=&#123;x,pos,n&#125;;    &#125;&#125;void solve()&#123;    ans.clear();    memset(f,0,sizeof(f));    memset(s,0,sizeof(s));    memset(pre,0,sizeof(pre));    cin&gt;&gt;n&gt;&gt;L&gt;&gt;P;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;st[i];        s[i]=s[i-1]+st[i].length()+1;    &#125;    ql=1,qr=0;    q[++qr]=&#123;0,1,n&#125;;    for(int i=1;i&lt;=n;i++)&#123;        while(ql&lt;=qr&amp;&amp;q[ql].r&lt;i) ql++;        f[i]=clac(q[ql].c,i);        pre[i]=q[ql].c;        insert(i);    &#125;    if(f[n]&gt;1e18)&#123;        cout&lt;&lt;&quot;Too hard to arrange\n&quot;;    &#125;else&#123;        cout&lt;&lt;(ll)f[n]&lt;&lt;&#x27;\n&#x27;;        for(int i=n;i;i=pre[i])&#123;            ans.push_back(i);        &#125;        int cur=ans.size()-1,tmp=0;        for(int i=1;i&lt;=n;i++)&#123;            if(tmp) cout&lt;&lt;&quot; &quot;;            cout&lt;&lt;st[i];            if(i==ans[cur]) cout&lt;&lt;&#x27;\n&#x27;,cur--,tmp=0;            else tmp++;        &#125;    &#125;    cout&lt;&lt;&quot;--------------------\n&quot;;&#125;int main()&#123;    cin&gt;&gt;T;    while (T--)    &#123;        solve();    &#125;        return 0;&#125;
2.[分治法] CF868F Yet Another Minimization Problem

给定一个长度为nnn的序列 aaa，要把它分成 kkk 个子段。每个子段的费用是其中相同元素的对数。求所有子段的费用之和的最小值。
2≤n≤105,2≤k≤min(n,20),1≤ai≤n2\le n\le 10^5,2\le k\le min(n,20),1\le a_{i}\le n2≤n≤105,2≤k≤min(n,20),1≤ai​≤n

不难设转移方程，f[i][j]f[i][j]f[i][j]表示执行到第iii个数，共化了jjj个子段，不难有转移方程。
f[i][j]=min⁡k=1i−1f[k][j−1]+w(k+1,i)f[i][j]=\min_{k=1}^{i-1}f[k][j-1]+w(k+1,i)
f[i][j]=k=1mini−1​f[k][j−1]+w(k+1,i)
时间复杂度为O(n2)O(n^2)O(n2)，不可承受，况且www的计算又是一个头痛的地方。
考虑www能否满足四边形不等式，不难发现iii向右移动时www单调不减，所以肯定满足决策单调性。
考虑决策单调性，不难发现这个不用顺序计算，考虑分治法，但是这样算不太好，我们把方程两维转换一下。
f[i][j]f[i][j]f[i][j]表示共化了iii个段，执行到第jjj个数，转移方程类似。
这样就能分治了，其实也可以不换（雾）。
考虑www如何快速的计算，区间相同元素，区间颜色段问题，这不是莫队的拿手好戏吗。我们做一个类似莫队的暴力，这样，用左右指针进行区间移动，考虑一次最多移动多少次？从[l,r][l,r][l,r]移动到最后一次的[l,mid][l,mid][l,mid]最多移动r−lr-lr−l次，同一层最多O(n)O(n)O(n)次，所以均摊单次计算O(1)O(1)O(1)，时间复杂度O(knlog⁡n)O(kn\log n)O(knlogn)。
其实这里www的计算也和上面分治法的优点对应，我们的w(i±1,j±1)w(i\pm 1,j\pm 1)w(i±1,j±1)可以通过O(1)O(1)O(1)移动指针O(1)O(1)O(1)算出来，但是如果我们使用单调队列的话就不能利用这个性质了。
故代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=1e5+15;int n,mk,a[MN],cnt[MN],wl=1,wr;ll f[MN][2],now,pre=1,w;inline ll cost(int l, int r) &#123;    while (wl &gt; l) wl--, w += cnt[a[wl]]++;    while (wr &lt; r) wr++, w += cnt[a[wr]]++;    while (wl &lt; l) w -= --cnt[a[wl]], wl++;    while (wr &gt; r) w -= --cnt[a[wr]], wr--;    return w;&#125;inline ll clac(int i, int j) &#123;    return f[j][pre] + cost(j+1, i);&#125;void dfs(int l,int r,int kl,int kr)&#123;    int mid=(l+r)&gt;&gt;1,k=kl;    ll kv=clac(mid,k);    for(int i=kl;i&lt;=min(kr,mid);i++)&#123;        ll tmp=clac(mid,i);        if(tmp&lt;kv)&#123;            k=i;            kv=tmp;        &#125;    &#125;    f[mid][now]=kv;    if(mid&gt;l) dfs(l,mid-1,kl,k);    if(mid&lt;r) dfs(mid+1,r,k,kr);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;mk;    wr=n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        f[i][now]=(w+=cnt[a[i]]++);    &#125;    for(int i=2;i&lt;=mk;i++)&#123;        swap(now,pre);        dfs(1,n,1,n);    &#125;    cout&lt;&lt;f[n][now];    return 0;&#125;
 3. 2D/1D优化
 3.1 区间决策点单调性
这里和上面的单点决策单调性就没太大关系了，我们这里是区间决策单调性。
这里2D表示我们的状态维度是二维，而决策点是一维的。
特征方程：
f[i][j]=min⁡k=ij−1(f[i][k]+f[k+1][j]+w[i][j])=min⁡k=ij−1(f[i][k]+f[k+1][j])+w[i][j]\begin{aligned}
f[i][j]&amp; =\min_{k=i}^{j-1}(f[i][k]+f[k+1][j]+w[i][j])\newline
&amp; = \min_{k=i}^{j-1}(f[i][k]+f[k+1][j])+w[i][j]
\end{aligned}
f[i][j]​=k=iminj−1​(f[i][k]+f[k+1][j]+w[i][j])​=k=iminj−1​(f[i][k]+f[k+1][j])+w[i][j]​
你会说，这不就是区间DP吗？
是…也不是？
但是这里我们的w(i,j)w(i,j)w(i,j)不仅要满足四边形不等式，更要满足单调性。
即：
对于任意a≤b≤c≤d,w(a,d)≥w(b,c) 或 w(i+1,j)≤w(i,j+1)\text{对于任意}a\le b\le c\le d,w(a,d)\ge w(b,c )\text{ 或 }w(i+1,j) \le w(i,j+1)
对于任意a≤b≤c≤d,w(a,d)≥w(b,c) 或 w(i+1,j)≤w(i,j+1)
速记：小区间≤\le≤大区间。
如果w(i,j)w(i,j)w(i,j)满足四边形不等式和单调性，那么我们用dpdpdp计算的时间复杂度是O(n2)O(n^2)O(n2)。

引理1：如果w(i,j)w(i,j)w(i,j)满足四边形不等式和单调性，则f[i][j]=min⁡k=ij−1(f[i][k]+f[k+1][j]+w[i][j])f[i][j]=\min_{k=i}^{j-1}(f[i][k]+f[k+1][j]+w[i][j])f[i][j]=mink=ij−1​(f[i][k]+f[k+1][j]+w[i][j])也满足四边形不等式。


引理2：记s[i][j]=ks[i][j]=ks[i][j]=k为f[i][j]f[i][j]f[i][j]取得最小值的kkk，如果f[i][j]f[i][j]f[i][j]满足四边形不等式，有：

s[i][j−1]≤k≤s[i+1][j]s[i][j-1]\le k\le s[i+1][j]
s[i][j−1]≤k≤s[i+1][j]
速记：左中区间≤\le≤ 大区间≤\le≤ 右中区间。

对于求最大值：
f[i][j]=max⁡k=ij−1(f[i][k]+f[k+1][j]+w[i][j])=max⁡k=ij−1(f[i][k]+f[k+1][j])+w[i][j]\begin{aligned}
f[i][j]&amp; =\max_{k=i}^{j-1}(f[i][k]+f[k+1][j]+w[i][j])\newline
&amp; = \max_{k=i}^{j-1}(f[i][k]+f[k+1][j])+w[i][j]
\end{aligned}f[i][j]​=k=imaxj−1​(f[i][k]+f[k+1][j]+w[i][j])​=k=imaxj−1​(f[i][k]+f[k+1][j])+w[i][j]​
需要满足反四边形不等式与最大值的单调性。
单调性即：
对于任意a≤b≤c≤d,w(a,d)≤w(b,c)\text{对于任意}a\le b\le c\le d,w(a,d)\le w(b,c )
对于任意a≤b≤c≤d,w(a,d)≤w(b,c)
速记：小区间≥\ge≥大区间。反过来即可。
如果w(i,j)w(i,j)w(i,j)满足反四边形不等式和单调性，那么我们用dpdpdp计算的时间复杂度是O(n2)O(n^2)O(n2)。

引理3：如果w(i,j)w(i,j)w(i,j)满足反四边形不等式和单调性，则f[i][j]=max⁡k=ij−1(f[i][k]+f[k+1][j]+w[i][j])f[i][j]=\max_{k=i}^{j-1}(f[i][k]+f[k+1][j]+w[i][j])f[i][j]=maxk=ij−1​(f[i][k]+f[k+1][j]+w[i][j])也满足反四边形不等式。


引理4：记s[i][j]=ks[i][j]=ks[i][j]=k为f[i][j]f[i][j]f[i][j]取得最大值的kkk，如果f[i][j]f[i][j]f[i][j]满足四边形不等式，有：

s[i][j−1]≤k≤s[i+1][j]s[i][j-1]\le k\le s[i+1][j]
s[i][j−1]≤k≤s[i+1][j]
速记：左中区间≤\le≤ 大区间≤\le≤ 右中区间。这个是一样的。
 3.2 区间决策点单调性模板题
石子合并，只求最小，有环，但n≤5000n\le 5000n≤5000，喜欢我O(n2)O(n^2)O(n2)吗？
不难发现这个转移方程是很明显满足四边形不等式的，毕竟本身就有单调性。
所以怎么实现呢，根据上面的引理，我们只需要在[s[i][j−1],s[i+1][j]][s[i][j-1],s[i+1][j]][s[i][j−1],s[i+1][j]]这个区间内进行遍历即可，顺便记录一下决策点，这个可比1D/1D好写多了，只需要开个数组记录就可以。
代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=5125,INF=1e9;int f[MN][MN],p[MN][MN],n,s[MN];int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;s[i];        s[i]+=s[i-1];        p[i][i]=i;    &#125;    for(int len=2;len&lt;=n;len++)&#123;        for(int l=1;l+len-1&lt;=n;l++)&#123;            int r=l+len-1;            f[l][r]=INF;            for(int k=p[l][r-1];k&lt;=p[l+1][r];k++)&#123;                int t=f[l][k]+f[k+1][r]+s[r]-s[l-1];                if(f[l][r]&gt;t)&#123;                    f[l][r]=t;                    p[l][r]=k;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;f[1][n];    return 0;&#125;
为啥没说最大值，最大值不满足最大值的单调性，所以不行只能O(n3)O(n^3)O(n3)。
 4.写在最后
感谢阅读！
本文章素材来源：

算法竞赛进阶指南
しずり雪 の Blog，大佬图太好了！
洛谷日报，但是不知道哪篇www

]]></content>
      <categories>
        <category>DP优化</category>
      </categories>
      <tags>
        <tag>DP优化</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>基环树</title>
    <url>/posts/70f2f90a/</url>
    <content><![CDATA[ 0. 前言
你需要的知识点：

图的遍历与存储（这都会吧。。。）
树的直径与树上最大独立集（没有上司的舞会）等树形DP基础芝士
环的认识

 1. 基环树基本芝士
 1.1 概念
想必都知道树结构的特点吧。

给定一张 nnn 个点，n−1n-1n−1 条边的无向图，…

这个就是树的特点，有 n−1n-1n−1 条边。而基环树呢？就是在原先树的情况上加了一条边，于是基环树的特点就是：

给定一张 nnn 个点，nnn 条边的无向（或有向）图，…

那长什么样？

那有人就会说链，这根本就不是树啊，这有环怎么能叫树呢？事实上也是这样的，人家是个图吗。
比一般的树多一条边，这导致这个基环树图上出现了一个唯一的环，这个的前提是图联通。如果不联通，就会出现多个环，例如下图：

当然，基环树也有有向图的版本，这个版本有2个，一个叫内向基环树，一个叫外向基环树。

 1.2 找环
我们对于基环树的处理一般是找到他最特殊的地方，也就是他的环。
怎么找环呢？其实也很简单，我们分无向的和有向的来分别说。
 1.2.1 并查集（无向图）
复杂度均摊O(1)O(1)O(1)。
无向图我们可以使用并查集来判断联通性，这也是找环的一个方法。我们在读取边的时候就可以使用并查集判断，如果发现u,vu,vu,v的并查集节点一致，那么他们互相联通，已经成环，此时u−vu-vu−v组成的边就是环边的一部分，也就是那一条加入的非树边。
int n,pre[MN];vector&lt;int&gt; adj[MN];int root(int x)&#123;    if(x==pre[x]) return x;    else return pre[x]=root(pre[x]);&#125;void init()&#123;    for(int i=1;i&lt;=n;i++)&#123;        pre[i]=i;    &#125;&#125;int main()&#123;        cin&gt;&gt;n;    init();    for(int i=1;i&lt;=n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        int ru=root(u),rv=root(v);        if(ru==rv)&#123;            cir.push_back(pir(ru,v));// 找到环边            continue;        &#125;else pre[rv]=ru;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    return 0;&#125;
 1.2.2 拓扑排序（无向图）
复杂度O(n)O(n)O(n)
一个显然的想法就是将无向图转化成有向图去做，把无向图转化成两条有向边，当一个节点的入度大于等于2时，点在环上。用的不算太多，不给出代码了。
 1.2.3 LCA (无向图)
复杂度O(n)−O(nlog⁡n)O(n)-O(n\log n)O(n)−O(nlogn)

显然？只需要找到最短路径即可，但是没太大啥用。
 1.2.4 DFS序（无向图）
复杂度O(n)O(n)O(n)
这需要我们记录2个变量：dfn,fadfn,fadfn,fa，分别代表DFS序（时间戳）与父亲节点编号。
不难发现如果我们下一个访问的节点已经被访问过，说明已经成环，我们可以借助这个来实现找环。
void dfs(int u,int pre)&#123;    dfn[u]=++tot;    fa[u]=pre;    for(auto v:adj[u])&#123;        if(v==pre) continue;        if(dfn[v])&#123;            if(dfn[v]&lt;dfn[u]) continue; // 为什么这里continue？            lp[++htot]=v;            for(;v!=u;v=fa[v]) lp[++htot]=fa[v];	        &#125;else dfs(v,u);    &#125;&#125;
有些人会对if(dfn[v]&lt;dfn[u]) continue;这一句感到疑惑，为什么要这么搞？
仔细思考，当dfn[v]&lt;dfn[u]时其实就是vvv是uuu的祖先节点（不是父亲节点），这个其实就是返祖边，如果我们只靠返祖边来判断环肯定是不对的，我们需要跳过所有祖先节点，避免跨代误判。如果去掉，则会出现路径记录不全的情况，甚至会将树边误判为环边。
 1.2.5 自底向上（有向图）
有向图最简单的算法，不需要太多解释，你发现有个节点之前被访问过那么肯定成环：
int getlp(int u)&#123;    vis[u]=1;    if(vis[fa[u]]) return u;    else return getlp(fa[u]);&#125;
 1.3 基环树问题解法
问题解法有哪些呢，一般来说我们有2个思想（计数的滚出去(#`Д´)ﾉ）：

借鉴环形DP两次DP，在环一个位置强制断开（或忽略）成树跑一遍计算答案。第二次通过适当的改动算出的答案等价于把断开的边强制相连。
把基环树的环给提起来，这样提起来的树换上的节点挂着一个一个对应的子树，先算子树的答案，在合并到环上的节点，最后就变成链环上问题。例如下图：


 2. 基环树的例题
 2.1 基环树直径——洛谷P4381
基环树的直径指基环树中最长的简单路径被称为基环树的最长链，其长度就是基环树直径。
基环树的直径的答案可能出现在2个位置：

单个子树中（不跨环）
跨子树（跨环）

我们利用第二个方法：
先找出基环树的环，让后先对环上的节点跑树形DP求树的直径，记为DiD_iDi​。
对于答案1，即为ans1=max⁡i=1lenDians1=\max\limits_{i=1}^{len} D_ians1=i=1maxlen​Di​，其中 lenlenlen 为记录的环节点个数（即环长）。
而对于跨子树，答案即为：
f[i]=max⁡j=1,j≠ilenDi+Dj+dis(i,j)f[i]=\max\limits_{j=1,j\neq i}^{len} D_i+D_j+dis(i,j)
f[i]=j=1,j=imaxlen​Di​+Dj​+dis(i,j)
对于dis(i,j)dis(i,j)dis(i,j)，有逆时针和顺时针两种走法，走最长的。
O(n2)O(n^2)O(n2) 有点炸裂，而且环不好处理，我们可以考虑一个环形DP最常用的方法，断环复制1分。让后因为 DiD_iDi​ 是定值可以提出来。
不难有：
f[i]=Di+max⁡j=1i−1Dj+dis(i,j)f[i]=D_i+\max\limits_{j=1}^{i-1} D_j+dis(i,j)
f[i]=Di​+j=1maxi−1​Dj​+dis(i,j)
到这里还看不出来怎么优化的（没学过没关系可以看我的DP优化博客)，这不就是最标准1D/1D单调队列优化模型吗？复杂度O(n)O(n)O(n)结束。
但是原题其实是个基环树森林，每一次统计一遍答案就可以了。
当然，还记得我们提到的那个小可爱二元环吗，那个需要特判，在大部分题中作为一个普遍的hack数据出现，请大家特别注意。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=1e6+15;struct Edge&#123;    int v,w;&#125;;int n,len,fa[MN],dfn[MN],tot,lp[MN];ll d[MN];vector&lt;Edge&gt; adj[MN];ll q[MN&lt;&lt;1],s[MN&lt;&lt;1],ql,qr,anszj;bool vis[MN];void dfs(int u,int pre)&#123;    dfn[u]=++tot;    fa[u]=pre;    for(auto e:adj[u])&#123;        if(e.v==pre) continue;        if(dfn[e.v])&#123;            if(dfn[e.v]&lt;dfn[u]) continue;            lp[++len]=e.v;            for(;e.v!=u;e.v=fa[e.v]) lp[++len]=fa[e.v];	        &#125;else dfs(e.v,u);    &#125;&#125;void getzj(int u,int pre)&#123;    vis[u]=1;    for(auto e:adj[u])&#123;        if(e.v==pre||vis[e.v]) continue;        getzj(e.v,u);        anszj=max(anszj,1ll*d[u]+d[e.v]+e.w);        d[u]=max(d[u],d[e.v]+e.w);    &#125;&#125;ll solve(int rt)&#123;    ll ans1=0,ans2=0;    len=tot=0;    dfs(rt,0);    lp[0]=lp[len];    for(int i=1;i&lt;=len;i++)&#123;        vis[lp[i]]=1;    &#125;    for(int i=1;i&lt;=len;i++)&#123;        anszj=0;        getzj(lp[i],0);        ans1=max(ans1,anszj);    &#125;    if(len==2)&#123;// 特判小可爱        for(auto e:adj[lp[1]])&#123;            if(e.v==lp[2]) ans2=max(ans2,1ll*d[lp[1]]+d[lp[2]]+e.w);        &#125;        return max(ans1,ans2);    &#125;    for(int i=1;i&lt;=len;i++)&#123;        for(auto e:adj[lp[i]])&#123;            if(e.v==lp[i-1])&#123;// 考虑前缀和优化dis计算                s[i]=s[i-1]+e.w;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=len;i++)&#123;// 复制        s[len+i]=s[len]+s[i];    &#125;    ql=1,qr=0;    q[++qr]=0;    for(int i=1;i&lt;=len*2;i++)&#123;        while(ql&lt;=qr&amp;&amp;q[ql]&lt;=i-len) ql++;        ans2=max(ans2,d[lp[q[ql]%len]]+d[lp[i%len]]+s[i]-s[q[ql]]);        while(ql&lt;=qr&amp;&amp;s[q[qr]]-d[lp[q[qr]%len]]&gt;=s[i]-d[lp[i%len]]) qr--;        q[++qr]=i;    &#125;    return max(ans1,ans2);&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int v,w;        cin&gt;&gt;v&gt;&gt;w;        adj[i].push_back(&#123;v,w&#125;);        adj[v].push_back(&#123;i,w&#125;);    &#125;    ll ans=0;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i]) ans+=solve(i);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 2.2 基环树找环 洛谷P8655
无向图找环，可以作为试验场。记得排序后输出。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,dfn[MN],lp[MN],fa[MN],htot,tot;vector&lt;int&gt; adj[MN];template&lt;typename type&gt;inline void read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();    flag?x=-x:0;&#125;void dfs(int u,int pre)&#123;    dfn[u]=++tot;    fa[u]=pre;    for(auto v:adj[u])&#123;        if(v==pre) continue;        if(dfn[v])&#123;            if(dfn[v]&lt;dfn[u]) continue;            lp[++htot]=v;            for(;v!=u;v=fa[v]) lp[++htot]=fa[v];	        &#125;else dfs(v,u);    &#125;&#125;int main()&#123;    read(n);    for(int i=1;i&lt;=n;i++)&#123;        int u,v;        read(u);        read(v);        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs(1,0);    sort(lp+1,lp+1+htot);    for(int i=1;i&lt;=htot;i++) cout&lt;&lt;lp[i]&lt;&lt;&quot; &quot;;    return 0;&#125;
 2.3 无向基环树最大独立集  洛谷P2607
相互厌恶的骑士之间建无向边，但是没说联通，是基环树森林。
其实我们想跑没有上司的舞会，但是因为不是树不好做，我们用第一种方法，强制不选，另外一个随便。这样就可以分别统计了。
#include&lt;bits/stdc++.h&gt;#define ll long long#define pir pair&lt;int,int&gt;using namespace std;const int MN=1e6+15;struct circle&#123;    int u,v;&#125;;struct edge&#123;    int v,id;&#125;;int n,pre[MN];ll val[MN],f[MN][2];vector&lt;edge&gt; adj[MN];vector&lt;pir&gt; cir;int root(int x)&#123;    if(x==pre[x]) return x;    else return pre[x]=root(pre[x]);&#125;void init()&#123;    for(int i=1;i&lt;=n;i++)&#123;        pre[i]=i;    &#125;&#125;void dfs(int u,int fa)&#123;    f[u][0]=0;    f[u][1]=val[u];    for(auto e:adj[u])&#123;        int v=e.v,id=e.id;        if(v==fa) continue;        dfs(v,u);        f[u][1]+=f[v][0];        f[u][0]+=max(f[v][0],f[v][1]);    &#125;&#125;int main()&#123;    ios::sync_with_stdio(0);    cin&gt;&gt;n;    init();    for(int i=1;i&lt;=n;i++)&#123;        int v;        cin&gt;&gt;val[i]&gt;&gt;v;        int ri=root(i),rv=root(v);        if(ri==rv)&#123;            cir.push_back(pir(i,v));            continue;        &#125;else pre[rv]=ri;        adj[i].push_back(&#123;v,i&#125;);        adj[v].push_back(&#123;i,i&#125;);    &#125;    ll ans=0;    for(auto awa:cir)&#123;        dfs(awa.first,0);        ll ret=f[awa.first][0];        dfs(awa.second,0);        ans+=max(ret,f[awa.second][0]);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 2.4 有向基环树最大独立集改编——洛谷P10933
一个显然的想法就是 i→A[i]i\rightarrow A[i]i→A[i]连边，但是发现是内向基环树有一点难做，我们不妨反过来连边，这样就变成了上面提到的有向基环树。
考虑转移方程，定义和最大独立集差不太多，但是方程有细微的变化。
f[u][0]=∑v∈son(u)max⁡(f[v][0],f[v][1])f[u][0]=\sum\limits_{v\in son(u)}\max(f[v][0],f[v][1])
f[u][0]=v∈son(u)∑​max(f[v][0],f[v][1])
f[u][1]=1+∑v∈son(u)f[v][0]+∑v′∈son(u),v′≠vmax⁡(f[v′][0],f[v′][1])f[u][1]=1+\sum\limits_{v\in son(u)}f[v][0]+\sum\limits_{v&#x27; \in son(u),v&#x27;\neq v}\max(f[v&#x27;][0],f[v&#x27;][1])
f[u][1]=1+v∈son(u)∑​f[v][0]+v′∈son(u),v′=v∑​max(f[v′][0],f[v′][1])
第二个方程就是当前选了其他可以任意选择，因为题面说了只能限制一个。
但是O(n2)O(n^2)O(n2)我们不喜欢可以改变以下：
f[u][1]=1+f[u][0]−min⁡v∈son(u)(max⁡(f[v][0],f[v][1])−f[v][0])f[u][1]=1+f[u][0]-\min\limits_{v\in son(u)} ( \max(f[v][0],f[v][1])-f[v][0] ) 
f[u][1]=1+f[u][0]−v∈son(u)min​(max(f[v][0],f[v][1])−f[v][0])
当然这个和2.3一样我们也需要考虑，但这里我们是忽略了uuu可以限制vvv的条件，我们可以强制限制计算。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,fa[MN],f[MN][2];bool vis[MN];vector&lt;int&gt; adj[MN];int dodp(int u,int mode,int rt)&#123;    f[u][0]=f[u][1]=0;    vis[u]=1;    int minp=1e9;    for(auto v:adj[u])&#123;        if(v==rt) continue;        int ret=dodp(v,mode,rt);        minp=min(minp,ret-f[v][0]);        f[u][0]+=ret;    &#125;    f[u][1]=f[u][0]+1-(mode&amp;&amp;u==fa[rt]?0:minp);    return max(f[u][0],f[u][1]);&#125;int getlp(int u)&#123;    vis[u]=1;    if(vis[fa[u]]) return u;    else return getlp(fa[u]);&#125;int solve(int u)&#123;    int lp=getlp(u);    int ret1=dodp(lp,0,lp),ret2=dodp(lp,1,lp);    return max(ret1,f[lp][0]);&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;fa[i];        adj[fa[i]].push_back(i);    &#125;    int ans=0;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i]) ans+=solve(i);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 3. 总结
好了差不多就是这样，基环树的解法都离不开2个方法，好了请大家自行练手吧。byebye~
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束系统</title>
    <url>/posts/1149ba34/</url>
    <content><![CDATA[ 0. 前言
你需要知道：

SPFA
图论基础建模
不等式基础

 1. 负环
为什么先讲负环啦？是因为差分约束是要用负环的。
给定一张有向图（无向图看作两条等权边），每条边有权值。若一个边权值是负数，那么我们称这个边为负权边。
若图中存在一个环，如果环上的边有负权边，那么我们称这个为负环。

例如4,5,7构成负环，而5,8,1构成正环
我们可以用最短路算法来跑判断负环，什么你跟我说拓扑排序？如果一张图既有正环也有负环那判断不出来啊，拓扑只能判环不能判是哪个类型的。
但是不是所有都能用…



算法
适用条件
时间复杂度




Dijkstra
不可以，负边权会对之后结果造成影响不一定最小。
O(n2)→O(mlog⁡n)O(n^2)\rightarrow O(m \log n)O(n2)→O(mlogn)


Bellman-Ford
可以，无负环的时候最短路边数一定小于 nnn ，无负环的情况下走n−1n-1n−1 次后一定收敛。
O(nmO(nmO(nm)


SPFA
同Bellman-Ford
O(nm)→O(km)O(nm)\rightarrow O(km)O(nm)→O(km)



所以也就只能用SPFA了…
所以怎么判断？很简单，只需要开个桶，如果一个点走了不少于 nnn 次那么一定有负环。那么就可以了。
bool spfa()&#123; //1有负环 0无负环    queue&lt;int&gt; q;    while(!q.empty())&#123;        int u=q.front();        q.pop();        vis[u]=0;        for(auto e:adj[u])&#123;            if(dis[e.v]&lt;dis[u]+e.w)&#123;                dis[e.v]=dis[u]+e.w;                if(!vis[e.v])&#123;                    vis[e.v]=1;                    q.push(e.v);                    cnt[e.v]++;                    if(cnt[e.v]&gt;=n) return 1; // 不少于n次一定有                &#125;            &#125;        &#125;    &#125;    return 0;&#125;
你跟我说负边权图被卡SPFA了？可以考虑一下DAG跑。
 2.差分约束系统
差分约束系统是一种特殊的 NNN 元一次不等式组，有NNN 个变量与 MMM 个约束条件（其实就是不等式）。
所以为什么叫差分约束呢？是因为每一个不等式都是两个变量作差得到的：
{X2−X1≤C1X3−X2≤C2X4−X3≤C3\begin{cases}
 X_2-X_{1} \le C_{1} \\
X_3-X_{2}\le C_{2} \\
X_4-X_{3}\le C_{3} \\
\end{cases}
⎩⎪⎪⎨⎪⎪⎧​X2​−X1​≤C1​X3​−X2​≤C2​X4​−X3​≤C3​​
如上，都是作差得到的，所以叫差分约束了。
我们取第一个出来，我们变变形：
X2≤X1+C1X_2 \le X_{1}+C_{1}
X2​≤X1​+C1​
是不是有点像dis[e.v]&lt;dis[u]+e.w，及其相似。
我们怎么求解这些方程组呢？我们可以像上面的式子一样，我们就让后面的连前面的，例如下面的式子：
Xi−Xj≤CiX_i-X_{j}\le C_i
Xi​−Xj​≤Ci​
我们从Xj→XiX_j\rightarrow X_iXj​→Xi​ 连边，边权为CiC_iCi​。这样就可以了，但是这个有多组解（两边统一加上一个常数 ddd 不等式仍然成立），而且还有负数解，我们不喜欢负数解，但是我们可以加一个源点 X0X_0X0​，我们不妨令 X0=0X_0=0X0​=0 ，让后显然有 Xi−X0≤0X_i-X_{0}\le 0Xi​−X0​≤0 ，那么0→i0\rightarrow i0→i 连边权为 000 的边，这样就可以保证都是整数解了。
不妨设 dis[0]=0dis[0]=0dis[0]=0 ，让后以此为起点跑单源最短路，这样我们就能求出一组解了。如果有负环那么说明不等式不成立，那么就无解。
 2.1 大于等于推导
当然做题你会发现如下的式子：
Xi−Xj≥CiX_i-X_{j}\ge C_i
Xi​−Xj​≥Ci​
这个时候有两个方法，第一个两边都取负，不等式变号，就有Xj−Xi≤−CiX_j-X_{i}\le -C_iXj​−Xi​≤−Ci​，九二可以连边了；第二种方法就是改成跑单源最长路，如果有正环说明无解。
 2.2 等于式推导
还有如下的式子：
Xi=XjX_i=X_j
Xi​=Xj​
其实可以转化成：
Xi=Xj⇒{Xi−Xj≤0Xj−Xi≤0X_i=X_{j}\Rightarrow 
\begin{cases}
 X_i-X_{j}\le 0 \\
X_j-X_{i}\le 0
\end{cases}
Xi​=Xj​⇒{Xi​−Xj​≤0Xj​−Xi​≤0​
 2.3 分式推导
更有甚者：
XiXj≤Ci\frac{X_i}{X_{j}}\le C_i
Xj​Xi​​≤Ci​
这是差分约束吗？其实也可以变变形，回忆对数相减代表这什么，其实就可以转化为：
log⁡XiXj=log⁡aXi−log⁡aXj≤log⁡aCi\log\frac{X_i}{X_{j}}=\log_aX_i-\log_aX_{j}\le \log_{a}C_i
logXj​Xi​​=loga​Xi​−loga​Xj​≤loga​Ci​
做就可以了，这个 aaa 取大于0的实数即可，但是取2就可以了。
总结一下：



差分约束
转化后
连边(w为边权)




Xi−Xj≥ciX_i-X_j\ge c_iXi​−Xj​≥ci​
Xj−Xi≤−CiX_j-X_{i}\le -C_iXj​−Xi​≤−Ci​
i→j,wi=−Cii \rightarrow j,w_i=-C_ii→j,wi​=−Ci​


Xi−Xj≤CiX_i-X_{j}\le C_iXi​−Xj​≤Ci​
同前
j→i,wi=Cij \rightarrow i,w_i=C_ij→i,wi​=Ci​


Xi=XjX_i=X_jXi​=Xj​
Xi−Xj≤0,Xj−Xi≤0X_i-X_{j}\le 0,X_j-X_{i}\le 0Xi​−Xj​≤0,Xj​−Xi​≤0
i↔j,wi=0i \leftrightarrow j,w_i=0i↔j,wi​=0


XiXj≤Ci\frac{X_i}{X_{j}}\le C_iXj​Xi​​≤Ci​
logaXi−log⁡aXj≤log⁡aCilog_aX_i-\log_aX_{j}\le \log_{a}C_iloga​Xi​−loga​Xj​≤loga​Ci​
j→i,wi=log⁡aCij\rightarrow i,w_i=\log_a C_ij→i,wi​=loga​Ci​



让后跑spfa就可以了www。
 2.1 例题——Interval
例题：六倍经验——SP116 Interval

有 nnn 个区间，在区间 [ai,bi][a_i,b_i][ai​,bi​] 中至少取任意互不相同的 cic_ici​ 个整数。求在满足 nnn 个区间的情况下，至少要取多少个正整数。

做法1：差分约束
其实就是让我们选数，变量就是数的数量。
不难发现有x[bi]−x[ai−1]≥cix[b_i]-x[a_{i-1}]\ge c_ix[bi​]−x[ai−1​]≥ci​，但是为了保证我们的解有意义，我们还需要添加$ 1≥s[i]−s[i−1]≥01\ge s[i]-s[i-1] \ge 01≥s[i]−s[i−1]≥0，保证不能选负数个数，又不能多选出来。
但是0≤ai≤5×1040\le a_{i}\le 5\times 10^40≤ai​≤5×104，所以我们要从−1-1−1开始，很难受，其实也很简单，只需要都加上一即可让后从0开始即可了。
故代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e4+15,INF=1e9;struct Edge&#123;    int v,w;&#125;;int n,T,dis[MN];vector&lt;Edge&gt; adj[MN];bool vis[MN];void init()&#123;    for(int i=1;i&lt;=n;i++)&#123;        adj[i].clear();        dis[i]=-INF;        vis[i]=0;    &#125;&#125;void spfa()&#123;    queue&lt;int&gt; q;    q.push(0);    vis[0]=1;    dis[0]=0;    while(!q.empty())&#123;        int u=q.front();        q.pop();        vis[u]=0;        for(auto e:adj[u])&#123;            if(dis[e.v]&lt;dis[u]+e.w)&#123;                dis[e.v]=dis[u]+e.w;                if(!vis[e.v])&#123;                    q.push(e.v);                    vis[e.v]=1;                &#125;            &#125;        &#125;    &#125;&#125;void solve()&#123;    int maxp=-1;    cin&gt;&gt;n;    init();    for(int i=1;i&lt;=n;i++)&#123;        int a,b,c;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        adj[a].push_back(&#123;b+1,c&#125;);        maxp=max(maxp,b+1);    &#125;    for(int i=1;i&lt;=maxp;i++)&#123;        adj[i-1].push_back(&#123;i,0&#125;);        adj[i].push_back(&#123;i-1,-1&#125;);    &#125;    spfa();    cout&lt;&lt;dis[maxp]&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 2.2 强联通分量优化——洛谷P10935，3275

我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 111。
现在对于 NNN 颗我们关注的恒星，有 MMM 对亮度之间的相对关系已经判明。
你的任务就是求出这 NNN 颗恒星的亮度值总和至少有多大。
输入格式：
第一行给出两个整数 NNN 和 MMM。
之后 MMM 行，每行三个整数 T,A,BT, A, BT,A,B，表示一对恒星 (A,B)(A, B)(A,B) 之间的亮度关系。恒星的编号从 111 开始。
如果 T=1T = 1T=1，说明 AAA 和 BBB 亮度相等。
如果 T=2T = 2T=2，说明 AAA 的亮度小于 BBB 的亮度。
如果 T=3T = 3T=3，说明 AAA 的亮度不小于 BBB 的亮度。
如果 T=4T = 4T=4，说明 AAA 的亮度大于 BBB 的亮度。
如果 T=5T = 5T=5，说明 AAA 的亮度不大于 BBB 的亮度。
无解输出−1-1−1
1≤N≤105,1≤M≤1061\le N \le 10^5,1\le M \le 10^61≤N≤105,1≤M≤106

首先我们归类一下能直接看出来的式子，这里我们先都转成大于式子，不知道大于式子怎么差分约束的看2.1：
{XA−XB≥0,XB−XA≥0A=B?A&lt;BXA−XB≥0A≥B?A&gt;BXB−XA≥0A≤B\begin{cases}
X_A-X_B\ge0,X_B-X_{A} \ge 0 &amp; A=B \\
? &amp; A&lt;B \\
X_A-X_{B} \ge 0 &amp; A\ge B \\
? &amp; A&gt;B  \\
X_B-X_{A}\ge 0 &amp; A\le B
\end{cases}
⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​XA​−XB​≥0,XB​−XA​≥0?XA​−XB​≥0?XB​−XA​≥0​A=BA&lt;BA≥BA&gt;BA≤B​
我们解决一下小于和大于的情况：
XA−XB&lt;0XB−XA&gt;0∵XB,XA∈Z∴XB−XA∈Z∴XB−XA≥1\begin{aligned}
X_A-X_{B}&amp; &lt; 0 \\ 
X_B-X_{A}&amp; &gt; 0 \\
\because X_B,X_{A} &amp; \in \mathbb{Z} \\
\therefore X_B-X_{A} &amp; \in \mathbb{Z} \\
\therefore X_B-X_{A}&amp; \ge 1
\end{aligned}
XA​−XB​XB​−XA​∵XB​,XA​∴XB​−XA​∴XB​−XA​​&lt;0&gt;0∈Z∈Z≥1​
大于情况同理。
整理一下：
{XA−XB≥0,XB−XA≥0A=BXB−XA≥1A&lt;BXA−XB≥0A≥BXA−XB≥1A&gt;BXB−XA≥0A≤B\begin{cases}
X_A-X_B\ge0,X_B-X_{A} \ge 0 &amp; A=B \\
X_B-X_{A}\ge 1 &amp; A&lt;B \\
X_A-X_{B} \ge 0 &amp; A\ge B \\
X_A-X_{B}\ge 1 &amp; A&gt;B  \\
X_B-X_{A}\ge 0 &amp; A\le B
\end{cases}
⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​XA​−XB​≥0,XB​−XA​≥0XB​−XA​≥1XA​−XB​≥0XA​−XB​≥1XB​−XA​≥0​A=BA&lt;BA≥BA&gt;BA≤B​
让后我们就可以用SPFA跑，于是代码如下…？怎么N≤105N \le 10^5N≤105。
O(NM)O(NM)O(NM)炸掉了呜呜呜。怎么做？
观察原图，不难发现每个边的边权不是1就是0，我们判断无解怎么判断？那当然是找环，不难发现如果有环并且环上一旦有权为1的边就是无解（正环无解）。
但是怎么求有向图的环呢？而且复杂度还不能O(NM)O(NM)O(NM)…Tarjan大法好！强联通分量复杂度O(N+M)O(N+M)O(N+M)。
但是不对啊，还有有解的情况呢？怎么求，其实也好，如果有解那么一个强联通分量的答案一定是相同的（因为要求最小所以都填一样就行了），那么直接缩点，缩点完后就是一个DAG，跑拓扑排序单源最长路就可以了。
什么？你不会DAG的单源最长路？
dis[v]=max⁡v∈son(u)(dis[v],dis[u]+wedge)dis[v]=\max\limits_{v\in son(u)}(dis[v],dis[u]+w_{edge})
dis[v]=v∈son(u)max​(dis[v],dis[u]+wedge​)
这是递推公式，因为初始 XXX 最小为1，所以初始化入度为0的节点 dis[u]=0dis[u]=0dis[u]=0 ，答案怎么算？也很简单。
ans=∑i=1dcccnti×disians=\sum\limits_{i=1}^{dcc}cnt_{i} \times dis_i
ans=i=1∑dcc​cnti​×disi​
其中 dccdccdcc 是强联通分量的个数，cntcntcnt 是强联通分量节点个数。
所以代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;struct Edge&#123;    int v,w;&#125;;int n,m,tot,dcc,top,s[MN],color[MN],in[MN],low[MN],dfn[MN],f[MN];vector&lt;Edge&gt; adj[MN],adj2[MN];vector&lt;int&gt; vdcc[MN];bool vis[MN];void tarjan(int u)&#123;    low[u]=dfn[u]=++tot;    s[++top]=u;    vis[u]=1;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;else if(vis[v])&#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(low[u]==dfn[u])&#123;        dcc++;        int p;        do        &#123;            p=s[top--];            color[p]=dcc;            vdcc[dcc].push_back(p);            vis[p]=0;        &#125; while (p!=u);            &#125;&#125;void toposort()&#123;    queue&lt;int&gt; q;    for(int i=1;i&lt;=dcc;i++)&#123;        if(!in[i])&#123;            q.push(i);            f[i]=1;        &#125;    &#125;    while(!q.empty())&#123;        int u=q.front();        q.pop();        for(auto e:adj2[u])&#123;            in[e.v]--;            f[e.v]=max(f[e.v],f[u]+e.w);            if(!in[e.v]) q.push(e.v);        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int mode,u,v;        cin&gt;&gt;mode&gt;&gt;u&gt;&gt;v;        if(mode==1)&#123;            adj[v].push_back(&#123;u,0&#125;);            adj[u].push_back(&#123;v,0&#125;);            //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; 0\n&quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; 0\n&quot;;        &#125;        if(mode==2)&#123;            adj[u].push_back(&#123;v,1&#125;);            //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; 1\n&quot;;        &#125;        if(mode==3)&#123;            adj[v].push_back(&#123;u,0&#125;);            // cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; 0\n&quot;;        &#125;        if(mode==4)&#123;            adj[v].push_back(&#123;u,1&#125;);            // cout&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; 1\n&quot;;        &#125;        if(mode==5)&#123;            adj[u].push_back(&#123;v,0&#125;);            // cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; 0\n&quot;;        &#125;    &#125;    //for(int i=1;i&lt;=n;i++) adj[0].push_back(&#123;i,1&#125;);    for(int i=1;i&lt;=n;i++)&#123;        if(!dfn[i]) tarjan(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(auto e:adj[i])&#123;            if(color[i]!=color[e.v])&#123;                adj2[color[i]].push_back(&#123;color[e.v],e.w&#125;);                in[color[e.v]]++;            &#125;            if(color[i]==color[e.v]&amp;&amp;e.w==1)&#123;                cout&lt;&lt;-1;                return 0;            &#125;        &#125;    &#125;    toposort();    int ans=0;    for(int i=1;i&lt;=dcc;i++)&#123;        ans+=f[i]*vdcc[i].size();    &#125;    cout&lt;&lt;ans;    return 0;&#125;
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>广义圆方树</title>
    <url>/posts/23139b1/</url>
    <content><![CDATA[ 0. 前言
我们主要讨论的就是广义的圆方树。
 1. 介绍
广义圆方树是刻画图上点连通性的工具，是 Tarjan 算法的一个强有力拓展。广义圆方树能够述原图任意两点之间的所有割点，即路径 u→vu\to vu→v 上所有必须经过的点。下面有一张图来举例：

图的问题我们不好处理，但是众所周知，树上问题是比普通的图论问题处理起来方便得多的。所以我们将图转化为圆方树的意义就是在于通过树上的算法简化问题。
广义圆方树中的节点分为两类：圆点和方点，在上图中所表示出来。圆点就是原本图上的点，而每个方点都代表了一个点双联通分量。将每个方点和所有在这个联通分量中的点连起来。
注意，只有原图联通的时候才能是一棵树，如果不连通的话那么会形成森林。
我们在求解点双的时候可以顺便建出圆方树，以下为代码，adjadjadj 为原图，GGG 为圆方树。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,m;vector&lt;int&gt; adj[MN],G[MN];namespace YFTree&#123;    int dfn[MN],low[MN],s[MN],top,dtot,ftot;    void init()&#123;        ftot=n;    &#125;    void tarjan(int u)&#123;        cerr&lt;&lt;&quot;ENTER: &quot;&lt;&lt;u&lt;&lt;&#x27;\n&#x27;;        low[u]=dfn[u]=++dtot;        s[++top]=u;        for(auto v:adj[u])&#123;            if(!dfn[v])&#123;                tarjan(v);                low[u]=min(low[u],low[v]);                if(low[v]==dfn[u])&#123;                    ++ftot;                    cerr&lt;&lt;&quot;FOUND NEW BCC &quot;&lt;&lt;ftot-n&lt;&lt;&#x27;\n&#x27;;                    int p;                    while(p!=v)&#123;                        p=s[top--];                        G[ftot].push_back(p);                        G[p].push_back(ftot);                        cerr&lt;&lt;ftot&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&#x27;\n&#x27;;                    &#125;                    G[ftot].push_back(u);                    G[u].push_back(ftot);                    cerr&lt;&lt;ftot&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&#x27;\n&#x27;;                &#125;            &#125;else low[u]=min(low[u],dfn[v]);        &#125;    &#125;&#125;using namespace YFTree;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    init();    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(!dfn[i]) tarjan(i),--top;    &#125;    return 0;&#125;
 2. 例题
在说明例题之前，完全有必要说明一个结论：

若在圆方树上 zzz 是 x,yx,yx,y 的必经点，则原图 zzz 是 x,yx,yx,y 的必经点，且为割点。

 P4630
考虑两圆点在圆方树上的简单路径，与路径上经过的方点相邻的圆点的集合，即为原图此简单路径上的点集。
对于题目中三元组 (s,c,f)(s,c,f)(s,c,f)，考虑固定 s,fs,fs,f，求 ccc 的数量。答案就是 s,fs,fs,f 之间简单路径并集的数量减去 2。
我们考虑如何用圆方树实习这一过程，这里有一个圆方树的 Trick：在路径统计时，给点附上合适的点权。
本题中，我们方点赋权为点双大小，而圆点赋值为 -1，这样问题转化为了统计圆方树上两圆点之间简单路径权值和，时间复杂度是 O(n2log⁡n)O(n^2 \log n)O(n2logn) 的，无法通过，考虑优化。我们考虑把贡献分摊到每个点上，每个点对答案的贡献就是通过他的路径条数乘上它的权值，而路径条数围为： (所有以此点为根的树中每两个子树中圆点个数相乘再相加，再加上每个子树中圆点个数与不属于这个点的树的圆点个数相乘) ×2\times 2×2。
也可以用换根 DP 解决，时间复杂度都是 O(n+m)O(n+m)O(n+m)。
 P4606 战略游戏
扣掉这个节点后 uuu 不能到达 vvv，说明该点为 u→vu\to vu→v 路径上的一个必经点，转化一下题意就是割点。考虑建广义圆方树，那么原题转化为求点集 SSS 的虚树上不包含属于 SSS 的圆点数量。每次统计虚树上的点数即可，复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
如果你不想建虚树，不妨考虑做树上距离前缀和即可。
 P4334
考虑建广义圆方树。

第二问：即判断圆方树两点路径上是否存在点 ccc，可以用树剖解决。

具体的，我们在树刨求 LCA⁡(x,y)\operatorname{LCA}(x,y)LCA(x,y) 的时候，跳深度大的点 xxx 的时候，若 ccc 和当前要跳的点 xxx 在一条链上并且深度比 xxx 小，那么存在。否则一直判断，直到 x,yx,yx,y 在同一链上的时候（仍令 depx&lt;depydep_x &lt; dep_ydepx​&lt;depy​），判断 x,yx,yx,y 和 ccc 是否在一条链上并且 depc∈[depx,depY]dep_c \in [dep_x,dep_Y]depc​∈[depx​,depY​] 即可。


第一问：首先判断 G1→G2G_1 \to G_2G1​→G2​ 是否为割边（对应到圆方树就是点双大小为 2），若是，则判断其对应的方点是否在路径上，问题转化为第二问。

时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
 P3225 矿场搭建
以下 nnn 为图的点数。
并非板子，考虑题目希望我们给出一种选择关键点的方式，满足删去任何一个点后形成的每个连通块内都存在至少一个关键点。
非割点是没有营养的，割点是十分有的，那么命题等价为删掉任意一个割点之后连通块存在关键点。
考虑最好情况，整个图是点双连通分量，那么答案就是 (n2)\dbinom{n}{2}(2n​)。
考虑不是，那么注意到是和割点有关的信息，考虑建出广义圆方树。让后我们要对这个圆方树进行一些小操作，即把所有叶子都给删掉，即原图的非割点，我们得到了广义圆方树的由原图割点和点双方点构成的树。
我们在这颗树上搞事情，那么命题相当于在上面任意删掉一个圆点，连通块存在关键点。有一个方案就是将这颗树的叶子（即叶子方点）放一个关键点，证明这个方案是最少的。反证法可以证明。
那么令叶子对应点双大小为 s1,s2,…,sks_1,s_2,\dots,s_ks1​,s2​,…,sk​，那么若第一问答案为 kkk，第二问的答案就是 ∏i=1k(si−1)\prod_{i=1}^k (s_i -1)∏i=1k​(si​−1)。
 CF487E
点赋权与树分治 Trick 应用。
ccc 在 a→ba\to ba→b 的简单路径上当且仅当 ccc 和 a→ba\to ba→b 某个方点相邻，令方点的权值为对应点双所有节点对应权值最小值，将圆方树树剖求路径最小值即可回答询问。
但是有修改哎，怎么办，修改点权时可能影响到很多方点权值，无法承受。我们可以考虑类似于树分治的思想，只维护儿子的信息，我们将方点维护一个 multiset，里面存所有与之相邻的圆点权值，然后权值就是 multiset 中的最小值，修改圆点权值时修改其父节点的 multiset 并更新其父节点权值。
同理求点权最小值即可，时间复杂度 O(((n+q)log⁡n)log⁡n)O(((n+q)\log n)\log n)O(((n+q)logn)logn)。
 P8456
好题，但是做这个题的时候脑子特别困，浪费了这个题了呜呜呜。
先建出圆方树，那么原命题可以分类讨论成两种情况：在一个点双和不在一个点双。

在一个点双：如何点双里面所有颜色都相同那么就完蛋了。如果两种颜色都有的话，你可能和我一样点双内部点都合法，但是分析一下发现不是这样。例如一个二元环，但有 d 和 D 的边，就炸杠了。考虑这个反例会对答案如何贡献，发现这个反例有且仅有一个，也就是说如果一个点双里有且只有两个点满足其既有 D 也有 d 的出边，那么其对答案的贡献就是 (siz2)−1\dbinom{siz}{2}-1(2siz​)−1，否则贡献的就是 (siz2)\dbinom{siz}{2}(2siz​)。
不在一个点双：我们把点双分类：全 d 点双，全 D 点双，混合点双。论是如果两点在圆方树上的路径上全是黑点双，或者全是白点双的时候才不合法。证明见 Alex_weiのSolution

实现上我们容斥，不合法的首先有形如同色点双构成的极大同色连通块，可以通过圆方树上 dp 求解贡献，再对每个非同色点双看看是否要减去一对 u,v 的贡献即可。
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>序理论与dilworth定理</title>
    <url>/posts/87bd8cf4/</url>
    <content><![CDATA[ 0. 引入
你需要的前置：

一颗清醒的大脑（因为这是抽象的东西）
概念基础辨析
集合（高一数学必修一）

 1. 序理论
 1.1 定义与二元关系

序理论是研究捕获数学排序的直觉概念的各种二元关系的数学分支。——百度百科

数学排序？这个我会啊，不就是排序吗…？
其实这里并不指的是单独的排序。
既然有不同的点，那么特殊在哪里？
先来一个小定义：

笛卡尔积：设 X,YX,YX,Y 两个集合，那么存在一个集合，它的元素是用 XXX 中元素为第一元素，YYY 中元素为第二元素组成的有序二元组，称它为集合X,YX,YX,Y的笛卡尔积集，记为 X×YX\times YX×Y。
X×Y={(a,b)∣a∈X,b∈Y}X\times Y=\left\{ (a,b)|a\in X,b\in Y \right\}X×Y={(a,b)∣a∈X,b∈Y}

怎么理解？类比一下C++中的pair容器吗。
例如 X={1,2},Y={a,b,c}X=\left\{ 1,2 \right\},Y=\left\{ a,b,c \right\}X={1,2},Y={a,b,c}，那么有X×Y={(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)}X\times Y=\left\{ (1,a),(1,b),(1,c),(2,a),(2,b),(2,c) \right\}X×Y={(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)}。
接下来是正式的定义：

二元关系：集合 XXX 与集合 YYY 上的二元关系是R=(X,Y,G(R))R=(X,Y,G(R))R=(X,Y,G(R))，其中G(R)G(R)G(R)，称为R的图称为R的图称为R的图，是笛卡尔积 X×YX×YX×Y 的子集。若 (x,y)∈G(R)(x,y) \in G(R)(x,y)∈G(R) ，则称 xxx 是 RRR 关系于 yyy ，并记作xRyx R yxRy或R(x,y)R(x,y)R(x,y)。否则称 xxx 与 yyy 无关系 RRR。但经常地我们把关系与其图等同起来，即：若R⊆X×YR⊆X×YR⊆X×Y，则 RRR 是一个关系。

什么？看不懂？没关系我也看不懂www。举个例子吧，例如在 N+\mathbb{N}_{+}N+​ 自然数集合上的小于等于关系就是一个二元关系，例如对于R⇒≤R \Rightarrow \leR⇒≤，对于 2,32,32,3 来说是有关系，而对于3,23,23,2 来说不行，因为 3≤23\le 23≤2 不满足，所以称他们无关系。
到现在应该有一点模糊的理解了吧，那么对于那个图 GGG 怎么说呢？我理解的就是满足 RRR 关系的集合（事实也是这样的，并且这个集合还是类似于一个pair），比如说上面的 (2,3)(2,3)(2,3) 他就属于 G(R)G(R)G(R)，而 (3,2)(3,2)(3,2) 不属于因为它不满足我们上面提到的 “ RRR ” 关系。
 1.2 二元关系的性质
一般来说我们研究关系会研究有没有一些特殊性质。我们对于集合 SSS 上的二元关系 RRR （就是 R⊆S×SR⊆S\times SR⊆S×S）定义以下性质：

自反性：(∀a∈S),(a,a)∈R(\forall a\in S),(a,a)\in R(∀a∈S),(a,a)∈R，例如a≤a,(a∈N+)a\le a,(a\in \mathbb{N}_{+})a≤a,(a∈N+​)。
反自反性：(a,a)∉R,(∀a∈S)(a,a) \notin R,(\forall a \in S)(a,a)∈/R,(∀a∈S) ，例如a&lt;a,(a∈N+)a&lt;a,(a\in \mathbb{N}_+)a&lt;a,(a∈N+​)就不成立。
对称性：(a,b)∈R⇔(b,a)∈R,(a,b∈S)(a,b)\in R \Leftrightarrow (b,a) \in R,(a,b \in S)(a,b)∈R⇔(b,a)∈R,(a,b∈S)，等于关系。
反对称性：(a,b),(b,a)∈R,(a,b∈S)⇒a=b(a,b),(b,a) \in R,(a,b \in S) \Rightarrow a=b(a,b),(b,a)∈R,(a,b∈S)⇒a=b
传递性：(a,b)∈R,(b,c)∈R⇒(a,c)∈R,(a,b,c∈S)(a,b)\in R,(b,c) \in R \Rightarrow (a,c) \in R,(a,b,c \in S)(a,b)∈R,(b,c)∈R⇒(a,c)∈R,(a,b,c∈S)，例如小于等于。

 1.3 偏序关系，偏序集与哈斯图

对于二元关系 R⊆X×XR\subseteq X\times XR⊆X×X，如果 RRR 有自反性，反对称性，传递性，那么 RRR 就是偏序关系。

而偏序集就是 集合 SSS 与 SSS 上的偏序关系 RRR 构成的，记为 (S,R)(S,R)(S,R)。
例如SSS 中的元素x,yx,yx,y ，若(x,y)(x,y)(x,y) 或 (y,x)(y,x)(y,x) 在 RRR 关系下成立，那么我们称 x,yx,yx,y 可比，反之则不可比。
但是太抽象了，我们需要一个更清晰明了的图。

覆盖元素：对于元素 xxx，如果 x&lt;yx&lt;yx&lt;y 不存在 zzz 使得有 x&lt;z&lt;yx&lt;z&lt;yx&lt;z&lt;y 那么我们称 yyy 就是 xxx 的覆盖元素（注意这里的小于号其实是一种关系，不是真的小于！），在哈斯图中连出 x→yx\rightarrow yx→y 的有向边，这种关系生成的图叫做哈斯图。

借用Tofu大佬的图：
例如集合 {1,2,3,4,6,7，8，9}\left\{ 1,2,3,4,6,7，8，9 \right\}{1,2,3,4,6,7，8，9} 上的关系 {(a,b)∣a整除b}\left\{ (a,b)|a\text{整除}b \right\}{(a,b)∣a整除b}。左侧图即为：

实际中我们不标注方向，所以一般来说我们将较大的元放在上面，隐式的表达有向。
不难发现这其实是一个DAG(有向无环图)。
对于右面那个图是另外一个东西，我们设定的关系是“属于关系”，可以自己对比以下。
 2. Dilworth定理
 2.1 定义
我们这里阐述以下链和反链的定义：

设 CCC 是偏序集的一个子集，如果 CCC 中元素互相可比，那么称 CCC 是链。反之互相不可比，那么就是反链。

例如oiwiki的图：下面的关系还是我们的属于关系：

例如 {∅,{1},{1,2}}\left\{ \varnothing_,\left\{ 1\right\},\left\{ 1,2\right\} \right\}{∅,​{1},{1,2}}，就是一条链，而{{1},{0,2}}\left\{ \left\{ 1\right\},\left\{ 0,2\right\} \right\}{{1},{0,2}} 就是反链。不难发现这里最长反链长度就是3，我们称最长反链长度为 偏序集 SSS 的宽度。
那么diliworth定理呢？

对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。此定理的对偶形式亦真。

例如下面的整除关系图（tofu大佬orz）：

不难发现最长反链只能是2，而刚好只需要2条链就能覆盖。
证明？自行了解www。
 2.2 例题
P1020——导弹拦截
想当年我做这个题的时候我还根本就不知道DilWorth定理是什么。感慨万千
设高度序列为 P={x1,x2,...,xn}P=\left\{ x_1,x_2,...,x_n \right\}P={x1​,x2​,...,xn​}，集合 S={(i,xi)∣i∈N且1≤i≤N}S=\left\{ (i,x_{i)}| i\in N \text{且} 1\le i\le N \right\}S={(i,xi)​∣i∈N且1≤i≤N}。
那么偏序关系为 R={((i,xi),(j,pj))∣i≤j,xi≥xj}R=\left\{ ((i,x_i),(j,p_{j))}| i\le j,x_{i}\ge x_j \right\}R={((i,xi​),(j,pj))​∣i≤j,xi​≥xj​}。
这时候 (S,R)(S,R)(S,R) 构成一个偏序集，具体含义就是 i≤j,xi≥xji\le j,x_{i}\ge x_ji≤j,xi​≥xj​ 那么就说明拦截了第 iii 个导弹后还可以拦截 第 jjj 个导弹。
对于第一问，就是求最长链的长度，对于第二问，最少拦截系统个数？
最少系统个数其实就是要求每一个系统所管束的链最长，这不就是求最小链覆盖吗。
 2.3 DAG，二分图转化
dilworth的理解另一个形式，链覆盖与二分图匹配的对应关系。
在一个二分图匹配中，非匹配点一定是链的起点，所以链覆盖集的个数就是非匹配节点的个数，而匹配越大，非匹配点越少。那么就有一个及其强有力的结论：
∣链覆盖集∣=∣V∣−∣最大匹配∣|\text{链覆盖集}|=|V|-|\text{最大匹配}|
∣链覆盖集∣=∣V∣−∣最大匹配∣
那怎么用？我们拿一个我想不出来的例题来说：
P12148 【MX-X11-T2】「蓬莱人形 Round 1」所以我放弃了音乐
我们看图，我们把能够访问到的棋子之间从上往下连有向边：

我们对于任意一行，都只能往下取连边不能往左往右连边。
“对于任意……都有唯一……” 这是一个很好的性质，我们可以将它抽象成二分图，这是因为二分图匹配后的每一个匹配点都有唯一一个点与之匹配。
但是我们观察这个，我们变变形：

很像二分图，但其实是k-分图，但是我们可以转成二分图的样式，我们看看题目求什么，要求最小的操作次数…这不就是最小链覆盖吗。
于是就做完了，时间复杂度 O(n)O(n)O(n)。实现带log⁡\loglog。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=2e6+15;struct Node&#123;    int x,y;&#125;nd[MN];int n,maxx;map&lt;pir,int&gt; um;map&lt;pir,bool&gt; vis;set&lt;int,greater&lt;int&gt;&gt; s[MN];signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;nd[i].x&gt;&gt;nd[i].y;        um[pir(nd[i].x,nd[i].y)]=i;        s[nd[i].x].insert(nd[i].y);        maxx=max(maxx,nd[i].x);    &#125;    int ans=n;    for(int i=1;i&lt;maxx;i++)&#123;        for(auto p:s[i])&#123;            if(um[pir(i+1,p+1)]&amp;&amp;!vis[pir(i+1,p+1)])&#123;                ans--;                vis[pir(i+1,p+1)]=1;            &#125;            else if(um[pir(i+1,p)]&amp;&amp;!vis[pir(i+1,p)])&#123;                ans--;                vis[pir(i+1,p)]=1;            &#125;            else if(um[pir(i+1,p-1)]&amp;&amp;!vis[pir(i+1,p-1)])&#123;                ans--;                vis[pir(i+1,p-1)]=1;            &#125;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
回头过来思考这个题，其实这个DAG已经说明满足偏序关系了，关系就是 u→vu\rightarrow vu→v谁否能够到达。而我们就是要在这个关系上求解最小链覆盖。
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>换根DP</title>
    <url>/posts/4286fd48/</url>
    <content><![CDATA[ 换根DP
树形 DP 中的换根 DP 问题又被称为二次扫描，通常不会指定根结点，并且根结点的变化会对一些值，例如子结点深度和、点权和等产生影响。
他相比于相比与一般的树形dp拥有以下特点

以树上不同点作为根，他的解不同
求解答案，不能单求解某点的信息，需要求解每个节点的信息。
无法用一次搜索完成答案求解。

难度不算太高
 1.例题引入
  P3478 [POI 2008] STA-Station

给定一个 nnn 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。
一个结点的深度之定义为该节点到根的简单路径上边的数量。

我们先假设某个节点为根（例如1为根），将无根树转换为有根树，再通过一次DFS搜索出以该节点的深度和，时间复杂度O(n)O(n)O(n)
但问题是我们无法确定以该点为根时一定能得到最优解，如果可以的话可以拿样例推推，可以显然发现以任意点为根无法确定是最优解（例如从1开始）

没错这个树长得很奇怪。
我们可以在第二次搜索时完成对答案的统计。

我们假设第一次搜索我们从1号节点出发，通过一次搜索我们就可以获得所有节点子树的大小与节点深度，代码如下：

void dfs1(int u,int fa)&#123;    siz[u]=1;    dep[u]=dep[fa]+1;    for(auto v:adj[u])&#123;        if(fa!=v)&#123;            dfs1(v,u);            siz[u]+=siz[v];        &#125;    &#125;&#125;


第二次搜索依旧从1号节点开始，若1号节点与节点x联通，我们考虑能不能从1号节点的答案推出节点x的答案，如下图



假设这时候我们将根节点换为xxx节点，那么该节点子树就会分成两部分。一部分是原来的子树，一部分是1号节点的其他子树

根从1号节点变为xxx节点的时候，我们发现xxx原来的子树的深度都降低了1，而111号节点的深度增加1。



递推公式即可得:ans[v]=ans[u]−siz[v]+(siz[1]−siz[v])ans[v]=ans[u]-siz[v]+(siz[1]-siz[v])ans[v]=ans[u]−siz[v]+(siz[1]−siz[v])
不了解？我们一个一个来解释
首先我们要求解的是深度和，我们由uuu推的vvv的答案，那么我们首先需要以uuu作为根节点的答案。
减去siz[v]siz[v]siz[v]是因为对于vvv节点的原子树，我们对其在处理深度时应当全部减1，故减去siz[v]siz[v]siz[v]（根节点自己也算，他的深度减去就是0）
siz[1]siz[1]siz[1]表示这个图所有的点数，减去siz[v]siz[v]siz[v]就是除原子树外与vvv节点链接的其他子树，可以相当于上图的橙色链。
化简即得ans[v]=ans[u]+siz[1]−2×siz[v]ans[v]=ans[u]+siz[1]-2\times siz[v]ans[v]=ans[u]+siz[1]−2×siz[v]
故代码如下
#include&lt;iostream&gt;#include&lt;vector&gt;#define ull long longusing namespace std;const int MN=1e6+15;vector&lt;int&gt; adj[MN];ull n,ans[MN],siz[MN],dep[MN];void dfs1(int u,int fa)&#123;    siz[u]=1;    dep[u]=dep[fa]+1;    for(auto v:adj[u])&#123;        if(fa!=v)&#123;            dfs1(v,u);            siz[u]+=siz[v];        &#125;    &#125;&#125;void dfs2(int u,int fa)&#123;    for(auto v:adj[u])&#123;        if(fa!=v)&#123;            ans[v]=ans[u]+siz[1]-2*siz[v];            dfs2(v,u);        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs1(1,0);    for(int i=1;i&lt;=n;i++)&#123;        ans[1]+=dep[i];    &#125;    dfs2(1,0);    ull maxx=-1e13,p;    for(int i=1;i&lt;=n;i++)&#123;        if(ans[i]&gt;maxx)&#123;            maxx=ans[i];            p=i;        &#125;    &#125;    cout&lt;&lt;p;    return 0;&#125;
 2.例题引入的总结
我们看出换根dp的套路

指定某个节点为根节点
第一次搜索完成预处理，处理出子树大小等信息，同时得到该节点的解
第二次搜索进行换根的DP，用已知解的信息推出未知解的答案

 3.例题1——P2986 [USACO10MAR] Great Cow Gathering G

每个奶牛居住在 NNN 个农场中的一个，这些农场由 N−1N-1N−1 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 iii 连接农场 AiA_iAi​ 和 BiB_iBi​，长度为 LiL_iLi​。集会可以在 NNN 个农场中的任意一个举行。另外，每个牛棚中居住着 CiC_iCi​ 只奶牛。
在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 XXX 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 iii 到达农场 XXX 的距离是 202020，那么总路程就是 Ci×20C_i\times 20Ci​×20）。帮助 Bessie 找出最方便的地点来举行大集会。

这个题我们需要维护一个disdisdis变量表示从其他节点走到当前节点的距离，这个变量我们只需要在第一次搜索时使用即可。这个变量是为了统计出其他子树的奶牛到当前节点的距离。
我们考虑递推公式，我们发现在换根的时候会有相应的边权加减，例如下图

故显然得到递推方程
ans[v]=ans[u]+(1−2×siz[v])∗Edge（u,v）ans[v]=ans[u]+(1-2\times siz[v])*Edge_{（u,v）}ans[v]=ans[u]+(1−2×siz[v])∗Edge（u,v）​
也就是说要乘上边权
故有代码：
struct edge&#123;    int v,w;&#125;;ll n,siz[MN],dis[MN],c[MN],ans[MN],minn=1e16;vector&lt;edge&gt; adj[MN];void dfs1(int u,int fa)&#123;    siz[u]=c[u];    for(auto v:adj[u])&#123;        if(v.v!=fa)&#123;            dfs1(v.v,u);            siz[u]+=siz[v.v];            dis[u]+=dis[v.v]+siz[v.v]*v.w;        &#125;    &#125;&#125;void dfs2(int u,int fa)&#123;    for(auto v:adj[u])&#123;        if(v.v!=fa)&#123;            ans[v.v]=ans[u]+(siz[1]-2*siz[v.v])*v.w;            dfs2(v.v,u);        &#125;    &#125;&#125;
初始化ans[1]=dis[1]ans[1]=dis[1]ans[1]=dis[1]
 4.例题2——CF1324F

给定一棵 nnn 个节点无根树，每个节点 uuu 有一个颜色 aua_uau​，若 aua_uau​ 为 000 则 uuu 是黑点，若 aua_uau​ 为 111 则 uuu 是白点。
对于每个节点 uuu，选出一个包含 uuu 的连通子图，设子图中白点个数为 cnt1cnt_1cnt1​，黑点个数为 cnt2cnt_2cnt2​，请最大化 cnt1−cnt2cnt_1 - cnt_2cnt1​−cnt2​。并输出这个值。
1≤n≤2×1051 \leq n \leq 2 \times 10^51≤n≤2×105，0≤au≤10 \leq a_u \leq 10≤au​≤1。

要求最大化cnt1−cnt2cnt_1-cnt_2cnt1​−cnt2​，不妨设白点带来的权值是+1+1+1，黑点带来的权值是−1-1−1。
对于这道题而言，我们任意选取节点作为根，所得到的答案也各不相同。
故设状态f[u]f[u]f[u]表示以u为根节点，走uuu子树能得到的最大值，故初始值我们就设f[u]=color[u]f[u]=color[u]f[u]=color[u]，color就是上面颜色所带来的权值，这里我们先设根节点为1，故第一次dfs我们能得到f[1]f[1]f[1]的答案，但是对于其他节点来时f[v]f[v]f[v]并不是以u为根节点，而是只走其子树的答案。不理解看下图：

但是我们维护的是最大值，也就是说我们尽量不加答案为负的子树的答案，也就是我们需要判断以下，看代码。
void dfs1(int u,int fa)&#123;    f[u]=c[u] ? 1 : -1;    for(auto v:adj[u])&#123;        if(fa==v) continue;        dfs1(v,u);        f[u]+=max(f[v],0);    &#125;&#125;
我们开始考虑转移，我们开始考虑每个子树对于根节点的贡献，我们发现在第一次dfs如果权值为正那么子树答案是必定算上的。故如果当前节点的f[v]f[v]f[v]为正的话那么f[u]f[u]f[u]应当减去当前节点的贡献。
计算完毕后我们开始考虑以当前点为根，还是和第一次dfs转移一样，尽量不加答案为负子树的答案，这点同样适用于f[v]f[v]f[v]从f[u]f[u]f[u]转移过来。


故代码如下：
void dfs2(int u,int fa)&#123;    for(auto v:adj[u])&#123;        if(fa==v) continue;        int fu=f[u],fv=f[v];        if(fv&gt;0)&#123;            fu-=fv;        &#125;        if(fu&gt;0)&#123;            fv+=fu;        &#125;        f[v]=ans[v]=fv;        dfs2(v,u);    &#125;&#125;

参考：【朝夕的ACM笔记】动态规划-换根DP
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/posts/a3781d1f/</url>
    <content><![CDATA[ 0.引入的引入
数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。
而数位DP，就是解决在区间[L,R][L,R][L,R]这个范围内，求满足某种约束的数字的数量或总和或乘积或平方这一类问题。
两种写法，一种是记忆化搜索，一种是迭代写法。这里是记忆化搜索，优点是好写好维护。
 1.由例题引入数位DP
数位DP有一个通用的技巧，就是利用前缀和的思想，先求出[1,R][1,R][1,R]区间的满足约束的数字答案，再处理[1,L−1][1,L-1][1,L−1]的满足约束的数字答案，这样Ans[R]−Ans[L−1]Ans[R]-Ans[L-1]Ans[R]−Ans[L−1]所求得的区间就是[L,R][L,R][L,R]区间的答案。
所以我们要求解的内容就变为了求[0/1,x][0/1,x][0/1,x]这一区间满足限定的答案，其实0/1表示可以区间取0或1作为开始
在代码中表现为

a[1...len]a[1...len]a[1...len]表示将数分解成R进制（一般为10进制或者2进制），用数组存储，表示数字分解为R进制下的第aia_iai​位，或者也可以说是系数
最高位为a[len]a[len]a[len]，最低位为a[1]a[1]a[1]。
例如我们将1145转化为10进制下的数位

pos:1 2 3 4a:  1 1 4 5
代码写起来是这样的
ll solve(ll x)&#123;    int len=0;    while (x&gt;0)    &#123;        a[++len]=x%10;        x/=10;    &#125;    return dfs(...)&#125;
填数的话我们从高位往低位去填
例题：[洛谷P4999]

求解区间[L,R][L,R][L,R]中所有数的数位和之和
数位和就是把一个数所有数位上的数字加起来，例如1145-&gt;1+1+4+5=11

既然是记忆化搜索，我们一层一层搜索，我们先来定义一些状态能够跑起来再说。

pospospos：整形变量，表示当前枚举的位置，一般从高位到低位

我们假设x=2048x=2048x=2048，用？表示仍未填写的位数,目前一位都没有填，所以是???
我们从高位往低位取填，第一步填写最高位，很显然我们只能填[0,2][0,2][0,2]的数

若填写[0,1][0,1][0,1]的数，则我们可以从[0,1999][0,1999][0,1999]都可以取到
若填写222，则我们只能从[2000,2048][2000,2048][2000,2048]，我们发现对于一般情况，可以做到[1,9][1,9][1,9]随便填写，但是这里因为有着上界的限制，2???后面的三位只能最高填到048，所以我们需要记录一个变量limitlimitlimit来表示当前数位是否可以任意填写



limitlimitlimit：布尔变量，表示当前的第pos位是否收到取值限制

当为True表示取的数不能大于当前的数位，为true时表示[pos+1,R][pos+1,R][pos+1,R]取的都是aia_iai​的限制，



当我们搜索到pos=0pos=0pos=0的时候表示所有数位填写完毕，这是一个递归边界，我们需要返回枚举的结果，在传递结果的时候我们需要一个变量进行存储

sumsumsum: 整形变量，表示[pos+1,len][pos+1,len][pos+1,len]填写完毕所获得的结果答案，这个题表示的是数位和

以上是最普通的暴搜，但是鉴于我们有着101810^{18}1018的上界，所以我们需要暴力枚举。
我们观察枚举的数位，我们发现如下案例
03?? 12?? 30?? 21??
我们发现其实他们的结果都是一样的！因为对于后面未填写的结果，只要没有上界的限制，都会取到[0,99][0,99][0,99]，因为我们关注的是数位和，所以只需要前面数字数位和一样，并且没有限制(limit=falselimit=falselimit=false)就可以记录答案！
设状态f[pos][sum]f[pos][sum]f[pos][sum]

位置[pos+1,len][pos+1,len][pos+1,len]已经填写完毕，在没有最高数位限制的情况下，我对于[1,pos][1,pos][1,pos]进行任意填写，满足约束的所有数位和。


我们可以大致写出记忆化搜索的代码啦，这里我们先初始化fff数组为−1-1−1，即全为非法状态。

小技巧，~xxx是按位取反操作，该操作返回0时当且仅当x=−1x=-1x=−1，用来判断值是否为−1-1−1
代码如下

ll dfs(int pos,bool limit,int sum)&#123;    if(!pos)&#123;//递归边界为0        return sum;    &#125;    if(!limit&amp;&amp;~f[pos][sum])&#123;//如果没有最高限制并且有记录        return f[pos][sum];    &#125;    int up;    if(limit)&#123;//如果有最高位限制        up=a[pos];    &#125;else up=9;//baka    ll ret=0;    for(int i=0;i&lt;=up;i++)&#123;        //要求当这个位取到最高位并且limit也是1才能往下继续limit        ret=(ret+dfs(pos-1,limit&amp;&amp;i==up,sum+i))%mod;    &#125;    if(!limit)&#123;//如果没有最高位限制就是一般性答案，可以记录        f[pos][sum]=ret;    &#125;    return ret;&#125;
等会，初始状态怎么办，limitlimitlimit怎么处理！
我们想一想，我们发现对于上界最大取多少完全取决于limitlimitlimit，如果limit=falselimit=falselimit=false则上界可以取到999，如果limit=truelimit=truelimit=true，则上界只能取到数位的值。
也就是说，如果我们初始状态我们设limit=falselimit=falselimit=false的话，那最高位的枚举就会取到[1,9][1,9][1,9]，这样答案就会错误！
所以我们在初始化时limit=truelimit=truelimit=true，pos=lenpos=lenpos=len，sum=0sum=0sum=0。
代码solve函数即如下
ll solve(ll x)&#123;    int len=0;    while (x&gt;0)    &#123;        a[++len]=x%10;        x/=10;    &#125;    return dfs(len,true,0);    //先从最高位开始，肯定有limit=1不然如果出来个不是9的最高位直接炸了&#125;
那么如何证明我这个并没有退化成暴搜呢
考虑fff状态数量，数字上界为101810^{18}1018，18个9时是sumsumsum最大，结果即为9×18+19 \times 18 + 19×18+1即163
总状态数即为19×163=309719 \times 163=309719×163=3097，很少
计算复杂度时，我们考虑一个状态计算值时，需访问多少个状态，由数位一般性取值下为[0,9][0,9][0,9]，容易得到为10个状态。
可得计算出fff的时间复杂度为O(len×sum×R)O(len\times sum \times R)O(len×sum×R)，也就是共有3097×10=309703097\times 10=309703097×10=30970个状态
是否会存在limitlimitlimit为truetruetrue的节点过多导致状态记录不符合一般性退化成暴力搜索呢，我们显然可以发现

limit=truelimit=truelimit=true在全部数位都是truetruetrue的情况下只能是一条链！链的长度就是lenlenlen，也就是说扣除最右边那条链，剩下的状态数量也是不会超过len×sum×Rlen\times sum \times Rlen×sum×R的，黑色部位的连边我们默认认为O(1)O(1)O(1)复杂度，就是假设已经算完。
所以我们为什么要设置limit=falselimit=falselimit=false才能使用状态？

多组数据下这个状态是可以复用的
我们发现当limit=truelimit=truelimit=true属于是特殊情况，这种情况出现只是因为数位的限制，这些状态不符合一般性能取到[0,9][0,9][0,9]的情况，这些情况我们是不能复用的，记录上还浪费我们的空间。
所以你不会在任何数位dp题目中见到将limitlimitlimit作为状态的

完整代码如下,一般来说我们是需要开long long的
#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;int T;const ll ML=20,mod=1e9+7,MZ=9*18+5;int a[ML],f[ML][MZ];ll dfs(int pos,bool limit,int sum)&#123;    if(!pos)&#123;//递归边界为0        return sum;    &#125;    if(!limit&amp;&amp;~f[pos][sum])&#123;//如果没有最高限制并且有记录        return f[pos][sum];    &#125;    int up;    if(limit)&#123;//如果有最高位限制        up=a[pos];    &#125;else up=9;//baka    ll ret=0;    for(int i=0;i&lt;=up;i++)&#123;        //要求当这个位取到最高位并且limit也是1才能往下继续limit        ret=(ret+dfs(pos-1,limit&amp;&amp;i==up,sum+i))%mod;    &#125;    if(!limit)&#123;//如果没有最高位限制就是一般性答案，可以记录        f[pos][sum]=ret;    &#125;    return ret;&#125;ll solve(ll x)&#123;    int len=0;    while (x&gt;0)    &#123;        a[++len]=x%10;        x/=10;    &#125;    return dfs(len,true,0);    //先从最高位开始，肯定有limit=1不然如果出来个不是9的最高位直接炸了&#125;int main()&#123;    memset(f,-1,sizeof(f));    cin&gt;&gt;T;    while (T--)    &#123;        ll l,r;        cin&gt;&gt;l&gt;&gt;r;        ll ans=(solve(r)-solve(l-1)+mod)%mod;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;        return 0;&#125;
 例题实践
 例题1——windy数

不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 aaa 和 bbb 之间，包括 aaa 和 bbb ，总共有多少个 windy 数？(1≤a≤b≤2×1091\le a \le b \le 2\times 10^91≤a≤b≤2×109)
我们发现有了相邻数位的约束，
所以我们需要加上前面是否有前导0——lead0lead0lead0和上一位填写的数字——lastlastlast

注意lastlastlast初始赋值不能赋值−1-1−1！不然最高位就取不到−1,0,1-1,0,1−1,0,1。
我们可以知道约束条件体现在[pos+1,len][pos+1,len][pos+1,len]上，[1,pos][1,pos][1,pos]任意填写，这里的约束条件就是lastlastlast
故设状态f[pos][last]f[pos][last]f[pos][last]，表示[pos+1,len][pos+1,len][pos+1,len]已经填写完毕，[1,pos][1,pos][1,pos]任意填写，上一位数为lastlastlast的情况下windy数共有多少
不难写出代码
#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int MN=15,INF=1e9+7;int f[MN][MN],a[MN];//f[pos,last]表示[pos+1,len]都已经填写，且pos+1位填写的是last//的windy数数量，即以last开头的windy数的数量ll dfs(int pos,bool limit,bool lead0,int last)&#123;    if(!pos) return 1;    if(!limit&amp;&amp;last!=INF&amp;&amp;~f[pos][last])&#123;	    //如果无限制并且last填链并且状态合法        return f[pos][last];    &#125;    int up,ret=0;    if(limit)&#123;        up=a[pos];    &#125;else up=9;    for(int i=0;i&lt;=up;i++)&#123;        if(lead0)&#123;//如果是前导0表示还没填数，不能约束下一个数！	        //所以i=0时我们将last传递就行，如果不是0就传递i            ret=ret+dfs(pos-1,limit&amp;&amp;i==up,lead0&amp;&amp;i==0,i==0 ? last : i);        &#125;else if(abs(last-i)&gt;=2)&#123;            ret=ret+dfs(pos-1,limit&amp;&amp;i==up,0,i);        &#125;    &#125;    if(!limit&amp;&amp;last!=INF)&#123;	    //如果前一位填并且无限制适用于一般性情况        f[pos][last]=ret;    &#125;    return ret;&#125;int solve(ll x)&#123;    int len=0;    while (x&gt;0)    &#123;        a[++len]=x%10;        x/=10;    &#125;    //这里前导0也要设置不然前导0的情况算不上，和上面例0的情况差不多    return dfs(len,1,1,INF);&#125;int main()&#123;    memset(f,-1,sizeof(f));    ll l,r;    cin&gt;&gt;l&gt;&gt;r;    cout&lt;&lt;solve(r)-solve(l-1);    return 0;&#125;
 例题2:花神的数论题P4317

设  sum(i)\text{sum}(i)sum(i)  表示  iii  的二进制表示中  111  的个数。给出一个正整数  NNN  ，花神要问你  ∏i=1Nsum(i)\prod_{i=1}^{N}\text{sum}(i)∏i=1N​sum(i) ，也就是  sum(1)∼sum(N)\text{sum}(1)\sim\text{sum}(N)sum(1)∼sum(N)  的乘积。

注意这题的不同点是求乘积
我们仔细想一下其实差不多，我们在统计递归树子树答案结果用的是和，这里我们只需要改为乘就可以了
但是，如果我们仍设ret=0ret=0ret=0的话那0×x=00\times x=00×x=0啊，没关系只需要设ret=1ret=1ret=1就可以了
类似例子0，但这里是二进制，只有1，而1出现次数就是数码和
故设状态f[pos][cnt]f[pos][cnt]f[pos][cnt]，表示[pos+1,len][pos+1,len][pos+1,len]体经填写了cntcntcnt个1，[1,pos][1,pos][1,pos]填写，所有合法方案的乘积
故不难写出代码
#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int mod=1e7+7,MN=110;ll f[MN][MN],a[MN];ll dfs(int pos,bool limit,int cnt)&#123;    if(!pos)&#123;        return max(cnt,1);    &#125;    if(!limit&amp;&amp;~f[pos][cnt])&#123;        return f[pos][cnt];    &#125;    ll up,ret=1;    if(limit)&#123;        up=a[pos];    &#125;else up=1;    for(int i=0;i&lt;=up;i++)&#123;        ret=(ret*dfs(pos-1,limit&amp;&amp;i==up,cnt+(i==1)))%mod;    &#125;    if(!limit)&#123;        f[pos][cnt]=ret;    &#125;    return ret;&#125;ll solve(ll x)&#123;    int len=0;    while (x&gt;0)    &#123;        a[++len]=x%2;        x/=2;    &#125;    return dfs(len,true,0);&#125;int main()&#123;    memset(f,-1,sizeof(f));    ll x;    cin&gt;&gt;x;    cout&lt;&lt;solve(x);    return 0;&#125;
 例题3:启示录

古代人认为 666666666 是属于魔鬼的数。
不但如此，只要某数字的十进制表示中有三个连续的 666，古代人也认为这是个魔鬼的数，比如 666,1666,6663,16666,6660666666,1666,6663,16666,6660666666,1666,6663,16666,6660666 等等。
古代典籍中经常用“第 XXX 小的魔鬼的数”来指代这些数，这给研究人员带来了极大的不便。
现在请编写一个程序，可以实现输入 XXX，输出对应的魔鬼数。

不难设状态为f[pos][lst1][lst2]f[pos][lst1][lst2]f[pos][lst1][lst2]，表示[pos+1,len][pos+1,len][pos+1,len]填写完毕，对于pospospos的上一位lst1lst1lst1是否是6（lst1=0/1lst1=0/1lst1=0/1，bool变量），对于pospospos的上上一位lst2lst2lst2是否为6（lst2=0/1lst2=0/1lst2=0/1)，的蘑菇数的个数。
不难有dfs：
ll f[MN][2][2];ll dfs(int pos,bool lt1,bool lt2,bool lim)&#123;    if(!pos) return 1;    if(!lim&amp;&amp;~f[pos][lt1][lt2]) return f[pos][lt1][lt2];    int up;    if(lim) up=a[pos];    else up=9;    ll ret=0;    for(int i=0;i&lt;=up;i++)&#123;        if(lt1&amp;&amp;lt2&amp;&amp;i==6) continue;//蘑菇数状态重复了，要排了        ret+=dfs(pos-1,i==6,lt1,lim&amp;&amp;i==up);    &#125;    if(!lim) f[pos][lt1][lt2]=ret;    return ret;&#125;ll solve(ll x)&#123;    int len=0;    while(x&gt;0)&#123;        a[++len]=x%10;        x/=10;    &#125;    return dfs(len,0,0,1);&#125;
考虑第xxx小如何求出，不难发现值域上对于次数，右边界扩大那么一定有单调性。我们实际上可以考虑在值域上二分，每一次二分DFS求出个数，mid+1−dfsmid+1-dfsmid+1−dfs即为次数，我们要求二分恰好到xxx，那么当mid+1−dfs≥xmid+1-dfs\ge xmid+1−dfs≥x时才能更新rrr，否则更新lll
那么代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=20;int a[MN],T;ll f[MN][2][2];ll dfs(int pos,bool lt1,bool lt2,bool lim)&#123;    if(!pos) return 1;    if(!lim&amp;&amp;~f[pos][lt1][lt2]) return f[pos][lt1][lt2];    int up;    if(lim) up=a[pos];    else up=9;    ll ret=0;    for(int i=0;i&lt;=up;i++)&#123;        if(lt1&amp;&amp;lt2&amp;&amp;i==6) continue;        ret+=dfs(pos-1,i==6,lt1,lim&amp;&amp;i==up);    &#125;    if(!lim) f[pos][lt1][lt2]=ret;    return ret;&#125;ll solve(ll x)&#123;    int len=0;    while(x&gt;0)&#123;        a[++len]=x%10;        x/=10;    &#125;    return dfs(len,0,0,1);&#125;int main()&#123;    memset(f,-1,sizeof(f));    cin&gt;&gt;T;    while(T--)&#123;        int x;        cin&gt;&gt;x;        ll l=665,r=1e18;        while(l+1&lt;r)&#123;            ll mid=(l+r)&gt;&gt;1;            if(mid+1-solve(mid)&lt;x)&#123;                l=mid;            &#125;else r=mid;        &#125;        cout&lt;&lt;l+1&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 形参设定
以下为记忆化搜索dfsdfsdfs常设定的形参

pospospos：整形，表示当前枚举的位置，一般从高到低
limitlimitlimit：布尔，表示当前pospospos位是否收到限制

为truetruetrue时表示当前取得位数不能大于a[pos]a[pos]a[pos]，只有在[pos+1,len][pos+1,len][pos+1,len]的值填写的数都是aia_iai​的时候该值才能为truetruetrue，在递归树上表示为一条链


lastlastlast：整形，表示上一位填写的值（即pos+1pos+1pos+1填写的值）
lead0lead0lead0：布尔，表示是否有前导零，即在len→(pos+1)len\rightarrow (pos+1)len→(pos+1)的位置是否都是前导0

基于尝试，我们往往认为一个数没有前导0，最高位不能为0.在只有没有前导0的时候，才能够计算0的贡献，那么前导0什么时候会和答案有关，有以下情况

统计0的出现次数
相邻数值的差值
以最高位为起点确定的奇偶位




sumsumsum：整形，表示len→(pos+1)len\rightarrow (pos+1)len→(pos+1)的数位和
rrr：整形变量，表示整个数前缀取模mmm所得的余数

这种情况下一般用在约束中出现了能被mmm整除


ststst：整形变量，用于状态压缩

对一个集合的数在数位上的出现次数的奇偶性有要求时，其二进制形式就可以表示每个数出现的奇偶性
3



 参考
GhostXL算法学习笔记——数位DP
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数论从入门到入坟</title>
    <url>/posts/88d351e8/</url>
    <content><![CDATA[ 数论——从入门到入坟

注：线性代数并不算于这篇文章

 0.前言
数论应该算是oi里面一个比较算是重要的章节了吧，他在大纲内标得难度居然比平衡树还简单？听老师说这个难度其实是按学起来的难度表的。应用起来和平衡树的区间操作一样难。
故借一个下午，整理数论笔记，重新思考思考一下吧。
数论研究的是整数的性质，但是性质要好多啊啊啊。一个一个慢慢学吧.
 1.扬帆启航——整除
整除应该早就在小学中学过他的概念了。这里我们添加几个符号来表示整除，并且重新复述一遍定义。
若aaa和bbb为整数，aaa整除bbb。则b是a的倍数，a是b的约数（或者也可以叫做因数），我们记为a∣ba|ba∣b。整除的大部分性质都是显而易见的，如下
 1.任意性
若a∣ba|ba∣b，则对于任意非零整数mmm，有am∣bmam|bmam∣bm。
 2.传递性
若a∣ba|ba∣b且b∣cb|cb∣c，则a∣ca|ca∣c。
 3.可消性
若a∣bca|bca∣bc且aaa与ccc互素，则a∣ba|ba∣b
 4.组合性
若c∣ac|ac∣a且c∣bc|bc∣b，对于任意整数m,nm,nm,n，有c∣(ma+nb)c|(ma+nb)c∣(ma+nb)
 2.数论的基础——素数
 1.素数的定义


素数又称质数，其满足性质就是大于等于2，并且除了1和他本身外不能被其他的任何自然数整除。


不满足该性质的数为合数，但是1既不是素数又不是合数


2是唯一的偶素数


随着整数的增大，素数的分布越来越稀疏。随机整数xxx是素数的概率是1log2x\frac{1}{log_2x}log2​x1​，


 2.素数判定
怎样取判定一个数是否为素数？我们先从定义来看，素数表示只能被1和自己整除的正整数。那我们就可以得到如下的做法

朴素判定：对nnn做[2,n)[2,n)[2,n)范围的余数判定，如果至少一个数取余nnn后为0，则nnn为合数，反之为素数，时间复杂度O(n)O(n)O(n)。

我们考虑一下优化，假设一个数能够整除nnn，即a∣na|na∣n，那么na\frac{n}{a}an​也一定能够整除aaa，那么不妨设a≤naa\le \frac{n}{a}a≤an​ ，可得a2≤na^2\le na2≤n，可得a≤na\le \sqrt{n}a≤n​ ，也就是说我们只需要筛到n\sqrt{n}n​就可以了，时间复杂度就降到了n\sqrt{n}n​，

优化判定:对nnn做[2,n][2,\sqrt{n}][2,n​]的判定，同朴素筛法取余，时间复杂度O(n)O(\sqrt{n})O(n​)

要不要再快点？我们显然可得如果n是合数，那么必然有一个小于等于n\sqrt{n}n​的素银子，只需要对n\sqrt{n}n​范围内的素数进行测试即可，假设该范围内的素数个数为sss，则时间复杂度为O(s)O(s)O(s)
不过，我们发现这个的复杂度只能在101210^{12}1012内管用，往外就超时了，我们可以使用Miller_Rabin算法来求解，下文在费马小定理会提到。
 3.素数筛法
给定nnn，求[2,n][2,n][2,n]内所有素数
像上面一样逐个判断会很慢，我们可以用“筛子”，来一起筛所有的整数，把合数都筛掉。常用的两种算法分别为埃式筛和欧拉筛。
 1.埃式筛
我们直接利用素数的定义，即除了1和他本身外不能被其他的任何自然数整除。可以得出他的倍数都是合数。
步骤如下


用一个标记数组f[maxn]f[maxn]f[maxn]，其中f[i]=0f[i]=0f[i]=0表示iii为素数否则为非素数。首先先把f[0]=f[1]=1f[0]=f[1]=1f[0]=f[1]=1，因为他们都不是素数


从未被标记的数中找到最小的数，为2，它不是任何（除1与其本身）数的倍数，所以2是素数，这时候我们将4，6，8，10，…等2的倍数标记为1


从未被标记的数中找到最小的数，为3.它也是素数，我们把它的倍数也标记上，6，9，12…


从未被标记的数中找到最小的数，为5，它也是素数，我们标记他的倍数，10，15，20，25…


…



这种方式我们遍历完标记数组f[i]f[i]f[i]，如果没有标记1，就是素数。这种的时间复杂度就是O(nloglogn)O(nloglogn)O(nloglogn)，已经十分接近线性了。
如果我们对于fff数组使用vector&lt;bool&gt;vector&lt;bool&gt;vector&lt;bool&gt;或者bitsetbitsetbitset进行优化可以将效率大幅提高。
vector&lt;int&gt; prime;vector&lt;bool&gt; notprime(100000000);void aishi(int n)&#123;    for(int i=2;i&lt;=n;i++)&#123;        if(notprime[i]!=1)&#123;            prime.push_back(i);            for(int j=i*2;j&lt;=n;j+=i)&#123;                notprime[j]=1;            &#125;        &#125;    &#125;&#125;
但是带log，当数量级增大的时候就会TLE。我们考虑上面的情况（重复划掉），我们发现有重复的数组被筛掉，我们能否优化掉这一过程呢
 2.欧拉筛（线性筛）
原理就是一个合数肯定有一个最小质因数。让每个合数被他的最小质因数筛选一次，以达到不重复筛的目的，步骤如下


逐一检查[2,n)[2,n)[2,n)的所有数，第一个数2是素数，取出来


当检查到第iii个数的时候，利用已经求过的素数取筛到对应的合数xxx，而且用xxx的最小质因数取筛


代码如下
vector&lt;bool&gt; notprime(MN+5);vector&lt;int&gt; prime;void shai()&#123;    for(int i=2;i&lt;=n;i++)&#123;        if(!notprime[i])&#123;            prime.push_back(i);        &#125;        for(int j=0;j&lt;prime.size();j++)&#123;            if(i*prime[j]&gt;n) break;            notprime[i*prime[j]]=1;            if(i%prime[j]==0)&#123;                break;            &#125;        &#125;    &#125;&#125;
我们可以比较一下埃式筛和线性筛的性能差距，都使用了vector优化
线性筛

埃式筛

飞快
 3.算数唯一分解定理
我们来看素数真正的定义，也就是算数基本引理

设ppp是素数，若p∣a1a2p|a_1 a_2p∣a1​a2​那么p∣a1p|a_1p∣a1​和p∣a2p|a_2p∣a2​至少有一个成立

算数唯一分解定理表示如下


设正整数aaa，都可以唯一分解成素数的乘积，如下


n=p1p2p3...pkn=p_1p_2p_3...p_kn=p1​p2​p3​...pk​（p1≤p2≤p3≤...≤pkp_1\le p_2\le p_3\le...\le p_kp1​≤p2​≤p3​≤...≤pk​），这里素数并不要求是一样的，我们可以将相同的素数合并变成幂的形式，如下


n=p1e1p2e2...pkekn=p^{e_1}_{1}p^{e_2}_{2}...p^{e_k}_{k}n=p1e1​​p2e2​​...pkek​​ 。


遇到一个数不要只把它当作一个普普通通的数，要想到算数唯一分解定理。
 4.素因子分解
还是靠经典的试除法，考虑朴素算法，因数是成对分布的， 的所有因数可以被分成两块，即[2,n][2,\sqrt{n}][2,n​]和 [n+1,n][\sqrt{n}+1,n][n​+1,n]。只需要把[2,n][2,\sqrt{n}][2,n​]里的数遍历一遍，再根据除法就可以找出至少两个因数了。这个方法的时间复杂度为 O(n)O(\sqrt{n})O(n​)。
代码如下(粘贴自oiwiki)
vector&lt;int&gt; breakdown(int N) &#123;  vector&lt;int&gt; result;  for (int i = 2; i * i &lt;= N; i++) &#123;    if (N % i == 0) &#123;  // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。      while (N % i == 0) N /= i;      result.push_back(i);    &#125;  &#125;  if (N != 1) &#123;  // 说明再经过操作之后 N 留下了一个素数    result.push_back(N);  &#125;  return result;&#125;
证明result中所有元素是NNN的全体素因数


首先考察 N 的变化。当循环进行到 i 结束时，由于刚执行结束 while(N % i == 0) N /= i 部分，i 不再整除 N。而且，每次除去一个因子，都能够保证 N 仍整除 。这两点保证了，当循环进行到 i 开始时，N 是  的一个因子，且不被任何小于 i 的整数整除。


其次证明 result 中的元素均为  的因子。当循环进行到 i 时，能够在 result 中存入 i 的条件是 N % i == 0，这说明 i 整除 N，且已经说明 N 是  的因子，故而有 i 是  的因子。当对 i 的循环结束时，若 N 不为一，也会存入 result。此时它根据前文，也必然是  的一个因子。


其次证明 result 中均为素数。我们假设存在一个在 result 中的合数 ，则必然存在 i 不超过 ，满足 i 是 K 的一个因子。这样的  不可能作为循环中的某个 i 存入 result，因为第一段已经说明，当循环到  时，N 不被任何小于  的 i 整除。这样的  也不可能在循环结束后加入，因为循环退出的条件是 i * i &gt; N，故而已经遍历完了所有不超过  的 i，而且据上文所说， 这些 i 绝不能整除目前的 N，亦即 。


最后证明，所有  的素因子必然出现在 result 中。不妨假设  是  的一个素因子，但并没有出现在 result 中。根据上文的讨论， 不可能是循环中出现过的 i。设 i 是退出循环前最后的 i，则 i 严格小于 ，而退出循环后的 N 不被之前的 i 整除，故而  整除 N。所以最后的 N 大于一，则根据前文所述，它必然是素数，则 N 就等于 ，必会在最后加入 result，与假设矛盾。


 5.素因子个数
 1.朴素求法
还是试除法，我们套用优化枚举[1,n][1,\sqrt{n}][1,n​]即可，时间复杂度O(n)O(\sqrt{n})O(n​)
 2.素数分解法
根据算数基本定理可得，nnn的因子一定是p1,p2...pkp_1,p_2...p_kp1​,p2​...pk​的组合，而且例如p1p_1p1​取得个数为[0,e1][0,e_1][0,e1​]，p2p_2p2​是[0,e2][0,e_2][0,e2​]，以此类推。
由乘法原理可得，设总因子个数为g(n)g(n)g(n)，等于ei+1e_i+1ei​+1的连乘，即表示如下
g(n)=∏i=1k(ei+1)g(n)=\prod_{i=1}^{k}(e_i+1)g(n)=∏i=1k​(ei​+1)
时间复杂度即求素因子分解的复杂度O(s)O(s)O(s)
 6.GCD与LCM
 1.模运算
对于一个正整数ppp，任意一个整数nnn，一定存在等式n=kp+rn=kp+rn=kp+r，其中k,rk,rk,r是整数，且0≤r&lt;p0\le r&lt;p0≤r&lt;p，称kkk为nnn除以ppp的商，rrr为nnn除以ppp的余数，表示为n mod p=rn\,mod\,p =rnmodp=r

我们定义正整数和整数a,ba,ba,b满足如下运算
a mod pa\,mod\,pamodp表示a除以p所得的余数
以下公式分别是模p加法，减法，乘法和幂模p

模运算满足结合律，交换律与分配律。
我们用a≡b (mod m)a\equiv b\,(mod\,m)a≡b(modm)表示aaa与bbb模mmm意义下同余，说人话就是aaa和bbb除以mmm的余数相等
对于同余有如下性质


自反性：若a是整数，则a≡a (mod m)a\equiv a\,(mod\, m)a≡a(modm)


对称性：若a和b是整数，且a≡b (mod m)a\equiv b\,(mod\,m)a≡b(modm)，则b≡a (mod m)b\equiv a\,(mod\,m)b≡a(modm)


传递性：若a,b,c是整数，且a≡b (mod m)a\equiv b\,(mod\,m)a≡b(modm),b≡c (mod m)b\equiv c\,(mod\,m)b≡c(modm)，则a≡c (mod m)a\equiv c\,(mod\,m)a≡c(modm)。


关于同余的加减乘除，若a，b，c，d和m是整数，m&gt;0m&gt;0m&gt;0，且a≡b (mod m)a\equiv b\,(mod\,m)a≡b(modm),c≡d (mod m)c\equiv d\,(mod\,m)c≡d(modm)


加：a+c≡b+d (mod m)a+c\equiv b+d\,(mod\,m)a+c≡b+d(modm)


减：a−c≡b−d (mod m)a-c\equiv b-d\,(mod\,m)a−c≡b−d(modm)


乘：ac≡bd (mod m)ac\equiv bd\,(mod\,m)ac≡bd(modm)


除：在模的左右都同除一个数不能保证同余，后面会讲模除法


 2.最大公约数
寻求最大公约数是人民民主的真谛…
最大的正整数ddd使得d∣ad|ad∣a并且d∣bd|bd∣b，则称ddd是a,ba,ba,b的最大公约数，记作gcd(a,b)gcd(a,b)gcd(a,b)，则k∣ak|ak∣a和k∣bk|bk∣b就等价于k∣gcd(a,b)k|gcd(a,b)k∣gcd(a,b)
由算数基本定理可得，有如下公式满足：


a=p1x1p2x2p3x3...pkxka=p_1^{x_1}p_2^{x_2}p_3^{x_3}...p_k^{x_k}a=p1x1​​p2x2​​p3x3​​...pkxk​​


b=p1y1p2y2p3y3...pkykb=p_1^{y_1}p_2^{y_2}p_3^{y_3}...p_k^{y_k}b=p1y1​​p2y2​​p3y3​​...pkyk​​


那么gcd(a,b)gcd(a,b)gcd(a,b)可以表示为以下形式，这个形式思考很好用！
gcd(a,b)=p1min(x1,y1)p2min(x2,y2)p3min(x3,y3)...pkmin(xk,yk)gcd(a,b)=p_1^{min(x_1,y_1)}p_2^{min(x_2,y_2)}p_3^{min(x_3,y_3)}...p_k^{min(x_k,y_k)}gcd(a,b)=p1min(x1​,y1​)​p2min(x2​,y2​)​p3min(x3​,y3​)​...pkmin(xk​,yk​)​
需要说明的是这里aaa和bbb的分解式中指数可以为0。
 2.1 辗转相除法求最大公约数

当b≠0b\ne0b=0时，我们令a=kb+ra=kb+ra=kb+r，其中k=⌊ab⌋，r=a mod bk=\lfloor\frac{a}{b}\rfloor，r=a\,mod\,bk=⌊ba​⌋，r=amodb，并且满足(0≤r&lt;b)(0\le r&lt;b)(0≤r&lt;b)，当一个数c即使a的约数也是b的约数，那么则必然也是a−kba-kba−kb的约数，即r的约数。那么a和b的最大公约数=b和r的最大公约数。表示如下

gcd(a,b)=gcd(b,a mod b)gcd(a,b)=gcd(b,a\,mod\,b)gcd(a,b)=gcd(b,amodb)
但是假设建立在b≠0b\ne0b=0的情况下，而b=0b=0b=0的情况，答案显然为a，对于上述gcd函数，可以表示为如下递归式子。
gcd(a,b)={ab=0gcd(b,a mod b)b≠0gcd(a,b)=\begin{cases} a &amp; b=0 \\ gcd(b,a\,mod\,b) &amp; b\ne 0 \end{cases}gcd(a,b)={agcd(b,amodb)​b=0b=0​
写成代码就是如下
int gcd(int a, int b) &#123;    return !b ? a : gcd(b, a % b);&#125;
也可以用std实现的std::__gcd(a,b)加下划线是不推荐使用因为没有安全保护，但毕竟我们又不是写多线程，直接用就完了。
gcd具有结合律，如下
gcd(a,b,c,d,e,f,g)=gcd(gcd(a,b),c,d,e,f,g)gcd(a,b,c,d,e,f,g)=gcd(gcd(a,b),c,d,e,f,g)gcd(a,b,c,d,e,f,g)=gcd(gcd(a,b),c,d,e,f,g)
P10463 Interval GCD

给定一个长度为 NNN 的数列 AAA，以及 MMM 条指令，每条指令可能是以下两种之一：




C l r d，表示把 A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r] 都加上 ddd。


Q l r，表示询问 A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r]A[l],A[l+1],…,A[r] 的最大公约数(GCD)。


显然线段树，根据gcd的结合律，我们可以进行暴力的单点修改，gcd根据结合律进行维护：
#include&lt;bits/stdc++.h&gt;#define ll long long#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1#define gcd(a,b) __gcd(abs(a),abs(b))#define pir pair&lt;int,int&gt;using namespace std;const int MN=5e5+15;struct segtree&#123;    int l,r;    ll sum,d;&#125;t[MN&lt;&lt;2];  int n,m;ll a[MN];  void pushup(int p)&#123;    t[p].sum=t[ls].sum+t[rs].sum;    t[p].d=gcd(t[ls].d,t[rs].d);&#125;    void build(int p,int l,int r)&#123;    t[p].l=l;    t[p].r=r;    if(l==r)&#123;        t[p].d=t[p].sum=a[l]-a[l-1];        return;    &#125;    int mid=l+r&gt;&gt;1;    build(ls,l,mid);    build(rs,mid+1,r);    pushup(p);&#125;  void modify(int p,int x,ll k)&#123;    if(t[p].l==t[p].r)&#123;        t[p].sum+=k;        t[p].d+=k;        return;    &#125;    int mid=t[p].l+t[p].r&gt;&gt;1;    if(mid&gt;=x) modify(ls,x,k);    else modify(rs,x,k);    pushup(p);&#125;  ll querys(int p,int fl,int fr)&#123;    if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;        return t[p].sum;    &#125;    int mid=t[p].l+t[p].r&gt;&gt;1;    ll ret=0;    if(mid&gt;=fl)&#123;        ret+=querys(ls,fl,fr);    &#125;    if(mid&lt;fr)&#123;        ret+=querys(rs,fl,fr);    &#125;    return ret;&#125;  ll queryd(int p,int fl,int fr)&#123;    if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;        return t[p].d;    &#125;    ll ret=0;    int mid=t[p].l+t[p].r&gt;&gt;1;    if(mid&gt;=fl)&#123;        ret=gcd(ret,queryd(ls,fl,fr));    &#125;    if(mid&lt;fr)&#123;        ret=gcd(ret,queryd(rs,fl,fr));    &#125;    return ret;&#125;int main()&#123;    ios::sync_with_stdio(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    char op;    int l,r;    ll v;    build(1,1,n);    while (m--)    &#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;        if(op==&#x27;C&#x27;)&#123;            cin&gt;&gt;v;            modify(1,l,v);            if(r!=n) modify(1,r+1,-v);        &#125;else&#123;            cout&lt;&lt;gcd(queryd(1,l+1,r),querys(1,1,l))&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 3.最小公倍数
两个数a和b的最小公倍数是指同时被a和b整除的最小倍数，记为lcm(a,b)lcm(a,b)lcm(a,b)。
特殊的，当a和b互素时，lcm(a,b)=ablcm(a,b)=ablcm(a,b)=ab
求LCM需要先求gcd，所以易得
lcm(a,b)=abgcd(a,b)lcm(a,b)=\frac{ab}{gcd(a,b)}lcm(a,b)=gcd(a,b)ab​
由算数唯一分解定理可得如下公式：


a=p1x1p2x2p3x3...pkxka=p_1^{x_1}p_2^{x_2}p_3^{x_3}...p_k^{x_k}a=p1x1​​p2x2​​p3x3​​...pkxk​​


b=p1y1p2y2p3y3...pkykb=p_1^{y_1}p_2^{y_2}p_3^{y_3}...p_k^{y_k}b=p1y1​​p2y2​​p3y3​​...pkyk​​


那么gcd(a,b)和lcm(a,b)gcd(a,b)和lcm(a,b)gcd(a,b)和lcm(a,b)可以表示为如下式子


gcd(a,b)=p1min(x1,y1)p2min(x2,y2)p3min(x3,y3)...pkmin(xk,yk)gcd(a,b)=p_1^{min(x_1,y_1)}p_2^{min(x_2,y_2)}p_3^{min(x_3,y_3)}...p_k^{min(x_k,y_k)}gcd(a,b)=p1min(x1​,y1​)​p2min(x2​,y2​)​p3min(x3​,y3​)​...pkmin(xk​,yk​)​


lcm(a,b)=p1max(x1,y1)p2max(x2,y2)p3max(x3,y3)...pkmax(xk,yk)lcm(a,b)=p_1^{max(x_1,y_1)}p_2^{max(x_2,y_2)}p_3^{max(x_3,y_3)}...p_k^{max(x_k,y_k)}lcm(a,b)=p1max(x1​,y1​)​p2max(x2​,y2​)​p3max(x3​,y3​)​...pkmax(xk​,yk​)​


需要说明的是这里aaa和bbb的分解式中指数可以为0。
我们将gcd和lcm相乘，由下列公式可得
min(x,y)+max(x,y)=x+ymin(x,y)+max(x,y)=x+ymin(x,y)+max(x,y)=x+y
可得lcm(a,b)×gcd(a,b)=ablcm(a,b)\times gcd(a,b)=ablcm(a,b)×gcd(a,b)=ab
等式两边同除gcd(a,b)gcd(a,b)gcd(a,b)
lcm(a,b)=abgcd(a,b)lcm(a,b)=\frac{ab}{gcd(a,b)}lcm(a,b)=gcd(a,b)ab​
代码如下
int lcm(int a, int b) &#123;    return a / gcd(a, b) * b;&#125;
 7.拓展欧几里得定理——裴蜀定理
裴蜀定理是关于GCD的一个定理。


对于整数a和ba和ba和b，一定存在整数x,yx,yx,y使得ax+by=gcd(a,b)ax+by=gcd(a,b)ax+by=gcd(a,b)成立


推论：当a和b互素（即gcd(a,b)=1gcd(a,b)=1gcd(a,b)=1时）ax+by=1ax+by=1ax+by=1


或另一种形式

对于任意x,yx,yx,y，d=ax+byd=ax+byd=ax+by，ddd一定是gcd(a,b)gcd(a,b)gcd(a,b)的整数倍，最小的d就是gcd(a,b)gcd(a,b)gcd(a,b)，即可得ax+by=k×gcd(a,b)  (k≥1)ax+by=k\times gcd(a,b)\,\,(k \ge 1)ax+by=k×gcd(a,b)(k≥1)

证明如下

例题： P4549 【模板】裴蜀定理

给定一个包含 nnn 个元素的整数序列 AAA，记作 A1,A2,A3,...,AnA_1,A_2,A_3,...,A_nA1​,A2​,A3​,...,An​。



求另一个包含 nnn 个元素的待定整数序列 XXX，记 S=∑i=1nAi×XiS=\sum\limits_{i=1}^nA_i\times X_iS=i=1∑n​Ai​×Xi​，使得 S&gt;0S&gt;0S&gt;0 且 SSS 尽可能的小

我们可以发现，这个Ai×XiA_i\times X_iAi​×Xi​很类似于ax+byax+byax+by，并且这里的a和ba和ba和b给出了。这样Ai×XiA_i\times X_iAi​×Xi​就处理成了gcd(A1,A2)gcd(A_1,A_2)gcd(A1​,A2​)。

引理：gcd(a1,a2,...ak)=gcd(gcd(a1,a2),gcd(a3,a4)...gcd(ak−1,ak))gcd(a_1,a_2,...a_k)=gcd(gcd(a_1,a_2),gcd(a_3,a_4)...gcd(a_{k-1},a_k))gcd(a1​,a2​,...ak​)=gcd(gcd(a1​,a2​),gcd(a3​,a4​)...gcd(ak−1​,ak​))

那么只需要合并结果就可以了
代码如下
#include&lt;iostream&gt;#include&lt;cmath&gt;#define ll long longusing namespace std;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;ll ans,awa;int n;int main()&#123;    cin&gt;&gt;n;    cin&gt;&gt;ans;    if(n==1)&#123;        cout&lt;&lt;ans;        return 0;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        cin&gt;&gt;awa;        awa=abs(awa);        ans=gcd(ans,awa);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 8.线性同余方程——exgcd求解
 exgcd拓展欧几里得算法
线性同余方程（也叫模线性方程）是最基本的同余方程，即 ax≡b(mod n)ax \equiv b(mod \ n)ax≡b(mod n)
其中 a、b、n 都为常量，x 是未知数，这个方程可以进行一定的转化，得到：ax=kn+bax = kn + bax=kn+b
这里的 k 为任意整数，于是我们可以得到更加一般的形式即：ax+by+c=0ax + by + c = 0ax+by+c=0
求解的第一步就是将原式化为ax+by=cax+by=cax+by=c 。
第二步求出d=gcd(a,b)d=gcd(a,b)d=gcd(a,b)，由裴蜀定理演变式可得如下式子
d(axd+byd)=cd(a \frac xd + b \frac yd) = cd(adx​+bdy​)=c
容易知道(axd+byd)(a \frac xd + b \frac yd)(adx​+bdy​)为整数，如果d不能整除c，则方程无解。
第三步：我们由2步可知方程有解则可以一定能表示成ax+by=c=gcd(a,b)×cax + by = c = gcd(a, b) \times cax+by=c=gcd(a,b)×c，那么如何求解呢，根据欧几里得定理有如下转化
d=gcd(a,b)=gcd(b,a%b)(1)=bx′+(a%b)y′(2)=bx′+[a−b×⌊ab⌋]y′(3)=ay′+b[x′−⌊ab⌋y′](4)\begin{aligned} d &amp;= gcd(a, b) \\&amp;= gcd(b, a\%b) &amp; (1)\\&amp;= bx&#x27; + (a\%b)y&#x27; &amp; (2)\\&amp;= bx&#x27; + [a-b \times \lfloor \frac ab \rfloor]y&#x27; &amp; (3)\\&amp;= ay&#x27; + b[x&#x27; - \lfloor \frac ab \rfloor y&#x27;] &amp; (4)\end{aligned}d​=gcd(a,b)=gcd(b,a%b)=bx′+(a%b)y′=bx′+[a−b×⌊ba​⌋]y′=ay′+b[x′−⌊ba​⌋y′]​(1)(2)(3)(4)​
于是有{x=y′y=x′−⌊ab⌋y′\begin{cases}x &amp;= y&#x27; \\ y &amp;= x&#x27; - \lfloor \frac ab \rfloor y&#x27; \end{cases}{xy​=y′=x′−⌊ba​⌋y′​
需要注意的是，当递归边界即b=1b=1b=1的情况下，此时易得x=1x=1x=1,y=0y=0y=0。
代码也就如下，这样吧xxx和yyy输进去，就得到了一组解
void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1;        y=0;        return;    &#125;    exgcd(b,a%b,y,x);    y-=a/b*x;&#125;
例如求解方程27x+8y=127x+8y=127x+8y=1
点我观看动画！
   例1：P1082 [NOIP2012 提高组] 同余方程

求关于 xxx 的同余方程 ax≡1(modb)ax \equiv 1 \pmod {b}ax≡1(modb) 的最小正整数解。

显然可以变化为ax+by=1ax+by=1ax+by=1，由裴蜀定理可得gcd(a,b)=1gcd(a,b)=1gcd(a,b)=1，a与b互素，通过exgcd我们能求出这个题的一组解，但是题目要求是最小正整数解，有可能求得的解为负数，也有可能过大。
对于原式ax+by=1ax+by=1ax+by=1，我们做如下变形
ax+by+k×ba−k×ba=1ax+by+k\times ba-k\times ba=1ax+by+k×ba−k×ba=1
a(x+kb)+b(y−ka)=1a(x+kb)+b(y-ka)=1a(x+kb)+b(y−ka)=1
即可得求出的解xxx由x0+kbx_0+kbx0​+kb推得，所以我们可以对得出的结果做如下操作
    ll a,b,x,y;    cin&gt;&gt;a&gt;&gt;b;    exgcd(a,b,x,y);    cout&lt;&lt;(x%b+b)%b;
可以理解为加上b和减去b不会错过任何解
故AC代码如下，套板子就行
#include&lt;iostream&gt;#define ll long longusing namespace std;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1;        y=0;        return;    &#125;    exgcd(b,a%b,y,x);    y-=a/b*x;&#125;int main()&#123;    ll a,b,x,y;    cin&gt;&gt;a&gt;&gt;b;    exgcd(a,b,x,y);    cout&lt;&lt;(x%b+b)%b;    return 0;&#125;
仔细看看这个题，是不是有点眼熟，我们把xxx替换为a−1a^{-1}a−1，我们发现这不就是在求模运算的逆元吗！
 例题2：# P5656 【模板】二元一次不定方程 (exgcd)

要求输出ax+by=cax+by=cax+by=c中xxx和yyy的最小解和最大解,无解输出-1

有裴蜀定理可得，如果ccc不是gcd(a,b)gcd(a,b)gcd(a,b)的倍数，方程必定无解。
用exgcd求出ax0+by0=gcd(a,b)ax_0+by_0=gcd(a,b)ax0​+by0​=gcd(a,b)的整数解后，我们开始用这个特殊解取推ax+by=cax+by=cax+by=c的解，也就是求通解
由裴蜀定理推论得ax+by=k×gcd(a,b)  (k≥1)ax+by=k\times gcd(a,b)\,\,(k \ge 1)ax+by=k×gcd(a,b)(k≥1)
所以可得ax+by=cax+by=cax+by=c变形为ax+by=k×gcd(a,b)=cax+by=k\times gcd(a,b)=cax+by=k×gcd(a,b)=c
k×gcd(a,b)=ck\times gcd(a,b)=ck×gcd(a,b)=c
k=cgcd(a,b)k=\frac{c}{gcd(a,b)}k=gcd(a,b)c​
代入原式ax0+by0=gcd(a,b)ax_0+by_0=gcd(a,b)ax0​+by0​=gcd(a,b)
x0cgcd(a,b)a+x0cgcd(a,b)b=c\frac{x_0c}{gcd(a,b)}a+\frac{x_0c}{gcd(a,b)}b=cgcd(a,b)x0​c​a+gcd(a,b)x0​c​b=c
故可得xxx和yyy可以表示为
ax+by=c {x=x0×cgcd(a,b)y=y0×cgcd(a,b) ax+by=c\,\begin{cases} x=x_0\times\frac{c}{gcd(a,b)} \\ y=y_0\times\frac{c}{gcd(a,b)}   \end{cases}ax+by=c{x=x0​×gcd(a,b)c​y=y0​×gcd(a,b)c​ ​
既然我们用x0x_0x0​和y0y_0y0​表示了xxx和yyy，那我们就可以开始找出所有的解
我们开例1推的式子，我们将x0x_0x0​和y0y_0y0​分别代入x和yx和yx和y
不过我们换元求一下k
m=kbm=kbm=kb
n=kan=kan=ka
a(x0+m)+b(y0−n)=ca(x_0+m)+b(y_0-n)=ca(x0​+m)+b(y0​−n)=c
展开可得ax0+by0+am−bn=cax_0+by_0+am-bn=cax0​+by0​+am−bn=c
我们只需要让am−bn=0am-bn=0am−bn=0即可
设gcd(a,b)=dgcd(a,b)=dgcd(a,b)=d，我们让{m=t×bdn=t×ad\begin{cases} m=t\times\frac{b}{d}\\n=t\times\frac{a}{d} \end{cases}{m=t×db​n=t×da​​
代入计算得abd−abd=0\frac{ab}{d}-\frac{ab}{d}=0dab​−dab​=0
这时候我们就证明了一个定理
 由特殊解推到所有整数解的定理

设方程ax+by=cax+by=cax+by=c(其中a，b为非零整数)有一组整数解x=x0,y=y0x=x_0,y=y_0x=x0​,y=y0​，则方程的所有整数解可以表示为x=x0+bgcd(a,b)t，y=y0−agcd(a,b)tx=x_0+\frac{b}{gcd(a,b)}t，y=y_0-\frac{a}{gcd(a,b)}tx=x0​+gcd(a,b)b​t，y=y0​−gcd(a,b)a​t

我们开始考虑最大最小值
{x=x0+t×bdy=y0−t×ad\begin{cases} x=x_0+t\times\frac{b}{d}\\y=y_0-t\times\frac{a}{d} \end{cases}{x=x0​+t×db​y=y0​−t×da​​
我们可以发现当t增大的时候，x越来越大，y越来越小
由于增加减少的值太难写，我们考虑换元法。
令tx=t×bd，ty=t×adt_x=t\times\frac{b}{d}，t_y=t\times\frac{a}{d}tx​=t×db​，ty​=t×da​
既然是正整数，那么即求xmin≥1x_{min}\ge1xmin​≥1
代入上式可得
x0+ktx≥1x_0+kt_x\ge1x0​+ktx​≥1
变形即可得
k≥⌈1−x0tx⌉k\ge\lceil\frac{1-x_0}{t_x}\rceilk≥⌈tx​1−x0​​⌉
为什么是上取整因为k必须大于这个值
可得xmin=x0−⌈1−x0tx⌉x_{min}=x_0-\lceil\frac{1-x_0}{t_x}\rceilxmin​=x0​−⌈tx​1−x0​​⌉
xminx_minxm​in对应的y值正好就是ymaxy_{max}ymax​，若ymax&lt;0y_{max}&lt;0ymax​&lt;0 则无正整数解
懒的敲式子了


代码如下
#include&lt;iostream&gt;#include&lt;cmath&gt;#define ll long longusing namespace std;int T;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1;        y=0;        return a;    &#125;    ll d=exgcd(b,a%b,y,x);    y-=a/b*x;    return d;//这里求出的是gcd(a,b)&#125;int main()&#123;    cin&gt;&gt;T;ll qp(ll a,ll b,ll mod)&#123;    a%=mod;    ll res=1;    while(b&gt;0)&#123;        if(b&amp;1)&#123;            res=res*a%mod;        &#125;        a=a*a%mod;        b&gt;&gt;=1;    &#125;    return res;&#125;    while (T--)    &#123;        ll a,b,c,x,y;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        ll d=exgcd(a,b,x,y);        if(c%d!=0)&#123;//不能整除方程无解            cout&lt;&lt;-1&lt;&lt;endl;            continue;        &#125;        x=x*c/d,y=y*c/d;//求x0和y0        ll tx=b/d,ty=a/d;        ll k=ceil((1.0-x)/tx);        x+=tx*k;        y-=ty*k;//求xmin和ymax        if(y&lt;=0)&#123;//如果ymax&lt;0            ll ansy=y+ty*(ll)1*ceil((1.0-y)/ty);            cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;ansy&lt;&lt;endl;        &#125;else&#123;            cout&lt;&lt;(y-1)/ty+1&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;(y-1)%ty+1&lt;&lt;&quot; &quot;&lt;&lt;x+(y-1)/ty*tx&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;
总结以下就是这个结论

 9.快速幂

已知三个正整数a,b,c(a,b,c&lt;=105)a,b,c(a,b,c&lt;=10^5)a,b,c(a,b,c&lt;=105) 求abmod  ca^{b}\mod cabmodc

 9.1 朴素算法
直接模拟一个b次的循环，枚举a对b次乘法
int f(int a, int b, int c) &#123;    int ans = 1;    while(b--)        ans = ans * a;    return ans % c;&#125;
显然我们发现1010510^{10^5}10105 肯定在算的时候就炸INT了。
并且时间复杂度是O(b)O(b)O(b)的，时间复杂度不可以接受。
 9.2 模乘
abmod  c=(amod  c)(bmod  c)mod  cab\mod c=(a\mod c)(b\mod c)\mod cabmodc=(amodc)(bmodc)modc
证明贴一个别人的

改进如下
int f(int a, int b, int c) &#123;    a = (a % c + c) % c;    int ans = 1 % c;    while(b--)        ans = ans * a % c;    return ans;&#125;
但是时间复杂度并没有改善。
 9.3 二分快速幂
我们采用二分的思想，对原式进行分治法，有如下公式。
abmod  c={1mod  cb为0a(a(b−12)2mod  cb为奇数(ab/2)2mod  cb为偶数a^{b}\mod c=\begin{cases} 1\mod c &amp; b为0\\a(a^{(b-1}{2})^{2}\mod c &amp; b为奇数 \\ (a^{b/2})^2\mod c &amp; b为偶数 \end{cases}abmodc=⎩⎪⎪⎨⎪⎪⎧​1modca(a(b−12)2modc(ab/2)2modc​b为0b为奇数b为偶数​
于是我们可以利用程序的递归思想，把函数描述成如下形式
f(a,b,c)={1mod  cb为0af(a,b−12,c)2b为奇数f(a,b2,c)2b为偶数f(a,b,c)=\begin{cases} 1\mod c &amp; b为0\\ af(a,\frac{b-1}{2},c)^2 &amp; b为奇数 \\ f(a,\frac{b}{2},c)^2 &amp; b为偶数\end{cases}f(a,b,c)=⎩⎪⎪⎨⎪⎪⎧​1modcaf(a,2b−1​,c)2f(a,2b​,c)2​b为0b为奇数b为偶数​
代码如下：
ll qp(ll a,ll b,ll mod)&#123;    a%=mod;    ll res=1;    while(b&gt;0)&#123;        if(b&amp;1)&#123;            res=res*a%mod;        &#125;        a=a*a%mod;        b&gt;&gt;=1;    &#125;    return res;&#125;
注意如果乘法可能溢出，要使用龟速乘！
 10.欧拉函数
对于正整数nnn，欧拉函数是小于等于n的正整数中与n互素的个数，记为φ(n)\varphi(n)φ(n) (其中φ(1)=1\varphi(1)=1φ(1)=1)
即φ(n)=∑i=1n[gcd(i,n)=1]\varphi(n)=\sum\limits_{i=1}^n[gcd(i,n)=1]φ(n)=i=1∑n​[gcd(i,n)=1]
其中[A][A][A]表示当A成立时，[A]=1，反之[A]=0A成立时，[A]=1，反之[A]=0A成立时，[A]=1，反之[A]=0
对于素数ppp而言，小于等于ppp的数必然与他互素，故
φ(p)=p−1\varphi(p)=p-1φ(p)=p−1
对于素数的幂来说，有
φ(pk)=pk−pk−1\varphi(p^k)=p^k-p^{k-1}φ(pk)=pk−pk−1
对于素数ppp来说，有
φ(2p)=φ(p)\varphi(2p)=\varphi(p)φ(2p)=φ(p)
对于任意正整数n，有
n=∑d∣nφ(d)n=\sum\limits_{d|n}\varphi(d)n=d∣n∑​φ(d)
对于任意两个互素的数p,qp,qp,q，他们乘积的欧拉函数如下
φ(pq)=φ(p)×φ(q)\varphi(pq)=\varphi(p)\times\varphi(q)φ(pq)=φ(p)×φ(q)
利用算数基本定理可得

故有任意正整数n，有
φ(n)=n∏i=1k(1−1pi)\varphi(n)=n\prod^k_{i=1}(1-\frac{1}{p_i})φ(n)=n∏i=1k​(1−pi​1​)
 单个数的欧拉函数求解
我们可以用定义来做，那么只需要枚举iii，并求gcd(n,i)=1gcd(n,i)=1gcd(n,i)=1的满足个数。考虑算数唯一分解定理，和上面的一般式，我们可以枚举素数进行试除法
φ(n)=n∏i=1k(pi−1pi)\varphi(n)=n\prod^k_{i=1}(\frac{p_i-1}{p_i})φ(n)=n∏i=1k​(pi​pi​−1​)


当n=1的时候，返回1


当n&gt;1，用ans来记录最终的欧拉函数值，初始值为n


- 对[2,n][2,\sqrt{n}][2,n​]的素数进行试除，对于素数ppp，若满足p∣np|np∣n，则执行ans=ans/(i−1i)ans=ans/(\frac{i-1}{i})ans=ans/(ii−1​)，n/=in/=in/=i把她质数次方因子筛没

当某个时刻n=1的时候直接返回ans的值。若试除完后还有剩余说明n是一个素数，返回ans/(n−1n)ans/(\frac{n-1}{n})ans/(nn−1​)

代码如下
int phi(int n)&#123;    int ans=n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            ans=ans/i*(i-1);            while (n%i==0)            &#123;                n/=i;            &#125;        &#125;    &#125;    if(n&gt;=2)&#123;        ans=ans/n*(n-1);    &#125;    return ans;&#125;
先除后乘防止超Int范围
 欧拉筛
因为欧拉函数是积性函数，φ(xy)=φ(x)φ(y)\varphi(xy)=\varphi(x)\varphi(y)φ(xy)=φ(x)φ(y)
可得如下筛法，时间复杂度O(n)O(n)O(n)
phi[1]=1;    for(int i=2;i&lt;=n;i++)    &#123;        if(!vis[i]) p[++cnt]=i,phi[i]=i-1;//质数只有自身与自己不互质        for(int j=1;p[j]&amp;&amp;i*p[j]&lt;=n;j++)        &#123;            vis[i*p[j]]=1;            if(!(i%p[j]))            &#123;                phi[i*p[j]]=phi[i]*p[j];                //这里是平方因子了，不要减1                break;            &#125;            else phi[i*p[j]]=phi[i]*(p[j]-1);//第一次出现因子，乘p-1        &#125;    &#125;  
 11.积性函数
数论函数指定义域为正整数的函数。
若数论函数 fff 满足当 gcd⁡(a,b)=1\gcd(a,b)=1gcd(a,b)=1 且f(1)=1f(1)=1f(1)=1时 f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)，则 fff 为积性函数。
若数论函数 fff 满足任何正整数 a,ba,ba,b 有 f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)，则 fff 为完全积性函数。
 一些积性函数


单位函数 ϵ(n)=[n=1]\epsilon(n)=[n=1]ϵ(n)=[n=1]（完全积性）


常函数 1(n)=11(n)=11(n)=1（完全积性）


幂函数 Ik(n)=nkI_k(n)=n^kIk​(n)=nk


恒等函数 id(n)=n\mathrm{id}(n)=nid(n)=n，idk(n)=nk\mathrm{id}_k(n)=n^kidk​(n)=nk（完全积性）


因数和函数 σ(n)=∑d∣nd\sigma(n)=\sum_{d|n}dσ(n)=∑d∣n​d，σk(n)=∑d∣ndk\sigma_k(n)=\sum_{d|n}d^kσk​(n)=∑d∣n​dk


约数个数d(n)=σ0(n)=∑d∣n1d(n)=\sigma_0(n)=\sum_{d|n}1d(n)=σ0​(n)=∑d∣n​1


 1-1e18的函数取值对照表
经典永流传~

例题：CF920F

给定nnn个数的数组aaa，mmm次操作，操作有2种(1≤n,m≥3× 105,1≤ai≤1061 \le n,m \ge 3\times  10^5,1\le a_{i}\le 10^61≤n,m≥3× 105,1≤ai​≤106)



将i∈[l,r]i \in [l,r]i∈[l,r]中所有aia_iai​替换为d(ai)d(a_i)d(ai​)




求∑i=lrai\sum\limits_{i=l}^{r}a_ii=l∑r​ai​


这里阐述一个估算d(x)d(x)d(x)的方法


对于任意正整数xxx，一定有d(x)≤3xd(x)\le \sqrt{3x}d(x)≤3x​


对于x&gt;1260x&gt;1260x&gt;1260，一定有d(x)&lt;xd(x)&lt;\sqrt{x}d(x)&lt;x​


那么这个题很好做，不难根据表发现当ai=106,d(ai)=240a_i=10^6,d(a_i)=240ai​=106,d(ai​)=240。线段树维护，单点暴力修改，注意要打tag来保持复杂度。
故有代码：
#include&lt;bits/stdc++.h&gt;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1#define ll long longusing namespace std;const int MN=3e5+15,MA=1e6+15;template&lt;typename type&gt;inline void read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();    flag?x=-x:0;&#125;struct segtree&#123;    int l,r;    bool isok;    ll sum;&#125;t[MN&lt;&lt;2];ll a[MN];int n,m;  //https://wenku.baidu.com/view/9e336795bb4cf7ec4afed057.html?_wkts_=1739964897460&amp;needWelcomeRecommand=1//对于任意正整数n,有d(n)&lt;=sqrt(3*n)//对于n&gt;1260，有d(n)&lt;sqrt(n)  //d是约数个数，时间复杂度线性筛O(n)// num是最小素因子个数，用于筛约数int d[MA],num[MA];vector&lt;bool&gt; vis(MA);vector&lt;int&gt; prime;  void pushup(int p)&#123;    t[p].sum=t[ls].sum+t[rs].sum;    if(t[ls].isok==1&amp;&amp;t[rs].isok==1)&#123;        t[p].isok=1;    &#125;&#125;  void build(int p,int l,int r)&#123;    t[p].l=l;    t[p].r=r;    if(l==r)&#123;        t[p].sum=a[l];        if(t[p].sum==1||t[p].sum==2)&#123;            t[p].isok=1;        &#125;        return;    &#125;    int mid=l+r&gt;&gt;1;    build(ls,l,mid);    build(rs,mid+1,r);    pushup(p);&#125;  void update(int p,int fl,int fr)&#123;    if(t[p].isok) return;    if(t[p].l==t[p].r)&#123;        t[p].sum=d[t[p].sum];        if(t[p].sum==1||t[p].sum==2) t[p].isok=1;        return;    &#125;    int mid=t[p].l+t[p].r&gt;&gt;1;    if(mid&gt;=fl) update(ls,fl,fr);    if(mid&lt;fr) update(rs,fl,fr);    pushup(p);&#125;  ll query(int p,int fl,int fr)&#123;    if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;        return t[p].sum;    &#125;    ll ret=0;    int mid=t[p].l+t[p].r&gt;&gt;1;    if(mid&gt;=fl)ret+=query(ls,fl,fr);    if(mid&lt;fr) ret+=query(rs,fl,fr);    return ret;&#125;  void getd()&#123;    d[1]=1;    for(int i=2;i&lt;MA;i++)&#123;        if(!vis[i])&#123;            prime.push_back(i);            d[i]=2;            num[i]=1;        &#125;        for(int j=0;1ll*i*prime[j]&lt;MA&amp;&amp;j&lt;prime.size();j++)&#123;            vis[i*prime[j]]=1;            if(i%prime[j]==0)&#123;                num[i*prime[j]]=num[i]+1;                d[i*prime[j]]=d[i]/(num[i]+1)*(num[i*prime[j]]+1);                break;            &#125;else&#123;                d[i*prime[j]]=d[i]*2;                num[i*prime[j]]=1;            &#125;        &#125;    &#125;&#125;  int main()&#123;    ios::sync_with_stdio(0);    getd();    read(n);    read(m);    for(int i=1;i&lt;=n;i++)&#123;        read(a[i]);    &#125;    int op,x,y;    build(1,1,n);    while (m--)    &#123;        read(op);        read(x);        read(y);        if(op==1)&#123;            update(1,x,y);        &#125;else&#123;            cout&lt;&lt;query(1,x,y)&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;  &#125;
 12.欧拉定理与费马小定理
 12.1 欧拉定理

nnn和aaa为正整数，且n,an,an,a互素，则aφ(n)≡1(mod  n)a^{\varphi(n)} \equiv 1(\mod n)aφ(n)≡1(modn)

证明？

推论：

若正整数 a,ba,ba,b 互质则满足 ax≡1(modb)a^x \equiv 1 \pmod bax≡1(modb) 的最小正整数解 x0x_0x0​ 是 φ(b)\varphi(b)φ(b) 的约数

可以用欧拉定理反证法证明。
例题：洛谷P1463_POI_2001_HAOI_2007_反素数
 12.2 费马小定理

若ppp为素数，gcd(a,p)=1gcd(a,p)=1gcd(a,p)=1，则ap−1≡1(mod  p)a^{p-1}\equiv 1(\mod p)ap−1≡1(modp)
对于任意整数aaa，有ap≡a(mod  p)a^p\equiv a(\mod p)ap≡a(modp)


 12.2.1 判定素数
我们回到判定素数的那一节，如果我们要判定的范围超过的101210^{12}1012，那么就无法使用O(n)O(\sqrt{n})O(n​)的算法来求解。
我们可以用费马小定理，随机找几个和nnn互素的aaa。
计算an−1mod  na^{n-1} \mod nan−1modn
若结果均为1，那么认为nnn，是一个素数。这样的时间复杂度O(Clog2n)O(Clog_2n)O(Clog2​n)，常数C表示找C个a来测试。
但是，以上假设不成立！
因为在费马小定理的条件中，若置换条件。
若ap−1≡1(mod  p)a^{p-1}\equiv 1(\mod p)ap−1≡1(modp)，不能推导出ppp是素数
例如561，这一类数我们称其为伪素数，又称为卡迈克尔数，在 n≤109n\le 10^9n≤109 内有 255 个。
若 nnn 为卡迈克尔数，则 2n−12^n-12n−1 也是卡迈克尔数，故其个数是无穷的。
 12.2.2 Miller_Rabin算法
Miller Rabin素性检验是一种素数判定的法则，由CMU的教授Miller首次提出，并由希大的Rabin教授作出修改，变成了今天竞赛人广泛使用的一种算法，故称Miller Rabin素性检验。
本质其实是随机化算法，能在时间复杂度为 O(Clog⁡3n)O(C \log^3 n)O(Clog3n) 的情况下判断（这里 CCC 同上），但是具有一定错误概率，但是在 OI 范围内能保证步出错。
既然我们单纯费马小定理无法判断，我们只好引入新的定理来提高我们的正确性。

二次探测定理：对于质数 ppp，若 x2≡1(modp)x^2 \equiv 1 \pmod px2≡1(modp)，则小于 ppp 的解只有两个，x1=1,x2=p−1x_1=1,x_2=p-1x1​=1,x2​=p−1。

证明：
x2≡1(modp)x2−1≡0(modp)(x+1)(x−1)≡0(modp)p∣(x+1)(x−1)∵p是质数∴{x1=1x2=p−1\begin{aligned}
x^2 &amp; \equiv 1 \pmod p \\
x^{2}-1 &amp; \equiv 0 \pmod p \\
(x+1)(x-1) &amp; \equiv 0 \pmod p \\
  p   &amp;| (x+1)(x-1) \\ \\
\because  &amp;p \text{是质数} \\ \\
\therefore 
&amp;\begin{cases}
x_1=1  \\
 x_{2}= p-1\\
\end{cases}
\end{aligned}
x2x2−1(x+1)(x−1)p∵∴​≡1(modp)≡0(modp)≡0(modp)∣(x+1)(x−1)p是质数{x1​=1x2​=p−1​​
这个定理有什么用？
如果费马小定理检测得到 ap−1≡1(modp)a^{p-1} \equiv 1 \pmod pap−1≡1(modp)，并且 p−1p-1p−1 为偶数（否则 ppp 为偶数直接被筛了），则 ap−1a^{p-1}ap−1 相当于 x2x^2x2。
拆分为 (ap−12)2≡1(modp)\left(a^{\dfrac{p-1}{2}}\right)^2 \equiv 1 \pmod p⎝⎛​a2p−1​⎠⎞​2≡1(modp)，可以用二次检测定理判断。
如果 ap−12a^{\frac{p-1}{2}}a2p−1​ 在 (modp)\pmod p(modp) 的情况下的解不是 1 或者 p−1p-1p−1，那么 ppp 就不是素数。
如果 (ap−12)2≡1(modp)\left(a^{\frac{p-1}{2}}\right)^2 \equiv 1 \pmod p(a2p−1​)2≡1(modp)，可以模仿之前操作在进行一次检验，变判断 ap−14a^{\frac{p-1}{4}}a4p−1​，不断执行直到为计数。
也就是说，我们可以将 p−1=u×2tp-1=u\times 2^tp−1=u×2t，其中 uuu 为奇数。对于 au,au×2,au×22…a^u,a^{u\times 2},a^{u \times 2^2} \dotsau,au×2,au×22…这一系列数进行检验，他们的解要么是 1 要么出现 p−1p-1p−1 后全是 1 （前面不能出现1），否则就不是素数，当然要注意 p−1p-1p−1 不能出现在最后一个数否则不满足费马小定理，还要注意过程中不能产生 ppp 的倍数。
过程如下：

先特判 3 以下的数和偶数
将 n−1n-1n−1 化为 u×2tu\times 2^tu×2t。
选取多个底数 aaa，对 au,au×2,au×22…a^u,a^{u\times 2},a^{u \times 2^2} \dotsau,au×2,au×22…进行检验，判断解是否全为 1，或在非最后一个数的情况下出现 p−1p-1p−1。
如果都满足，则认为为素数。

板子题：SP288——PON
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr ll prime[]=&#123;2,3,5,7,11,13,17,37&#125;;ll qmul(ll a,ll b,ll MOD)&#123;    ll ret=0;    while(b)&#123;        if(b&amp;1) ret=(ret+a)%MOD;        b&gt;&gt;=1;        a=(a+a)%MOD;    &#125;    return ret;&#125;ll qpow(ll a,ll b,ll MOD)&#123;    ll ret=1;    while(b)&#123;        if(b&amp;1) ret=qmul(ret,a,MOD);        a=qmul(a,a,MOD);        b&gt;&gt;=1;    &#125;    return ret;&#125;bool MillerRabin(ll n)&#123;    if(n&lt;3||n%2==0) return n==2;    ll d=n-1,tot=0;    while(d%2==0) d/=2,++tot;    for(auto p:prime)&#123;        ll v=qpow(p,d,n);        if(v==1||v==n-1||v==0) continue;        for(int j=1;j&lt;=tot;j++)&#123;            v=qmul(v,v,n);            if(v==n-1&amp;&amp;j!=tot)&#123;                v=1;                break;            &#125;            if(v==1) return 0;        &#125;        if(v!=1) return 0;    &#125;    return 1;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        ll n;        cin&gt;&gt;n;        cout&lt;&lt;(MillerRabin(n)?&quot;YES\n&quot;:&quot;NO\n&quot;);    &#125;    return 0;&#125;
 12.2.2 二分快速幂降幂

给出一个大整数n(1≤n≤10100000)n(1\le n \le 10^{100000})n(1≤n≤10100000)


求2nmod  1e9+72^n\mod 1e9+72nmod1e9+7

令x=p−1x=p-1x=p−1，由费马小定理得
2p−1mod  p=12^{p-1}\mod p=12p−1modp=1

m=nmod  (p−1)m=n\mod(p-1)m=nmod(p−1) 可以用大数取余求解，求得的m∈[0,p−1)m \in [0,p-1)m∈[0,p−1)，再利用快速幂求解即可。
 12.3 拓展欧拉定理
说到这里，我们先来看看欧拉定理的局限性

欧拉定理：


nnn和aaa为正整数，且n,an,an,a互素，则aφ(n)≡1(mod  n)a^{\varphi(n)} \equiv 1(\mod n)aφ(n)≡1(modn)

不难发现，局限性在于互素，即gcd(a,n)=1gcd(a,n)=1gcd(a,n)=1，那么如果不互素，怎么办？这时候就要用到“拓展欧拉定理”了
拓展欧拉定理如下：
定义：
ab≡{a(bmod  φ(m))gcd(a,m)=1abgcd(a,m)≠1,b&lt;φ(m)a((b+φ( mod φ(m))gcd(a,m)≠1,(b≥φ(m) (mod    m)a^b \equiv \begin{cases} a^{(b \mod \varphi(m))} &amp; gcd(a,m)=1 \\ a^b &amp; gcd(a,m) \ne 1,b&lt; \varphi(m) \\ a^{((b+\varphi(\,mod \,\varphi(m))} &amp; gcd(a,m)\ne 1,(b\ge \varphi(m)  \end{cases} \quad (mod\,\,\,\,m)
ab≡⎩⎪⎪⎨⎪⎪⎧​a(bmodφ(m))aba((b+φ(modφ(m))​gcd(a,m)=1gcd(a,m)=1,b&lt;φ(m)gcd(a,m)=1,(b≥φ(m) ​(modm)
其中第二行的意思，若gcd(a,m)≠1,b&lt;φ(m)gcd(a,m) \ne 1,b&lt; \varphi(m)gcd(a,m)=1,b&lt;φ(m)那么是不能降幂的。
题目中的mmm不会太大，但是如果b&lt;φ(m)b&lt;\varphi(m)b&lt;φ(m)，复杂度可以用快速幂求解，但是大于那么就会问题，所以就要靠降幂来实现。
证明略（啊？）
应用：
 12.3.1 拓展欧拉定理的应用
P5091 【模板】扩展欧拉定理

求abmod  ma^b \mod mabmodm


其中1≤a≤109,1≤b≤1020000000,1≤m≤1081\le a\le 10^9,1\le b\le10^{20000000},1\le m \le 10^81≤a≤109,1≤b≤1020000000,1≤m≤108

十分甚至九分的恐怖，甚至都没有互素，直接套上去看看。
φ(x)\varphi(x)φ(x)可以用线性筛求得，但是bbb过大，我们可以用边读入边取余的方式。
代码？
#include&lt;iostream&gt;#define ll long longusing namespace std;int phi(int n)&#123;    int ans=n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            ans=ans/i*(i-1);            while (n%i==0)            &#123;                n/=i;            &#125;        &#125;    &#125;    if(n&gt;=2)&#123;        ans=ans/n*(n-1);    &#125;    return ans;&#125;inline int read(int mod)&#123;    int x=0;    bool g=false;    char c=getchar();    while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) c=getchar();    while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)    &#123;        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^&#x27;0&#x27;);        if(x&gt;=mod) x%=mod,g=true;//判断是否大于哦啦函数        c=getchar();    &#125;    if(g) return (x+mod);    else return x;&#125;ll quickpow(ll a,ll b,ll mod)&#123;    ll ret=1;    while (b)    &#123;        if (b&amp;1)&#123;            ret=ret*a%mod;        &#125;        a=a*a%mod;        b&gt;&gt;=1;    &#125;    return ret%mod;&#125;int main()&#123;    ll a,mod,cishu;    cin&gt;&gt;a&gt;&gt;mod;    cishu=read(phi(mod));    cout&lt;&lt;quickpow(a,cishu,mod);    return 0;&#125;
 13.逆元与线性同余方程
定义：
形如
ax≡b   (mod m)ax \equiv b \,\,\, (mod \,m)
ax≡b(modm)
的方程称为线性同余方程，其中a,b,ma,b,ma,b,m均已知，但是xxx未知。从[0,m−1][0,m-1][0,m−1]中求解xxx，xxx不唯一需求出全体解。
 13.1 逆元求解
逆元可以理解为模意义下的除法，符号为a−1a^{-1}a−1（暴论）
可以理解为倒数eee，然而实际上不是倒数，人家就叫做逆元。
考虑最简单的情况，gcd(a,m)=1gcd(a,m)=1gcd(a,m)=1即互素时，可以计算aaa的逆元，并将方程两边乘以aaa的逆元，得到唯一解。

线性方程组解的数量等于gcd(a,n)gcd(a,n)gcd(a,n)或等于0（即无解）
 13.2 拓展欧几里得算法求解
我们可以将取余的式子改写为如下的形式：
ax+ny=bax+ny=b
ax+ny=b
不难发现可以用拓展欧几里得算法求解该方程，得一组解，在通过之前上面讲过的单一解求通解，在拓展到全体解，即可得到。
其实说实话这两个不是一种东西吗…
其实是等价的。
例题：
  P1082 [NOIP2012 提高组] 同余方程

求关于 xxx 的同余方程 ax≡1(modb)ax \equiv 1 \pmod {b}ax≡1(modb) 的最小正整数解。

不是这个题怎么又上来了？
然而实际上这个题刚好就能作为例题eee
代码重放
#include&lt;iostream&gt;#define ll long longusing namespace std;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1;        y=0;        return;    &#125;    exgcd(b,a%b,y,x);    y-=a/b*x;&#125;int main()&#123;    ll a,b,x,y;    cin&gt;&gt;a&gt;&gt;b;    exgcd(a,b,x,y);    cout&lt;&lt;(x%b+b)%b;    return 0;&#125;
 13.3 快速幂求解逆元
乘法逆元就是求abmod  p=a×xmod  p\frac{a}{b} \mod p=a\times x \mod pba​modp=a×xmodp中的xxx。
那么也就是说ab≡a×x (mod p)\frac{a}{b} \equiv a\times x \,\text{(mod p)}ba​≡a×x(mod p)
那么有1≡b×x (mod p)1\equiv b\times x \,\text{(mod p)}1≡b×x(mod p)
由费马小定理可得当ppp为质数时逆元为x=b(p−2)x=b^{(p-2)}x=b(p−2)
快速幂即可求解。
 13.4 阶乘逆元O(n)
留存一份，一般是先exgcd或快速幂求解f[n]f[n]f[n]，让后倒序递推，一定注意开long long！
    jc[0] = 1;    for (int i = 1; i &lt;= 1e5; i++)    &#123;        jc[i] = (i * jc[i - 1]) % MOD;    &#125;    ll x, y;    inv[100000] = binpow(jc[100000], MOD - 2);    for (int i = 100000 - 1; i &gt;= 0; i--)    &#123;        inv[i] = inv[i + 1] * (i + 1) % MOD;    &#125;
 14.线性同余方程组——中国剩余定理（EXTRA！）

「物不知数」问题：有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？

答：我不会，我不会，我不会，啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊┗( T﹏T )┛
 14.1 中国剩余定理
中国剩余定理可以求解如下的一元线性同余方程组。
{x≡a1mod  n1x≡a2mod  n2     ⋮x≡anmod  nk\begin{cases} x\equiv a_{1} \mod n_{1}\\ x\equiv a_{2} \mod n_{2} \\ \space \space \space\ \ \vdots \\ x\equiv a_{n} \mod n_{k}\end{cases}
⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x≡a1​modn1​x≡a2​modn2​     ⋮x≡an​modnk​​
其中n1,n2…nkn_1,n_{2} \ldots n_{k}n1​,n2​…nk​两两互质
方法：


计算所有模数的积：nnn


对于第iii个方程：


- 计算mi=nnim_i=\frac{n}{n_i}mi​=ni​n​
- 计算mim_imi​在模nin_ini​意义下的逆元mi−1m_i^{-1}mi−1​
- 计算ci=mi∗mi−1c_i=m_{i}* m_i^{-1}ci​=mi​∗mi−1​ (不要取模！)

方程组在模nnn意义下的唯一解为$$x=\sum\limits_{i=1}^k a_ic_i$$

P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪
实现代码如下：
#include&lt;iostream&gt;#define ll long longusing namespace std;const int MN=1e5+15;int a[MN],b[MN],n;ll mt=1;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1;        y=0;        return a;    &#125;    ll d=exgcd(b,a%b,y,x);    y-=a/b*x;    return d;&#125;ll inv(ll a,ll n)&#123;    ll x,y;    exgcd(a,n,x,y);    return (x%n+n)%n;&#125;long long quick_mul(long long x,long long y,long long mod)&#123;    long long ans=0;    while(y!=0)&#123;        if(y&amp;1==1)ans+=x,ans%=mod;        x=x+x,x%=mod;        y&gt;&gt;=1;    &#125;    return ans;&#125;ll crt()&#123;    ll ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ll m=mt/a[i],invm=inv(m,a[i]);//exgcd求逆元        ll ci=m*invm;        ans=(ans+quick_mul(b[i],ci,mt))%mt;//使用龟速乘    &#125;    return (ans%mt+mt)%mt;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i]&gt;&gt;b[i];        mt*=a[i];    &#125;    cout&lt;&lt;crt();    return 0;&#125;
 14.2 EXCRT拓展中国剩余定理
{x≡a1mod  n1x≡a2mod  n2     ⋮x≡anmod  nk\begin{cases} x\equiv a_{1} \mod n_{1}\\ x\equiv a_{2} \mod n_{2} \\ \space \space \space\ \ \vdots \\ x\equiv a_{n} \mod n_{k}\end{cases}
⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x≡a1​modn1​x≡a2​modn2​     ⋮x≡an​modnk​​
其中n1,n2…nkn_1,n_{2} \ldots n_{k}n1​,n2​…nk​两两互质，这样我们当然是可以用CRT来解决的，但是如果不互质怎么办？就需要用到拓展中国剩余定理。
与中国剩余定理的区别在哪里？在于我们需要合并方程才能做，例如合并上面两个式子：
x≡a1mod  n1x\equiv a_{1} \mod n_{1}x≡a1​modn1​
x≡a2mod  n2x \equiv a_{2}\mod n_2x≡a2​modn2​
合并为：x≡a′mod  (n1n2/gcd(m1,m2))x\equiv a&#x27; \mod (n_1n_{2}/ gcd(m_1,m_2))x≡a′mod(n1​n2​/gcd(m1​,m2​))
若合并了所有方程，那么得到的解即为最终解。
证明：
根据方程可变形为：
x≡a1+n1y1x\equiv a_1+n_1y_1x≡a1​+n1​y1​
x≡a2+n2y2x\equiv a_2+n_2y_2x≡a2​+n2​y2​
可得：a1+n1y1=a2+n2y2⇒n1y1−m2y2=a2−a1a_1+n_1y_1=a_2+n_2y_{2}\Rightarrow n_1y_1-m_2y_2=a_2-a_1a1​+n1​y1​=a2​+n2​y2​⇒n1​y1​−m2​y2​=a2​−a1​
转换为经典的ax+by=cax+by=cax+by=c的格式，先用exgcd求出ax+by=gcd(a,b)ax+by=gcd(a,b)ax+by=gcd(a,b)的解。
通过上面变形过的方程够再出一个mod  m1m2/gcd(m1,m2)\mod m_1m_2/gcd(m_1,m_2)modm1​m2​/gcd(m1​,m2​)的解
即得证。
代码如下：
#include&lt;iostream&gt;#define ll long longusing namespace std;const int MN=1e5+15;ll md[MN],b[MN],mt; // md数组存储模数，b数组存储余数，mt未使用int n; // 同余方程的数量  // 慢速乘法：计算 (a*b) % mod，使用快速乘法算法避免溢出ll slowti(ll a,ll b,ll mod)&#123;    ll ret=0;    while (b&gt;0)    &#123;        if(b&amp;1) ret=(ret+a)%mod; // 如果b的最低位是1，累加a        a=(a+a)%mod; // a乘以2        b&gt;&gt;=1; // b右移一位    &#125;    return ret;&#125;  // 扩展欧几里得算法：解ax + by = gcd(a,b)ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(!b)&#123;        x=1; // 基础情况处理        y=0;        return a; // 返回gcd    &#125;    // 递归调用，交换x和y的位置    ll ret=exgcd(b,a%b,y,x);    y-=a/b*x; // 更新y的值    return ret;&#125;  // 扩展中国剩余定理(EXCRT)：求解同余方程组ll excrt()&#123;    ll x,y; // 用于存储exgcd的解    ll m1=md[1],b1=b[1]; // 初始化第一个方程    ll ans=(b1%m1+m1)%m1; // 初始解    for(int i=2;i&lt;=n;i++)&#123;        ll m2=md[i],b2=b[i]; // 当前方程的模数和余数        // 合并方程为 m1*x ≡ (b2-b1) mod m2        ll a=m1,b=m2,c=(b2-b1%m2+m2)%m2; // c = (b2-b1) mod m2        // 求解方程 a*x + b*y = c        ll d=exgcd(a,b,x,y); // d是gcd(a,b)        // 如果c不能被d整除，无解        if(c%d!=0)&#123;            return -1;        &#125;        // 调整x的解        x=slowti(x,c/d,b/d);        // 计算新的解        ans=b1+x*m1;        // 更新模数为lcm(m1,m2) = m1*m2/d        m1=m2/d*m1;        // 确保解在模m1意义下最小非负        ans=(ans%m1+m1)%m1;        // 更新b1为当前解        b1=ans;    &#125;    return ans;&#125;  int main()&#123;    cin&gt;&gt;n; // 输入同余方程的数量    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;md[i]&gt;&gt;b[i]; // 输入每个方程的模数和余数    &#125;    cout&lt;&lt;excrt(); // 输出解    return 0;&#125;
 15.数论分块
 15.1 数论分块引入

求∑i=1n⌊ni⌋\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloori=1∑n​⌊in​⌋，其中n≤1012n\le 10^{12}n≤1012

第一眼看上去是不可做题，因为如果我们直接暴力枚举的话是肯定不行的，因为我们枚举到10910^9109就做不动了，这个时候就要清楚数论分块。
我们比如果举例一个函数，比如果y=15xy=\frac{15}{x}y=x15​罢，他的函数图像如下：

我们根据题意，把他的下取整表示出来（图中红色）：

有没有发现什么，发现对应的下取整都是一个横线端（这不废话吗)，而且是分成一小段一小段的。
或者我们搬一个图来举例（出处vvauted的数论分块：

没错，数论分块中的分块就是看中的这一点,图像中是被分割成了几个大块，只要我们不断枚举块，就能显著的降低时间复杂度！
但是问题在于我们怎么知道每个块的右端点？这里给出一个引理。
对于任意一个iii，其最大的满足⌊ni⌋=⌊nj⌋\lfloor \frac{n}{i} \rfloor=\lfloor \frac{n}{j} \rfloor⌊in​⌋=⌊jn​⌋的 jjj 满足：
j=⌊n⌊ni⌋⌋j=\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor}\rfloor
j=⌊⌊in​⌋n​⌋
证明如下：
⌊ni⌋≤ni\lfloor \frac{n}{i} \rfloor \le \frac{n}{i}⌊in​⌋≤in​
⌊n⌊ni⌋⌋≥⌊nni⌋\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor}\rfloor \ge \lfloor \frac{n}{\frac{n}{i}}\rfloor⌊⌊in​⌋n​⌋≥⌊in​n​⌋
⌊n⌊ni⌋⌋≥i\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor}\rfloor \ge i⌊⌊in​⌋n​⌋≥i
得证。
复杂度分析：
当x∈[1,⌊n⌋]x\in[1,\lfloor \sqrt{n} \rfloor]x∈[1,⌊n​⌋]的区间时最多有⌊n⌋\lfloor \sqrt{n} \rfloor⌊n​⌋个取值
当x∈[⌊n⌋,n]x\in[\lfloor \sqrt{n} \rfloor,n]x∈[⌊n​⌋,n]同理仍最多有⌊n⌋\lfloor \sqrt{n} \rfloor⌊n​⌋个取值。
共2⌊n⌋2\lfloor \sqrt{n} \rfloor2⌊n​⌋的值，时间复杂度即O(n)O(\sqrt{n})O(n​)
 15.2.1 例题1： 约数研究

求∑i=1nf(i)\sum\limits_{i=1}^{n}f(i)i=1∑n​f(i)，其中n≤106n\le 10^6n≤106


f(i)f(i)f(i)即iii的约束个数

对于iii，我们在[1,n][1,n][1,n]中的约数个数就是⌊ni⌋\lfloor \frac{n}{i} \rfloor⌊in​⌋，那么原命题转化为：
∑i=1nf(i)=∑i=1n⌊ni⌋\sum\limits_{i=1}^n f(i)=\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloor
i=1∑n​f(i)=i=1∑n​⌊in​⌋
那么其实可以直接O(n)O(n)O(n)暴力就可以了，所以说吗这个题难度其实是个橙题。
但是如果n≤1014n\le 10^{14}n≤1014呢？那么就可以数论分块楼。
我们考虑一个块怎么贡献，根据式子，其实就是(r−l+1)×⌊ni⌋(r-l+1)\times \lfloor \frac{n}{i} \rfloor(r−l+1)×⌊in​⌋。
那么代码也就如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main()&#123;    ll n,ans=0;    cin&gt;&gt;n;    for(ll i=1,j;i&lt;=n;i=j+1)&#123;        j=n/(n/i);        ans+=(j-i+1)*(n/i);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 15.2.2 余数求和

给定n,kn,kn,k，求：∑i=1nkmod  n\sum\limits_{i=1}^n k \mod ni=1∑n​kmodn
n,k≤109n,k\le 10^9n,k≤109

这个题很有数论分块的感觉，毕竟这已经不能O(n)O(n)O(n),必须出分块！
简单转换一下，把取模变成如下式子：
∑i=1nk−⌊ki⌋×i\sum\limits_{i=1}^{n} k-\lfloor \frac{k}{i} \rfloor \times i
i=1∑n​k−⌊ik​⌋×i
=n×k−∑i=1n⌊ki⌋×i=n\times k - \sum\limits_{i=1}^n \lfloor \frac{k}{i} \rfloor \times i
=n×k−i=1∑n​⌊ik​⌋×i
直接数论分块就可以了，但是这个我们再算贡献的时候与∑i=lri\sum\limits_{i=l}^r ii=l∑r​i，需要等差数列一下。
那么代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,k,ret=0;ll getsum(ll l,ll r)&#123;    if(r&gt;n) r=n;    return (r-l+1)*(l+r)/2;&#125;  int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    ret+=n*k;    for(ll i=1,j;i&lt;=n;i=j+1)&#123;        if(k/i==0) break;        j=k/(k/i);        if(j&gt;n) j=n;        ret-=(k/i)*getsum(i,j);    &#125;    cout&lt;&lt;ret;    return 0;&#125;
 15.2.3 约数求和PLUS

定义f(n)=∑i∣nif(n)=\sum\limits_{i|n} if(n)=i∣n∑​i，给定x,yx,yx,y求区间[x,y][x,y][x,y]的fff和


x,y≤109x,y \le 10^9x,y≤109

简单的拆成两个前缀和的形式，现在只需要求出[1,n][1,n][1,n]的答案怎么求，可以想到转化成如下式子：
∑i=1nf(i)=∑i=1n∑k∣ik\sum\limits_{i=1}^n f(i)=\sum\limits_{i=1}^n\sum\limits_{k|i} k
i=1∑n​f(i)=i=1∑n​k∣i∑​k
交换一下求和顺序：
∑k=1n∑k∣ik(k≤n)\sum\limits_{k=1}^n\sum\limits_{k|i}k(k\le n)
k=1∑n​k∣i∑​k(k≤n)
不难发现转化为了约数为k的数的前缀和，那么直接做就可以了。即为∑k=1nk×⌊nk⌋\sum\limits_{k=1}^{n} k\times \lfloor \frac{n}{k} \rfloork=1∑n​k×⌊kn​⌋
那么直接写就没了。。。代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,m;  ll getsum(ll l,ll r)&#123;    return (r-l+1)*(l+r)/2;&#125;  int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    n--;    ll retn=0,retm=0;    for(ll i=1,j;i&lt;=n;i=j+1)&#123;        j=n/(n/i);        retn+=(n/i)*getsum(i,j);    &#125;    for(ll i=1,j;i&lt;=m;i=j+1)&#123;        j=m/(m/i);        retm+=(m/i)*getsum(i,j);    &#125;    cout&lt;&lt;retm-retn;    return 0;&#125;
这个只是属于一个工具，如果考这个复杂度是显然可以观察出来的，往下取整的式子推就可以了。
 16.狄利克雷卷积
证明一般可能省略或给出。
狄利克雷卷积，是定义在数论函数间的一种二元运算，有如下两个等价定义：
(f∗g)(n)=∑xy=nf(x)g(y)(f*g)(n)=\sum\limits_{xy=n}f(x)g(y)
(f∗g)(n)=xy=n∑​f(x)g(y)
或如下等价式：
(f∗g)(n)=∑d∣nf(d)g(nd)(f*g)(n)=\sum\limits_{d|n}f(d)g(\frac{n}{d})
(f∗g)(n)=d∣n∑​f(d)g(dn​)
积性函数之间的狄利克雷卷积有一个重要的性质：

若f,gf,gf,g是积性函数，那么f∗gf*gf∗g也是积性函数。

证明如下：
显然有(f∗g)(1)=f(1)g(1)=1(f*g)(1)=f(1)g(1)=1(f∗g)(1)=f(1)g(1)=1，我们不妨设a,ba,ba,b互质，有：
(f∗g)(a)=∑d∣af(d)g(ad),(f∗g)(b)=∑d∣bf(d)g(bd)(f*g)(a)=\sum\limits_{d|a}f(d)g(\frac{a}{d}),(f*g)(b)=\sum\limits_{d|b}f(d)g(\frac{b}{d})
(f∗g)(a)=d∣a∑​f(d)g(da​),(f∗g)(b)=d∣b∑​f(d)g(db​)
(f∗g)(ab)=∑d∣abf(d)g(abd)(f*g)(ab)=\sum\limits_{d|ab}f(d)g(\frac{ab}{d})
(f∗g)(ab)=d∣ab∑​f(d)g(dab​)
注意到：
\begin{align}
\sum\limits_{d|a}f(d)g(\frac{a}{d}) \cdot \sum\limits_{d|b}f(d)g(\frac{b}{d}) &amp; = \sum\limits_{d_1|a,d_2|b}f(d_1)g(\frac{a}{d_1}) \cdot f(d_2)g(\frac{b}{d_2})\\
\sum\limits_{d|a}f(d)g(\frac{a}{d}) \cdot \sum\limits_{d|b}f(d)g(\frac{b}{d}) &amp; = \sum\limits_{d_1|a,d_2|b}f(d_1d_2)g(\frac{ab}{d_1d_2})
\end{align}

因为a,ba,ba,b互质，那么ababab的因数可以唯一的表示a,ba,ba,b的某个因数。
那么若f,gf,gf,g是积性函数，那么f∗gf*gf∗g也是积性函数这一结论得证，同时我们也证明了如下式子：

(f∗g)(a)⋅(f∗g)(b)=(f∗g)(ab)(f*g)(a) \cdot (f*g)(b) =(f*g)(ab)(f∗g)(a)⋅(f∗g)(b)=(f∗g)(ab)

 16.1 除数函数与幂函数
根据定义有(f∗1)(n)=∑d∣nf(d)1(nd)=∑d∣nf(d)(f*1)(n)=\sum\limits_{d|n}f(d)1(\frac{n}{d})=\sum\limits_{d|n}f(d)(f∗1)(n)=d∣n∑​f(d)1(dn​)=d∣n∑​f(d)
所以得：
(Idk∗1)(n)=∑d∣nIdk(d)=∑d∣ndk=σk(Id_k * 1)(n)  =\sum\limits_{d|n} Id_k(d)  =\sum\limits_{d|n} d^k  = \sigma _k 
(Idk​∗1)(n)=d∣n∑​Idk​(d)=d∣n∑​dk=σk​
 16.2 欧拉函数与恒等函数
因为：
(φ∗1)(n)=∑d∣nφ(d)(\varphi * 1)(n)=\sum\limits_{d|n} \varphi(d)
(φ∗1)(n)=d∣n∑​φ(d)
当d=pmd=p^md=pm时（ppp为质数），有：
∑d∣nφ(d)=φ(1)+∑i=1mφ(pi)=pm=d\sum\limits_{d|n} \varphi(d) =\varphi(1)+\sum\limits_{i=1}^m \varphi(p^i) = p^m  = d
d∣n∑​φ(d)=φ(1)+i=1∑m​φ(pi)=pm=d
那么可得(φ∗1)(pm)=pm(\varphi * 1)(p^m)=p^m(φ∗1)(pm)=pm
那么现在设nnn为任意正整数时，由算数唯一分解定理，并且(φ∗1)(pm)(\varphi * 1)(p^m)(φ∗1)(pm)显然为积性函数，那么根据算数唯一分解定理，因为带入一个质数的任意方仍和原值相同，那么带入之后其实和带入之前是一模一样的，即：
(φ∗1)(Πpm)=Π(φ∗1)(pm)=Πpm(\varphi * 1)(\Pi p^m)=\Pi (\varphi * 1)(p^m)=\Pi p^m
(φ∗1)(Πpm)=Π(φ∗1)(pm)=Πpm
即得：
(φ∗1)(n)=n(\varphi * 1)(n)=n
(φ∗1)(n)=n
φ∗1=Id\varphi * 1 =Id
φ∗1=Id
 16.3 单位函数eee与莫比乌斯函数μ\muμ
有如下关系式：
e=μ∗1=∑d∣nμ(d)e=\mu*1=\sum\limits_{d|n}\mu(d)
e=μ∗1=d∣n∑​μ(d)
证明利用单位元（下面）性质即可，略。
 16.4 狄利克雷卷积的性质
接下来我们来阐述狄利克雷卷积的一些性质：

具有交换性:(f∗g)(n)=(g∗f)(n)(f*g)(n)=(g*f)(n)(f∗g)(n)=(g∗f)(n)
具有结合律:((f∗g)∗h)(n)=(f∗(g∗h))(n)((f*g)*h)(n)=(f*(g*h))(n)((f∗g)∗h)(n)=(f∗(g∗h))(n)
对函数加法的分配率:(f∗(g+h))(n)=(f∗g)(n)+(f∗h)(n)(f*(g+h))(n)=(f*g)(n)+(f*h)(n)(f∗(g+h))(n)=(f∗g)(n)+(f∗h)(n)

单位元：
(ε∗f)(n)=∑d∣nε(d)f(nd)=f(n)(\varepsilon * f)(n)=\sum\limits_{d|n}\varepsilon(d)f(\frac{n}{d})=f(n)
(ε∗f)(n)=d∣n∑​ε(d)f(dn​)=f(n)
故单位函数即为狄利克雷卷积的单位元。
逆元：
假设f∗g=εf*g=\varepsilonf∗g=ε，我们称ggg为fff的狄利克雷逆元，记为f−1f^{-1}f−1。
fff存在狄利克雷卷积的必要条件是f(1)≠0f(1)\neq 0f(1)=0
f−1f^{-1}f−1是积性函数。
对于证明过程可以去网上找，这里就不在叙述了。
 17.莫比乌斯函数及反演
 17.1 莫比乌斯函数的小性质
对于莫比乌斯函数的定义我们这里不在详细叙述，需要去积性函数那里找。
莫比乌斯函数是积性函数，于是我们可以用线性筛来筛！
代码如下：
vector&lt;bool&gt; vis(MN);vector&lt;ll&gt; prime;ll n,mu[MN];void euler()&#123;    vis[1]=1;    mu[1]=1;    for(int i=2;i&lt;=n;i++)&#123;        if(!vis[i])&#123;            prime.push_back(i);            mu[i]=-1;        &#125;        for(auto p:prime)&#123;            if(i*p&gt;n) break;            vis[p*i]=1;            if(i%p==0)&#123;                mu[i*p]=0;                break;            &#125;            mu[i*p]=-mu[i];        &#125;    &#125;&#125;
莫比乌斯函数还具有另一个性质：
∑d∣nμ(d)=[n=1]\sum\limits_{d|n}\mu(d)=[n=1]
d∣n∑​μ(d)=[n=1]
证明需用到组合计数，这里就不在叙述了。
那么我们就能根据推论得到一个反演常用的结论：
∑d∣gcd(i,j)μ(d)=[gcd(i,j)=1]\sum\limits_{d|gcd(i,j)}\mu(d)=[gcd(i,j)=1]
d∣gcd(i,j)∑​μ(d)=[gcd(i,j)=1]
但是到现在我们还并没有说反演到底是啥，我们下面就来说。
 17.2 莫比乌斯反演
设f(n),g(n)f(n),g(n)f(n),g(n)为两个数论函数。
如果有：
f(n)=(g∗1)(n)=∑d∣ng(d)f(n)=(g*1)(n)=\sum\limits_{d|n}g(d)
f(n)=(g∗1)(n)=d∣n∑​g(d)
那么有：
g(n)=(μ∗f)(n)=∑d∣nμ(d)f(nd)g(n)=(\mu * f)(n)=\sum\limits_{d|n}\mu(d) f(\frac{n}{d})
g(n)=(μ∗f)(n)=d∣n∑​μ(d)f(dn​)
证明运用卷积即可。
 17.3 对于一类求和式
有如下式子：
∑i=1n∑j=1mf(gcd(i,j))\sum\limits_{i=1}^{n}\sum\limits_{j=1}^mf(gcd(i,j))
i=1∑n​j=1∑m​f(gcd(i,j))
一般套路：
我们可以尝试构造出函数ggg，使得有如下式子：
f=(g∗1)=∑d∣ng(d)f=(g*1)=\sum\limits_{d|n}g(d)
f=(g∗1)=d∣n∑​g(d)
不难替换：
∑i=1n∑j=1m∑d∣gcd(i,j)g(d)\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d|gcd(i,j)}g(d)
i=1∑n​j=1∑m​d∣gcd(i,j)∑​g(d)
不难发现当d∣gcd(i,j)d|gcd(i,j)d∣gcd(i,j)成立时，d∣id|id∣i与d∣jd|jd∣j肯定同时成立，考虑调整顺序，d∣id|id∣i与d∣jd|jd∣j同时成立时，才能产生贡献，不难调整。
∑d=1g(d)∑i=1n[d∣i]∑j=1m[d∣j]\sum\limits_{d=1}g(d)\sum\limits_{i=1}^n [d|i]\sum\limits_{j=1}^m [d|j]
d=1∑​g(d)i=1∑n​[d∣i]j=1∑m​[d∣j]
不难发现后面两项就是在枚举约数个数，可以转化为⌊nd⌋⌊md⌋\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor⌊dn​⌋⌊dm​⌋
最终式为：
∑d=1g(d)⌊nd⌋⌊md⌋\sum\limits_{d=1}g(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
d=1∑​g(d)⌊dn​⌋⌊dm​⌋
即得，数论分块求解即可。
 17.4 小例题
例1.1 :
∑i=1n∑j=1mgcd(i,j)\sum\limits_{i=1}^n\sum\limits_{j=1}^mgcd(i,j)
i=1∑n​j=1∑m​gcd(i,j)
不难发现其实就是Id(gcd(i,j))Id(gcd(i,j))Id(gcd(i,j))，利用16.2学到的性质，那么就直接发现是欧拉函数，结束。
∑d=1φ(d)⌊nd⌋⌊md⌋\sum\limits_{d=1}\varphi(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
d=1∑​φ(d)⌊dn​⌋⌊dm​⌋
例1.2:
∑i=1n∑j=1m[gcd(i,j)=1]\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)=1]
i=1∑n​j=1∑m​[gcd(i,j)=1]
不难发现是单位函数eee，那么根据16.3结束。
∑d=1μ(d)⌊nd⌋⌊md⌋\sum\limits_{d=1}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
d=1∑​μ(d)⌊dn​⌋⌊dm​⌋
例2:
∑x=ab∑y=cd[gcd(x,y)=k]\sum\limits_{x=a}^b\sum\limits_{y=c}^d [gcd(x,y)=k]
x=a∑b​y=c∑d​[gcd(x,y)=k]
其中1≤a,b,c,d,k≤5×1041\le a,b,c,d,k\le 5\times 10^41≤a,b,c,d,k≤5×104
这种区间，我们可以套路的转化为前缀和的形式，用容斥原理求解，那么不难转化：
f(n,m)=∑i=1n∑j=1m[gcd(i,j)=k]f(n,m)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)=k]
f(n,m)=i=1∑n​j=1∑m​[gcd(i,j)=k]
考虑把kkk给提出来，有：
∑i=1⌊nk⌋∑j=1⌊mk⌋[gcd(i,j)=1]\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{k}\rfloor}[gcd(i,j)=1]
i=1∑⌊kn​⌋​j=1∑⌊km​⌋​[gcd(i,j)=1]
套入例1.2
∑i=1⌊nk⌋∑j=1⌊mk⌋∑d∣gcd(i,j)μ(d)\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum\limits_{d|gcd(i,j)}\mu(d)
i=1∑⌊kn​⌋​j=1∑⌊km​⌋​d∣gcd(i,j)∑​μ(d)
考虑下取整的式子能否直接代入，其实是可以的。那么有
∑d=1μ(d)⌊nkd⌋⌊mkd⌋\sum\limits_{d=1}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor
d=1∑​μ(d)⌊kdn​⌋⌊kdm​⌋
线性筛求μ\muμ让后整除分块即可，瓶颈在线性筛，时间复杂度O(n)O(n)O(n)
例3:
P3768 简单的数学题
∑i=1n∑j=1n(ij∗gcd(i,j))mod  m\sum\limits_{i=1}^n\sum\limits_{j=1}^n(ij*gcd(i,j)) \mod m
i=1∑n​j=1∑n​(ij∗gcd(i,j))modm
上来发现式子有点不像人样，尝试枚举gcd，有：
∑d=1d∑i=1n∑j=1nij[gcd(i,j)=d]\sum\limits_{d=1}d\sum\limits_{i=1}^n\sum\limits_{j=1}^nij[gcd(i,j)=d]
d=1∑​di=1∑n​j=1∑n​ij[gcd(i,j)=d]
我们发现这个式子和例2及其详细，我们可以转化过去，但是注意ij→id∗jdij\rightarrow id*jdij→id∗jd，我们不能一步转化
∑d=1d∑i=1⌊nk⌋∑j=1⌊nk⌋[gcd(i,j)=1]∗id∗jd\sum\limits_{d=1}d\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{k}\rfloor}[gcd(i,j)=1]*id*jd
d=1∑​di=1∑⌊kn​⌋​j=1∑⌊kn​⌋​[gcd(i,j)=1]∗id∗jd
考虑把ddd提出来
∑d=1d3∑i=1⌊nk⌋∑j=1⌊nk⌋[gcd(i,j)=1]∗ij\sum\limits_{d=1}d^3\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{k}\rfloor}[gcd(i,j)=1]*ij
d=1∑​d3i=1∑⌊kn​⌋​j=1∑⌊kn​⌋​[gcd(i,j)=1]∗ij
现在把例二丢进去：
∑d=1d3∑i=1⌊nk⌋∑j=1⌊nk⌋ij∑k∣gcd(i,j)μ(k)\sum\limits_{d=1}d^3\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{k}\rfloor}ij\sum\limits_{k|gcd(i,j)}\mu(k)
d=1∑​d3i=1∑⌊kn​⌋​j=1∑⌊kn​⌋​ijk∣gcd(i,j)∑​μ(k)
如果我们想转化成最终形式，我们考虑ijijij的贡献，其实只是在运算的时候把求和式子中的1变了ijijij，那么不难有。
∑d=1d3∑k=1μ(k)k2∑i=1⌊nkd⌋∑j=1⌊nkd⌋ij\sum\limits_{d=1}d^3\sum\limits_{k=1}\mu(k)k^2\sum\limits_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{kd}\rfloor}ij
d=1∑​d3k=1∑​μ(k)k2i=1∑⌊kdn​⌋​j=1∑⌊kdn​⌋​ij
有没有发现多了个k2k^2k2，是因为你的ijijij如果都提出来（指求和里的分母kd）里面都有一个kkk，那么提出来就要k2k^2k2
考虑后面式子，后面式子我们其实可以O(1)O(1)O(1)计算，有：
f(⌊nkd⌋,⌊mkd⌋)=∑i=1⌊nkd⌋i∑j=1⌊nkd⌋j=⌊nkd⌋×(⌊nkd⌋+1)2×⌊mkd⌋×(⌊mkd⌋+1)2f(\lfloor\frac{n}{kd}\rfloor,\lfloor\frac{m}{kd}\rfloor)=\sum\limits_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{kd}\rfloor}j=\frac{\lfloor\frac{n}{kd}\rfloor\times(\lfloor\frac{n}{kd}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{kd}\rfloor\times(\lfloor\frac{m}{kd}\rfloor+1)}{2}
f(⌊kdn​⌋,⌊kdm​⌋)=i=1∑⌊kdn​⌋​ij=1∑⌊kdn​⌋​j=2⌊kdn​⌋×(⌊kdn​⌋+1)​×2⌊kdm​⌋×(⌊kdm​⌋+1)​
考虑前面的式子，发现枚举没有上界或者上界很大，我们能不能限制上界？
发现分式中的kdkdkd可以换元，并且换元的上界在nnn，考虑换元为t=kdt=kdt=kd。
考虑枚举ddd，让后kkk能够求出来：
∑t=1n∑d∣td3μ(td)(td)2f(⌊nt⌋,⌊nt⌋)\sum\limits_{t=1}^n\sum\limits_{d|t}d^3\mu(\frac{t}{d})(\frac{t}{d})^2f(\lfloor\frac{n}{t}\rfloor,\lfloor\frac{n}{t}\rfloor)
t=1∑n​d∣t∑​d3μ(dt​)(dt​)2f(⌊tn​⌋,⌊tn​⌋)
考虑把立方和平方消去：
∑t=1nt2f(⌊nt⌋,⌊nt⌋)∑d∣tdμ(td)\sum\limits_{t=1}^nt^2f(\lfloor\frac{n}{t}\rfloor,\lfloor\frac{n}{t}\rfloor)\sum\limits_{d|t}d\mu(\frac{t}{d})
t=1∑n​t2f(⌊tn​⌋,⌊tn​⌋)d∣t∑​dμ(dt​)
后面的式子其实就是∑d∣nId(d)μ(T)=φ(t)\sum\limits_{d|n}Id(d)\mu(T)=\varphi(t)d∣n∑​Id(d)μ(T)=φ(t),反演得到。
不难有：
∑t=1nt2φ(t)f(⌊nt⌋,⌊nt⌋)\sum\limits_{t=1}^{n}t^2\varphi(t)f(\lfloor\frac{n}{t}\rfloor,\lfloor\frac{n}{t}\rfloor)
t=1∑n​t2φ(t)f(⌊tn​⌋,⌊tn​⌋)
到这里我们完成80%，不难发现后面O(1)O(1)O(1)可以求，对于前面，数论函数前缀和，考虑杜教筛。
原式为∑i=1nId2(i)φ(i)\sum\limits_{i=1}^nId_2(i)\varphi(i)i=1∑n​Id2​(i)φ(i)
我们需要构造函数ggg使得：
∑d∣nId2(d)φ(d)g(nd)\sum\limits_{d|n}Id_2(d)\varphi(d)g(\frac{n}{d})
d∣n∑​Id2​(d)φ(d)g(dn​)
能够快速求出。
考虑直接把Id2Id_2Id2​砍了
令g=Id2g=Id_2g=Id2​
那么原式Id2Id_2Id2​拆开：
∑d∣nd2φ(d)(nd)2=n2∑d∣nφ(d)=n3\sum\limits_{d|n}d^2\varphi(d)(\frac{n}{d})^2=n^2\sum\limits_{d|n}\varphi(d)=n^3
d∣n∑​d2φ(d)(dn​)2=n2d∣n∑​φ(d)=n3
最后一个式子考虑反演变为IdIdId
那么这道题做完了，不难发现ggg可以快速预处理，时间复杂度O(n)O(n)O(n)。
代码如下：
#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN = 2e6 + 15;ll inv2, inv6, P, n, fsum[MN + 15], phi[MN + 15];unordered_map&lt;ll, ll&gt; ump;vector&lt;bool&gt; vis(MN + 15);vector&lt;ll&gt; prm;inline ll read()&#123;    ll x = 0, t = 1;    char ch = getchar();    while ((ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &amp;&amp; ch != &#x27;-&#x27;)        ch = getchar();    if (ch == &#x27;-&#x27;)        t = -1, ch = getchar();    while (ch &lt;= &#x27;9&#x27; &amp;&amp; ch &gt;= &#x27;0&#x27;)        x = x * 10 + ch - 48, ch = getchar();    return x * t;&#125;ll ksm(ll a, ll b)&#123;    ll ret = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ret = (ret * a) % P;        &#125;        a = a * a % P;        b &gt;&gt;= 1;    &#125;    return ret;&#125;ll getlf(ll k)&#123;    k %= P;    return ((k * (k + 1) % P * inv2 % P) * (k * (k + 1) % P * inv2 % P)) % P;&#125;ll getpf(ll k)&#123;    k %= P;    return (k * (k + 1) % P * (2 * k + 1) % P * inv6 % P) % P;&#125;void getphi()&#123;    vis[0] = vis[1] = 1;    phi[1] = 1;    for (ll i = 2; i &lt;= MN; i++)    &#123;        if (!vis[i])        &#123;            prm.push_back(i);            phi[i] = i - 1;        &#125;        for (auto p : prm)        &#123;            if (p * i &gt; MN)                break;            vis[p * i] = 1;            if (i % p == 0)            &#123;                phi[i * p] = phi[i] * p;                break;            &#125;            else                phi[i * p] = phi[i] * (p - 1);        &#125;    &#125;    for (ll i = 1; i &lt;= MN; i++)    &#123;        fsum[i] = (fsum[i - 1] + i * i * phi[i] % P) % P;    &#125;&#125;ll dushu(ll k)&#123;    if (k &lt;= MN)        return fsum[k];    if (ump[k])        return ump[k];    ll ans = getlf(k), now, pre;    for (ll i = 2, j; i &lt;= k; i = j + 1)    &#123;        j = k / (k / i);        ans = (ans - (getpf(j) - getpf(i - 1)) % P * dushu(k / i) % P) % P;    &#125;    return ump[k] = (ans + P) % P;&#125;ll solve()&#123;    ll ans = 0, pre = 0, now;    for (ll i = 1, j; i &lt;= n; i = j + 1)    &#123;        j = n / (n / i);        now = dushu(j);        ans = (ans + ((now - pre) * getlf(n / i)) % P) % P;        pre = now;    &#125;    return (ans + P) % P;&#125;int main()&#123;    P = read();    n = read();    getphi();    inv6 = ksm(6, P - 2);    inv2 = ksm(2, P - 2);    cout &lt;&lt; solve();    return 0;&#125;
 18. 二项式反演
 18.1 定义及转化
真服了好多次模拟赛考这个自己都不会转化导致就只能在那里坐牢。
二项式反演用于解决 “某个物品恰好若干个” 这一类计数例题。
我们记 fnf_nfn​ 表示恰好使用 nnn 个有标号的元素形成特定结构的方案数，gng_ngn​ 表示从 nnn 个有标号的元素中选出 i(i≥0)i(i\ge 0)i(i≥0) 个元素形成特定结构的总方案数。
若已知 gng_ngn​，需要求解 fif_ifi​，那么有如下反演公式。
fn=∑i=0n(ni)(−1)n−igif_n=\sum\limits_{i=0}^n \binom{n}{i} (-1)^{n-i} g_i
fn​=i=0∑n​(in​)(−1)n−igi​
证明过程如下：
fn=∑i=0n(ni)(−1)n−igifn=∑i=0n(ni)(−1)n−i[∑j=0i(ij)fj]fn=∑i=0n∑j=0i(ni)(ij)(−1)n−ifj\begin{aligned}
f_n&amp;=\sum\limits_{i=0}^n \binom{n}{i}(-1)^{n-i}g_{i}\\

f_n&amp;=\sum\limits_{i=0}^n \binom{n}{i}(-1)^{n-i} \left[ \sum\limits_{j=0}^i \binom{i}{j}f_{j} \right]\\
f_n&amp;=\sum\limits_{i=0}^n\sum\limits_{j=0}^i \binom{n}{i} \binom{i}{j} (-1)^{n-i} f_j 
\end{aligned}
fn​fn​fn​​=i=0∑n​(in​)(−1)n−igi​=i=0∑n​(in​)(−1)n−i[j=0∑i​(ji​)fj​]=i=0∑n​j=0∑i​(in​)(ji​)(−1)n−ifj​​
考虑交换求和顺序，为了满足 j≤ij\le ij≤i，交换后对于 jjj 需要满足大于等于它的 iii。
fn=∑i=0n∑j=0i(ni)(ij)(−1)n−ifj=∑j=0nfj∑i=jn(ni)(ij)(−1)n−i∵(ni)(ij)=(nj)(n−ji−j)∴∑j=0nfj∑i=jn(nj)(n−ji−j)(−1)n−i=∑j=0n(nj)fj∑i=jn(n−ji−j)(−1)n−i\begin{aligned}
f_n&amp;=\sum\limits_{i=0}^n\sum\limits_{j=0}^i \binom{n}{i} \binom{i}{j} (-1)^{n-i} f_j \\
&amp; = \sum\limits_{j=0}^nf_{j}\sum\limits_{i=j}^n \binom{n}{i} \binom{i}{j} (-1)^{n-i} \\
\\
&amp; \because \binom{n}{i}\binom{i}{j}=\binom{n}{j}\binom{n-j}{i-j} \\

 &amp; \therefore  \sum\limits_{j=0}^nf_{j}\sum\limits_{i=j}^n \binom{n}{j} \binom{n-j}{i-j} (-1)^{n-i} \\ \\
&amp; =\sum\limits_{j=0}^n \binom{n}{j} f_{j}\sum\limits_{i=j}^n  \binom{n-j}{i-j} (-1)^{n-i} \\
\end{aligned}

fn​​=i=0∑n​j=0∑i​(in​)(ji​)(−1)n−ifj​=j=0∑n​fj​i=j∑n​(in​)(ji​)(−1)n−i∵(in​)(ji​)=(jn​)(i−jn−j​)∴j=0∑n​fj​i=j∑n​(jn​)(i−jn−j​)(−1)n−i=j=0∑n​(jn​)fj​i=j∑n​(i−jn−j​)(−1)n−i​
设 k=i−jk=i-jk=i−j , ∵i∈[j,n]\because i\in [j,n]∵i∈[j,n] , ∴k∈[0,n−j]\therefore k\in [0,n-j]∴k∈[0,n−j]。
fn=∑j=0n(nj)fj∑i=jn(n−ji−j)(−1)n−i=∑j=0n(nj)fj∑k=0n−j(n−jk)(−1)n−j−k∵∑i=0n(−1)n−i(ni)=[n=0]∴fn=∑i=0n(nj)fj[n−j=0]=∑i=0n(nj)fj[n=j]=fn∵fn=fn∴得证\begin{aligned}
f_n&amp;=\sum\limits_{j=0}^n \binom{n}{j} f_{j}\sum\limits_{i=j}^n  \binom{n-j}{i-j} (-1)^{n-i} \\

&amp;=\sum\limits_{j=0}^n \binom{n}{j} f_{j}\sum\limits_{k=0}^{n-j}  \binom{n-j}{k} (-1)^{n-j-k} \\

&amp; \because \sum\limits_{i=0}^n (-1)^{n-i}\binom{n}{i}=[n=0] \\ \\
\therefore f_n&amp;=\sum\limits_{i=0}^n \binom{n}{j}f_{j}[n-j=0] \\

&amp; = \sum\limits_{i=0}^n \binom{n}{j}f_{j}[n=j] \\
&amp; =f_{n}\\ \\

&amp; \because f_n=f_{n}\\
&amp; \therefore \text{得证}
\end{aligned}
fn​∴fn​​=j=0∑n​(jn​)fj​i=j∑n​(i−jn−j​)(−1)n−i=j=0∑n​(jn​)fj​k=0∑n−j​(kn−j​)(−1)n−j−k∵i=0∑n​(−1)n−i(in​)=[n=0]=i=0∑n​(jn​)fj​[n−j=0]=i=0∑n​(jn​)fj​[n=j]=fn​∵fn​=fn​∴得证​
而做题过程中往往遇见的是 gng_ngn​ 好求而 fnf_nfn​ 却不好求。
那么二项式反演就是干这个的，利用 gng_ngn​ 去求 fnf_nfn​。
 18.2 二项式反演形式总结
形式1:
gng_ngn​ 表示至多 nnn 个/种的方案数量，fnf_nfn​ 恰好 nnn 个/种方案数量。
gn=∑i=0n(ni)fi⇔fn=∑i=0n(−1)n−i(ni)gig_n=\sum\limits_{i=0}^n \binom{n}{i} f_{i}\Leftrightarrow f_{n}= \sum\limits_{i=0}^n (-1)^{n-i} \binom{n}{i} g_i
gn​=i=0∑n​(in​)fi​⇔fn​=i=0∑n​(−1)n−i(in​)gi​
形式2:
gkg_kgk​ 表示至少 kkk 个/种的方案数量，fkf_kfk​ 恰好 kkk 个/种方案数量。
gk=∑i=kn(ik)fi⇔fk=∑i=0n(−1)i−k(ik)gig_k=\sum\limits_{i=k}^n \binom{i}{k} f_{i}\Leftrightarrow f_{k}= \sum\limits_{i=0}^n (-1)^{i-k} \binom{i}{k} g_i
gk​=i=k∑n​(ki​)fi​⇔fk​=i=0∑n​(−1)i−k(ki​)gi​
 18.3 例题
洛谷P9850
[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat

给定 nnn 个点的完全图，其中 mmm 条边为红色边，其余边为蓝色边。
定义以下：
f红色f_{\text{红色}}f红色​ 为四元组 (i,j,k,l)(i,j,k,l)(i,j,k,l)，其中任意两点都有红色边连接的个数。
f蓝色f_{\text{蓝色}}f蓝色​ 为四元组 (i,j,k,l)(i,j,k,l)(i,j,k,l)，其中任意两点都有蓝色边连接的个数。
求 ∣f红色−f蓝色∣|f_{\text{红色}}-f_{\text{蓝色}}|∣f红色​−f蓝色​∣。
其中 1≤n≤105,1≤m≤2×1051\le n \le 10^5,1\le m \le 2\times 10^51≤n≤105,1≤m≤2×105。

赛时没想出正解（废话都没学二项式反演能做？）
发现蓝色很难受，显然可以考虑以下容斥，但是怎么容斥呢？
红色边的信息我们是有的，我们可以通过红色边来容斥。
但是这咋求啊？暴力枚举直接 O(n4)O(n^4)O(n4) 了www。
对于一张存在 jjj 条红色边的图，假设存在 gig_igi​ 个 iii 条边的红色子图，而且只需要满足边颜色都是红色就可以了，那么有 (ji)\binom{j}{i}(ij​) 种选择方法，那么我们不妨设 fif_ifi​ 表示四元组存在 iii 条边的红色子图个数，有下列式子：
gi=∑j=i(ji)fjg_i=\sum\limits_{j=i}\binom{j}{i} f_j
gi​=j=i∑​(ij​)fj​
长的就很二项式反演：
fi=∑j=i(ji)(−1)j−igjf_i=\sum\limits_{j=i}\binom{j}{i} (-1)^{j-i} g_j
fi​=j=i∑​(ij​)(−1)j−igj​
那么 ∣f6−f0∣=∣g0−g1+g2−g3+g4−g5∣|f_6-f_0|=|g_0-g_1+g_2-g_3+g_4-g_5|∣f6​−f0​∣=∣g0​−g1​+g2​−g3​+g4​−g5​∣。不难发现可以一个一个讨论（废话那你怎么求）

g0g_0g0​：不选红色边，瞎选4个点：(n4)\dbinom{n}{4}(4n​)。
g1g_1g1​:选一个的方案数 (m1)\dbinom{m}{1}(1m​)，让后在确定2个端点瞎选：(m1)(n−22)\dbinom{m}{1}\dbinom{n-2}{2}(1m​)(2n−2​)。
g2g_2g2​：分类讨论

如果是一点连两条边，枚举公共点，让后再枚举以该端点出发的两个点，让后再瞎选一个：(n−3)∑i=1n(degi2)(n-3)\sum\limits_{i=1}^{n}\dbinom{deg_i}{2}(n−3)i=1∑n​(2degi​​)，其中 degideg_idegi​ 表示节点 iii 的度数
如果没有公共点，正南则反，就是原图任意选2个边减去有公共点的，即：(m2)−∑i=1n(degi2)\dbinom{m}{2}-\sum\limits_{i=1}^n \dbinom{deg_i}{2}(2m​)−i=1∑n​(2degi​​)。


g3g_3g3​：继续

如果三元环，那就枚举剩下一个点为 (n−3)C3(n-3)C_3(n−3)C3​.
如果是共用一个顶点，那么很简单直接枚举即可，结果 ∑i=1n(n3)\sum\limits_{i=1}^n \binom{n}{3}i=1∑n​(3n​)。
如果是链，注意一下要把三元环的三个情况舍去，结果就是 ∑(u,v)∈E(degu−1)(degv−1)−3C3\sum\limits_{(u,v)\in E}(deg_u-1)(deg_v-1)-3C_3(u,v)∈E∑​(degu​−1)(degv​−1)−3C3​。


g4g_4g4​:

如果四元环，那不用枚举直接 C4C_4C4​.
如果三元环出来一个那就是 ∑i=1nTi(degi−2)\sum\limits_{i=1}^n T_i(deg_i-2)i=1∑n​Ti​(degi​−2)，其中 TiT_iTi​ 为 iii 号点不同三元环的个数


g5g_5g5​ ：只能是两个三元环共用一条边枚举公共边即可，其中 f5=∑i=∈C3(ti2)f_5=\sum\limits_{i=\in \mathbb{C}_3}\binom{t_i}{2}f5​=i=∈C3​∑​(2ti​​) ，其中 C3\mathbb{C}_3C3​ 表示求解三元环完成定向的边集，tit_iti​ 表示覆盖带边 iii 的不同三元环个数。

做完了，直接公式计算即可，注意瓶颈在三元环和四员化计算，不要超过 O(n2)O(n^2)O(n2)：
#include &lt;bits/stdc++.h&gt;#define pir pair&lt;int, int&gt;#define ll long longusing namespace std;constexpr int MN = 1e5 + 15, MM = 2e5 + 15;struct Edge &#123;    int u, v;&#125; e[MM];ll f0, f1, f2, f3, f4, f5;int dg[MN],n,m,top,s[MN],id[MN];ll cp[MN], ce[MM];vector&lt;int&gt; adj[MN];vector&lt;pir&gt; G[MN];ll countthree() &#123;    ll ret = 0;    for (int i = 1; i &lt;= n; i++) &#123;        for (auto p : G[i]) id[p.first] = p.second;        for (auto p : G[i]) &#123;            int v = p.first;            for (auto pv : G[v]) &#123;                int w = pv.first;                if (id[w]) &#123;                    ret++;                    cp[i]++;                    cp[v]++;                    cp[w]++;                    ce[p.second]++;                    ce[pv.second]++;                    ce[id[w]]++;                &#125;            &#125;        &#125;        for (auto p : G[i]) id[p.first] = 0;    &#125;    return ret;&#125;ll countfour() &#123;    memset(id, 0, sizeof(id));    ll ret = 0;    for (int i = 1; i &lt;= n; i++) &#123;        for (int v : adj[i]) &#123;            for (auto p : G[v]) &#123;                int w = p.first;                if (dg[i] &lt; dg[w] || (dg[i] == dg[w] &amp;&amp; i &lt; w)) &#123;                    ret += id[w];                    if (!id[w]) s[++top] = w;                    id[w]++;                &#125;            &#125;        &#125;        for (int j = 1; j &lt;= top; j++) id[s[j]] = 0;        top = 0;    &#125;    return ret;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; e[i].u &gt;&gt; e[i].v;        dg[e[i].u]++;        dg[e[i].v]++;        adj[e[i].u].push_back(e[i].v);        adj[e[i].v].push_back(e[i].u);    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int u = e[i].u, v = e[i].v;        if ((dg[u] == dg[v] &amp;&amp; u &gt; v) || dg[u] &gt; dg[v])            swap(u, v);        G[u].push_back(&#123;v, i&#125;);    &#125;    ll tri = countthree();    ll quad = countfour();    for (int i = 1; i &lt;= n; i++) &#123;        f2+=1LL * dg[i] * (dg[i] - 1) / 2 * (n - 4);        f3+=1LL * dg[i] * (dg[i] - 1) * (dg[i] - 2) / 6;        f4+=1LL * cp[i] * (dg[i] - 2);        for (auto p : G[i]) &#123;            int v = p.first;            f3+=1LL * (dg[i] - 1) * (dg[v] - 1);        &#125;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        f5+=1LL * ce[i] * (ce[i] - 1) / 2;    &#125;    f0=(__int128)n * (n - 1) * (n - 2) * (n - 3) / 24;    f1=1LL * m * (n - 2) * (n - 3) / 2;    f2+=1LL * m * (m - 1) / 2;    f3+=tri * (n - 6);    f4+=quad;    cout &lt;&lt; abs(f0 - f1 + f2 - f3 + f4 - f5);    return 0;&#125;
 19. 威尔逊定理
这个定理真的很冷门的……
威尔逊定理给定了判断某个自然是是否是素数的一个充分必要条件。

对于自然数 n&gt;1n&gt;1n&gt;1，当且仅当 nnn 是素数时，(n−1)!≡−1(modn)(n-1)! \equiv -1 \pmod n(n−1)!≡−1(modn)。


逆定理：若 (p−1)!≡−1(modp)(p-1)! \equiv -1 \pmod p(p−1)!≡−1(modp)，则 ppp 是质数。

证明？
 19.1 证明
首先需要说明的是，我们的前提是 n&gt;1,n∈Zn&gt;1,n \in \mathbb{Z}n&gt;1,n∈Z。
我们把非素数分成几类：
非素数{4大于4{完全平方数非完全平方数\text{非素数}
\begin{cases}
4 \\
\text{大于}4 \begin{cases} \text{完全平方数} \\ \text{非完全平方数}  \end{cases}
\end{cases}
非素数⎩⎪⎪⎨⎪⎪⎧​4大于4{完全平方数非完全平方数​​
显然这样分类保证不重不漏
 19.1.1 充分性
当 n=4n=4n=4 时，代入有 (4−1)!≡2(mod4)(4-1)! \equiv 2 \pmod 4(4−1)!≡2(mod4) ,不成立。
当 nnn 为完全平方数，则 p=k2p=k^2p=k2，因为 p&gt;4p&gt;4p&gt;4 那么有 k&gt;2k&gt;2k&gt;2。
让后我们比较 2k,p2k,p2k,p 之间的大小。
2k−p=2k−k2=2k−k2−1+1=−(k−1)2+1&lt;0\begin{aligned}
2k-p &amp; = 2k-k^2 \\
&amp; = 2k-k^2-1+1 \\
&amp; = -(k-1)^2+1&lt;0
\end{aligned}
2k−p​=2k−k2=2k−k2−1+1=−(k−1)2+1&lt;0​
推论既得
∵k&lt;p,2k&lt;p∴(p−1)!=1×2×⋯×k×2k×⋯×(p−1)=k×2k×n=2nk2=2np∴(p−1)!≡0(modp)\begin{aligned}
&amp;\because k&lt;p,2k&lt;p \\
&amp; \therefore (p-1)! \\
&amp; = 1\times 2 \times \dots \times k \times 2k\times \dots \times (p-1) \\
&amp; =k \times 2k \times n \\
&amp; = 2nk^2 \\
&amp; = 2np \\
&amp; \therefore (p-1)! \equiv 0 \pmod p
\end{aligned}
​∵k&lt;p,2k&lt;p∴(p−1)!=1×2×⋯×k×2k×⋯×(p−1)=k×2k×n=2nk2=2np∴(p−1)!≡0(modp)​
若 ppp 不是完全平方数，那么 ppp 必然等于两个完全不相等的数 aaa 和 bbb 的乘积，不妨设 a&lt;ba&lt;ba&lt;b，满足：1&lt;a&lt;b&lt;p1&lt;a&lt;b&lt;p1&lt;a&lt;b&lt;p。
显然有：
(p−1)!=1×2×⋯×a×b×⋯×(p−1)=a×b×n=nab=np∴(p−1)!≡0(modp)\begin{aligned}
(p-1)! &amp; =1\times 2\times \dots \times a\times b \times \dots \times (p-1) \\
&amp; = a\times b\times n \\
&amp; = nab \\
&amp; =np \\
&amp; \therefore (p-1)! \equiv 0 \pmod p
\end{aligned}
(p−1)!​=1×2×⋯×a×b×⋯×(p−1)=a×b×n=nab=np∴(p−1)!≡0(modp)​
 19.1.2 必要性
当 ppp 为素数，考虑二次探测定理：

二次探测定理：对于质数 ppp，若 x2≡1(modp)x^2 \equiv 1 \pmod px2≡1(modp)，则小于 ppp 的解只有两个，x1=1,x2=p−1x_1=1,x_2=p-1x1​=1,x2​=p−1。

再对于 a∈[2,p−2]a\in [2,p-2]a∈[2,p−2]，必然存在一个和它不相登的逆元 a−1∈[2,p−2]a^{-1} \in [2,p-2]a−1∈[2,p−2]，满足
aa−1≡1(modp)aa^{-1} \equiv 1 \pmod p
aa−1≡1(modp)
所以必然有 p−32\frac{p-3}{2}2p−3​ 对数相乘的乘积为 1，即：
(p−2)!≡1(modp)(p-2)! \equiv 1 \pmod p
(p−2)!≡1(modp)
两边同乘 p−1p-1p−1，注意到 (−1+p)mod  p(-1+p) \mod p(−1+p)modp 不就是经典的负数取模吗，直接游戏结束。
(p−1)!≡−1(modp)(p-1)! \equiv -1 \pmod p
(p−1)!≡−1(modp)
 19.2例题
 广义问题
对于 2≤n≤1092\le n \le 10^92≤n≤109，求
(n−1)!mod  n(n-1)! \mod n
(n−1)!modn
建议看证明。
 配合素数判定
UVA1434 YAPTCHA
求下列式子答案：
∑k=1n⌊(3k+6)!+13k+7−⌊(3k+6!)3k+7⌋⌋\sum\limits_{k=1}^n \lfloor \frac{(3k+6)!+1}{3k+7} -\lfloor \frac{(3k+6!)}{3k+7} \rfloor \rfloor
k=1∑n​⌊3k+7(3k+6)!+1​−⌊3k+7(3k+6!)​⌋⌋
我们对于上面定理变个形式：
(n−1)!+1≡0(modn)(n-1)!+1\equiv 0 \pmod n
(n−1)!+1≡0(modn)
到这里你回看上面这个式子，是不是直接就秒了。
别急，我们分类讨论：

当 kkk 为质数，显然 (3k+6)!+13k+7\dfrac{(3k+6)!+1}{3k+7}3k+7(3k+6)!+1​ 这个式子是整除式子，得到的是整数，而对于后面的式子不难想出来下取整为 一定比前面式子小，但两者之差绝对值不会不是 1 （有疑惑自行举例自己想）。
当 kkk 不为质数，显然 (3k+6)!+13k+7\dfrac{(3k+6)!+1}{3k+7}3k+7(3k+6)!+1​ 得到为的数就不是整除式子其结果就大于 0 了，而且还不是整数，而对于后面的式子呢？其实他们下取证的结果是一样的，差1不会影响。所以得到的结果为0

源命题转化为，统计素数问题，线性筛即可。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e6+100;int T,cnt[MN];vector&lt;bool&gt; notprime(MN+5),isprime(MN+15);vector&lt;int&gt; prime;void shai(int n)&#123;    for(int i=2;i&lt;=n;i++)&#123;        if(!notprime[i])&#123;            isprime[i]=1;            prime.push_back(i);        &#125;        for(auto p:prime)&#123;            if(i*p&gt;n) break;            notprime[i*p]=1;            if(i%p==0) break;        &#125;    &#125;&#125;int main()&#123;    shai(3e6+15);    for(int i=1;i&lt;=1e6;i++)&#123;        cnt[i]=cnt[i-1]+isprime[3*i+7];    &#125;    cin&gt;&gt;T;    while (T--)    &#123;        int x;        cin&gt;&gt;x;        cout&lt;&lt;cnt[x]&lt;&lt;&#x27;\n&#x27;;    &#125;        return 0;&#125;
 20.BSGS 与 exBSGS
补天坑
我们能够解决线性同余方程，这很好，我们来解决高级一点的——高次同余方程。
高次同余方程，有 ax≡b(modp)a^x \equiv b \pmod pax≡b(modp) 和 xa≡b(modp)x^a \equiv b \pmod pxa≡b(modp) 这两个形式，其中 xxx 均为未知数，前面就是我们要讲的 BSGS，而后面就是我们大名鼎鼎的原根，这里我们讨论BSGS。
 20.1 BSGS
问题：
给定整数 a,b,pa,b,pa,b,p，其中 a,pa,pa,p 互质，求 ax≡b(modp)a^x \equiv b \pmod pax≡b(modp) 的非负整数解。
因为 a,pa,pa,p 互质，我们可以在模 ppp 意义下瞎搞乘除运算。
 暴力做法
当然我们可以暴力枚举 xxx 计算，根据欧拉定理我们给出推论这个 xxx 是 O(φ(p))O(\varphi(p))O(φ(p)) 级别的，暴力枚举即可。
 BSGS
虽然 O(φ(p))O(\varphi(p))O(φ(p)) 的枚举可以解决这个问题，但是性能肯定不行，我们需要一个更优雅的暴力来解决这个问题。
什么，优雅的暴力？那不就是分块吗。
我们不妨把待求的 xxx 分解以下，给定一个 AAA，那么就能分解成 x=mA−nx=mA-nx=mA−n 的形式，原式为：
amA−n≡b(modp)amA≡ban(modp)\begin{aligned}
a^{mA-n} &amp; \equiv b \pmod p \\
a^{mA} &amp; \equiv ba^{n} \pmod p
\end{aligned}
amA−namA​≡b(modp)≡ban(modp)​
显然这里的 nnn 应该不大于 A,m≤⌈pA⌉A,m\le \lceil \frac{p}{A} \rceilA,m≤⌈Ap​⌉。
我们考虑暴力枚举每一个 nnn ，把 banmod  pba^n \mod pbanmodp 的值用哈希表存起来让后再枚举每一个 mmm 判断 amAmod  pa^{mA} \mod pamAmodp 在哈希表中有没有对应的元素。
枚举 nnn 的复杂度为 O(A)O(A)O(A)，枚举 mmm 的复杂度为 O(pA)O(\frac{p}{A})O(Ap​)。
注意到 A+nAA+\frac{n}{A}A+An​，当 A=nA=\sqrt{n}A=n​ 时取最小值，复杂度即为优秀的 O(n)O(\sqrt{n})O(n​)。
所以为什么是大步小步呢，你看 ana^nan 枚举 nnn 是小小的枚举 aaa 的指数，而 amAa^{mA}amA  是以 aAa^AaA 的指数一大步一大步枚举，所以形象的称为大步小步算法。
代码如下,实现因为用了 map 所以多一个 log⁡\loglog ：
map&lt;int,int&gt; mp; // 注意爆long long!int BSGS(int a,int b,int p)&#123;    mp.clear();    b%=p;    int t=sqrt(p)+1;    for(int j=0;j&lt;t;j++)&#123;        int val=(long long)b*qpow(a,j,p)%p;        mp[val]=j;    &#125;    a=qpow(a,t,p);    if(a==0) return b==0?1:-1;    for(int i=0;i&lt;t;i++)&#123;        int val=qpow(a,i,p);        int j=mp.find(val)==mp.end()?-1:mp[val];        if(j&gt;=0&amp;&amp;i*t-j&gt;=0) return i*t-j;    &#125;    return -1;&#125;
 20.2 exBSGS
就和拓展中国剩余定理一样，我们这里的拓展就是不互质的情况下，那怎么做？
注意到，我们当然互质不能做（废话），我们考虑怎么改写。
咱们可以换成求解线性同余方程的形式，变形为：
ax+kp=na^x +kp =n
ax+kp=n
当 gcd⁡(a,n)∣n\gcd(a,n)|ngcd(a,n)∣n 时有解，否则无解（裴蜀定理）。
由特殊解推一般解公式（还是裴蜀定理那里）得：
ax−1⋅ad+k⋅pd=nda^{x-1} \cdot \frac{a}{d} + k \cdot \frac{p}{d}=\frac{n}{d}
ax−1⋅da​+k⋅dp​=dn​
考虑重新传参，一直递归直到 gcd⁡(a,p)=1\gcd(a,p)=1gcd(a,p)=1，让后做正常的 BSGS。
不妨设递归了 cntcntcnt 次，那么所有次递归的 ddd 的乘积我们设为 d′d&#x27;d′。
原式即为：
ax−cnt⋅acntd′≡nd′(modpd′)a^{x-cnt} \cdot \frac{a^{cnt}}{d&#x27;} \equiv \frac{n}{d&#x27;} \pmod{\frac{p}{d&#x27;}}
ax−cnt⋅d′acnt​≡d′n​(modd′p​)
此时互质，BSGS即可，当然结果要加上 cntcntcnt ，那么代码如下。
int qpow(int a,int b,int MOD)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1)&#123;            ret=ret*a%MOD;        &#125;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;    if(!b)&#123;        x=1,y=0;        return a;    &#125;    int d=exgcd(b,a%b,y,x);    y-=a/b*x;    return d;&#125;int BSGS(int a,int b,int p)&#123;    mp.clear(); // 记得换unordered_map    b%=p;    int t=sqrt(p)+1;    for(int j=0;j&lt;t;j++)&#123;        int val=b*qpow(a,j,p)%p;        mp[val]=j;    &#125;    a=qpow(a,t,p);    if(a==0) return b==0?1:-1;    for(int i=0;i&lt;=t;i++)&#123;        int val=qpow(a,i,p);        int j=mp.find(val)==mp.end()?-1:mp[val];        if(j&gt;=0&amp;&amp;i*t-j&gt;=0) return i*t-j;    &#125;    return -1;&#125;int exBSGS(int a,int b,int p)&#123;    a%=p,b%=p;// 战术取余，因为以及是转线性同余可以这样做    if(b==1||p==1) return 0;    int gcdd,d=1,cnt=0,x,y;    while((gcdd=exgcd(a,p,x,y))^1)&#123;        if(b%gcdd) return -1;// 如果无解        b/=gcdd,p/=gcdd;        cnt++;        d=1ll*d*(a/gcdd)%p; // 累计d        if(d==b) return cnt; // 如果已经有解    &#125;    exgcd(d,p,x,y); // 战术求逆元    int inv=(x%p+p)%p;    b=1ll*b*inv%p;    int ans=BSGS(a,b,p);    if(ans==-1) return -1; // 特别注意不要写错！    else return ans+cnt;&#125;
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>整体DP—从勤拿少取到量大管饱</title>
    <url>/posts/904f5191/</url>
    <content><![CDATA[ 0. 前言
这可能是全网比较全面的整体 DP 思想叙述？话说回来到底什么是整体 DP 啊嘞？
你在做 DP 题的时候。如果熟练的话，常常会写出正确的 DP 方程，却因为状态太多或过多的重复转移而超时。而整体 DP 的思想就是一种化繁为简的思路，我们把原本需要逐个处理的状态或子问题，放进一个整体里批量处理。本蒟蒻遇到的情况大致可以分为以下两类：

转移整体化：将逐点更新的转移，通过改写转移方程，转化通过数据结构上的批量操作替代逐点枚举，用数据结构一次性完成转移从而达到复杂度的优化。
多次转移合并：将多次重复的转移，转化为不再对每个问题单独求解，而是把所有子问题作为整体嵌入同一个 DP 过程。

上述的所有过程，都体现整体 DP 的思想中的核心——整体：用一次整体操作代替多次操作，避免重复计算。
想这些概括的词很累的呜呜呜。
 1. 转移整体化
 1.1 概述
转移整体化是什么呢？你看上面不说人话的大范围概括，其实就是通过类似数据结构维护序列的方式将 DP 状态中的一维压入数据结构，并通过批量操作（整体修改、整体查询）优化。其中最常见的就是线段树合并优化转移。
同时不难发现，我们由于是要求对整体进行转移，我们需要的是这个转移具有一定的固定性，即有大量相同或者说相似转移的 dp，这样才可以优化。若某一维（通常是后一维）的转移具有较强的共性时，可以考虑利用整体 dp 优化。
一般的，使用整体 dp 的题目有以下几个步骤：

写出朴素 DP；
发现朴素 DP 转移具有大量重复同样的操作，或将朴素 DP 通过前缀和等方式将转移具有一定的固定性。
出 dp 状态中转移具有共性的一维，使用数据结构维护这一维。具体地，随着其它维的变化，在数据结构上执行各种修改操作，动态维护此时此刻，当压进数据结构一维的下标为某个值时的 dp 值。

接下来我们将会以例题来详细解释这种整体转移的优化。
 1.2 例题
 线段树维护整体位移—P9400
显然的 DP，设 f(i,j)f(i,j)f(i,j) 表示考虑到前 iii 个数，最后的 jjj 个大于 bbb 的方案数，有转移：
f(i,j)=f(i−1,j−1)⋅v1j&gt;0f(i,0)=∑j=0ai−1f(i−1,j)⋅v2\begin{aligned}
f(i,j)&amp;=f(i-1,j-1)\cdot v_{1} &amp; j&gt;0 \\
f(i,0) &amp; = \sum\limits_{j=0}^{a_{i}-1} f(i-1,j)\cdot v_{2}
\end{aligned}
f(i,j)f(i,0)​=f(i−1,j−1)⋅v1​=j=0∑ai​−1​f(i−1,j)⋅v2​​j&gt;0
其中 v1=max⁡(0,ri−max⁡{li−1,b})v_{1}=\max(0,r_{i}-\max\{l_{i}-1,b\})v1​=max(0,ri​−max{li​−1,b})，v2=(ri−li+1)−max⁡(0,ri−max⁡{li−1,b})v_{2}=(r_{i}-l_{i}+1)-\max(0,r_{i}-\max\{l_{i}-1,b\})v2​=(ri​−li​+1)−max(0,ri​−max{li​−1,b})。时间复杂度 O(n2)O(n^2)O(n2)，考虑优化，注意到第二个转移可以通过前缀和 O(1)O(1)O(1) 求出，那么不难发现所有转移都由上一层转移过来，并且所有转移 O(1)O(1)O(1) 进行。考虑整体 DP，对于第一个方程可以看作整体向后移动一次然后整体乘上 v1v_{1}v1​，对于第二个转移就是更新以前的值乘上权值单点更新。
故我们需要维护一个支持单点插、单点删、区间位移、区间乘、区间求和的数据结构，用 FHQ-Treap 简单可以做到，但是有更简单的做法，由于序列长度始终为 aaa，且位移最多 nnn 次，因此我们用线段树维护一个长度为 n+an+an+a 的序列，类似于滑动窗口一样的维护当前的有效区间，每次操作先算出新的 f(i,0)f(i,0)f(i,0)，然后移动指针整体向左移动，将左侧新增的位置设置为 f(i,0)f(i,0)f(i,0)，具体实现见代码，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15,MOD=998244353;int n,a,b,L[MN],R[MN];struct Segment&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,val,tag;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].val=(t[ls].val+t[rs].val)%MOD;    &#125;    void domul(int p,int k)&#123;        t[p].val=t[p].val*k%MOD;        t[p].tag=t[p].tag*k%MOD;    &#125;    void pushdown(int p)&#123;        if(t[p].tag!=1)&#123;            domul(ls,t[p].tag);            domul(rs,t[p].tag);            t[p].tag=1;        &#125;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        t[p].tag=1;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void modify(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            domul(p,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modify(ls,fl,fr,k);        if(mid&lt;fr) modify(rs,fl,fr,k);        pushup(p);    &#125;    void change(int p,int pos,int k)&#123;        if(t[p].l==t[p].r)&#123;            t[p].val=k;            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) change(ls,pos,k);        else change(rs,pos,k);        pushup(p);    &#125;    int query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1,ret=0;        if(mid&gt;=fl) (ret+=query(ls,fl,fr))%=MOD;        if(mid&lt;fr) (ret+=query(rs,fl,fr))%=MOD;        return ret;    &#125;&#125;sg;signed main()&#123;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;L[i]&gt;&gt;R[i];    &#125;    sg.build(1,1,n+a);    int ql=n+1,qr=n+a;    sg.change(1,n+1,1);    for(int i=1;i&lt;=n;i++)&#123;        int sum=sg.query(1,ql,qr);        ql--,qr--;        int val=max(0ll,R[i]-max(b,L[i]-1));        if(ql+1&lt;=qr)&#123;            sg.modify(1,ql+1,qr,val);        &#125;        val=max(0ll,min(b,R[i])-L[i]+1)*sum%MOD;        sg.change(1,ql,val);    &#125;    cout&lt;&lt;sg.query(1,ql,qr)&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 线段树维护复杂转移—P8476
显然有一个 O(nV2)O(nV^2)O(nV2) 的 DP 就是设 f(i,j)f(i,j)f(i,j) 表示前 iii 个数最后一个 bi−1b_{i-1}bi−1​ 的值为 jjj 的最小答案。显然有转移：
f(i,j)=min⁡k=jnf(i−1,k)+w(i,j)f(i,j)=\min\limits_{k=j}^n f(i-1,k)+w(i,j)
f(i,j)=k=jminn​f(i−1,k)+w(i,j)
其中 w(i,j)w(i,j)w(i,j) 表示将 aia_{i}ai​ 改为 jjj 的代价。
注意到 V=109V=10^9V=109 很难泵，不过我们可以通过离散化 aaa 将时间复杂度做到 O(n3)O(n^3)O(n3)。考虑优化，注意到这个 min⁡\minmin 操作是一个后缀 min⁡\minmin，而且转移都是逐层转移的。考虑整体 DP，可以用线段树简单维护这个转移因为没有位移操作，但注意到 www 是一个分段函数，我们考虑 ai=ja_{i}=jai​=j 的位置作为分界点，对于这个位置之前的所有下标操作代价都是 CCC，区间价即可。
而对于后面的所有下标 xxx，每个位置需要加上 bx−aib_{x}-a_{i}bx​−ai​，首先 −ai-a_{i}−ai​ 的部分可以区间加。现在问题在于如何快速处理 bxb_{x}bx​ 的操作，注意到后缀 min⁡\minmin 会导致 DP 值单调递增，所以修改后的最小值一定取在区间的最左端点处。可以直接打 Tag 即可。
现在问题还有一个后缀 min⁡\minmin，不难发现，修改后 j&lt;aij&lt;a_{i}j&lt;ai​ 和 j&gt;aij&gt;a_{i}j&gt;ai​ 的位置分别单调递增，于是直接找到 j≥aij\ge a_{i}j≥ai​ 部分的最小值，并在 j&lt;aij&lt;a_{i}j&lt;ai​ 二分找到大于右侧最小值的部分，区间赋值抹平即可。时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e5+15;int n,tot,C,a[MN],b[MN];struct Segment&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,mn,mx,cov,add1,add2;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].mn=min(t[ls].mn,t[rs].mn);        t[p].mx=max(t[ls].mx,t[rs].mx);    &#125;    void docov(int p,int k)&#123;        t[p].cov=k;        t[p].mn=t[p].mx=k;        t[p].add1=t[p].add2=0;    &#125;    void doadd1(int p,int k)&#123;        t[p].add1+=k;        t[p].mn+=1ll*k*b[t[p].l];        t[p].mx+=1ll*k*b[t[p].r];    &#125;    void doadd2(int p,int k)&#123;        t[p].add2+=k;        t[p].mn+=k;        t[p].mx+=k;    &#125;    void pushdown(int p)&#123;        if(t[p].l==t[p].r) return;        if(~t[p].cov)&#123;            docov(ls,t[p].cov);            docov(rs,t[p].cov);            t[p].cov=-1;        &#125;        if(t[p].add1)&#123;            doadd1(ls,t[p].add1);            doadd1(rs,t[p].add1);            t[p].add1=0;        &#125;        if(t[p].add2)&#123;            doadd2(ls,t[p].add2);            doadd2(rs,t[p].add2);            t[p].add2=0;        &#125;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        t[p].cov=-1;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void cover(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            docov(p,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) cover(ls,fl,fr,k);         if(mid&lt;fr) cover(rs,fl,fr,k);        pushup(p);    &#125;    void add1(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            doadd1(p,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) add1(ls,fl,fr,k);        if(mid&lt;fr) add1(rs,fl,fr,k);        pushup(p);    &#125;    void add2(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            doadd2(p,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) add2(ls,fl,fr,k);        if(mid&lt;fr) add2(rs,fl,fr,k);        pushup(p);    &#125;    int querymn(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].mn;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        int ret=1e18;        if(mid&gt;=fl) ret=min(ret,querymn(ls,fl,fr));        if(mid&lt;fr) ret=min(ret,querymn(rs,fl,fr));        return ret;    &#125;    int binary(int p,int k)&#123;        if(t[p].mx&lt;k) return t[p].r+1;        if(t[p].l==t[p].r) return t[p].l;        pushdown(p);        if(t[ls].mx&gt;=k) return binary(ls,k);        else return binary(rs,k);    &#125;&#125;sg;signed main()&#123;    cin&gt;&gt;n&gt;&gt;C;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        b[i]=a[i];    &#125;    sort(b+1,b+1+n);    tot=unique(b+1,b+1+n)-b-1;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(b+1,b+tot+1,a[i])-b;    &#125;    sg.build(1,1,tot);    for(int i=1;i&lt;=n;i++)&#123;        if(a[i]!=1)&#123;            sg.add2(1,1,a[i]-1,C);         &#125;        sg.add2(1,a[i],tot,-b[a[i]]);        sg.add1(1,a[i],tot,1);         int rm=sg.querymn(1,a[i],tot);         int pos=sg.binary(1,rm);        if(pos&lt;a[i]) sg.cover(1,pos,a[i]-1,rm);    &#125;    cout&lt;&lt;sg.t[1].mn&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 线段树合并维护—P6733
首先考虑发掘性质，题目叽里咕噜看不懂，但是有几个性质挺好：

对于一个 vvv 及其配对祖先 uuu，我们只需要选择最深的 uuu 即可满足限制。
一个点 uuu 将其下属边置为 111，会影响其子树内部分点的限制，但这个限制影响当且仅当范围包含 uuu（即最深祖先仍在 uuu 上方）。这个操作一开始看见有 “存在” 我就哈气，直接就转为钦定边为 111。

第二个性质是第一个性质的推论，其本质就点明了子问题的设计，即限制影响的设计。
两个性质启示我们 DP 状态的设计应当包含这个限制影响范围。设 f(u,i)f(u,i)f(u,i) 表示 uuu 子树内限制祖先深度最远到了深度为 jjj 的祖先，其他我们都保证合法的方案数。
转移考虑一个一个子树合并，利用性质 2 我们可以枚举边权设置为为 0/10/10/1 转移。

边权为 111：我们把儿子一些不合法的情况清楚，如果比 depudep_{u}depu​ 还大那就没法解决，统计为 f′(u,i)=f(u,i)×(∑j=0depuf(v,j))f&#x27;(u,i)=f(u,i)\times (\sum\limits_{j=0}^{dep_{u}}f(v,j))f′(u,i)=f(u,i)×(j=0∑depu​​f(v,j))。
边权为 000，考虑合并并且讨论大小关系：

f′(u,i)=f(u,i)×∑j≤if(v,j)f&#x27;(u,i)=f(u,i)\times \sum\limits_{j\le i}f(v,j)f′(u,i)=f(u,i)×j≤i∑​f(v,j)；
f′(u,j)=(∑i&lt;jf(u,i))×f(v,j)f&#x27;(u,j)=(\sum\limits_{i&lt;j}f(u,i))\times f(v,j)f′(u,j)=(i&lt;j∑​f(u,i))×f(v,j)。



时间复杂度为 O(n2)O(n^2)O(n2)，但是发现转移是一个区间形式的转移，考虑用线段树优化这一过程，第一个式子是全局乘，第二个式子是前后缀乘法，可以利用线段树合并动态维护值优化这一过程。时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
在一些和祖先带相关限制的树形 DP 中，我们会遇到一种现象就是子树内部能解决一部分限制，但有些限制不能在当前子树内解决，只能依赖于祖先去兜底。所以 DP 状态不能只描述当前子树内部已经解决的情况，还必须记录子树内尚未解决、但需要祖先去兜底的残余需求。在下一道例题中我们会再次叙述。
如果你还需要一些线段树合并维护转移的题目，我们还有更厉害的：P5298 [PKUWC2018] Minimax
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e6+15,MOD=998244353;int n,m,mx[MN],rt[MN];vector&lt;int&gt; adj[MN];struct Segment&#123;    #define ls t[p].lson    #define rs t[p].rson    struct Node&#123;        int lson,rson,val,tag=1;    &#125;t[MN&lt;&lt;3];    int tot,tmp;    void pushup(int p)&#123;        t[p].val=(t[ls].val+t[rs].val)%MOD;    &#125;        void domul(int p,int k)&#123;        t[p].val=t[p].val*k%MOD;        t[p].tag=t[p].tag*k%MOD;    &#125;    void pushdown(int p)&#123;        if(t[p].tag!=1)&#123;            domul(ls,t[p].tag);            domul(rs,t[p].tag);            t[p].tag=1;        &#125;    &#125;    void update(int &amp;p,int l,int r,int pos,int k)&#123;        if(!p) p=++tot;        if(l==r)&#123;            t[p].val=k;            return;        &#125;        pushdown(p);        int mid=(l+r)&gt;&gt;1;        if(mid&gt;=pos) update(ls,l,mid,pos,k);        else update(rs,mid+1,r,pos,k);        pushup(p);    &#125;    int query(int p,int l,int r,int fl,int fr)&#123;        if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;            return t[p].val;        &#125;        pushdown(p);        int mid=(l+r)&gt;&gt;1,ret=0;        if(mid&gt;=fl) (ret+=query(ls,l,mid,fl,fr))%=MOD;        if(mid&lt;fr) (ret+=query(rs,mid+1,r,fl,fr))%=MOD;        return ret;    &#125;    int merge(int x,int y,int l,int r,int s1,int s2)&#123;        if(!x&amp;&amp;!y) return 0;        if(!x)&#123;            domul(y,s2);            return y;        &#125;        if(!y)&#123;            domul(x,s1+tmp);            return x;        &#125;        if(l==r)&#123;            t[x].val=(t[x].val*(s1+t[y].val+tmp)%MOD+t[y].val*s2)%MOD;            return x;        &#125;        int mid=(l+r)&gt;&gt;1;        pushdown(x);        pushdown(y);        t[x].rson=merge(t[x].rson,t[y].rson,mid+1,r,(s1+t[t[y].lson].val)%MOD,(s2+t[t[x].lson].val)%MOD);        t[x].lson=merge(t[x].lson,t[y].lson,l,mid,s1,s2);        pushup(x);        return x;    &#125;&#125;sg;namespace Tree&#123;    int dep[MN];        void dfs1(int u,int pre)&#123;        dep[u]=dep[pre]+1;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs1(v,u);        &#125;    &#125;    void dfs2(int u,int pre)&#123;        sg.update(rt[u],0,n,mx[u],1);        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs2(v,u);            sg.tmp=sg.query(rt[v],0,n,0,dep[u]);            rt[u]=sg.merge(rt[u],rt[v],0,n,0,0);        &#125;    &#125;&#125;using namespace Tree;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs1(1,0);    cin&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        mx[v]=max(mx[v],dep[u]);    &#125;    dfs2(1,0);    cout&lt;&lt;sg.query(rt[1],0,n,0,0);    return 0;&#125;
 用堆维护—CF671D
祖先限制，考虑 DP，设 f(u,i)f(u,i)f(u,i) 表示 uuu 子树内全部覆盖，其限制向上延伸到了深度为 jjj 的祖先的最小花费，其中 jjj 满足 j≤depij\le dep_{i}j≤depi​。那么有转移方程：
f(u,i)=min⁡v∈son(u){f(u,i)+min⁡j=0depif(v,j),f(v,i)+min⁡j=0depif(u,j)}f(u,i)=\min\limits_{v\in son(u)} \{f(u,i)+\min\limits_{j=0}^{dep_{i}}f(v,j),f(v,i)+\min\limits_{j=0}^{dep_{i}}f(u,j)\}
f(u,i)=v∈son(u)min​{f(u,i)+j=0mindepi​​f(v,j),f(v,i)+j=0mindepi​​f(u,j)}
即我们考虑合并子节点的答案，答案合并的时候可能从 f(u)f(u)f(u) 或者 f(v)f(v)f(v) 一个产生。我们不难发现有两个前缀 min⁡\minmin 的操作，并且操作为子树合并取 min⁡\minmin 操作，考虑线段树合并，对合并时可能产生的情况进行分类讨论即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)，但是显然有点过于难了不是吗？
我们还有跟简单的方法，注意到我们操作每次取操作的时前缀 min⁡\minmin，而且在子树合并过程中 depidep_{i}depi​ 单调不升，我们可以考虑用堆来维护这个操作，对于 j&gt;depij&gt;dep_{i}j&gt;depi​ 的操作我们考虑懒惰删除（我们用的时候在排除不合法状态）。因此我们在每个节点上维护一个堆，堆里装所有的第二维状态和值即可。使用左偏树可以做到 O(nlog⁡n)O(n\log n)O(nlogn)，使用堆或 set 加启发式合并可以做到 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=3e5+15;struct Node&#123;    int j,cst;    bool operator&lt;(const Node &amp;x)const&#123;        return cst&lt;x.cst;    &#125;&#125;;int n,m,dep[MN],ans,tag[MN];bool flag=1;vector&lt;int&gt; adj[MN];vector&lt;pir&gt; path[MN];multiset&lt;Node&gt; st[MN];void merge(int x,int y)&#123;    if(st[x].size()&lt;st[y].size()) swap(st[x],st[y]),swap(tag[x],tag[y]);     int mnx=(!st[x].size())?0:(*st[x].begin()).cst,mny=(!st[y].size())?0:(*st[y].begin()).cst;    while(!st[y].empty())&#123;        auto tp=(*st[y].begin());        st[y].erase(st[y].begin());        tp.cst+=mnx-mny;        st[x].insert(tp);    &#125;    tag[x]+=mny+tag[y];&#125;void dfs1(int u,int pre)&#123;    dep[u]=dep[pre]+1;    for(auto v:adj[u])&#123;        if(v==pre||!flag) continue;        dfs1(v,u);        merge(u,v);    &#125;    if(!flag) return;    int minn=0;    if(!st[u].empty()) minn=(*st[u].begin()).cst;    for(auto p:path[u])&#123;        st[u].insert(&#123;p.first,p.second+minn&#125;);    &#125;    if(st[u].empty())&#123;        flag=0;        return;    &#125;    if(u!=1)&#123;        while(!st[u].empty()&amp;&amp;dep[(*st[u].begin()).j]&gt;=dep[u]) st[u].erase(st[u].begin());        if(st[u].empty())&#123;            flag=0;            return;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        path[u].push_back(pir(v,w));    &#125;    dfs1(1,0);    if(!flag)&#123;        cout&lt;&lt;-1;        return 0;    &#125;    else if(m==1) cout&lt;&lt;0;    else cout&lt;&lt;st[1].begin()-&gt;cst+tag[1];    return 0;&#125;
 差分化维护—P6847
今天没有什么太好的性质，考虑 DP，设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内断边在 ≤j\le j≤j 的时间断开，转移：

不获取 u 点的果汁：f(u,i)=∑vf(v,i)f(u,i)=\sum\limits_{v}f(v,i)f(u,i)=v∑​f(v,i)
断开父边，获取 u 点的果汁：f(u,x)=wu+∑vf(v,du)f(u,x)=w_{u}+\sum\limits_{v}f(v,d_{u})f(u,x)=wu​+v∑​f(v,du​)，其中 x≥dux\ge d_{u}x≥du​。
线段树合并来优化，第一种转移就直接线段树合并，第二种转移不能维护区间最值标记。而且合并不太好维护，考虑分析性质，发现 f(u,∗)f(u,*)f(u,∗) 随 iii 增加而单调，那么第二种转移可以考虑成区间赋值。实现中区间赋值不打标记，而是线段树上的点维护 min⁡\minmin 和 max⁡\maxmax，如果 min⁡=max⁡\min=\maxmin=max 的时候就说明这个区间是一个值，线段树合并的时候如果遇到区间同值的情况就打加法标记，修改的时候如果区间同值就新开儿子节点，上传的时候如果发现区间同值可以把儿子节点删掉，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。

更 nb 的，因为 dp 值单调所以可以考虑差分，那么第一种转移就能直接启发式合并，第二种转移是增加 wuw_{u}wu​ 的差分值，直接插入 set 中，这其实是取 max 操作，所以要从后面删除一些差分标记，时间复杂度 O(nlog⁡2n)O(n\log^2 n)O(nlog2n)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e5+15;int n,m,K,rt[MN],d[MN],w[MN];vector&lt;int&gt; adj[MN];struct Segment&#123;    #define ls t[p].lson    #define rs t[p].rson    struct Node&#123;        int lson=0,rson=0;        int mx=0,mn=0,add=0;    &#125;t[MN*50];    int tot=0;    bool isleaf(int p)&#123;        if(!p) return true;        return !t[p].lson &amp;&amp; !t[p].rson;    &#125;    void doadd(int p,int k)&#123;        if(!p) return;        t[p].mn += k;        t[p].mx += k;        t[p].add += k;    &#125;    void pushup(int p)&#123;        int L=t[p].lson, R=t[p].rson;        int mxL = L? t[L].mx : INT_MIN/2;        int mxR = R? t[R].mx : INT_MIN/2;        int mnL = L? t[L].mn : INT_MAX/2;        int mnR = R? t[R].mn : INT_MAX/2;        t[p].mx = max(mxL,mxR);        t[p].mn = min(mnL,mnR);        if(t[p].mx==t[p].mn)&#123;            t[p].lson = t[p].rson = 0;            t[p].add = 0;        &#125;    &#125;    void pushdown(int p)&#123;        if(!p) return;        if(t[p].add)&#123;            doadd(t[p].lson,t[p].add);            doadd(t[p].rson,t[p].add);            t[p].add=0;        &#125;    &#125;    int merge(int x,int y)&#123;        if(!x || !y) return x?x:y;        if(isleaf(y))&#123;            doadd(x,t[y].mx);            return x;        &#125;        if(isleaf(x))&#123;            doadd(y,t[x].mx);            return y;        &#125;        pushdown(x);        pushdown(y);        t[x].lson = merge(t[x].lson, t[y].lson);        t[x].rson = merge(t[x].rson, t[y].rson);        pushup(x);        return x;    &#125;    int query(int p,int l,int r,int k)&#123;        if(!p) return 0;        if(isleaf(p)) return t[p].mx;        pushdown(p);        int mid=(l+r)&gt;&gt;1;        if(k&lt;=mid) return query(t[p].lson,l,mid,k);        else return query(t[p].rson,mid+1,r,k);    &#125;    void modify(int &amp;p,int l,int r,int fl,int fr,int k)&#123;        // non-overlap        if(l&gt;fr || r&lt;fl || !p) return;        // if current interval&#x27;s min already &gt;= k, nothing to do        if(t[p].mn &gt;= k) return;        // fully covered and max &lt;= k -&gt; set to k and clear children        if(l&gt;=fl &amp;&amp; r&lt;=fr &amp;&amp; t[p].mx &lt;= k)&#123;            t[p].mx = t[p].mn = k;            t[p].lson = t[p].rson = t[p].add = 0;            return;        &#125;        pushdown(p);        int mid=(l+r)&gt;&gt;1;        if(isleaf(p))&#123;            t[p].lson = ++tot;            t[p].rson = ++tot;            t[t[p].lson].mx = t[t[p].lson].mn = t[t[p].rson].mx = t[t[p].rson].mn = t[p].mx;            // add/add initialized to 0 by Node default        &#125;        if(fl &lt;= mid) modify(t[p].lson, l, mid, fl, fr, k);        if(fr &gt; mid) modify(t[p].rson, mid+1, r, fl, fr, k);        pushup(p);    &#125;&#125;sg;void dfs(int u,int pre)&#123;    rt[u] = ++sg.tot;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs(v,u);        rt[u] = sg.merge(rt[u], rt[v]);    &#125;    if(d[u])&#123;        int cur = sg.query(rt[u],1,K,d[u]);        int val = w[u] + cur;        sg.modify(rt[u],1,K,d[u],K,val);    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;K;    for(int i=2;i&lt;=n;i++)&#123;        int fa;        cin&gt;&gt;fa;        adj[fa].push_back(i);        adj[i].push_back(fa);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int x;        cin&gt;&gt;x&gt;&gt;d[x]&gt;&gt;w[x];    &#125;    dfs(1,0);    cout&lt;&lt;sg.t[rt[1]].mx&lt;&lt;&quot;\n&quot;;    return 0;&#125;
 1.3 习题与反思
一开始所提到的转移整体化的核心，在于把原本需要在 DP 中逐个状态枚举的转移，用批量可维护的方式交给数据结构来完成，从而让复杂度从 O(n2)O(n^2)O(n2)、O(nV)O(nV)O(nV) 这类指数或平方级，下降到 O(nlog⁡n)O(n\log n)O(nlogn) 甚至更优。对于一类有大量相同或者说相似转移的 dp，把 dp 的一维换成数据结构，用数据结构批量处理相同的转移。
来点习题练练手！

CF490F Treeland Tour
P4577 [FJOI2018] 领导集团问题

 2. 多次转移合并
 2.1 概述
多次转移合并这个名字怎么这么奇怪呢？
回忆我们一开始所提到的：

多次转移合并：将多次重复的转移，转化为不再对每个问题单独求解，而是把所有子问题作为整体嵌入同一个 DP 过程。

换句话说，如果每个问题的转移规则是固定的，那么我们可以把每个问题对答案的贡献统一考虑，通过一次 DP 或一次数据结构操作，计算出全部结果，而不必重复遍历。
这种整体化思想有两种展开（也是本蒟蒻所能够遇见的）：

转移贡献可叠加性：每个询问的转移对最终答案的贡献要独立计算，但所有贡献可以累加到一次 DP 中。我们可以通过合理的初始化，通过一次 DP 计算出所有答案。
多询问整体处理：当存在多个修改或查询时，每次修改只影响少量节点，但转移规则固定。我们可以将每次查询抽象为初始值修改，用数据结构一次性维护所有查询的结果，而不是重复跑 DP。

接下来我们会通过例题详细展开：
 2.2 例题
 转移贡献可叠加性
当 DP 的转移是固定的、局部的贡献可线性累加，就可以用一次整体 DP 代替多次重复计算。这一类常见的就是子区间问题的统计。
 CF1603C Extreme Extension
首先考虑序列给定的话如何计算，显然最后一个值不可能动不然根据调整法不难证明不优。
那么也就是说最后一个值肯定是最大值，然后我们从后往前考虑，不妨记当前最大值为 xxx 每次拆我们尽量往大的拆，那么最少需要拆 k=⌈aix⌉k=\lceil \dfrac{a_{i}}{x} \rceilk=⌈xai​​⌉ 次，而拆值后新的开头 x′=⌊aik⌋x&#x27;=\lfloor \dfrac{a_{i}}{k} \rfloorx′=⌊kai​​⌋。
显然对于每个 iii 其 kkk 与 x′x&#x27;x′ 的取值最多只有 n\sqrt{n}n​ 种，并且计算只和当前开头有关，故设 f(i,j)f(i,j)f(i,j) 表示第 iii 个位置开头数字为 jjj 的方案数。直接做的话是 O(nn)O(n\sqrt{n})O(nn​) 的，但是问题在于子区间统计做的话是 O(n2n)O(n^2\sqrt{n})O(n2n​) 的，注意到我们每次转移都是一致的系数完全一致，考虑整体 DP，在所有右端点处初始化，在左端点处统计答案，由于这个贡献是子区间完全可以累加贡献，只需要做一次 dp 就可以解决问题。时间复杂度 O(nn)O(n\sqrt{n})O(nn​)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15,MOD=998244353;int n,mx,a[MN],f[2][MN],ans;vector&lt;int&gt; vct[2];void initdp()&#123;    ans=0;    vct[0].clear();    vct[1].clear();    mx=0;    for(int i=1;i&lt;=n;i++)&#123;        mx=max(mx,a[i]);    &#125;    for(int i=0;i&lt;=mx;i++)&#123;        f[0][i]=f[1][i]=0;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    initdp();    int now=0,bef=1;    for(int i=n;i&gt;=1;i--)&#123;        now^=1,bef^=1;        int lst=a[i];        vct[now].push_back(a[i]);        f[now][a[i]]=1;        for(auto p:vct[bef])&#123;            int cnt=ceil(1.0*a[i]/p),val=a[i]/cnt;            f[now][val]=(f[now][val]+f[bef][p])%MOD;            ans=(ans+(cnt-1)*i%MOD*f[bef][p]%MOD)%MOD;                       if(lst!=val)&#123;                vct[now].push_back(val);                lst=val;            &#125;        &#125;        for(auto p:vct[bef]) f[bef][p]=0;        vct[bef].clear();    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 CF1142D Foreigner
首先这个玩意过于抽象。但是我们不难发现每一层判断决策只和当前排名个数和上一位是什么有关，而且这个数列是根据生成顺序递增的。考虑增量法，我们考虑计算往数列中第 iii 个数后面接一位 ccc，得到的数字的排名是多少？我们可以考虑计算比它小的合法数量，这里给出式子：
9+∑j=1i−1k mod 11+c+19+\sum\limits_{j=1}^{i-1} k\bmod 11 +c+1
9+j=1∑i−1​kmod11+c+1
但是我们只需要判断一个数是否是合法数字即可，考虑把上面式子放在  mod 11\bmod 11mod11 的意义下进行就可以得到，有：
10+i(i−1)2+c(mod11)10+\dfrac{i(i-1)}{2}+c \pmod{11}
10+2i(i−1)​+c(mod11)
不难发现这个值只和  mod 11\bmod 11mod11 后的值有关，对于原来的计数问题，可以考虑设计一个自动机来转移，说人话，设 f(i,j)f(i,j)f(i,j) 表示前 iii 位中有多少排名  mod 11\bmod 11mod11 为 jjj 的不充分数字。枚举起点然后做时 O(n2)O(n^2)O(n2) 的，但是注意到这是子区间，显然满足贡献可叠加，直接在左端点初始化，走到右端点时上拿答案即可，时间复杂度 O(n)O(n)O(n)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;int n,f[MN][15],ans;string st;int nxt(int x,int c)&#123;	return (x*(x-1)/2+c+10)%11;&#125;signed main()&#123;    cin&gt;&gt;st;    n=st.length();    st=&quot; &quot;+st;    for(int i=1;i&lt;=n;i++)&#123;        int ch=st[i]-&#x27;0&#x27;;        if(ch&gt;0) f[i][ch]++;        for(int j=ch+1;j&lt;=10;j++)&#123;            f[i][nxt(j,ch)]+=f[i-1][j];        &#125;        for(int j=0;j&lt;=10;j++) ans+=f[i][j];    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 P3352 线段树
需要把这些序列大小要整合到一起，不知道用什么处理？笛卡尔树？bro 有点难。咱们还是考虑 01 序列怎么做吧。
首先没有概率，就是纯纯的求方案数乘上权值。考虑值域为 {0,1}\{0,1\}{0,1} 的时候怎么做，不难发现对答案造成贡献必定是 000 段和 111 段合并，并且发现 000 段必定会被 111 段给包夹（边界位置设置为 111)。考虑到每次操作 111 段大小单调不降，000 段大小单调不升，我们考虑 DP 主体应该为 000 段，有状态 f(i,l,r)f(i,l,r)f(i,l,r) 表示 iii 操作后 000 段缩小到 [l,r][l,r][l,r] 的方案数，有转移：
dp[i][l][r]←{dp[i−1][l][r]⋅l(l+1)+(n−r+1)(n−r+2)+(r−l)(r−l−1)2QwQdp[i−1][l′][r]⋅l′l′&lt;ldp[i−1][l][r′]⋅(n−r′+1)r′&gt;rdp[i][l][r]\leftarrow\begin{cases}dp[i-1][l][r]\cdot\frac{l(l+1)+(n-r+1)(n-r+2)+(r-l)(r-l-1)}{2} &amp; \text{QwQ}\\dp[i-1][l&#x27;][r]\cdot l&#x27; &amp; l&#x27;&lt;l \\ dp[i-1][l][r&#x27;]\cdot (n-r&#x27;+1) &amp; r&#x27;&gt; r\end{cases}
dp[i][l][r]←⎩⎪⎪⎨⎪⎪⎧​dp[i−1][l][r]⋅2l(l+1)+(n−r+1)(n−r+2)+(r−l)(r−l−1)​dp[i−1][l′][r]⋅l′dp[i−1][l][r′]⋅(n−r′+1)​QwQl′&lt;lr′&gt;r​
不难发现可以用前缀和优化转移，时间复杂度 O(n2q)O(n^2q)O(n2q)，拓展到一般序列上我们把 www 的贡献拆为 max⁡ai−max⁡i=0max⁡ai[w&lt;i]\max a_{i}-\max_{i=0}^{\max a_{i}} [w&lt;i]maxai​−maxi=0maxai​​[w&lt;i]，即把所有 ≥i\ge i≥i 的位置标为 1，把所有 &lt;i&lt;i&lt;i 的位置标为 0。此时我们就可以算出每一个位置 &lt;i&lt;i&lt;i 的方案数，时间复杂度 O(n3q)O(n^3q)O(n3q)，数据随机可过。
显然太吃运气了，考虑优化！发现所有的 dp 值的转移柿子都完全一致而且系数完全固定，只有转移是不同的！所以我们可以把所有初始值放到同一个 dp 数组里面，然后通过合理初始化进行一次整体的 dp，就可以求出答案。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=520,MOD=1e9+7,INV2=500000004;struct Node&#123;    int v,id;&#125;a[MN];int n,q,ans[MN],f[MN][MN],s1[MN][MN],s2[MN][MN],v[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;int w(int l,int r)&#123;    return (l*(l+1)%MOD+(n-r+1)*(n-r+2)%MOD+(r-l-1)*(r-l)%MOD)*INV2%MOD;&#125;bool cmp(Node x,Node y)&#123;    return x.v&lt;y.v;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].v;        a[i].id=i;    &#125;    sort(a+1,a+1+n,cmp);    v[n+1]=1;    for(int i=n;i&gt;=1;i--)&#123;        int lst=0;        v[a[i].id]=1;        for(int j=1;j&lt;=n+1;j++)&#123;            if(v[j])&#123;                f[lst][j]+=a[i].v-a[i-1].v;                lst=j;            &#125;        &#125;    &#125;    ans[1]=a[n].v*ksm(n*(n+1)%MOD*INV2%MOD,q);    for(int i=2;i&lt;=n;i++) ans[i]=ans[1];    for(int i=1;i&lt;=q;i++)&#123;        for(int j=0;j&lt;=n;j++)&#123;            for(int k=n+1;k&gt;j+1;k--)&#123;                if(j)&#123;                    s1[j][k]=(s1[j-1][k]+f[j][k]*j%MOD)%MOD;                &#125;else s1[j][k]=f[j][k]*j%MOD;                if(k&lt;=n)&#123;                    s2[j][k]=(s2[j][k+1]+f[j][k]*(n-k+1)%MOD)%MOD;                &#125;else s2[j][k]=(f[j][k]*(n-k+1)%MOD)%MOD;            &#125;        &#125;        for(int j=0;j&lt;=n;j++)&#123;            for(int k=j+2;k&lt;=n+1;k++)&#123;                f[j][k]=f[j][k]*w(j,k)%MOD;                if(j)&#123;                    f[j][k]=(f[j][k]+s1[j-1][k])%MOD;                &#125;                if(k&lt;=n) f[j][k]=(f[j][k]+s2[j][k+1])%MOD;            &#125;        &#125;    &#125;    for(int i=0;i&lt;=n;i++)&#123;        for(int j=i+2;j&lt;=n+1;j++)&#123;            for(int k=i+1;k&lt;j;k++)&#123;                ans[k]=(ans[k]-f[i][j]+MOD)%MOD;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;;    return 0;&#125;
 多询问整体处理
每次修改只影响少量节点，但转移规则固定。这就是核心，对于一些只有状态上的值不同而转移方程完全相同的 DP 可以考虑使用这个 trick。接下来我们会以保卫王国这道经典题来作为叙述。
 P5024 保卫王国
显然可以写出朴素转移方程，设 f(i,0/1)f(i,0/1)f(i,0/1) 表示 iii 子树中，钦定 iii 不选或选的最小代价，有转移：
f(u,0)=∑v∈son(u)f(v,1)f(u,1)=∑v∈son(u)min⁡{f(v,0),f(v,1)}\begin{aligned}
f(u,0) &amp;=\sum\limits_{v\in son(u)} f(v,1) \\
f(u,1) &amp;= \sum\limits_{v\in son(u)} \min\{f(v,0),f(v,1)\}
\end{aligned}
f(u,0)f(u,1)​=v∈son(u)∑​f(v,1)=v∈son(u)∑​min{f(v,0),f(v,1)}​
显然转移都是 O(n)O(n)O(n) 的，如果对于每个询问直接强制钦定然后重新 DP 的话时间复杂度是 O(n2)O(n^2)O(n2) 的，无法通过。
我们发现尽管强制钦定之后转移仍是固定的，虽然在每次询问中，某些节点被强制钦定，但转移方程本身从来没有变过，变的只是某些节点的取值。例如对于每个节点 uuu，正常的 DP 状态就是 f(u,∗)f(u,*)f(u,∗)，这是在没有任何强制约束时的最优值。当一条询问出现，比如强制 uuu 不选，这其实就是把 f(u,1)f(u,1)f(u,1) 赋为 ∞\infty∞；同理强制 uuu 必须选，就是把 f(u,0)f(u,0)f(u,0) 赋为 ∞\infty∞**。
如果我们对于每个询问都从根重新跑一次树形 DP，复杂度就是 O(nm)O(nm)O(nm)。但是发现每次询问都只是修改了少量个别节点的 DP 初值；而且合并答案的规则是固定的。
我们可以将 DP 方程改写为矩阵形式，这里矩阵运算为 (min⁡,+)(\min,+)(min,+) 广义矩阵乘法，这里不再列举。此时，强制钦定相当于在某个叶子节点上乘一个特殊矩阵，例如强制不选：[f(0),f(1)]×[∞∞∞0][f(0), f(1)] \times \begin{bmatrix}\infty &amp; \infty \\ \infty &amp; 0\end{bmatrix}[f(0),f(1)]×[∞∞​∞0​]；这样我们就能通过矩阵的形式表达对于某个节点的 DP 修改，并且这种修改是可以自下而上合并的。
如果对每个询问单独做矩阵 DP，复杂度仍高。但是我们发现只有少量的值会被修改，而且每次询问吧修改至多是 222 次单点修改，既然修改只发生在极少数节点，我们能不能把询问当作一堆修改，整体放到同一套 DP 里？正难则反！我们不考虑对每个询问求 DP 的值，而是在 DP 过程中维护每个询问情况下所对应的值！我们可以批量地对所有需要进行这一转移的 DP 进行转移，从而加快速度。
那如果我们现在拿着所有询问的 dp 值组成的一个数组，那么发现如果一个儿子没有成为过特殊点，它的转移显然用固定的转移矩阵维护就可以了；如果它成为过特殊点，我们可以单独转移它成为特殊点的那几次，就像上面特殊的用矩阵乘上。
暴力转移是 O(n2)O(n^2)O(n2) 的，如何更快地维护呢，例如 O(log⁡n)O(\log n)O(logn)？我们有很多次修改，每次询问对应修改几个节点的 DP 初值；还需要快速把这些修改合并到全局结果里，这不线段树合并吗！
具体的，我们对于树上每个节点开一个线段树，让线段树上第 iii 个叶子表示第 iii 次询问的 DP 值，即 [f(0),f(1)][f(0), f(1)][f(0),f(1)]。注意这里的线段树仅仅是一个分治结构，而不是什么维护区间结合律信息的数据结构，也就是没有 pushup 这种玩意。它存在的意义就是利用结构一致和深度为 O(log⁡n)O(\log n)O(logn) 来支持快速的单点修改和合并答案两个操作。
合并的时候，因为我们只关心叶子的信息，也就是 DP 值，考虑如果两棵线段树上有一棵有某个叶子 uuu，而另一棵没有，那么这个 uuu 的值应该没有变化，所以合并的时候不用管它如果两棵上都有 uuu，那么我们应该进行一个转移，我们记录这个 DP 值是属于哪一种转移，然后由于合并算法确实会走到这里，我们走到这里再执行转移就好了。
这个就是多询问整体处理的一个思想，其本质就是把多次 DP 叠加，转化为一次带修改的数据结构维护问题。在固定转移下，把多组独立询问抽象为初值修改，然后用线段树把它们整体维护起来，实现一次 DP 覆盖所有询问。
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e5+15;const int INF=1e18;int ans[MN],a[MN],n,m,rt[MN];vector&lt;int&gt; adj[MN];vector&lt;pir&gt; qry[MN];struct Matrix&#123;    int mat[2][2];    Matrix(int x=0)&#123;        mat[0][0]=mat[0][1]=mat[1][0]=mat[1][1]=x;    &#125;    Matrix(int x1,int y1,int x2,int y2)&#123;        mat[0][0]=x1;mat[0][1]=y1;mat[1][0]=x2;mat[1][1]=y2;    &#125;    Matrix(int x,int y)&#123;        mat[0][0]=x;mat[1][1]=y;mat[0][1]=mat[1][0]=INF;    &#125;    friend bool operator==(const Matrix &amp;x,const Matrix &amp;y)&#123;        for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) if(x.mat[i][j]!=y.mat[i][j]) return 0;        return 1;    &#125;    friend Matrix operator*(const Matrix &amp;x,const Matrix &amp;y)&#123;        Matrix ret(INF);        for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++)            ret.mat[i][j]=min(ret.mat[i][j],x.mat[i][k]+y.mat[k][j]);        return ret;    &#125;&#125;;const Matrix MINF=Matrix(0,INF,INF,0);struct Segment&#123;    #define ls t[p].lson    #define rs t[p].rson    struct Node&#123;        int lson,rson;        Matrix val;    &#125;t[MN*30];    int tot;    void init(int x)&#123;t[x].lson=t[x].rson=0;t[x].val=MINF;&#125;    void pushdown(int p)&#123;        if(t[p].val==MINF) return;        if(!ls) ls=++tot,init(ls);        if(!rs) rs=++tot,init(rs);        t[ls].val=t[ls].val*t[p].val;        t[rs].val=t[rs].val*t[p].val;        t[p].val=MINF;    &#125;    void modify(int &amp;p,int l,int r,int pos,const Matrix &amp;k)&#123;        if(!p) p=++tot,init(p);        if(l==r)&#123;            t[p].val=t[p].val*k;            return;        &#125;        pushdown(p);        int mid=(l+r)&gt;&gt;1;        if(pos&lt;=mid)&#123;            modify(ls,l,mid,pos,k);        &#125;else&#123;            modify(rs,mid+1,r,pos,k);        &#125;    &#125;    int merge(int x,int y)&#123;        if(!x||!y) return x|y;        if(!t[x].lson&amp;&amp;!t[x].rson) swap(x,y);        if(!t[y].lson&amp;&amp;!t[y].rson)&#123;            t[x].val=t[x].val*Matrix(t[y].val.mat[0][0],t[y].val.mat[0][1]);            return x;        &#125;        pushdown(x);        pushdown(y);        t[x].lson=merge(t[x].lson,t[y].lson);        t[x].rson=merge(t[x].rson,t[y].rson);        return x;    &#125;    void solve(int p,int l,int r)&#123;        if(l==r)&#123;            ans[l]=t[p].val.mat[0][1];            return;        &#125;        pushdown(p);        int mid=(l+r)&gt;&gt;1;        if(ls) solve(ls,l,mid);        if(rs) solve(rs,mid+1,r);    &#125;&#125;sg;void dfs(int u,int pre)&#123;    rt[u]=++sg.tot;    sg.init(rt[u]);    sg.t[rt[u]].val=Matrix(0,a[u],0,0);    for(auto v:adj[u]) if(v!=pre)&#123;        dfs(v,u);        rt[u]=sg.merge(rt[u],rt[v]);    &#125;    for(auto pr:qry[u])&#123;        if(pr.first==0) sg.modify(rt[u],1,m,pr.second,Matrix(0,INF));        else sg.modify(rt[u],1,m,pr.second,Matrix(INF,0));    &#125;    sg.t[rt[u]].val=sg.t[rt[u]].val*Matrix(INF,0,0,0);&#125;signed main()&#123;    string tmp;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;tmp;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int x1,v1,x2,v2;        cin&gt;&gt;x1&gt;&gt;v1&gt;&gt;x2&gt;&gt;v2;        qry[x1].push_back(&#123;v1,i&#125;);        qry[x2].push_back(&#123;v2,i&#125;);    &#125;    sg.init(0);    dfs(1,0);    if(rt[1]) sg.solve(rt[1],1,m);    for(int i=1;i&lt;=m;i++) cout&lt;&lt;(ans[i]&gt;=INF?-1:ans[i])&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 P2495 消耗战
虚树？不不不这是整体 DP！
先考虑一次询问怎么做，设 f(u)f(u)f(u) 表示子树 uuu 内所有关键点到 uuu 的路径切断的最小代价，转移方程显然：

若 uuu 的儿子是关键点，那么 f(u)f(u)f(u) 加上 w(u,v)w(u,v)w(u,v)；
否则，f(u)f(u)f(u) 加上 min⁡{w(u,v),f(v)}\min\{w(u,v),f(v)\}min{w(u,v),f(v)}。
特别的，若 uuu 为关键点，那么 f(u)=∞f(u)=\inftyf(u)=∞。

可以发现，这个 DP 的过程非常简洁，由几个简单的操作组成：求和，取 min。不难可以写成 O(1)O(1)O(1) 转移式子或者矩阵形式，然后用上面的技巧维护，取 min 就是全局取 min，求和就是线段树合并的时候对应位置相加。时间复杂度 O(mlog⁡m)O(m\log m)O(mlogm)。
代码咕咕咕，如果想要可以参考 Fuyuki 的文章。
 3. 参考与后言
上面说这么多，归根结底，这种方法的精髓在于将重复工作转化为一次统一处理。整体思想，就是在于整体处理，整体转移。种性质允许我们将原本需要多次重复计算的子问题，整合到一次整体 DP 中处理，从而大幅提升效率，避免重复操作。
这个博客提到的整体 DP 感觉可以单开一章，不过有点看不懂了，大家可以作为饭后作业 www。
求赞 QwQ。

「学习笔记」整体 dp - xgzc
高级算法指北——浅谈整体dp - 烟山嘉鸿
整体dp学习笔记——Querainy
zxy的思维技巧 - C202044zxy
DP 优化方法大杂烩——Alex_Wei
【学习笔记】(27) 整体 DP - Aurora-JC
保卫王国 整体 DP 做法——xxseven
「Tricks」整体DP——cirnovsky
NOIP2018 D2T3 题解 + 关于动态 DP 等科技的一些总结 -immortalCO的博客
题解 P2495 【[SDOI2011]消耗战】——Fuyuki

]]></content>
      <categories>
        <category>DP优化</category>
      </categories>
      <tags>
        <tag>DP优化</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化与WQS带权二分优化DP</title>
    <url>/posts/91825b20/</url>
    <content><![CDATA[ 1.前言
本文章图较多！
动态规划在转移的时候，我们称最终转移过来的状态为决策点。
而对于斜率优化和WQS带权二分都是利用凸包和切线的概念来优化DP

[!WARNING]
斜率优化和WQS带权二分几乎完全不同，请不要混淆！

 2.凸包与切线
 2.1 凸包
凸包是什么呢？其实就是字面意思，一个凸起的小包，但是这个是描述图形的。如下图：

严谨来说，应当是其图形的切线斜率是具有单调性，其导函数f′(x)f&#x27;(x)f′(x)具有单调性。
但是在OI中一般凸包都不是光滑的，如下图。

但是也还是可以满足定义的即：

经过相邻两点的直线斜率有单调性

 2.2 切线与一次函数
 2.2.1 一次函数
y=kx+by=kx+b
y=kx+b

kkk：斜率
bbb：截距（yyy 轴交点）

 2.2.2 切线
对于切线来说，不阐述概念，但是我们可以观察一下性质。
我们让一个固定斜率kkk的直线取切这个二次函数（也是个凸包）

发现什么？当恰好在切点时，截距bbb 最大，这是条基本也是条很重要的性质。
 3. 斜率优化
 3.1 k与x同单调
来做DP题。

nnn 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 nnn 个任务被分成若干批，每批包含相邻的若干任务。
从零时刻开始，这些任务被分批加工，第 iii 个任务单独完成所需的时间为 tit_iti​。在每批任务开始前，机器需要启动时间 sss，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。
每个任务的费用是它的完成时刻乘以一个费用系数 cic_ici​。请确定一个分组方案，使得总费用最小。
1≤n≤50001\le n \le 50001≤n≤5000，0≤s≤500 \le s \le 500≤s≤50，1≤ti,fi≤1001\le t_i,f_i \le 1001≤ti​,fi​≤100。

我们无论怎么分段和后面没有任何关系，每一个分段问题都是一个子问题且满足无后效性，我们其实没有必要单独设计分的段数这一状态来记录，不难设计转移方程：
f(i)=min⁡j=1i−1f[j]+sumT[i]∗(sumC[i]−sumC[j])+S∗(sumC[n]−sumC[j])f(i)=\min\limits_{j=1}^{i-1} f[j]+sumT[i]*(sumC[i]-sumC[j])+S*(sumC[n]-sumC[j])
f(i)=j=1mini−1​f[j]+sumT[i]∗(sumC[i]−sumC[j])+S∗(sumC[n]−sumC[j])

f(i)f(i)f(i)：表示把前iii个任务分成若干批执行的最小费用。
sumTsumTsumT：tit_iti​的前缀和
sumCsumCsumC：cic_ici​的前缀和

其实这里有一个费用提前计算的思想，观察转移方程后面部分的S∗(sumC[n]−sumC[j])S*(sumC[n]-sumC[j])S∗(sumC[n]−sumC[j])。我们并不知道前面启动过几次及其，但是执行任务花费的启动时间SSS必定会对后面的计算造成影响，累加贡献。
显然时间复杂度O(n2)O(n^2)O(n2)，代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=5125;int n,s;ll a[MN],sumt[MN],sumc[MN],f[MN];int main()&#123;    cin&gt;&gt;n&gt;&gt;s;    for(int i=1;i&lt;=n;i++)&#123;        ll t,c;        cin&gt;&gt;t&gt;&gt;c;        sumt[i]=sumt[i-1]+t;        sumc[i]=sumc[i-1]+c;    &#125;    memset(f,0x3f,sizeof(f));    f[0]=0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=0;j&lt;i;j++)&#123;            f[i]=min(f[i],f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]));        &#125;    &#125;    cout&lt;&lt;f[n];    return 0;&#125;
但是我们如果要求时间复杂度O(n)O(n)O(n)呢？
我们观察以下这个式子，首先这个min⁡\minmin太难受了，反正我知道要取就行：
f(i)=f[j]+sumT[i]∗(sumC[i]−sumC[j])+S∗(sumC[n]−sumC[j])f(i)=f[j]+sumT[i]*(sumC[i]-sumC[j])+S*(sumC[n]-sumC[j])
f(i)=f[j]+sumT[i]∗(sumC[i]−sumC[j])+S∗(sumC[n]−sumC[j])
我们拆一下这个式子，移个项。
f[i]=f[j]+sumT[i]∗sumC[i]−sumT[i]∗sumC[j]+S∗sumc[n]−S∗sumc[j]f[j]=(S+sumT[i])∗sumC[j]+f[i]−sumT[i]∗sumC[i]−S∗sumC[n]\begin{aligned}
f[i] &amp; =f[j]+sumT[i]*sumC[i]-sumT[i]*sumC[j]+S*sumc[n]-S*sumc[j] \\
f[j] &amp; = (S+sumT[i])*sumC[j]+f[i]-sumT[i]*sumC[i]-S*sumC[n]
\end{aligned}f[i]f[j]​=f[j]+sumT[i]∗sumC[i]−sumT[i]∗sumC[j]+S∗sumc[n]−S∗sumc[j]=(S+sumT[i])∗sumC[j]+f[i]−sumT[i]∗sumC[i]−S∗sumC[n]​
观察以下这个式子，首先sumT[i],sumC[n],sumC[i],i,nsumT[i],sumC[n],sumC[i],i,nsumT[i],sumC[n],sumC[i],i,n 我们肯定都是知道的（外层循环iii不变吗），但是其中唯一一个遍历jjj 的我们不知道，我们观察这个式子。有没有发现什么？
我们不妨设k=S+sumT[i],b=f[i]−sumT[i]∗sumC[i]−S∗sumC[n]k=S+sumT[i],b=f[i]-sumT[i]*sumC[i]-S*sumC[n]k=S+sumT[i],b=f[i]−sumT[i]∗sumC[i]−S∗sumC[n]
原式就有：
f[j]=k∗sumC[j]+bf[j]=k*sumC[j]+b
f[j]=k∗sumC[j]+b
这不是一次函数吗！
而且k,bk,bk,b我们肯定都是知道的，那么这个问题就变成一次函数的形式了，其图像是在以sumC[j]sumC[j]sumC[j]为横坐标f[j]f[j]f[j]为纵坐标的平面直角坐标系上。
根据我们开头提到的决策点，实际上每一个决策都对应坐标系的一个点(sumC[j],f[j])(sumC[j],f[j])(sumC[j],f[j])，每一个我想求解的f[i]f[i]f[i]一定对应这一个直线的截距。我们搬一下oiwiki的图。

这些黑点都是当前f[i]f[i]f[i]待选择的决策点。
我们的斜率kkk肯定是固定的，但是我们的bbb不一定。我们实际上就是在拿一条线从下去往上平移，并且要求我们的bbb最小（因为bbb里面有f[i]f[i]f[i]，我们要求f[i]f[i]f[i]的最小值），那么会靠到哪个点成为最优的呢？

我们连一下，发现了一个凸包，那么我们想想一条直线从下往上去平移。什么点会成为其决策呢？

不难发现就是凸包的切线！
所以我们可以通过构造像这样的“凸包”我们解可以快速找到这条切线使得截距bbb最小，但是有的时候并不是一个凸壳内所有点都能被切到，如蓝书上的图：

我们其实不难发现，要想获得最优决策，我们应当维护一个斜率单调递增的下凸壳，且顶点才能成为最优决策。
怎么求顶点，其实很简单？观察直线，最优决策点左边线斜率比kkk小，而右边大：

怎么维护？斜率单调递增，横坐标也肯定单调递增？比当前kkk小的会被排除不被选择…单调队列！
只需要维护一个单调队列，每一次新循环排除斜率 k′≤kk&#x27;\le kk′≤k 的决策，那么队列头即为顶点，即最优决策。
那么我们只需要这么维护：

检查队头2个决策变量，若他们构成的斜率k′≤kk&#x27; \le kk′≤k，直接out！
取队头计算f[i]f[i]f[i]
插入决策点iii，检查插入的时候队尾2个决策和 iii 满不满足斜率单调递增，不满足就把q[r]q[r]q[r] out了继续检查。

这样的时间复杂度就是O(n)O(n)O(n)
#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN = 3e5+15;int n, s;ll a[MN], sumt[MN], sumc[MN], f[MN], q[MN];int main()&#123;    cin &gt;&gt; n &gt;&gt; s;    for (int i = 1; i &lt;= n; i++)    &#123;        ll t, c;        cin &gt;&gt; t &gt;&gt; c;        sumt[i] = sumt[i - 1] + t;        sumc[i] = sumc[i - 1] + c;    &#125;    memset(f, 0x3f, sizeof(f));    f[0] = 0;    // O(n^2)    // for(int i=1;i&lt;=n;i++)&#123;    //     for(int j=0;j&lt;i;j++)&#123;    //         f[i]=min(f[i],f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]));    //     &#125;    // &#125;    // O(n)    int l = 1, r = 0;    q[++r]=0;    for (int i = 1; i &lt;= n; i++)    &#123;        ll k=s+sumt[i];        while (l &lt; r &amp;&amp; (f[q[l + 1]] - f[q[l]]) &lt;= k * (sumc[q[l + 1]] - sumc[q[l]]))        &#123;            // 除法转乘法避免小数            l++;        &#125;        f[i] = f[q[l]] - k * sumc[q[l]] + sumt[i] * sumc[i] + s * sumc[n];        while (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]]) &gt;= (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]]))            r--;        // 分式交叉相乘避免小数        q[++r] = i;    &#125;    cout &lt;&lt; f[n];    return 0;&#125;
坑点解析：

为什么单调队列循环中是l&lt;rl&lt;rl&lt;r，因为你判断斜率至少要2个决策点才能判断。
单调队列需在其中至少插入一个元素，默认为0
可以不用乘法，除法注意精度（long double）

这道题也是做完了。
总结一下，我们和单调队列优化相比，我们这里的单调性依赖的是元素的比值，因为这个对应斜率，我们称之为斜率优化。
 3.2 k不单调，x单调
什么意思，就是斜率不再单调了但是横坐标还是单调递增，那么不能像之前这样贸然的取队头了，我们无法从上一轮的最优点开始，直接往后在凸壳上找到这一轮的最优点。也就是说，必须搜索当前的整个凸壳！
作者：しずり雪博客的图

但其实维护凸壳的时候斜率函数单调递增，我们可以借助这个二分，找到顶点就可以了，其实二分也可以套在 kkk 与 xxx 同单调的地方，芝士没有那么优罢了。
时间复杂度显然O(nlog⁡n)O(n\log n)O(nlogn)
例题：

同上题，但：1≤n≤3×1051 \le n \le 3 \times 10^51≤n≤3×105，1≤s≤281 \le s \le 2^81≤s≤28，∣Ti∣≤28\left| T_i \right| \le 2^8∣Ti​∣≤28，0≤Ci≤280 \le C_i \le 2^80≤Ci​≤28。

sumTsumTsumT有可能是负数，不再单调递增，所以考虑二分。
代码如下：
#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN = 3e5+15;int n, s,l,r;ll a[MN], sumt[MN], sumc[MN], f[MN], q[MN];ll binsearch(ll k)&#123;    if(l==r) return q[l];    int L=l,R=r;    while (L&lt;R)    &#123;        int mid=L+R&gt;&gt;1;        //        if(f[q[mid+1]]-f[q[mid]]&gt;k*(sumc[q[mid+1]]-sumc[q[mid]])) R=mid;        else L=mid+1;    &#125;    return L;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; s;    for (int i = 1; i &lt;= n; i++)    &#123;        ll t, c;        cin &gt;&gt; t &gt;&gt; c;        sumt[i] = sumt[i - 1] + t;        sumc[i] = sumc[i - 1] + c;    &#125;    memset(f, 0x3f, sizeof(f));    f[0] = 0;    // O(n^2)    // for(int i=1;i&lt;=n;i++)&#123;    //     for(int j=0;j&lt;i;j++)&#123;    //         f[i]=min(f[i],f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]));    //     &#125;    // &#125;    l=1,r=0;    q[++r]=0;    // O(n) 没有维护下凸包只有上凸包    // for (int i = 1; i &lt;= n; i++)    // &#123;    //     ll k=s+sumt[i];    //     //为什么这里是l&lt;r? l&lt;r 能保证队列中至少有2个数，我们比较斜率是 delta(y)/delta(x) 2个值凑delta    //     while (l &lt; r &amp;&amp; (f[q[l + 1]] - f[q[l]]) &lt;= k * (sumc[q[l + 1]] - sumc[q[l]]))    //     &#123;    //         // 除法转乘法避免小数    //         l++;    //     &#125;    //     f[i] = f[q[l]] - k * sumc[q[l]] + sumt[i] * sumc[i] + s * sumc[n];    //     while (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]]) &gt;= (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]]))    //         r--;    //     // 分式交叉相乘避免小数    //     q[++r] = i;    // &#125;    // O(nlogn) 维护下凸包与上凸包，因为sumt不再具有单调性，不再是只有上凸包还有下凸包    // 还是考虑维护单调递增的k，不过这次我们要二分查找了因为队首不再是最优决策了    for(int i=1;i&lt;=n;i++)&#123;        ll k=s+sumt[i];        ll p=binsearch(k);        f[i] = f[q[p]] - k * sumc[q[p]] + sumt[i] * sumc[i] + s * sumc[n];        while (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]]) &gt;= (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]]))            r--;        q[++r]=i;    &#125;    cout &lt;&lt; f[n];    return 0;&#125;
 3.3 k单调x不单调
也就是kkk还有单调性，但是xxx没有单调性。这个时候可能在任意一个点插，我们需要动态维护凸包。

k：对于斜率因为还是有单调性，我们可以像3.2一样直接二分
x：我们不能用单调队列来优化了，必须出动高级算法：

李超线段树 时间复杂度O(nlog⁡n)O(n\log n)O(nlogn)
CDQ分治O(nlog⁡n)O(n\log n)O(nlogn)
set维护 O(nlog⁡n)O(n\log n)O(nlogn)



选择你喜欢的英雄，反正我选了李超www。
来做题：P4655

有 nnn 根柱子依次排列，每根柱子都有一个高度。第 iii 根柱子的高度为 hih_ihi​。
现在想要建造若干座桥，如果一座桥架在第 iii 根柱子和第 jjj 根柱子之间，那么需要 (hi−hj)2(h_i-h_j)^2(hi​−hj​)2​​ 的代价。
在造桥前，所有用不到的柱子都会被拆除，因为他们会干扰造桥进程。第 iii 根柱子被拆除的代价为 wiw_iwi​，注意 wiw_iwi​ 不一定非负，因为可能政府希望拆除某些柱子。
现在政府想要知道，通过桥梁把第 111 根柱子和第 nnn 根柱子连接的最小代价。注意桥梁不能在端点以外的任何地方相交。

不难有转移方程：
f[i]=min⁡j=1i−1f[j]+hi2−2hihj+hJ2+si−1−sjf[i]=\min\limits_{j=1}^{i-1} f[j]+h_{i^2}-2h_ih_j+h_J^2+s_{i-1}-s_j
f[i]=j=1mini−1​f[j]+hi2​−2hi​hj​+hJ2​+si−1​−sj​
其中sss 为www的前缀和。
式子化简有：
f[i]=hi2+si−1+min⁡(f[j]−2hihj+hj2−sj)f[i]=h_i^2+s_{i-1}+\min({f[j]-2h_ih_j+h_j^2-s_j})
f[i]=hi2​+si−1​+min(f[j]−2hi​hj​+hj2​−sj​)
显然斜率肯定递增，但是hhh不一定，我们考虑李超，李超的作用是什么？多条线段单点最值，我们的单点的xxx是必须固定。
令k=−2hj,b=fj+hJ2−sjk=-2h_j,b=f_j+h_J^2-s_jk=−2hj​,b=fj​+hJ2​−sj​
有$$f[i]=h_i^2+s_{i-1}+min(k*h_i+b)$$
李超即可。
#include&lt;bits/stdc++.h&gt;#define ll long long#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1using namespace std;const ll MN=1e6+15,INF=1e18,M=1e6;struct line&#123;    ll k,b;&#125;ln[MN];struct node&#123;    int l,r,id;&#125;t[MN&lt;&lt;2];ll f[MN],h[MN],s[MN];int n;ll clac(int id,int x)&#123;    return ln[id].k*x+ln[id].b;&#125;void build(int p,int l,int r)&#123;    t[p].l=l;    t[p].r=r;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    build(ls,l,mid);    build(rs,mid+1,r);&#125;void update(int p,int i)&#123;        if(t[p].l==t[p].r)&#123;            if(clac(i,t[p].l)&lt;clac(t[p].id,t[p].l)) t[p].id=i;            return;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(clac(i,mid)&lt;clac(t[p].id,mid))&#123;            swap(i,t[p].id);        &#125;        if(clac(i,t[p].l)&lt;clac(t[p].id,t[p].l))&#123;            update(ls,i);        &#125;        if(clac(i,t[p].r)&lt;clac(t[p].id,t[p].r))&#123;            update(rs,i);        &#125;        return;&#125;ll query(int p,ll k)&#123;    ll ret=INF;    if(t[p].id) ret=clac(t[p].id,k);    if(t[p].l==t[p].r) return ret;    int mid=(t[p].l+t[p].r)&gt;&gt;1;    if(mid&gt;=k) ret=min(ret,query(ls,k));    else ret=min(ret,query(rs,k));    return ret;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;h[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;s[i];        s[i]+=s[i-1];    &#125;    ln[0].b=INF;    build(1,0,M);    ln[1].k=-2*h[1];    ln[1].b=h[1]*h[1]-s[1];    update(1,1);    for(int i=2;i&lt;=n;i++)&#123;        f[i]=query(1,h[i])+s[i-1]+h[i]*h[i];        ln[i].k=-2*h[i];        ln[i].b=f[i]-s[i]+h[i]*h[i];        update(1,i);    &#125;    cout&lt;&lt;f[n];    return 0;&#125;
 3.4 k不单调，x不单调
其实和3.3差不太多。
 3.5 补充例题
 矩阵优化+斜率优化 CF1067D
首先这个升级显然是吓唬你的，因为我可以一直选一个游戏 van，所以我只需要看 bipib_{i}p_{i}bi​pi​ 最大就可以了。但是这里我们并不能考虑贪心，因为在时间短的情况下可能升级升不了，还是要 dp 的。
不难有 dp 方程如下，设 f(t)f(t)f(t) 表示还剩下 ttt 秒的最大期望，vvv 表示 bipib_{i}p_ibi​pi​ 的最大值：
f(t+1)=max⁡i=1n{pi(tv+ai)⏟升级成功+（1−pi)ft⏟升级失败}f(t+1)= \max_{i=1}^n \left\{ \underbrace{p_{i}(tv+a_i)}_{\text{升级成功}} +  \underbrace{（1-p_{i})f_t}_{\text{升级失败}}  \right\}
f(t+1)=i=1maxn​⎩⎪⎨⎪⎧​升级成功pi​(tv+ai​)​​+升级失败（1−pi​)ft​​​⎭⎪⎬⎪⎫​
时间复杂度 O(nt)O(nt)O(nt) ，这太 ntntnt 了www
不难看出来可以斜率优化啊，但是我们要变下形式：
f(t+1)=max⁡i=1n{pi(tv+ai)+(1−pi)ft}=pitv+piai+ft−pift=pi(tv−ft)+piai+ft\begin{aligned}
f(t+1) &amp; = \max_{i=1}^n \left\{ p_{i}(tv+a_i) +  (1-p_{i})f_t  \right\} \\
&amp; = p_{i}tv+p_{i}a_{i}+f_t-p_{i}f_{t} \\
&amp; = p_{i}(tv-f_t)+p_{i}a_{i}+f_t
\end{aligned}
f(t+1)​=i=1maxn​{pi​(tv+ai​)+(1−pi​)ft​}=pi​tv+pi​ai​+ft​−pi​ft​=pi​(tv−ft​)+pi​ai​+ft​​
因为 ftf_{t}ft​ 是已知的，所以这个就是一个显然的斜率优化式子，通过将 pip_ipi​ 排序可以满足 kkk 单调，但是 xxx 呢？其实也是一样的：
tv−ft≥(t−1)v−ft−1tv−ft≥tv−v−ft−1ft−1−ft≤v\begin{aligned}
tv-f_{t}&amp; \ge (t-1)v-f_{t-1} \\
tv-f_{t}&amp; \ge tv-v-f_{t-1} \\
f_{t-1}-f_{t} &amp; \le v
\end{aligned}tv−ft​tv−ft​ft−1​−ft​​≥(t−1)v−ft−1​≥tv−v−ft−1​≤v​
因为两个游戏之间获得的收益不可能比玩最大收益（最大的 bipib_{i}p_{i}bi​pi​ 的游戏）还大，所以式子成立，xxx 单调不降。
故单调队列优化，时间复杂度 O(t+n)O(t+n)O(t+n)…t≤1010t\le 10^{10}t≤1010？
这个数据范围已经不行了，必须出矩阵优化…等会矩阵怎么斜率优化？
首先我们先把转移的矩阵搞出来，推啊推：
[fi−1i−11]×[(1−pi)00piv10(pi−ai)11]=[fii1]\begin{bmatrix}
 f_{i-1} &amp; i-1 &amp; 1 
\end{bmatrix}
\times 
\begin{bmatrix}
 (1-p_i) &amp; 0 &amp; 0\\
 p_i v &amp; 1 &amp; 0\\
 (p_i-a_i) &amp; 1 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
 f_{i} &amp; i &amp; 1 
\end{bmatrix}[fi−1​​i−1​1​]×⎣⎢⎡​(1−pi​)pi​v(pi​−ai​)​011​001​⎦⎥⎤​=[fi​​i​1​]
其实也不是很难推，有啥加啥，因为少个 1 直接加上去就行。
如果我们想找出来有哪些游戏是我们在斜率优化需要的，可以利用单调栈（不能用单调队列我们要存下来的）来记录我们斜率从那些点转移过来，现在问题在于如何确定什么时候从一个点转移到另一个点。
回忆一下这张图：

在斜率优化上，我们能用单调队列来做是因为对于每一个点上的斜率，它有一定转移的边界，在这之前是这个斜率，在之后就不是了。
说的好听矩阵怎么做？首先一个游戏的转移矩阵肯定不会变。问题在于我们怎么像单调队列优化一样找到所谓的边界呢？
首先单调队列不太行因为它不适用于矩阵这种玩意，那怎么办，矩阵这玩意也不能上不单调三小将…………二分？

但其实维护凸壳的时候斜率函数单调递增，我们可以借助这个二分，找到顶点就可以了，其实二分也可以套在 kkk 与 xxx 同单调的地方，芝士没有那么优罢了 —— 3.2 k不单调 x单调

我们可以二分矩阵快速幂的幂，到哪个幂的时候转移是最优的！这样的时间复杂度是 O(nlog⁡2t)O(n \log^2 t)O(nlog2t)，可以通过。
我们不妨快点，不难发现幂其实是一个倍增的形式，我们可以利用倍增的形式二分，首先预处理矩阵快速幂后的各个幂对应的矩阵，从大到小枚举倍增的幂，不断检查是否合法（即是否 &lt;t&lt;t&lt;t )，让后检查是否更优，直接赋值即可！时间复杂度 O(nlog⁡t)O(n \log t)O(nlogt)，其中 log⁡t=33\log t=33logt=33 可以通过。
代码如下，注意精度！！！！！：
#include&lt;bits/stdc++.h&gt;#define ll long long#define double long doubleusing namespace std;constexpr int MN=6e5+15;constexpr double eps=1e-13;struct Node&#123;    double k,b;&#125;ln[MN],cl[MN],s[MN];ll n,t,top,tot,now;double v;struct Matrix&#123;    double mat[5][5];    Matrix operator *(const Matrix &amp;x)const&#123;        Matrix ret;        memset(ret.mat,0,sizeof(ret.mat));        for(int i=1;i&lt;=3;i++)&#123;            for(int j=1;j&lt;=3;j++)&#123;                for(int k=1;k&lt;=3;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;g[40],f;bool cmp(Node x,Node y)&#123;    if(fabs(x.k-y.k)&lt;eps) return x.b&lt;y.b;    return x.k&lt;y.k;&#125;int ck(double x)&#123;    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;&#125;double gety(Node x,Node y)&#123;    return (x.b-y.b)/(y.k-x.k);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;t;    for(int i=1;i&lt;=n;i++)&#123;        double a,b,p;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;        v=max(v,b*p);        ln[i].k=p;        ln[i].b=p*a;    &#125;    sort(ln+1,ln+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;	    // 先把那些相等斜率的全排了        if(i == n || ck(ln[i].k - ln[i+1].k) != 0) cl[++tot]=ln[i];    &#125;    for(int i=1;i&lt;=tot;i++)&#123;	    // 单调栈处理转移的点        while(top&gt;1&amp;&amp;ck(gety(s[top],s[top-1])-gety(cl[i],s[top-1]))&gt;=0) top--;        s[++top]=cl[i];    &#125;    // f 为 初始矩阵    f.mat[1][3]=1;    for(int i=1;i&lt;=top;i++)&#123;        double x=now*v-f.mat[1][1];        while(i&lt;top&amp;&amp;ck(x-gety(s[i],s[i+1]))&gt;=0) i++;// 先把过时决策排了        if(i&lt;top) x=gety(s[i],s[i+1]);        g[0].mat[1][2]=g[0].mat[1][3]=g[0].mat[2][3]=0;        g[0].mat[2][2]=g[0].mat[3][2]=g[0].mat[3][3]=1;        g[0].mat[1][1]=1-s[i].k,g[0].mat[2][1]=s[i].k*v,g[0].mat[3][1]=s[i].b;// 初始化矩阵        for(int j=1;j&lt;=35;j++) g[j]=g[j-1]*g[j-1];        for(int j=35;j&gt;=0;j--)&#123;            ll np=now+(1ll&lt;&lt;j);            if(np&gt;=t) continue;            // 如果决策更优或已经到头了即可转移            if(i==top||ck(x-np*v+(f*g[j]).mat[1][1])&gt;=0)&#123;                f=f*g[j];                now=np;            &#125;        &#125;        f=f*g[0];        now++;        if(now==t) break;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;f.mat[1][1];    return 0;&#125;
 3.6 总结
对于求最小值，应当维护下凸包，而最大值维护上凸包。
特征方程：f[i]=min⁡j=1i−1f[j]−a[i]d[j]f[i]=\min_{j=1}^{i-1} f[j]-a[i]d[j]f[i]=minj=1i−1​f[j]−a[i]d[j]
特点存在既有iii又有jjj的项a[i]d[j]a[i]d[j]a[i]d[j],并且两项均单调不减。
主要尝试把式子化成一个y=kx+by=kx+by=kx+b的形式，有的时候bbb可能会带高次项，不要怕当成整体看就可以了。
 4.WQS带权二分
特征：f(i,j)=min/max(g(i,k)+w(i,j)) , j∈[1,i],w(i,j)f(i,j)=min/max(g(i,k)+w(i,j))\,,\,j\in[1,i],w(i,j)f(i,j)=min/max(g(i,k)+w(i,j)),j∈[1,i],w(i,j)无明显性质。
当iii固定时，f(i,j)f(i,j)f(i,j)为凸函数。
当不限定jjj时，f(i)f(i)f(i)能够O(n)O(n)O(n)计算。
例题：

给定nnn个物品，每个物品有价值www（www可以小于0），从中选mmm个物品求最大价值。

这不是背包吗？但是我要求你O(nlog⁡n)O(n\log n)O(nlogn)呢？
一个简单的思路是wiw_iwi​排序，但是简单地排序无法保证正确性。
有朴素转移方程,时间复杂度O(n2)O(n^2)O(n2)：
f(i,j)=max⁡j=1i(f(i−1,j),f(i,j−1)+w(i))f(i,j)=\max\limits_{j=1}^i (f(i-1,j),f(i,j-1)+w(i))
f(i,j)=j=1maxi​(f(i−1,j),f(i,j−1)+w(i))
解题思路：
 1. 检查f(k,j)关于j的凸性
既然优化，我们需要挖掘性质来进行优化。
这里的f(k,j)关于j的凸性是什么意思呢，实际上就是我们固定f(i,j)f(i,j)f(i,j)其中的i=ki=ki=k，根据jjj的变化我们来看满足什么性质。
显然为上凸函数，因为我少选还不如多选吗，我选的越多肯定我拿到的钱就最多吗。

 2. 不限制 j 的时候f(i)很好算
如果不限制的化，那么很简单。
f(i)=max⁡(f(i−1),f(i−1)+wi)f(i)=\max (f(i-1),f(i-1)+w_i)
f(i)=max(f(i−1),f(i−1)+wi​)
时间复杂度O(n)O(n)O(n)，目标f(n)f(n)f(n)。
如果f(n)f(n)f(n)代表的刚好就是选mmm个物品时的最大价值，那不就可以了吗。
萧苯单，谁跟你说一定是mmm个了，往上看看题目后面对于www说的什么，wiw_iwi​可能为负数，不限制取那么肯定不选负数价值的。那怎么办？
 3. 直线切点求截距
还是一张图(实际上你是求不出来点的大致画一下就可以了），这里f(x)f(x)f(x)与g(x)g(x)g(x)是相同的：

我们用一条直线y=kx+by=kx+by=kx+b去切一个点(x,g(x))(x,g(x))(x,g(x))，显然有g(x)=kx+bg(x)=kx+bg(x)=kx+b，那么这个点可以表示为(x,kx+b)(x,kx+b)(x,kx+b)。
因为凸包有个性质，我们和这个凸包的顶点相切那么截距bbb肯定最大，这个在斜率优化里面提到过，假设我们知道kkk，只要我们求出最大的bbb并知道顶点xxx，就能确定具体坐标g(x)g(x)g(x)了。不难发现和斜率优化类似的一点是kkk具有单调性，所以我们只需要去二分kkk，就可以了。
问题在于怎么求最大截距bmaxb_{max}bmax​?
这个凸包我们根本都不知道长啥，如果先求出来那复杂度肯定会爆炸。
不难发现b=g(i)−kxb=g(i)-kxb=g(i)−kx，考虑再重新设转移方程，设h(i)h(i)h(i)表示当前g(i)g(i)g(i)的最大截距。显然有h(i)=g(i)−kxh(i)=g(i)-kxh(i)=g(i)−kx。我们求hih_ihi​并没有规定非要选多少个，而且不难发现h(i)h(i)h(i)是可以DP出来的，并且只是源问题的转换：

给定nnn个物品，每个物品有价值www（www可以小于0），同时选择物品会带有kkk的负权值，任意选择求最大价值。

不难有转移方程：
h(i)=max⁡(h(i−1),h(i−1)+w(i)−k)h(i)=\max (h(i-1),h(i-1)+w(i)-k)
h(i)=max(h(i−1),h(i−1)+w(i)−k)
每个都减去kkk其实就是kxkxkx，解释以下。
问题在于如果这么搞的这h(i)h(i)h(i)还是个凸函数吗，我们还想要他的极值点呢。
显然是的，可以看看下面的图，利用二次函数来模拟：

不难发现其实还是凸函数
那么用他的最值点来求f(i,j)f(i,j)f(i,j)，求h(x)h(x)h(x)显然为O(n)O(n)O(n)，转化为O(1)O(1)O(1)。
但是还是有一个问题，我怎么知道它能够恰好选到mmm个物品呢？这个时候−k-k−k的作用就体现在这里了，我们每选取一个物品，额外减少kkk的价值，间接限制DP对物品的选取数量，如下图：

并且不难发现一个性质，他的极值点随kkk增大而减少，这是因为fff的凸性造成的。
我们可以在一定范围内对kkk进行二分，直到找到某个hk(n)h_k(n)hk​(n)的极大值点刚好对应选mmm个物品，这样我们就获得了f(n,m)f(n,m)f(n,m)的值，二分时间复杂度O(log⁡n)O(\log n)O(logn)，一次DP求最大bbb时间复杂度O(n)O(n)O(n)，时间复杂度O(nlog⁡n)O(n\log n)O(nlogn)。我们搜索范围最大为[0,max(w(i))][0,max(w(i))][0,max(w(i))]。如果斜率存在小数我们需要实数二分，反之整数二分。
 特别注意！
如果是总代价最小化，我们需要加上kkk的代价。
如果是总代价最大化，我们需要减去kkk的代价。
这其实很好理解可以画画图，下凸壳和上凸壳的维护是不同的。
你的整数二分要和hkh_khk​的计算要匹配，如果hhh出现多点共线，整数二分只能获取到左右端点，搜索出来的选取个数不一定为mmm，但是可以算中间的点因为获得hhh是一样的，只是加上的kxkxkx不同。
如图：

注意有没有可能mmm永远无法取到，如果t&lt;m,m&lt;tt&lt;m,m&lt;tt&lt;m,m&lt;t任意一个成立，其中ttt为极致点选取的物品个数，那么mmm对应的h(n,m)h(n,m)h(n,m)百分百与h(n,t)h(n,t)h(n,t)（这里加上第二维是指极致点共选了多少个，不是状态中原本就有这个）共线，所以需要特别考虑。
 WQS模板题
 P6246 [IOI 2000] 邮局

高速公路旁边有 nnn 个村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。两个位置之间的距离是其整数坐标差的绝对值。
现在要建立  mmm 个邮局，邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。
你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。

邮局肯定放在一个区间的中间（中位数？），那么显然有朴素状态转移方程：设f(i,j)f(i,j)f(i,j)表示到了第iii个村庄，共放了jjj个邮局，有：
f(i,j)=min⁡j=1i−1f(j,i−1)+dis(j,i)f(i,j)=\min\limits_{j=1}^{i-1}f(j,i-1)+dis(j,i)
f(i,j)=j=1mini−1​f(j,i−1)+dis(j,i)
有人会问不是可以不放吗，你不放距离肯定大啊不是最优解，这里埋个铺垫后面会提到。
不难发现disdisdis其实可以O(n2)O(n^2)O(n2)预处理。
DP3维枚举时间复杂度O(n3)O(n^3)O(n3)
考虑优化，不难发现disdisdis满足四边形不等式，可以优化到O(n2log⁡n)O(n^2\log n)O(n2logn)，进一步可以优化到O(n2)O(n^2)O(n2)。这个复杂度还是不好，不能满足我们对于NOI的胃口。
“有人会问不是可以不放吗，你不放距离肯定大啊不是最优解”，这句话说明什么？
f(i,j)f(i,j)f(i,j)有凸性！而且还是刚好mmm个邮局，和上面我们提到的问题是一样的，不难推出h(i)h(i)h(i)的图像其实是一个下凸壳，不难发现h(i)h(i)h(i)还可以继续用四边形不等式优化，复杂度O(nlog⁡n)O(n\log n)O(nlogn)。故时间复杂度为O(nlog⁡nlog⁡∣V∣)O(n \log n \log |V|)O(nlognlog∣V∣)，其中VVV为值域。
很难发现disdisdis可以O(1)O(1)O(1)计算。怎么算看题解把（雾）
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=5e5+15;struct queueueue&#123;    int l,r,j;&#125;q[MN];int n,m,ql,qr;ll pos[MN],sump[MN],ans[MN];ll f[MN];ll w(int l,int r)&#123;    int p=(l+r+1)&gt;&gt;1;    return (sump[r]-sump[p])-(ll)pos[p]*(r-p)+(ll)pos[p]*(p-l)-(sump[p]-sump[l]);&#125;void insert(int x)&#123;    int pos=n+1;    while(ql&lt;=qr&amp;&amp;f[x]+w(x,q[qr].l)&lt;=f[q[qr].j]+w(q[qr].j,q[qr].l)) pos=q[qr--].l;    if(ql&lt;=qr&amp;&amp;f[x]+w(x,q[qr].r)&lt;=f[q[qr].j]+w(q[qr].j,q[qr].r))&#123;        int l=q[qr].l,r=q[qr].r;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(f[x]+w(x,mid)&lt;=f[q[qr].j]+w(q[qr].j,mid)) r=mid;            else l=mid;        &#125;        q[qr].r=r-1;        pos=r;    &#125;    if(pos!=n+1)&#123;        q[++qr]=&#123;pos,n,x&#125;;    &#125;&#125;bool check(ll k)&#123;    ql=1,qr=0;    q[++qr]=&#123;1,n,0&#125;;    for(int i=1;i&lt;=n;i++)&#123;        while(ql&lt;=qr&amp;&amp;q[ql].r&lt;i) ql++;        f[i]=f[q[ql].j]+w(q[ql].j,i)+k;        ans[i]=ans[q[ql].j]+1;        insert(i);// 可以看蓝书的四边形不等式教程，照这写的    &#125;    // cout&lt;&lt;ans[n]&lt;&lt;&quot; &quot;;    return ans[n]&gt;=m;//我们需要&gt;=m的决策&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;pos[i];    &#125;    sort(pos+1,pos+1+n);    for(int i=1;i&lt;=n;i++)&#123;        sump[i]=sump[i-1]+pos[i];    &#125;    ll l=0,r=8e11;    while(l+1&lt;r)&#123;        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) l=mid;        else r=mid;    &#125;    check(l);    cout&lt;&lt;f[n]-m*l;// 减去kx    return 0;&#125;
 CF739E Gosha is hunting

你要抓神奇宝贝！ 现在一共有 nnn 只神奇宝贝。 你有 aaa 个『宝贝球』和 bbb 个『超级球』。 『宝贝球』抓到第 iii 只神奇宝贝的概率是  只神奇宝贝的概率是  只神奇宝贝的概率是 p_i​，『超级球』抓到的概率则是 ​，『超级球』抓到的概率则是 ​，『超级球』抓到的概率则是 u_i$​。 不能往同一只神奇宝贝上使用超过一个同种的『球』，但是可以往同一只上既使用『宝贝球』又使用『超级球』（都抓到算一个）。 请合理分配每个球抓谁，使得你抓到神奇宝贝的总个数期望最大，并输出这个值，注意概率为实数。1≤n≤20001\le n\le 20001≤n≤2000

期望DP，我们先列个小方程出来。设f(i,j,k)f(i,j,k)f(i,j,k)表示第iii只神奇宝贝，总共用了jjj个宝贝球与kkk个超级球，显然有：
f(i,j,k)=max⁡{f(i−1,j,k)不选f(i−1,j−1,k)+Pi用宝贝球f(i−1,j,k−1)+Ui用超级球f(i−1,j−1,k−1)+1−(1−Pi)(1−Ui)都用f(i,j,k)=\max
\begin{cases}
f(i-1,j,k) &amp; \text{不选} \\ f(i-1,j-1,k)+P_i &amp; \text{用宝贝球} \\ f(i-1,j,k-1)+U_i &amp; \text{用超级球} \\ f(i-1,j-1,k-1)+1-(1-P_i)(1-U_i) &amp; \text{都用}
\end{cases}
f(i,j,k)=max⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​f(i−1,j,k)f(i−1,j−1,k)+Pi​f(i−1,j,k−1)+Ui​f(i−1,j−1,k−1)+1−(1−Pi​)(1−Ui​)​不选用宝贝球用超级球都用​
不难发现还是有凸性的，但是有两个限制变量，怎么办？那就WQS二分套WQS二分！
f(i)=max⁡{f(i−1)不选f(i−1)+Pi−ka宝贝球f(i−1)+Ui−kb超级球f(i−1)+Pi+Ui−PiUi−ka−kb都用f(i)=\max
\begin{cases}
f(i-1) &amp; \text{不选} \\
f(i-1)+P_i-k_a &amp; \text{宝贝球} \\
f(i-1)+U_i-k_b &amp; \text{超级球} \\
f(i-1)+P_i+U_i-P_iU_i-k_a-k_b &amp; \text{都用}
\end{cases}
f(i)=max⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​f(i−1)f(i−1)+Pi​−ka​f(i−1)+Ui​−kb​f(i−1)+Pi​+Ui​−Pi​Ui​−ka​−kb​​不选宝贝球超级球都用​
本题有实数二分，注意精度问题，并且要滚动数组一下不然会炸空间。
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;double,double&gt;using namespace std;constexpr int MN=2501;constexpr double eps=1e-8;double p[MN],q[MN];double f,pref;int n,a,b;pir check(double ka,double kb)&#123;    pref=0;    int cnta=0,cntb=0;    for(int i=1;i&lt;=n;i++)&#123;        //pref即f[i-1]        f=max(&#123;pref,pref+p[i]-ka,pref+q[i]-kb,pref+p[i]+q[i]-p[i]*q[i]-ka-kb&#125;);        if(f-(pref+p[i]-ka)&lt;eps)&#123;            cnta++;        &#125;else if(f-(pref+q[i]-kb)&lt;eps) cntb++;        else if(f-(pref+p[i]+q[i]-p[i]*q[i]-ka-kb)&lt;eps)&#123;            cnta++;            cntb++;        &#125;        pref=f;    &#125;    return pir(cnta,cntb);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;p[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;q[i];    &#125;    double la=0,ra=1,lb,rb,mida,midb;    while(la+eps&lt;ra)&#123;//先a        mida=(la+ra)/2;        lb=0,rb=1;        pir ansb;        while(lb+eps&lt;rb)&#123;// 后b            midb=(lb+rb)/2;            ansb=check(mida,midb);            if(ansb.second&gt;b) lb=midb;            else if(ansb.second&lt;b)rb=midb;            else break;//如果找到了就退出        &#125;        if(ansb.first&gt;a) la=mida;        else if(ansb.first&lt;a)ra=mida;        else break;    &#125;    cout&lt;&lt;f+mida*a+midb*b;//因为我们取最小，h(i)是减去k，这里要加上    return 0;&#125;
 UVA1537 Picnic Planning

给定一张 n 个点 n 条边的无向图，正边权，求出无向图的一棵最小生成树，满足一号节点的度数不超过给定的整数 s.
n≤20n\le 20n≤20

这不对啊这个和DP有什么关系？这不是显然有后效性吗。而且这题正解什么时候是WQS了。
事实上WQS二分可以套在许多类型的题上，不仅仅局限于DP.(只是没打标签而已)
观察这个题，又是我们熟悉的强迫sss，要求最小值。
考虑在不限制 sss 的情况下显然变为最小生成树模板可以O(mlog⁡m)O(m \log m)O(mlogm)做。
观察当我们选择加入最小生成树，连一号节点的边数越多，总边权越来越大（正边权），显然是个凸函数，考虑WQS二分消去sss的限制。
首先我们计算时需要统计一号节点的度数cntcntcnt，如果 cnt≤Scnt\le Scnt≤S，显然不用算。反之，进行WQS二分。
我们的权值kkk加的情况，当且仅当边连的是一号节点我们才加上权值。在排序的时候记得要加上特判。
时间复杂度多少？一次kru显然O(mlog⁡m)O(m\log m)O(mlogm)，总时间复杂度显然为O(Tmlog⁡mlog⁡∣V∣)O(Tm\log m \log |V|)O(Tmlogmlog∣V∣)，其中VVV为值域。
故代码如下：
#include&lt;bits/stdc++.h&gt;#define getid(x) (!ump[x]?ump[x]=++umptot:ump[x])#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1314;struct Edge&#123;    int u,v,w;&#125;e[MN];int pre[MN],n,k,T,umptot,s;unordered_map&lt;string,int&gt; ump;int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);&#125;void initpre()&#123;    for(int i=1;i&lt;=umptot;i++)&#123;        pre[i]=i;    &#125;&#125;bool cmp(Edge x,Edge y)&#123;    if(x.w+k*(x.u==1)==y.w+k*(y.u==1)) return x.u!=1;    return x.w+k*(x.u==1)&lt;y.w+k*(y.u==1);&#125;pir kru()&#123;    int ans=0,cnt=0;    initpre();    sort(e+1,e+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;        int ru=root(e[i].u),rv=root(e[i].v);        if(ru==rv) continue;        pre[rv]=ru;        ans+=e[i].w;        if(e[i].u==1)&#123;            cnt++;            ans+=k;        &#125;    &#125;    //cout&lt;&lt;&quot;K:&quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;    return pir(ans,cnt);&#125;void solve()&#123;    ump.clear();    umptot=1;    ump[&quot;Park&quot;]=1;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        string u,v;        int w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        e[i].u=getid(u);        e[i].v=getid(v);        e[i].w=w;                if(e[i].u&gt;e[i].v) swap(e[i].u,e[i].v);        //cout&lt;&lt;e[i].u&lt;&lt;&quot; &quot;&lt;&lt;e[i].v&lt;&lt;&quot; &quot;&lt;&lt;e[i].w&lt;&lt;&#x27;\n&#x27;;    &#125;    cin&gt;&gt;s;    int l=0,r=1000;    k=0;    if(kru().second&lt;=s)&#123;        cout&lt;&lt;&quot;Total miles driven: &quot;&lt;&lt;kru().first&lt;&lt;&#x27;\n&#x27;;        if(T) cout&lt;&lt;&#x27;\n&#x27;;        return;    &#125;    //cout&lt;&lt;umptot&lt;&lt;&#x27;\n&#x27;;    while(l+1&lt;r)&#123;        int mid=(l+r)&gt;&gt;1;        k=mid;        if(kru().second&gt;s) l=mid;        else r=mid;    &#125;    k=r;    cout&lt;&lt;&quot;Total miles driven: &quot;&lt;&lt;kru().first-s*k&lt;&lt;&#x27;\n&#x27;;    if(T) cout&lt;&lt;&#x27;\n&#x27;;&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 WQS总结
主要是利用凸包这一特性来消除掉选mmm的特性，适用的问题一般是nnn个里面强制选mmm个的问题，求最大最小价值，并且如果可以随便选可以很简单的做的题。最难的是发现性质。
主要注意二分斜率时的细节。
 写在最后
感谢阅读！
本文章素材来源：

算法竞赛进阶指南
FloatingLife的WQS二分博客,链接
しずり雪 の Blog

本文章遵循开源协议——[知识共享署名-相同方式共享 4.0 国际许可协议]。
]]></content>
      <categories>
        <category>DP优化</category>
      </categories>
      <tags>
        <tag>DP优化</tag>
      </tags>
  </entry>
  <entry>
    <title>树上差分</title>
    <url>/posts/5cb487af/</url>
    <content><![CDATA[ 1.树上差分概念
树上差分，字面意思就是在树上做差分。
所以她能干啥能，举个例子，如果题目问经过树上某个点或某个边的次数，树上差分就可以派上用场啦。
树上差分就是利用差分的性质，前缀和的思想。只对树上一部分节点进行修改。而不是暴力全改，能将O(n)O(n)O(n)的修改降为O(1)O(1)O(1)
这个在日后会经常用到，要好好学习。

 2.点差分
咱们一个一个加肯定包会TLE的，但是我们在讲树上差分啊！
那么我们如何进行差分呢，差分是在一条链上的在树上怎么操作呢？唉！就是将树拆成链
如下

对路径3→63\rightarrow 63→6路径进行加一的操作我们先找到3和6的LCA即2，将这个路径转化为2条链，一个是2→32\rightarrow 32→3和5→65\rightarrow 65→6，如下

让后分别进行差分，红色和橙色对应上面的链

等会，为什么非要是5→65\rightarrow 65→6而不是2→62\rightarrow 62→6呢？因为2→32\rightarrow 32→3的路径已经将2已经加过了啊。
为什么我们用LCA呢，我们假设2种情况，第一种情况就是要加的树都在一个链上，这时候LCA就是深度最小节点的的父亲，例如对2→32\rightarrow 32→3进行操作。第二种就是像上述3→63\rightarrow 63→6拐过来，我们用LCA就可以求出这个路径的拐点，拐点就是LCA(3,6)=2LCA(3,6)=2LCA(3,6)=2。让后像上面一样拆成2条链
让后跑一遍Dfs就可以统计出来答案啦。
例题P3128 [USACO15DEC] Max Flow P
其实就是上面的点差分经典例题
这里LCA我们使用的是倍增求LCA
小技巧：
__lg(x)
这个函数可以直接搞出来整数的log2xlog_2xlog2​x
#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int n,m;const int MN=5e4+15,ML=40;int fa[MN][ML],dep[MN],ml,sum[MN],ans=-1;vector&lt;int&gt; adj[MN];void dfs(int u,int pre)&#123;    fa[u][0]=pre;    dep[u]=dep[pre]+1;    for(int i=1;i&lt;=ml;i++)&#123;        fa[u][i]=fa[fa[u][i-1]][i-1];    &#125;    for(auto v:adj[u])&#123;        if(v!=pre)&#123;            dfs(v,u);        &#125;    &#125;&#125;int lca(int x,int y)&#123;    if(dep[x]&gt;dep[y])&#123;        swap(x,y);    &#125;    for(int i=ML-1;i&gt;=0;i--)&#123;        if(dep[fa[y][i]]&gt;=dep[x])&#123;            y=fa[y][i];        &#125;    &#125;    if(x==y) return x;    for(int i=__lg(dep[x]);i&gt;=0;i--)&#123;        if(fa[x][i]!=fa[y][i])&#123;            x=fa[x][i];            y=fa[y][i];        &#125;    &#125;    return fa[x][0];&#125;void dfss(int u,int fa)&#123;    for(auto v:adj[u])&#123;        if(v!=fa)&#123;            dfss(v,u);            sum[u]+=sum[v];        &#125;    &#125;    ans=max(ans,sum[u]);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    ml=__lg(n);    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs(1,0);    while (m--)    &#123;        int s,t;        cin&gt;&gt;s&gt;&gt;t;        int l=lca(s,t);        sum[s]++;        sum[t]++;        sum[l]--;        if(l!=1)&#123;            sum[fa[l][0]]--;        &#125;    &#125;    dfss(1,0);    cout&lt;&lt;ans;    return 0;&#125;
双倍经验 P3258 [JLOI2014] 松鼠的新家
 3.边差分
其实差不多
还是上面那个图

这回紫色使我们要访问的边，并加上1的边权。但是我们不能给边加边权不然不太好差分，我们只能把边权硬塞给点。

发现这不刚好可以拆成两条“链”吗，一个就是单独的333，一个5→65\rightarrow 65→6，那我们只需要sum[3]sum[3]sum[3]++，sum[6]sum[6]sum[6]–,sum[LCA(3,6)]sum[LCA(3,6)]sum[LCA(3,6)]-=2就ok啦
同样也只需要dfs1遍就可以统计出来答案啦（十分甚至九分的厉害）
至于为啥操作不同请自行用拆链的思想思考
 4.BB
树上差分之后用处很多的，尤其是重复的区间操作或贡献问题，有的时候其实也可用树链剖分取做（但是我不会），如果对您有帮助，请不要忘了点赞！(≧∇≦)ﾉ
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/posts/59a0de58/</url>
    <content><![CDATA[ 1.概念与代码
 1.0导入
树状数组是一种支持 单点修改 和 区间查询 的，代码量小的数据结构。利用数的二进制特性进行检索的一种树状的结构

显然可得树状数组是多叉树
如图，我们对 t[7]t[7]t[7] 进行检索
查询的过程就是每次去掉最后的二进制位的1，例如我们对7进行前缀和求值。sum(7)=t[7]+t[6]+t[4]

7的二进制是111 去掉最后的1，得110 即6
去掉6的二进制最后一个1，即100，即4
显然4不能再去1了，再去1就是0了

接下来进行维护（加），维护的过程就是每次在二进制的最后的1再加1.例如更新了a3a_3a3​ 就要修改t[3]t[3]t[3]，t[4]t[4]t[4]，t[8]t[8]t[8]

3的二进制是11，在最后的1加上1就是100 即4，更新
4的二进制是100，在最后的1加上1就是1000，即8，更新
8的二进制再加就超范围了，这时停止

显然这里有一个关键问题，如何找到二进制1，就是lowbit
 1.1 lowbit
这里先给出代码
int lowbit(int x)&#123;    return x &amp; -x;&#125;
功能就是找到二进制下最后一个1，自行证明一下。

 1.2 代码
P3374 单点修改区间查询（原汁原味）
#include&lt;iostream&gt;using namespace std;const int MN=5e5+15;int lowbit(int x)&#123;    return x &amp; -x;&#125;int t[MN],n,m;void add(int x,int k)&#123;    while (x&lt;=n)//防止超出边界    &#123;        //加值让后加上末尾的1        t[x]+=k;        x+=lowbit(x);    &#125;&#125;int sum(int x)&#123;    int ans=0;    while (x&gt;0)    &#123;        //加值让后减去末尾的1        ans+=t[x];        x-=lowbit(x);    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        int t;        cin&gt;&gt;t;        add(i,t);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int x,y,op;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==1)&#123;            add(x,y);        &#125;else&#123;//区间查询，sum代表1~k的前缀和            cout&lt;&lt;sum(y)-sum(x-1)&lt;&lt;endl;        &#125;    &#125;&#125;
0为下表的树状数组，感谢牢学长（@Renamoe）
0-index
 2.应用
 1.区间修改+单点查询
HDU-1556

N个气球排成一排，从左到右依次编号为1,2,3…N.每次给定2个整数 aaa ,bbb ( a&lt;=ba &lt;= ba&lt;=b ),lele便为骑上他的“小飞鸽&quot;牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是 NNN 次以后lele已经忘记了第 III 个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？
Input
每个测试实例第一行为一个整数 N,(N&lt;=100000)N,(N &lt;= 100000)N,(N&lt;=100000) .接下来的N行，每行包括2个整数 aaa,bbb (1&lt;=a&lt;=b&lt;=N)(1 &lt;= a &lt;= b &lt;= N)(1&lt;=a&lt;=b&lt;=N) 。
当 N=0N = 0N=0 ，输入结束。

31 12 23 331 11 21 30

Output


每个测试实例输出一行，包括 NNN 个整数，第 III 个数代表第 III 个气球总共被涂色的次数。

1 1 13 2 1
定义a[i]a[i]a[i]为气球涂色的次数，若用暴力法求解显然复杂度是O(n2)O(n^2)O(n2) 过不去。我们用上面提到的，单点修改区间查询，显然修改是O(n)O(n)O(n)的，那么反而更差，最终即为O(n2log2n)O(n^2log_2n)O(n2log2​n)，难受
对于一段区间重复操作，我们考虑差分。差分是一个很神奇的东西，能将区间问题转换为端点问题。自己先看看定义吧（其实是我懒）

代码如下
#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MN=1e5+15;int t[MN],n;int lowbit(int x)&#123;    return x &amp; -x;&#125;void add(int x,int k)&#123;    while (x&lt;=n)    &#123;        t[x]+=k;        x+=lowbit(x);    &#125;&#125;int ask(int x)&#123;    int ans=0;    while (x&gt;0)    &#123;        ans+=t[x];        x-=lowbit(x);    &#125;    return ans;&#125;int main()&#123;    while (1)    &#123;        memset(t,0,sizeof(t));        cin&gt;&gt;n;        if(!n) break;        for(int i=1;i&lt;=n;i++)&#123;            int a,b;//a-&gt;L b-&gt;R            cin&gt;&gt;a&gt;&gt;b;            add(a,1);            add(b+1,-1);        &#125;        for(int i=1;i&lt;=n;i++)&#123;            cout&lt;&lt;ask(i)&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;        return 0;&#125;
显然两个for循环时间复杂度均为O(nlog2n)O(nlog_2n)O(nlog2​n) 可以啦
（不是哥们为啥这个差分题非要用树状数组+差分做啊）
 2.区间修改+区间查询
老生常谈线段树

已知一个数列，你需要进行下面两种操作：

将某区间每一个数加上 kkk。
求出某区间每一个数的和。

第一行包含两个整数 n,mn, mn,m，分别表示该数列数字的个数和操作的总个数。
第二行包含 nnn 个用空格分隔的整数，其中第 iii 个数字表示数列第 iii 项的初始值。
接下来 mmm 行每行包含 333 或 444 个整数，表示一个操作，具体如下：

1 x y k：将区间 [x,y][x, y][x,y] 内每个数加上 kkk。
2 x y：输出区间 [x,y][x, y][x,y] 内每个数的和。

输入
5 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4
输出
11820
对于 30%30\%30% 的数据：n≤8n \le 8n≤8，m≤10m \le 10m≤10。
对于 70%70\%70% 的数据：n≤103n \le {10}^3n≤103，m≤104m \le {10}^4m≤104。
对于 100%100\%100% 的数据：1≤n,m≤1051 \le n, m \le {10}^51≤n,m≤105。
保证任意时刻数列中所有元素的绝对值之和 ≤1018\le {10}^{18}≤1018。

这里我们需要进一步强化对于差分的理解，你已经理解了差分是干嘛的，接下来差分我们显然可得两个性质

aia_iai​的值是bib_ibi​的前缀和，即an=∑i=1nbia_n=\sum_{i=1}^nb_ian​=∑i=1n​bi​
计算aka_kak​的前缀和sum=∑i=1kai=∑i=1k∑j=1ibi=∑i=1k(n−i+1)bisum=\sum_{i=1}^ka_i=\sum_{i=1}^k\sum_{j=1}^ib_i=\sum_{i=1}^k(n-i+1)b_isum=∑i=1k​ai​=∑i=1k​∑j=1i​bi​=∑i=1k​(n−i+1)bi​

ok这里直接放推导过程
a1+a2+a3+...+aka_1+a_2+a_3+...+a_ka1​+a2​+a3​+...+ak​
由性质2可得
=kB1+(k−1)B2+(k−2)B3+...+(k−(k−1))Bk=kB_1+(k-1)B_2+(k-2)B_3+...+(k-(k-1))B_k=kB1​+(k−1)B2​+(k−2)B3​+...+(k−(k−1))Bk​
=k(B1+B2+B3+...+Bk)−(B2−2B3−...−(k−1)Bk)=k(B_1+B_2+B_3+...+B_k)-(B_2-2B_3-...-(k-1)B_k)=k(B1​+B2​+B3​+...+Bk​)−(B2​−2B3​−...−(k−1)Bk​)
=k∑i=1kBi−∑i=1k(i−1)Bi=k\sum_{i=1}^kB_i-\sum_{i=1}^k(i-1)B_i=k∑i=1k​Bi​−∑i=1k​(i−1)Bi​
显然我们可以用2个树状数组来维护前缀和
代码如下
#include&lt;iostream&gt;#define ll long longusing namespace std;ll lowbit(ll x)&#123;    return x &amp; -x;&#125;const int MN=1e5+15;ll t1[MN],t2[MN],m,n,a[MN];void add(ll *t,ll x,ll k)&#123;    while (x&lt;=n)    &#123;        t[x]+=k;        x+=lowbit(x);    &#125;&#125;ll ask(ll *t,ll x)&#123;    ll ans=0;    while (x&gt;0)    &#123;        ans+=t[x];        x-=lowbit(x);    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(ll i=1,pre=0;i&lt;=n;i++)&#123;        ll t;        cin&gt;&gt;t;        //差分数组定义        add(t1,i,t-pre);        add(t2,i,(i-1)*(t-pre));        pre=t;    &#125;    while (m--)    &#123;        ll q,l,r,k;        cin&gt;&gt;q&gt;&gt;l&gt;&gt;r;        if(q==1)&#123;            cin&gt;&gt;k;            add(t1,l,k);            add(t1,r+1,-k);            add(t2,l,k*(l-1));            add(t2,r+1,-k*r);//-k*r=-k*(r+1-1)        &#125;else&#123;            cout&lt;&lt;r*ask(t1,r)-(l-1)*ask(t1,l-1)-ask(t2,r)+ask(t2,l-1)&lt;&lt;endl;//这里把括号去掉了        &#125;    &#125;        return 0;&#125;
 3.偏序问题（逆序对+离散化）
其实偏序问题应当用CDQ分治去做的，但是对于一维的来说，树状数组显然复杂度更优（O(nn)O(n\sqrt n)O(nn​) &lt; O(nlog2n)O(nlog_2n)O(nlog2​n)）
P1908
对于给定的一段正整数序列，逆序对就是序列中 ai&gt;aja_i&gt;a_jai​&gt;aj​ 且 i&lt;ji&lt;ji&lt;j 的有序对。
算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。
用这个解逆序对问题用到一个技巧，即对值域建树状数组
这样就很好处理了，每处理一个数字，树状数组下表所对应的元素数值加一，统计前缀和，就是逆序对的数量
这里倒序处理，注意离散化
#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MN=5e5+15;struct node&#123;    int v,id;&#125;;int n,t[MN],rnk[MN];node a[MN];int lowbit(int x)&#123;    return x &amp; -x;&#125;int ask(int x)&#123;    int ans=0;    while (x&gt;0)    &#123;        ans+=t[x];        x-=lowbit(x);    &#125;    return ans;&#125;void add(int x,int k)&#123;    while (x&lt;=n)    &#123;        t[x]+=k;        x+=lowbit(x);    &#125;&#125;bool cmp(node x,node y)&#123;    if(x.v==y.v)&#123;        return x.id&lt;y.id;    &#125;    return x.v&lt;y.v;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].v;        a[i].id=i;    &#125;    sort(a+1,a+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;        rnk[a[i].id]=i;    &#125;    long long ans=0;    for(int i=n;i&gt;0;i--)&#123;        add(rnk[i],1);        ans+=ask(rnk[i]-1);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 3.总结
树状数组优点在于

好写
常数小
1倍空间

大多数用来代替简单求和的线段树，但是复杂问题还是要上线段树
用树状数组解问题的关键就是如何把答案贡献转化为一个前缀和
若遇到许多区间计算，可以考虑使用差分来降低复杂度。
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组进阶使用</title>
    <url>/posts/b8c8d3e3/</url>
    <content><![CDATA[ 0. 前言
你需要知道树状数组
 1. 树状数组二分
 1.1 概念
类似于线段树二分，树状数组当然也可以二分。
它解决的是如下一类问题：

对于序列 aaa，存在分割点 qqq 使得 ≤q\le q≤q 的位置满足某个限制而 &gt;q&gt;q&gt;q 的位置不满足限制，求 qqq。
（注意是整个序列 aaa 找分割点），要求 O(nlog⁡n)O(n\log n)O(nlogn)。
nnn 类似于长度。

如果你是从某个位置开始二分，那这个就做不到，你可以考虑转化到整个序列二分。
考虑最后一个前缀和 ≤v\le v≤v 的位置，满足序列每个元素非负，则存在分割点 qqq 满足 ≤q\le q≤q 的位置的前缀和 ≤v\le v≤v ，而  &gt;q&gt;q&gt;q 的位置的前缀和 &gt;v&gt;v&gt;v ，那么 qqq 即为所求。
我们初始化两个变量，当前位置 ppp 和对应的前缀和 sss，初始权为 0。
我们从大到小枚举 1≤2k≤n1\le 2^k \le n1≤2k≤n，尝试将 ppp 加上 2k2^k2k。检查 s+∑i=p+1p+2kai≤vs+\sum\limits_{i=p+1}^{p+2^k} a_{i}\le vs+i=p+1∑p+2k​ai​≤v 是否成立，因为 kkk 从小到大枚举，此时 lowbit(p)&gt;2klowbit(p)&gt;2^klowbit(p)&gt;2k，那么显然有 lowbit(p+2k)=2klowbit(p+2^k)=2^klowbit(p+2k)=2k，因为树状数组中 t[i]t[i]t[i] 中填的是 [i−lowbit(i)+1,i][i-lowbit(i)+1,i][i−lowbit(i)+1,i] 这个区间的信息，那么也就是说 t[p+2k]=∑i=p+1p+2kait[p+2^k]=\sum\limits_{i=p+1}^{p+2^k} a_{i}t[p+2k]=i=p+1∑p+2k​ai​。
那么就可以这么做：

初始化两个变量，当前位置 ppp 和对应的前缀和 sss，初始权为 0。
从大到小枚举 1≤2k≤n1\le 2^k \le n1≤2k≤n。

若 p+2k≤np+2^k\le np+2k≤n 且 s+t[p+2k]≤vs+t[p+2^k]\le vs+t[p+2k]≤v。则 p←p+2k,s←s+t[p+2k]p\leftarrow p+2^k,s\leftarrow s+t[p+2^k]p←p+2k,s←s+t[p+2k]。
若 p+2k&gt;np+2^k&gt;np+2k&gt;n，啥也不做。



ppp 一定等于最终求的 qqq，否则 ppp 在过程一定会变得更大。
 1.2 例题
 [省选联考 2020 A/B 卷] 冰火战士
经典畅谈。
一个显然能看出来，我们要二分温度 kkk。
首先考虑能不能三分，显然不行这个是离散的，但是对于冰的能量求和 ficef_{ice}fice​ 是单调不降的，而 ffiref_{fire}ffire​ 是单调不升的。如果画出来的话就是两个函数打叉，我们就是要找那个叉。
借用 duyi大佬的图：


我们要找的就是这个叉，但是这个叉直接二分求有点难找。
我们可以两次二分，第一次找最大的 kkk 使得 fice(k)&lt;ffire(k)f_{ice}(k) &lt; f_{fire}(k)fice​(k)&lt;ffire​(k)，以此为左边界，第二次找最小的 kkk 使得 fice(k)≥ffire(k)f_{ice}(k)\ge f_{fire}(k)fice​(k)≥ffire​(k) 。

不难发现可以离线询问，我们考虑怎么维护这个区间修改 fff ，其实也很简单，差分就可以了。但是这里面有一个后缀和耶？那怎么办？其实后缀和就是总和-前缀和，让后做完了。
对于倍增查询，时间复杂度因为查询的是树状数组的数据，可以做到 O(log⁡q)O(\log q)O(logq) ，所以总时间复杂度为 O(qlog⁡q)O(q \log q)O(qlogq)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MQ=2e6+15;int q,a[MQ],tot,sum1;struct query&#123;    int op,t,x,y;&#125;qry[MQ];struct BIT&#123;    private:        int t[MQ];    public:    inline int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int pos,int k)&#123;        while(pos&lt;MQ)&#123;            t[pos]+=k;            pos+=lowbit(pos);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    int get(int x)&#123;        return t[x];    &#125;&#125;t0,t1;template&lt;typename type&gt;void read(type &amp;x)&#123;    x=0;bool flag(0);char ch=getchar();    while(!isdigit(ch)) flag=ch==&#x27;-&#x27;,ch=getchar();    while(isdigit(ch)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar();    flag?x=-x:0;&#125;void lisan()&#123;    sort(a+1,a+1+tot);    tot=unique(a+1,a+1+tot)-a-1;    for(int i=1;i&lt;=q;i++)&#123;        if(qry[i].op==2) continue;        qry[i].x=lower_bound(a+1,a+1+tot,qry[i].x)-a;    &#125;&#125;signed main()&#123;    read(q);    for(int i=1;i&lt;=q;i++)&#123;        read(qry[i].op);        if(qry[i].op==1)&#123;            // cin&gt;&gt;qry[i].t&gt;&gt;qry[i].x&gt;&gt;qry[i].y;            read(qry[i].t);            read(qry[i].x);            read(qry[i].y);            a[++tot]=qry[i].x;        &#125;else read(qry[i].t);    &#125;    lisan();    for(int i=1;i&lt;=q;i++)&#123;        if(qry[i].op==1)&#123;            if(qry[i].t)&#123;                t1.update(qry[i].x+1,qry[i].y);                sum1+=qry[i].y;            &#125;else t0.update(qry[i].x,qry[i].y);        &#125;else&#123;            int p=qry[i].t;            if(qry[p].t)&#123;                t1.update(qry[p].x+1,-qry[p].y);                sum1-=qry[p].y;            &#125;else t0.update(qry[p].x,-qry[p].y);        &#125;        int s0=0,s1=sum1,f0=0,f1=0,p0=0,p1=0;        for(int j=20;j&gt;=0;j--)&#123;            int np=p0+(1&lt;&lt;j),ns0=s0+t0.get(np),ns1=s1-t1.get(np);            if(np&gt;tot) continue;            if(ns0&lt;ns1)&#123;                p0=np;                s0=ns0,s1=ns1;            &#125;        &#125;        f0=s0,s0=0,s1=sum1;        if(p0&lt;tot)&#123;            f1=min(t0.query(p0+1),sum1-t1.query(p0+1));            for(int j=20;j&gt;=0;j--)&#123;                int np=p1+(1&lt;&lt;j),ns0=s0+t0.get(np),ns1=s1-t1.get(np);                if(np&gt;tot) continue;                if(ns0&lt;ns1)&#123;                    p1=np;                    s0=ns0,s1=ns1;                &#125;else if(min(ns0,ns1)==f1)&#123;                    p1=np;                    s0=ns0,s1=ns1;                &#125;            &#125;        &#125;        if(max(f0,f1)==0) cout&lt;&lt;&quot;Peace\n&quot;;        else if(f0&gt;f1) cout&lt;&lt;a[p0]&lt;&lt;&quot; &quot;&lt;&lt;f0*2&lt;&lt;&#x27;\n&#x27;;// 最小的能量消耗一定消耗完了，并且两边消耗同样做小        else cout&lt;&lt;a[p1]&lt;&lt;&quot; &quot;&lt;&lt;f1*2&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 [USACO03Open] Lost Cows
虽然原题是 O(n2)O(n^2)O(n2) 就能做，但是这里我们强制要求 O(nlog⁡n)O(n\log n)O(nlogn)。
但是我们先从暴力开始做，首先观察到如果正着做太难了而且后效性太大了受不了。正难则反，考虑倒着走，发现倒着走很好做啊，因为原题中的 aia_iai​ 看得是前面而不是后面，这样我们就可以利用后面占用的信息往前推过去了。
一个显然 O(n2)O(n^2)O(n2) 的做法就是考虑怎么分配编号，直接开 visvisvis 数组记录编号谁占了，其实就是找在 visvisvis 数组前缀和为 ai+1a_{i}+1ai​+1 的位置（随便找就行），找到后标 1 即可。
我们考虑怎么优化，上述瓶颈的过程在于查询前缀和，观察数组的性质，不难发现是一个 01 序列， 那么对于前缀和的形式我们可以直接转化成查询第 ai+1a_{i}+1ai​+1 个的 1 的位置，让后单点修改为 1 即可。
综上，我们要造一个数据结构，满足能够支持查询第 kkk 个 1 的位置（k∈N+k\in \mathbb{N}^+k∈N+），并且支持单调修改，时间复杂度要求操作都为 log⁡n\log nlogn 的时间复杂度。
不难发现它找的就是：满足在 ≤pos\le pos≤pos 的位置 vvv 的前缀和 ≤k\le k≤k，而在 &gt;pos&gt;pos&gt;pos 的位置 vvv 的前缀和 &gt;k&gt;k&gt;k，找的就是这个分界点。
这里我们可以用 树状数组+真正的二分 来做，其实也很简单，直接考虑二分答案，用查询函数 queryqueryquery 查询里面的数据就能获得前 midmidmid 有多少个 1 ，让后直接比较大小二分即可，但是这样的时间复杂度是 O(nlog⁡2n)O(n\log ^2 n)O(nlog2n)。
考虑用我们讲的方法，直接做，时间复杂度分析和上面题一样为 O(nlog⁡n)O(n \log n)O(nlogn)，其实到这里你应该能发现树状数组恰好为我们维护了区间长度为 222 的次幂的一些信息，所以我们不需要二分，直接利用树状数组这个特性倍增就能完成和真正二分一样的效果。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,a[MN],ans[MN];struct BIT&#123;    int t[MN];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;int main()&#123;    cin&gt;&gt;n;    bit.update(1,1);    for(int i=2;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        bit.update(i,1);    &#125;    for(int i=n;i&gt;=1;i--)&#123;        int p=0,s=0;        for(int j=20;j&gt;=0;j--)&#123;            int np=p+(1&lt;&lt;j);            if(np&gt;n) continue;            int ns=s+bit.t[np];            if(ns&lt;a[i]+1)&#123;                s=ns;                p=np;            &#125;        &#125;        p++;        bit.update(p,-1);        ans[i]=p;    &#125;    for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 [POI 2015] LOG

维护一个长度为 nnn 的序列，一开始都是 000，支持以下两种操作：

U k a 将序列中第 kkk 个数修改为 aaa。
Z c s 在这个序列上，每次选出 ccc 个正整数，并将它们都减去 111，询问能否进行 sss 次操作。
询问独立。
时间复杂度要求 O(nlog⁡n)O(n\log n)O(nlogn)，都是正整数不是正数。
but：1≤n≤106,1≤k,c≤n,1≤a,s≤1091\le n \le 10^6,1\le k,c\le n,1 \le a,s \le 10^91≤n≤106,1≤k,c≤n,1≤a,s≤109。


可以先自己想想。
这里的 sss 次操作选出的正数可以不同。
提示：贪心复杂度走不了思考一下排序是为了什么。
一个贪心的思路就是每次排序，找最大的那几个往后数，这个显然是正确的，但是这样的时间复杂度是 O(n2log⁡n)O(n^2 \log n)O(n2logn)，不能通过。
虽然贪心过不去，但是我们可以借鉴贪心中排序，我们排序是为了什么，其实就是为了发掘性质。实际上，我们不难发现每一次排序中总有数会被选择，那么就是那些 ≥s\ge s≥s 的数一定会被选择（长的高天塌下来先砸到他们www），一旦他们能够承受 sss 次操作的话那么万事大吉，如果一旦都 GG 了就得让 &lt;s&lt;s&lt;s 的承受了，我们考虑这个承受能否，如何判断？其实也很简单，如果每个数最终都减到 0 了还是不够那就完蛋，如果没有那就还是可以的。所以我们需要 &lt;s&lt;s&lt;s 的数的和 sumsumsum，判断一下就可以了。
等一下，到底怎么判断？
实际上，我们假设一个极端情况，就是那些大于等于 sss 的数都等于 sss，在这个极端情况下，必须保证 sum≥(c−x)×ssum\ge (c-x)\times ssum≥(c−x)×s，其中 xxx 为 ≥s\ge s≥s 的数的个数，只有这样才能保证可以，如果不是极端情况，那么最少也有 ⌈sums−1⌉\lceil \dfrac{sum}{s-1} \rceil⌈s−1sum​⌉ 个数，如果满足 sum≥(c−x)×ssum\ge (c-x)\times ssum≥(c−x)×s，那么满足 ⌈sums−1⌉&gt;c−x\lceil \dfrac{sum}{s-1} \rceil &gt; c-x⌈s−1sum​⌉&gt;c−x，这个时候肯定有解的。
有如下做法：

在线做法，平衡树或动态开点值域线段树瞎做，时间复杂度显然 O(nlog⁡n)O(n\log n)O(nlogn)。
离线下来，值域树状数组做，时间复杂度在离散化后也为 O(nlog⁡n)O(n \log n)O(nlogn)。这个做法是最简单的。
离线离散化，树状数组二分找这个 ≥s\ge s≥s 的数的个数，其实个上面第二个例题差不太多，只不过是倒着找，但是本质不如第二个做法简单。时间复杂度仍为 O(nlog⁡n)O(n \log n)O(nlogn)。

第二种我写的，代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;struct query&#123;    int op,k,a,c,s;&#125;q[MN];int n,m,tot,ls[MN],a[MN];struct BIT&#123;    private:        int t[MN];    public:    inline int lowbit(int x)&#123;        return x&amp;-x;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int get(int x)&#123;        return t[x];    &#125;&#125;b1,b2;void lisan()&#123;    sort(ls+1,ls+1+tot);    tot=unique(ls+1,ls+1+tot)-ls-1;    for(int i=1;i&lt;=m;i++)&#123;        if(q[i].op)&#123;            q[i].s=lower_bound(ls+1,ls+1+tot,q[i].s)-ls;        &#125;else q[i].a=lower_bound(ls+1,ls+1+tot,q[i].a)-ls;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        char op;        int x,y;        cin&gt;&gt;op;        if(op==&#x27;U&#x27;)&#123;            q[i].op=0;            cin&gt;&gt;q[i].k&gt;&gt;q[i].a;            ls[++tot]=q[i].a;        &#125;else&#123;            q[i].op=1;            cin&gt;&gt;q[i].c&gt;&gt;q[i].s;            ls[++tot]=q[i].s;        &#125;    &#125;    lisan();    for(int i=1;i&lt;=m;i++)&#123;        if(q[i].op==0)&#123;            int x=0;            if(x=a[q[i].k])&#123;                b1.update(x,-1);                b2.update(x,-ls[x]);            &#125;            x=a[q[i].k]=q[i].a;            b1.update(x,1);            b2.update(x,ls[q[i].a]);        &#125;else&#123;            int x=b1.query(tot)-b1.query(q[i].s-1);            int sum=q[i].s?b2.query(q[i].s-1):0;            if(sum&gt;=(q[i].c-x)*ls[q[i].s])&#123;                cout&lt;&lt;&quot;TAK\n&quot;;            &#125;else cout&lt;&lt;&quot;NIE\n&quot;;        &#125;    &#125;    return 0;&#125;
 普通平衡树
洒洒水啦，复杂度依旧是 O(qlog⁡n)O(q\log n)O(qlogn)。
#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MN = 1e5 + 15;int n, m, tot, op[MN], a[MN], b[MN];struct BIT&#123;    int t[MN];    int lowbit(int x)    &#123;        return x &amp; -x;    &#125;    void update(int x, int k)    &#123;        while (x &lt; MN)        &#123;            t[x] += k;            x += lowbit(x);        &#125;    &#125;    int query(int x)    &#123;        int ret = 0;        while (x)        &#123;            ret += t[x];            x -= lowbit(x);        &#125;        return ret;    &#125;    int getkth(int x)    &#123;        int p = 0, s = 0;        for (int i = 20; i &gt;= 0; i--)        &#123;            int np=p+(1&lt;&lt;i);            if(np&gt;tot) continue;            int ns=s+t[np];            if(ns&lt;x)&#123;                s=ns;                p=np;            &#125;        &#125;        return p+1;    &#125;&#125; bit;int main()&#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; op[i] &gt;&gt; a[i];        b[i] = a[i];    &#125;    sort(b + 1, b + 1 + n);    tot = unique(b + 1, b + 1 + n) - b - 1;    for (int i = 1; i &lt;= n; i++)    &#123;        if (op[i] == 4)            continue;        a[i] = lower_bound(b + 1, b + 1 + tot, a[i]) - b;    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        if (op[i] == 1)        &#123;            bit.update(a[i], 1);        &#125;        if (op[i] == 2)        &#123;            bit.update(a[i], -1);        &#125;        if (op[i] == 3)        &#123;            cout &lt;&lt; bit.query(a[i] - 1)+1&lt;&lt; &#x27;\n&#x27;;        &#125;        if (op[i] == 4)        &#123;            cout&lt;&lt;b[bit.getkth(a[i])]&lt;&lt;&#x27;\n&#x27;;        &#125;        if(op[i]==5)&#123;            cout&lt;&lt;b[bit.getkth(bit.query(a[i]-1))]&lt;&lt;&#x27;\n&#x27;;        &#125;        if(op[i]==6)&#123;            cout&lt;&lt;b[bit.getkth(bit.query(a[i])+1)]&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 2. 维护矩形
对于普通 BIT 来说，满足的就是一维度（其实就是数组）的区间查询与单点修改。
对于二维 BIT 来说，它可以做到单点加矩形查询，只需要差分就能做到对任意矩形求和，对于查询修改时间复杂度都是优秀的 O(log⁡2n)O(\log^2 n)O(log2n)。
但是我们给它上上难度呢？
P4514 上帝造题的七分钟

给定矩阵大小为 n×mn\times mn×m，你需要写一个 O(qlog⁡nlog⁡m)O(q\log n \log m)O(qlognlogm)（其中 qqq 为询问个数)，的数据结构维护如下操作
L a b c d k —— 代表将 (a,b),(c,d)(a,b),(c,d)(a,b),(c,d) 为顶点的矩形区域内的所有数字加上 kkk。
k a b c d     —— 代表求 (a,b),(c,d)(a,b),(c,d)(a,b),(c,d) 为顶点的矩形区域内所有数字的和。

矩形加矩形求和，就是维护二维差分数据的二阶二维前缀和，考虑 (i,j)(i,j)(i,j) 的差分修改对 (x,y)(x,y)(x,y) 查询的贡献，不难发现总共加了 (x−i+1)(y−j+1)k(x-i+1)(y-j+1)k(x−i+1)(y−j+1)k 个数。展开有 (x+1)(y+1)k−(y+1)ik−(x+1)jk+ijk(x+1)(y+1)k-(y+1)ik-(x+1)jk+ijk(x+1)(y+1)k−(y+1)ik−(x+1)jk+ijk，维护 k,ik,jk,ijkk,ik,jk,ijkk,ik,jk,ijk 的二维前缀和即可。
故代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15;struct query&#123;    int op,k,a,c,s;&#125;q[MN];int n,m,tot,ls[MN],a[MN];struct BIT&#123;    private:        int t[MN];    public:    inline int lowbit(int x)&#123;        return x&amp;-x;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;    void update(int x,int k)&#123;        while(x&lt;MN)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int get(int x)&#123;        return t[x];    &#125;&#125;b1,b2;void lisan()&#123;    sort(ls+1,ls+1+tot);    tot=unique(ls+1,ls+1+tot)-ls-1;    for(int i=1;i&lt;=m;i++)&#123;        if(q[i].op)&#123;            q[i].s=lower_bound(ls+1,ls+1+tot,q[i].s)-ls;        &#125;else q[i].a=lower_bound(ls+1,ls+1+tot,q[i].a)-ls;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        char op;        int x,y;        cin&gt;&gt;op;        if(op==&#x27;U&#x27;)&#123;            q[i].op=0;            cin&gt;&gt;q[i].k&gt;&gt;q[i].a;            ls[++tot]=q[i].a;        &#125;else&#123;            q[i].op=1;            cin&gt;&gt;q[i].c&gt;&gt;q[i].s;            ls[++tot]=q[i].s;        &#125;    &#125;    lisan();    for(int i=1;i&lt;=m;i++)&#123;        if(q[i].op==0)&#123;            int x=0;            if(x=a[q[i].k])&#123;                b1.update(x,-1);                b2.update(x,-ls[x]);            &#125;            x=a[q[i].k]=q[i].a;            b1.update(x,1);            b2.update(x,ls[q[i].a]);        &#125;else&#123;            int x=b1.query(tot)-b1.query(q[i].s-1);            int sum=q[i].s?b2.query(q[i].s-1):0;            if(sum&gt;=(q[i].c-x)*ls[q[i].s])&#123;                cout&lt;&lt;&quot;TAK\n&quot;;            &#125;else cout&lt;&lt;&quot;NIE\n&quot;;        &#125;    &#125;    return 0;&#125;
 3. 带修主席树
我们总结一下之前学过的：

静态整个序列的 k 小，排序即可。
动态整个序列的 k 小，平衡树或权值线段树即可。
静态区间的 k 小，主席树即可。
动态区间的 k 小？

P2617 Dynamic Rankings

给定一个含有 nnn 个数的序列 a1,a2…ana_1,a_2 \dots a_na1​,a2​…an​，需要支持两种操作：
Q l r k 表示查询下标在区间 [l,r][l,r][l,r] 中的第 kkk 小的数
C x y 表示将 axa_xax​ 改为 yyy
强制在线
1≤n,m≤1051\le n,m \le 10^51≤n,m≤105，1≤l≤r≤n1 \le l \le r \le n1≤l≤r≤n，1≤k≤r−l+11 \le k \le r-l+11≤k≤r−l+1，1≤x≤n1\le x \le n1≤x≤n，0≤ai,y≤1090 \le a_i,y \le 10^90≤ai​,y≤109。

所谓动态，就是多了个单点修改。
我们考虑静态是怎么做的，我们对于每个点以其前缀开权值线段树，任意一个区间可以表示为两个权值线段树作差，即 Rt[R]−Rt[L−1]Rt[R]-Rt[L-1]Rt[R]−Rt[L−1]。
但是如果我们有了修改呢，如果我们还是用之前的做法，我们要对所有区间的前缀都要做一次修改，极端情况下在下表为 1 的位置修改，我们的一次修改是 O(nlog⁡n)O(n\log n)O(nlogn)，实际上就是 O(qnlog⁡n)O(qn\log n)O(qnlogn)。
那怎么办？
我们考虑怎么优化这个前缀修改过程…树状数组？
发现上面的前缀的形式都是 [1,p][1,p][1,p]，这直接树状数组套上去就好了！
这样的话我们修改就能拆成 log⁡n\log nlogn 个区间，这样的化修改的时间复杂度就是 O(log⁡2n)O(\log ^2 n)O(log2n) 。时间复杂度就是 O(qlog⁡2n)O(q\log^2 n)O(qlog2n)。
但是查询的时候有一点变化，相减是肯定和上面是一样的，但是我们这里不再是两个权值线段树作差，而是两个 log⁡n\log nlogn 颗线段树作差，所以我们再跳的时候要跳 log⁡n\log nlogn 个儿子。
代码如下，可以看看查询函数：
#include&lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;(-x))#define ls t[p].lson#define rs t[p].rsonusing namespace std;const int MN=1e6+15,INF=INT_MAX;int n,m,tot,a[MN],rt[MN],now[MN],past[MN],ncnt,pcnt,LM;vector&lt;int&gt; lsan;struct segtree&#123;    int lson,rson,val;&#125;t[MN*100];struct querynode&#123;    int op,x,y,z;&#125;q[MN];void dolisan()&#123;    sort(lsan.begin(),lsan.end());    LM=unique(lsan.begin(),lsan.end())-lsan.begin();    for(int i=1;i&lt;=n;i++)&#123;        a[i]=lower_bound(lsan.begin(),lsan.begin()+LM,a[i])-lsan.begin();    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(q[i].op==2) q[i].y=lower_bound(lsan.begin(),lsan.begin()+LM,q[i].y)-lsan.begin();    &#125;    //for(int i=1;i&lt;=n;i++)&#123;    //    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    //&#125;    //cout&lt;&lt;&#x27;\n&#x27;;&#125;void change(int &amp;p,int l,int r,int pos,int k)&#123;    if(!p) p=++tot;    t[p].val+=k;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    if(mid&gt;=pos) change(ls,l,mid,pos,k);    else change(rs,mid+1,r,pos,k);&#125;int kth(int l,int r,int k)&#123;    if(l==r) return l;    int sum=0;    for(int i=1;i&lt;=ncnt;i++)&#123;        sum+=t[t[now[i]].lson].val;    &#125;    for(int i=1;i&lt;=pcnt;i++)&#123;        sum-=t[t[past[i]].lson].val;    &#125;    int mid=(l+r)&gt;&gt;1;    if(sum&gt;=k)&#123;        for(int i=1;i&lt;=ncnt;i++)&#123;            now[i]=t[now[i]].lson;        &#125;        for(int i=1;i&lt;=pcnt;i++)&#123;            past[i]=t[past[i]].lson;        &#125;        return kth(l,mid,k);    &#125;else&#123;        for(int i=1;i&lt;=ncnt;i++)&#123;            now[i]=t[now[i]].rson;        &#125;        for(int i=1;i&lt;=pcnt;i++)&#123;            past[i]=t[past[i]].rson;        &#125;        return kth(mid+1,r,k-sum);    &#125;&#125;void build()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=i;j&lt;=n;j+=lowbit(j))&#123;            change(rt[j],1,LM-1,a[i],1);        &#125;    &#125;&#125;int main()&#123;    lsan.push_back(-INF);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        lsan.push_back(a[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        char op;        cin&gt;&gt;op;        if(op==&#x27;Q&#x27;)&#123;            q[i].op=1;            cin&gt;&gt;q[i].x&gt;&gt;q[i].y&gt;&gt;q[i].z;        &#125;else&#123;            q[i].op=2;            cin&gt;&gt;q[i].x&gt;&gt;q[i].y;            lsan.push_back(q[i].y);        &#125;    &#125;    dolisan();    build();    for(int i=1;i&lt;=m;i++)&#123;        if(q[i].op==1)&#123;            pcnt=ncnt=0;            for(int j=q[i].x-1;j&gt;0;j-=lowbit(j))&#123;                past[++pcnt]=rt[j];            &#125;            for(int j=q[i].y;j&gt;0;j-=lowbit(j))&#123;                now[++ncnt]=rt[j];            &#125;            cout&lt;&lt;lsan[kth(1,LM-1,q[i].z)]&lt;&lt;&#x27;\n&#x27;;        &#125;else&#123;            for(int j=q[i].x;j&lt;=n;j+=lowbit(j))&#123;                change(rt[j],1,LM-1,a[q[i].x],-1);            &#125;            for(int j=q[i].x;j&lt;=n;j+=lowbit(j))&#123;                change(rt[j],1,LM-1,q[i].y,1);            &#125;            a[q[i].x]=q[i].y;        &#125;    &#125;    return 0;&#125;
练习：动态逆序对。
 4. 后言
树状数组的应用还是有很多很多，这里提了几个进阶应用的例子，之后也会稍加整理，感谢阅读！
参考：

qAlex_Weiq大佬的树状数组进阶

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/posts/7e454910/</url>
    <content><![CDATA[ 0.前言
你需要的必备芝士：

图的存储与遍历。
DFS序。
线段树的基础应用。
LCA的概念与性质。

准备好了？Let’s GO!
 1.重链剖分
什么是树链剖分？他是干什么的？
树链剖分，字面意思就是将树剖成一条一条链，让后我们利用这些链来维护树上路径的信息。
那我们举个例子吧。

nnn 个点的树，有 mmm 次操作，每一次操作将树上 x→yx\rightarrow yx→y 的路径都加 111 的权值 ，求树所有节点的权值之和。

不难发现树上差分。直接差分做一做就可以了，不知道的可以看我的博客。
但是如果我想求路径的值呢？

nnn 个点的树，有 mmm 次操作，每一次操作将树上 x→yx\rightarrow yx→y 的路径都加 111 的权值 。
给定 qqq 次询问，询问最短路径 u→vu\rightarrow vu→v上的权值之和

这个时候问题就不一样了，仅靠差分的话复杂度会炸成 O(nq)O(nq)O(nq)，怎么办？如果这个问题我们不放到树上，我们就是一个数组的操作，很简单对吧，线段树和树状数组都可以轻轻松松的做到，但是放到树上怎么做我们肯定是不会的。接下来我们要介绍树链剖分是如何做到这一点的。

树链剖分，就是把树剖分成若干条链，使其组合成线性结构，让后用数据结构维护链的信息。 ——OI Wiki

说人话就是：把一颗树拆成若干个不相交的链，让后用数据结构维护链的信息。
说到底为什么我们非要拆成链来维护呢？回忆树上差分，差分本质上我们只能在一个线性结构比如说数组上维护，但是放在树上我们不会做。但是我们可以把一条路径在LCA处劈成2半，分别进行拆分，如下图。我们将这颗树的 3→63\rightarrow 63→6的路径都加上 111 。我们拆成了3→2,5→63 \rightarrow 2,5\rightarrow 63→2,5→6，2条线性的链，这样我们进行差分就十分方便了。

让后差分的结果如下：

而对于路径信息的维护也很好说，就像差分拆成链的思想一样，我们也用链来去维护。上文我们提到了如果我们不放到树上就很好做，只需要用线段树来去维护就可以了，问题在于树不是像数组。但是我们可以利用拆链的思想，把它拆成一条一条链，这样不就类似于数组了吗，让后我们维护数组的信息，就可以了。
现在问题在于我们怎么把树拆成一条一条链？而且这个链应该怎么拆才能保证我的复杂度不会炸掉？
我们有2种方法，一种叫重链剖分，一种叫长链剖分。我们先讲重链剖分。
先来几个概念，别怕会有图辅助理解的：

重儿子（hsonhsonhson数组记录）：该节点子树中，节点个数最多的子树的根节点，即为该节点的重儿子。


对于上面的树结构，节点 111 的重儿子就是 222 因为节点个数有4个，而对于节点 222 的重儿子是 555 ，因为有2个比3号点要大。而对于3，6，5号点没有重儿子，因为他们是叶子节点。

重边：连接该节点与它重儿子的边

就像上面，例如1→2,2→51\rightarrow 2,2\rightarrow 51→2,2→5。

重链（toptoptop数组记录顶端）：由一系列重边相连得到的链。特别的，落单的节点也是重链。
轻链：由一系列非重边相连得到的链。

借用OI-Wiki的图：

这样就不难得到拆树的方法。对于每个节点我们只需要找出它的重儿子，让后就可以根据这些信息拆成许多许多链了。
话是这么说但是到底咋求？
我们要分成2次来DFS进行求，我们需要维护如下信息。



名称
变量名
含义
维护方式




子树大小
sizsizsiz
子树节点的数量，用于判断轻重儿子
自底向上统计（第一次DFS）


重儿子
hsonhsonhson
一个节点的重儿子，若无默认为0
用子树大小sizsizsiz计算取siz[v]siz[v]siz[v]最大的vvv（第一次DFS）


节点深度
depdepdep
节点在树的深度
自上向下计算（第一次DFS）


节点的父亲
fafafa
父亲节点
字面意思维护即可（第一次DFS）


重链
toptoptop
一条重链的顶端节点，其中top[u]top[u]top[u]表示uuu号点所在链的顶端
遍历重儿子赋值即可（第二次DFS）


按照链遍历的DFS序
ididid
重链优先遍历的DFS序
字面意思先遍历重边在遍历轻边（第二次DFS）



根据这个表，我们能够很轻松的设计出第一个DFS函数：
void dfs1(int u,int pre)&#123;// u号节点，父亲节点是pre    dep[u]=dep[pre]+1;// 深度    siz[u]=1;// 子树大小    fa[u]=pre;// 父亲    int maxp=-1;//初始化最大sizv为-1    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs1(v,u);        siz[u]+=siz[v];        if(maxp&lt;siz[v])&#123;// 更新hson            maxp=siz[v];            hson[u]=v;        &#125;    &#125;&#125;
而对于第二次的DFS函数，也是很好设计。
void dfs2(int u,int ltop)&#123;    id[u]=++cnt;// 设置id，因为我们优先遍历重链所以是重链优先的dfn序    top[u]=ltop;//节点u所在链的顶端    if(!hson[u]) return;//如果没有重儿子显然叶子节点    dfs2(hson[u],ltop);// 先剖重链    for(auto v:adj[u])&#123;        if(v==fa[u]||v==hson[u]) continue; // 别忘了排除重儿子！        dfs2(v,v);//处理轻链    &#125;&#125;
toptoptop 还好说，为什么要设计 ididid ？别忘了，我们最终是要用线段树等数据结构来进行维护，这样维护的话一条链在 ididid 上是排成一个连续区间（即DFS序是连续的），这样就方便了。
我们建一颗支持区间加的线段树，让后我们考虑怎么维护树上的操作。
回顾上面的图，我们其实对于路径来说就是根据LCA拆成2条链进行操作。
问题来了，怎么求LCA？
一个很显然的想法就是倍增求LCA，但是我跟你说这个也可以同时求出LCA呢？
我们对上面的图进行小小的改编，并进行重链剖分。对于6号点也是可以作为最长重链的终点，不过链不能分叉。

我们不妨借鉴倍增求LCA的思想：2个节点借助fafafa数组跳到同一个节点。对于重链剖分来说，就是在不同重链的节点，我们让他们不断的跳直到处于同一重链（如果一开始就是同一重链，想一想还用跳吗？）。还记得我们求的 toptoptop 数组吗？这个就是替代倍增fafafa的关键。我们直接跳到链的顶端，这样就可以有像倍增跳fafafa一样的效果了！当然和倍增算法一样，我们让dep[top[x]],dep[top[y]]dep[top[x]],dep[top[y]]dep[top[x]],dep[top[y]]中深度大的往上跳。
跳到最后会出现一个情况，虽然x,yx,yx,y在一条链上但不一定重合，此时lcalcalca就是深度小的节点。
不难有lcalcalca函数：
int lca(int x,int y)&#123;    while(top[x]!=top[y])&#123;//如果不在一条链就继续跳        if(dep[top[x]]&lt;dep[top[y]])&#123;// 优先跳深度大的            swap(x,y);        &#125;        x=fa[top[x]];    &#125;    return dep[x]&lt;dep[y]?x:y;// 深度小的即为LCA&#125;
等会，时间复杂度多少？这个我们待会再说。
LCA求完那就都好说，直接LCA维护就可以了。
例如路径加：
void addchain(int x,int y,ll k)&#123;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);        sg.add(1,id[top[x]],id[x],k);// x跳的过程中我们就要加上权值，顺序不要搞反了。        x=fa[top[x]];    &#125;    if(dep[x]&gt;dep[y]) swap(x,y);    sg.add(1,id[x],id[y],k);    // 处理路径LCA-&gt;y的权值，因为LCA与y已经在一条链上所以可以直接加&#125;
有的人会说，你这个跳LCA的时候会更换x,yx,yx,y，难道不会重复加吗？这种问题的解法可以自己模拟一遍LCA的跳法，看看是否会重复加区间，显然是不会的。
到这里前面2个问题就解决完毕了，但是我还有一个问题。如果我要加子树的权值呢。

给定节点uuu，将uuu的子树内权值都加上wiw_iwi​。特别的，叶子节点的子树就是节点本身。

我们思考一个问题，重链优先遍历在子树内的DFS序是连续的吗？
显然是连续的，这里不再证明。
那么就好说了，直接对[id[x],id[x]+siz[x]−1][id[x],id[x]+siz[x]-1][id[x],id[x]+siz[x]−1]维护即可。减一是因为sizsizsiz包含自己xxx。
void addchild(int x,ll k)&#123; //加    sg.add(1,id[x],id[x]+siz[x]-1,k);&#125;ll querychild(int x)&#123; // 查    return sg.query(1,id[x],id[x]+siz[x]-1)%MOD;&#125;
所以时间复杂度到底是多少？
有一个性质：向下经过一条 轻边 时，所在子树的大小至少会除以二。
这个是根据性质来说的，那么不难发现，我们拆LCA路径的做法只需要最多走O(log⁡n)O(\log n)O(logn)次，树上每条路径最多可以划分成不超过O(log⁡n)O(\log n)O(logn)条重链。
来做题，P3884:

nnn个节点的树，根节点为RRR，树节点有初始权值wiw_iwi​。mmm次操作:
1 x y z，表示将树从 xxx 到 yyy 结点最短路径上所有节点的值都加上 zzz。
2 x y，表示求树从 xxx 到 yyy 结点最短路径上所有节点的值之和。
3 x z，表示将以 xxx 为根节点的子树内所有节点值都加上 zzz。
4 x 表示求以 xxx 为根节点的子树内所有节点值之和。
数据对给定的模数PPP取模。
1≤n,m≤105,1≤R≤n,1≤P≤2301\le n,m \le 10^5,1\le R \le n,1\le P \le 2^{30}1≤n,m≤105,1≤R≤n,1≤P≤230

照着写就可以了。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=5e5+15;int n,m,rt,MOD,cnt,dep[MN],siz[MN],fa[MN],id[MN],hson[MN],top[MN];ll w[MN];vector&lt;int&gt; adj[MN];struct segtree&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct&#123;        int l,r;        ll sum,add;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].sum=(t[ls].sum+t[rs].sum)%MOD;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r)&#123;            t[p].sum=0;            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void pushdown(int p)&#123;        if(t[p].add)&#123;            t[ls].sum=(t[ls].sum+(t[ls].r-t[ls].l+1)*t[p].add)%MOD;            t[rs].sum=(t[rs].sum+(t[rs].r-t[rs].l+1)*t[p].add)%MOD;            t[ls].add=(t[ls].add+t[p].add)%MOD;            t[rs].add=(t[rs].add+t[p].add)%MOD;            t[p].add=0;        &#125;    &#125;    void add(int p,int fl,int fr,ll k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            t[p].add=(t[p].add+k)%MOD;            t[p].sum=(t[p].sum+(t[p].r-t[p].l+1)*k)%MOD;            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) add(ls,fl,fr,k);        if(mid&lt;fr) add(rs,fl,fr,k);        pushup(p);    &#125;    ll query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].sum;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        ll ret=0;        if(mid&gt;=fl) ret=(ret+query(ls,fl,fr))%MOD;        if(mid&lt;fr) ret=(ret+query(rs,fl,fr))%MOD;        return ret;    &#125;    #undef ls    #undef rs&#125;sg;void dfs1(int u,int pre)&#123;    dep[u]=dep[pre]+1;    siz[u]=1;    fa[u]=pre;    int maxp=-1;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs1(v,u);        siz[u]+=siz[v];        if(maxp&lt;siz[v])&#123;            maxp=siz[v];            hson[u]=v;        &#125;    &#125;&#125;void dfs2(int u,int ltop)&#123;    id[u]=++cnt;    top[u]=ltop;    if(w[u]!=0)&#123;        sg.add(1,id[u],id[u],w[u]);    &#125;    if(!hson[u]) return;    dfs2(hson[u],ltop);    for(auto v:adj[u])&#123;        if(v==fa[u]||v==hson[u]) continue;        dfs2(v,v);    &#125;&#125;void addchain(int x,int y,ll k)&#123;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);        sg.add(1,id[top[x]],id[x],k);        x=fa[top[x]];    &#125;    if(dep[x]&gt;dep[y]) swap(x,y);    sg.add(1,id[x],id[y],k);&#125;ll querychain(int x,int y)&#123;    ll ret=0;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);        ret=(ret+sg.query(1,id[top[x]],id[x]))%MOD;        x=fa[top[x]];    &#125;    if(dep[x]&gt;dep[y]) swap(x,y);    ret=(ret+sg.query(1,id[x],id[y]))%MOD;    return ret;&#125;void addchild(int x,ll k)&#123;    sg.add(1,id[x],id[x]+siz[x]-1,k);&#125;ll querychild(int x)&#123;    return sg.query(1,id[x],id[x]+siz[x]-1)%MOD;&#125;int main()&#123;    // freopen(&quot;ans.in&quot;,&quot;r&quot;,stdin);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;rt&gt;&gt;MOD;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;w[i];    &#125;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    sg.build(1,1,n);    dfs1(rt,0);    dfs2(rt,rt);    while(m--)&#123;        int op,x,y;        ll z;        cin&gt;&gt;op&gt;&gt;x;        if(op==1)&#123;            cin&gt;&gt;y&gt;&gt;z;            addchain(x,y,z%MOD);        &#125;        if(op==2)&#123;            cin&gt;&gt;y;            cout&lt;&lt;querychain(x,y)%MOD&lt;&lt;&#x27;\n&#x27;;        &#125;        if(op==3)&#123;            cin&gt;&gt;z;            addchild(x,z);        &#125;        if(op==4)&#123;            cout&lt;&lt;querychild(x)%MOD&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 1.1 例题
CF1555F:

有一含 n 个点的带权无向图。
一个简单环被定义为图上一没有重复顶点的环。令这样的一个环的权重为它环上所有边的权值的异或和。
若一个图中全部简单环的权重都是 1 ，那么我们称这个图为好图，而一个图若不是好图，那么这个图则是坏图。
最开始，图是空的。接着会有 q 个询问。每个询问为以下格式：
u v x — 若不会使图变成坏图，则在点 u 与点 v 间加一条权值为 x 的边。
对于每一个询问输出到底加不加这条边。

这个不是图论吗？和树上路径有什么关系？
针对环的问题我们有一个套路就是：离线造生成树。
环用并查集判断联通性。
我们考虑什么边能加进来，第一类就是生成树本来的边是可以加；第二类就是这条非树边加入所构成的环不与其他的任何环相交，并且路径异或和为1即可。
非树边的加入我们可以考虑转化成线段树最大值/和来维护，我们把在环上的边赋值为1，不再的赋值为0，可以加入的条件就是路径上所有边权值都是0，考虑树剖。路径异或和为1考虑树上前缀异或和。
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=5e5+15,MQ=5e5+15;int n,m,cnt,id[MN],sum[MN],hson[MN],pre[MN],top[MN],dep[MN],siz[MN],fa[MN];bool isok[MN];struct qedge&#123;    int u,v,w;&#125;q[MQ];struct edge&#123;    int v,w;&#125;;vector&lt;edge&gt; adj[MN];struct segtree&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct&#123;        int l,r,val,cov;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].val=max(t[ls].val,t[rs].val);    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        t[p].cov=-1;        if(l==r)&#123;            t[p].val=0;            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void pushdown(int p)&#123;        if(t[p].cov!=-1)&#123;            t[ls].val=t[ls].cov=t[rs].val=t[rs].cov=t[p].cov;            t[p].cov=-1;        &#125;    &#125;    void update(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            t[p].val=t[p].cov=k;            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) update(ls,fl,fr,k);        if(mid&lt;fr) update(rs,fl,fr,k);        pushup(p);    &#125;    int queryone(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r&gt;&gt;1);        if(mid&gt;=fl&amp;&amp;queryone(ls,fl,fr)) return 1;        if(mid&lt;fr&amp;&amp;queryone(rs,fl,fr)) return 1;        return 0;    &#125;    #undef ls    #undef rs&#125;sg;void initpre()&#123;    for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;void dfs1(int u,int pree)&#123;    dep[u]=dep[pree]+1;    siz[u]=1;    fa[u]=pree;    int maxp=-1;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==pree) continue;        sum[v]=sum[u]^w;        dfs1(v,u);        siz[u]+=siz[v];        if(maxp&lt;siz[v])&#123;            maxp=siz[v];            hson[u]=v;        &#125;    &#125;&#125;void dfs2(int u,int ltop)&#123;    id[u]=++cnt;    top[u]=ltop;    if(!hson[u]) return;    dfs2(hson[u],ltop);    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==hson[u]||v==fa[u]) continue;        dfs2(v,v);    &#125;&#125;int root(int x)&#123;    if(pre[x]==x) return x;    else return pre[x]=root(pre[x]);&#125;int ask(int x,int y)&#123;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);        if(sg.queryone(1,id[top[x]],id[x])) return 1;        x=fa[top[x]];    &#125;    if(dep[x]&gt;dep[y]) swap(x,y);    if(id[x]+1&lt;=id[y]&amp;&amp;sg.queryone(1,id[x]+1,id[y])) return 1;    return 0;&#125;void modify(int x,int y,int k)&#123;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);        sg.update(1,id[top[x]],id[x],1);        x=fa[top[x]];    &#125;    if(dep[x]&gt;dep[y]) swap(x,y);    if(id[x]+1&lt;=id[y])sg.update(1,id[x]+1,id[y],k);&#125;int main()&#123;    //freopen(&quot;ans.in&quot;,&quot;r&quot;,stdin);    cin&gt;&gt;n&gt;&gt;m;    sg.build(1,1,MQ);    initpre();    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;q[i].u&gt;&gt;q[i].v&gt;&gt;q[i].w;        int ru=root(q[i].u),rv=root(q[i].v);        if(ru!=rv)&#123;            isok[i]=1;            // cout&lt;&lt;q[i].u&lt;&lt;&quot; &quot;&lt;&lt;q[i].v&lt;&lt;&quot; &quot;&lt;&lt;q[i].w&lt;&lt;&#x27;\n&#x27;;            adj[q[i].u].push_back(&#123;q[i].v,q[i].w&#125;);            adj[q[i].v].push_back(&#123;q[i].u,q[i].w&#125;);            pre[rv]=ru;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(!dep[i])&#123;            dfs1(i,0);            dfs2(i,i);        &#125;    &#125;    //cout&lt;&lt;cnt&lt;&lt;&#x27;\n&#x27;;    for(int i=1;i&lt;=m;i++)&#123;        if(isok[i]) cout&lt;&lt;&quot;YES\n&quot;;        else&#123;            if(!(sum[q[i].u]^sum[q[i].v]^q[i].w)) cout&lt;&lt;&quot;NO\n&quot;;            else&#123;                if(ask(q[i].u,q[i].v))&#123;                    cout&lt;&lt;&quot;NO\n&quot;;                &#125;else&#123;                    modify(q[i].u,q[i].v,1);                    cout&lt;&lt;&quot;YES\n&quot;;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;
 1.2 LCA
根据我们上面说的求就可以了，这里给出一个模板。
时间复杂度预处理O(n)O(n)O(n)，查询O(log⁡n)O(\log n)O(logn)，常数小，代码简单。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e5+15;int n,m,s;int hson[MN],dep[MN],top[MN],fa[MN],siz[MN];vector&lt;int&gt; adj[MN];void dfs1(int u,int pre)&#123;    siz[u]=1;    fa[u]=pre;    dep[u]=dep[pre]+1;    int maxp=-1;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs1(v,u);        siz[u]+=siz[v];        if(maxp&lt;siz[v])&#123;            hson[u]=v;            maxp=siz[v];        &#125;    &#125;&#125;void dfs2(int u,int ltop)&#123;    top[u]=ltop;    if(!hson[u]) return;    dfs2(hson[u],ltop);    for(auto v:adj[u])&#123;        if(v==fa[u]||v==hson[u])&#123;            continue;        &#125;        dfs2(v,v);    &#125;&#125;int lca(int x,int y)&#123;    while(top[x]!=top[y])&#123;        if(dep[top[x]]&lt;dep[top[y]])&#123;            swap(x,y);        &#125;        x=fa[top[x]];    &#125;    return dep[x]&lt;dep[y]?x:y;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs1(s,0);    dfs2(s,s);    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        cout&lt;&lt;lca(u,v)&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 2.长链剖分
 2.1 介绍
长链剖分和重链剖分不一样的一点，前者以子树深度最大的儿子为重儿子，而后者以子树大小最大的儿子为重儿子。
举个例子，例如下面这棵树，绿色的边就是长链：

我们定义一个节点和它的长儿子节点相连的边（就是上图绿色的边）为实边，其他为虚边。
以下是代码实现，和重链剖分差不太多：
namespace Tree&#123;    int dep[MN],fa[MN],mxdep[MN],htop[MN],len[MN],hson[MN];    void dfs1(int u,int pre)&#123;        fa[u]=pre;        dep[u]=mxdep[u]=dep[pre]+1;        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==pre) continue;            dfs1(v,u);            if(mxdep[u]&lt;mxdep[v]) mxdep[u]=mxdep[v],hson[u]=v;        &#125;        len[u]=mxdep[u]-dep[u]+1;    &#125;    void dfs2(int u,int ltop)&#123;        htop[u]=ltop;        if(!hson[u])&#123;return;&#125;        dfs2(hson[u],ltop);        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;&#125;using namespace Tree;
 2.2 长链剖分的性质
长链剖分有如下的性质：

从根节点到任意叶子结点经过的轻边条数不超过 n\sqrt{n}n​，比重链剖分的 log⁡n\log nlogn 有点劣。
一个节点的 kkk 级祖先所在长链长度一定不小于 kkk。
每个节点所在长链末端为其子树内最深节点。
选一个节点能覆盖它到根的所有节点。选 kkk 个节点，覆盖的最多节点数就是前 kkk 条长链长度之和，选择的节点即 kkk 条长链末端。

 2.3 应用
 2.3.1 树上 k 级祖先
首先 O(nlog⁡n)O(n\log n)O(nlogn) 的倍增预处理求出每个节点 uuu 的 2k2^k2k 级祖先，以及对于每一条长链，从长链向上向下 iii 步分别能走到哪个节点，其中 iii 不超过长链深度。此外预处理每个数在二进制下的最高位（即 ⌊log⁡2i⌋\lfloor \log_2 i \rfloor⌊log2​i⌋，不想预处理的可以用 __lg 函数） lgilg_ilgi​。预处理为 O(nlog⁡n)+O(n)+O(n)O(n \log n)+O(n)+O(n)O(nlogn)+O(n)+O(n)。
一次查询 (u,k)(u,k)(u,k)，首先跳到 uuu 的 2lgk2^{lg_k}2lgk​ 级祖先 fafafa，由于我们与处理了从 fafafa 所在长链顶端 ttt 向上/下走不超过链长步分别到哪个节点，故不难直接查询，故查询时间复杂度为 O(1)O(1)O(1)。
#include&lt;bits/stdc++.h&gt;#define ui unsigned intusing namespace std;constexpr int MN=1e6+15;int n,q,rt,hb[MN];ui s;long long ans;vector&lt;int&gt; adj[MN];namespace Tree&#123;    int dep[MN],mxdep[MN],fa[21][MN],hson[MN],htop[MN];    vector&lt;int&gt; up[MN],dw[MN];    void dfs1(int u,int pree)&#123;        dep[u]=mxdep[u]=dep[pree]+1;        fa[0][u]=pree;        for(int i=1;i&lt;=20;i++)&#123;            fa[i][u]=fa[i-1][fa[i-1][u]];        &#125;        for(auto v:adj[u])&#123;            if(v==pree) continue;            dfs1(v,u);            if(mxdep[v]&gt;mxdep[u])&#123;                mxdep[u]=mxdep[v];                hson[u]=v;            &#125;        &#125;    &#125;    void dfs2(int u,int ltop)&#123;        htop[u]=ltop;        if(u==ltop)&#123;            for(int i=0,it=u;i&lt;=mxdep[u]-dep[u];i++)&#123;                up[u].push_back(it),it=fa[0][it];            &#125;            for(int i=0,it=u;i&lt;=mxdep[u]-dep[u];i++)&#123;                dw[u].push_back(it),it=hson[it];            &#125;        &#125;        if(hson[u]) dfs2(hson[u],ltop);        for(auto v:adj[u])&#123;            if(v==fa[0][u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;    int query(int x,int k)&#123;        if(!k) return x;        x=fa[__lg(k)][x];        k-=1&lt;&lt;(__lg(k));        k-=dep[x]-dep[htop[x]];        x=htop[x];        return k&gt;=0?up[x][k]:dw[x][-k];    &#125;&#125;using namespace Tree;ui get(ui x)&#123;	x ^= x &lt;&lt; 13;	x ^= x &gt;&gt; 17;	x ^= x &lt;&lt; 5;	return s = x; &#125;signed main()&#123;    read(n,q,s);    for(int i=1;i&lt;=n;i++)&#123;        int faa;        read(faa);        if(!faa)&#123;            rt=i;            continue;        &#125;        adj[faa].push_back(i);        adj[i].push_back(faa);    &#125;    dfs1(rt,0);    dfs2(rt,rt);    int lst=0;    for(int i=1;i&lt;=q;i++)&#123;        int x,k;        x=(get(s)^lst)%n+1;        k=(get(s)^lst)%dep[x];        lst=query(x,k);        ans^=1ll*i*(lst);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 2.3.2 长链剖分优化 DP
长链剖分的价值主要体现在于能够优化树上有关深度的 DP，如果子树内每个深度仅对应一个信息，我们就可以用长链剖分优化。
一般形式为：f(i,j)f(i,j)f(i,j) 表示以 iii 为根的子树内，深度为 jjj 节点的贡献。
下面以一道例题来看：
CF1009F
先考虑 ddd 怎么求，有一个显然的转移方程：
d(i,j)=∑x∈son(i)d(x,j−1)d(i,j)=\sum_{x\in son(i)} d(x,j-1)
d(i,j)=x∈son(i)∑​d(x,j−1)
初始化 f(i,0)=1f(i,0)=1f(i,0)=1。
然而是 O(n2)O(n^2)O(n2) 的，无法承受，注意到这个信息子树深度有且仅对应顶点个数这一个信息而非具体是哪些顶点，因此子树内深度相同的点等价。考虑长链剖分优化 DP。
具体的，类似于 DSU on Tree，我们直接继承重儿子的答案，让后将所有轻儿子的答案合并过来，因为每个点 uuu 最多合并一次，即合并 uuu 所在重链顶端 toptoptop 的父亲 fafafa 与 ttt 时，uuu 所包含的信息就和 dfad_{fa}dfa​ 在 depu−depfadep_u -dep_{fa}depu​−depfa​ 处的信息融为了一体，相当于点 uuu 直接消失了，时间复杂时优秀的 O(n)O(n)O(n)。
具体实现上，如何继承重儿子的 DP 值，一个解决方案就是用指针申请内存，对于一条重链，共用一个大小为其长度的数组。这同时解决了上述两个问题。实现时需要特别注意开足空间，并弄清转移方向。
另一个方法就是 vector，不过通用性没那么好，这里就不再赘述了。
 2.4 例题
 CF1009F
提交记录
 P4292 重建计划
直接 01 分数规划上来就是一个二分答案，让后将减掉 midmidmid 后问题转化为求一个长度在 [L,U][L,U][L,U] 之间且边权非负的路径。考虑 DP，设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内深度为 jjj 的最大路径权值和，转移是显然的，也容易看出来我们求的是最大值，每一个长度只会贡献唯一一个信息。
考虑长链剖分优化 DP，合并子树的时先遍历轻儿子的答案，这个需要我们求重链的一段区间 dp 值的最大值，若轻儿子对应位置比重儿子更大就修改，所以我们还需要区间单点修改，考虑线段树维护。线段树上我们可以通过给每一个节点赋一个 dfs 序，那么线段树上对应的位置就是 (dfn[x]+j)(dfn[x]+j)(dfn[x]+j)（jjj 为 dp 里面的），时间复杂度 O(nlog⁡2n)O(n \log^2 n)O(nlog2n)
#include&lt;bits/stdc++.h&gt;#define double long double#define int long longusing namespace std;constexpr int MN=1e5+15;constexpr double eps=1e-6;struct Edge&#123;    int v,w;&#125;;int n,L,R;double tmp[MN],V;vector&lt;Edge&gt; adj[MN];struct Segment&#123;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1    struct Node&#123;        int l,r;        double val;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].val=max(t[ls].val,t[rs].val);    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        t[p].val=-1e18;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);    &#125;    void modify(int p,int pos,double k)&#123;        if(t[p].l==t[p].r)&#123;            t[p].val=max(t[p].val,k);            return;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos) modify(ls,pos,k);        else modify(rs,pos,k);        pushup(p);    &#125;    double query(int p,int fl,int fr)&#123;        if(fl&gt;fr) return -1e18;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val;        &#125;        int mid=(t[p].l+t[p].r)&gt;&gt;1;        double ret=-1e18;        if(mid&gt;=fl) ret=query(ls,fl,fr);        if(mid&lt;fr) ret=max(ret,query(rs,fl,fr));        return ret;    &#125;#undef ls#undef rs&#125;sg;namespace Tree&#123;    int htop[MN],hson[MN],dep[MN],mxdep[MN],val[MN],len[MN],fa[MN],dfn[MN],dtot;    double dis[MN],ret;    void dfs1(int u,int pre)&#123;        fa[u]=pre;        dep[u]=mxdep[u]=dep[pre]+1;        for(auto e:adj[u])&#123;            int v=e.v,w=e.w;            if(v==pre) continue;            dfs1(v,u);            if(mxdep[u]&lt;mxdep[v])&#123;                mxdep[u]=mxdep[v];                hson[u]=v;                val[v]=w;            &#125;        &#125;        len[u]=mxdep[u]-dep[u];    &#125;    void dfs2(int u,int ltop)&#123;        dfn[u]=++dtot;        if(hson[u]) dfs2(hson[u],ltop);        for(auto e:adj[u])&#123;            int v=e.v,w=e.w;            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;    void dfs3(int u,int pre)&#123;        sg.modify(1,dfn[u],dis[u]);        if(hson[u])&#123;            dis[hson[u]]=dis[u]+val[hson[u]]-V;            dfs3(hson[u],u);        &#125;        for(auto e:adj[u])&#123;            int v=e.v,w=e.w;            if(v==fa[u]||v==hson[u]) continue;            dis[v]=dis[u]+e.w-V;            dfs3(v,u);            for(int i=1;i&lt;=len[v]+1;i++)&#123;                tmp[i]=sg.query(1,dfn[v]+i-1,dfn[v]+i-1);            &#125;            for(int i=1;i&lt;=min(len[v]+1,R);i++)&#123;                ret=max(ret,tmp[i]+sg.query(1,dfn[u]+L-i,min(dfn[u]+R-i,dfn[u]+len[u]))-2*dis[u]);            &#125;            for(int i=1;i&lt;=len[v]+1;i++)&#123;                sg.modify(1,dfn[u]+i,tmp[i]);            &#125;        &#125;        ret=max(ret,sg.query(1,dfn[u]+L,min(dfn[u]+R,dfn[u]+len[u]))-dis[u]);    &#125;&#125;using namespace Tree;bool check(double x)&#123;    sg.build(1,1,n);    V=x,ret=-1e18;    dfs3(1,0);    return ret&gt;=0;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;    for(int i=1;i&lt;n;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);        adj[v].push_back(&#123;u,w&#125;);    &#125;    dfs1(1,0);    dfs2(1,1);    double l=0,r=1e7;    while(r-l&gt;eps)&#123;        double mid=(l+r)/2;        if(check(mid)) l=mid;        else r=mid;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;l;    return 0;&#125;
 P5904 HOT-Hotels
手摸样例启示我们在三个点的 LCA 处统计贡献，直接统计的话虽然解决了三个点到 LCA 距离相等的情况，但是没有统计一个点离 LCA 远，另外两个点离 LCA 距离近一点的形态。考虑用 DP 统计答案，设 f(i,j)f(i,j)f(i,j) 表示 iii 子树内，距离为 jjj 的节点个数，让后再来一个转台处理离远一点的信息，设 g(i,j)g(i,j)g(i,j) 表示 iii 子树内来一个长度为 jjj 的链凑成 3 元组的数量。fff 的转移时显然的，而 ggg 不太好从儿子转移过来。
遇到这种不太好从儿子转移到父亲的节点的 DP 我们可以考虑合并儿子和父亲子树的信息。有如下分类讨论：
g(i,j)←∑x,y∈son(u),x≠yf(x,j−1)×f(y,j−1)g(i,j)\leftarrow \sum_{x,y \in son(u),x\neq y} f(x,j-1)\times f(y,j-1)
g(i,j)←x,y∈son(u),x=y∑​f(x,j−1)×f(y,j−1)
g(i,j)←∑x∈son(u)f(x,j−1)g(i,j)\leftarrow \sum_{x\in son(u)} f(x,j-1)
g(i,j)←x∈son(u)∑​f(x,j−1)
统计答案也需要分类讨论：
ans←g(i,0)ans\leftarrow g(i,0)
ans←g(i,0)
ans←∑x,y∈son(u),x≠yf(x,j−1)×g(y,j+1)ans\leftarrow \sum_{x,y \in son(u),x\neq y} f(x,j-1)\times g(y,j+1)
ans←x,y∈son(u),x=y∑​f(x,j−1)×g(y,j+1)
时间复杂度经优化后达到 O(n)O(n)O(n)。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=3e6+15;int n;ll buf[MN],ans,*f[MN],*g[MN],*now;vector&lt;int&gt; adj[MN];namespace Tree&#123;    int dep[MN],mxdep[MN],len[MN],fa[MN],hson[MN];    void dfs1(int u,int pre)&#123;        fa[u]=pre;        dep[u]=mxdep[u]=dep[pre]+1;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs1(v,u);            if(mxdep[u]&lt;mxdep[v])&#123;                mxdep[u]=mxdep[v];                hson[u]=v;            &#125;        &#125;        len[u]=mxdep[u]-dep[u]+1;    &#125;    void dfs3(int u,int pre)&#123;        if(hson[u])&#123;            f[hson[u]]=f[u]+1;            g[hson[u]]=g[u]-1;            dfs3(hson[u],u);        &#125;        f[u][0]=1;        ans+=g[u][0];        for(auto v:adj[u])&#123;            if(v==pre||v==hson[u]) continue;            f[v]=now;            now+=len[v]&lt;&lt;1;            g[v]=now;            now+=len[v]&lt;&lt;1;            dfs3(v,u);            for(int i=0;i&lt;len[v];i++)&#123;                if(i)&#123;                    ans+=f[u][i-1]*g[v][i];                &#125;                ans+=g[u][i+1]*f[v][i];            &#125;            for(int i=0;i&lt;len[v];i++)&#123;                g[u][i+1]+=f[u][i+1]*f[v][i];                if(i) g[u][i-1]+=g[v][i];                f[u][i+1]+=f[v][i];            &#125;        &#125;    &#125;&#125;using namespace Tree;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs1(1,0);    now=buf;    f[1]=now;    now+=len[1]&lt;&lt;1;    g[1]=now;    now+=len[1]&lt;&lt;1;    dfs3(1,0);    cout&lt;&lt;ans;    return 0;&#125;
 P3441 [POI2006]MET-Subway
形式化题面如下：

给定一棵有 nnn 个节点的无向树和一个整数 kkk，选出最多 kkk 条不分叉的路径（即简单链），使得这些路径覆盖的不同节点数尽可能多。输出最多能覆盖的节点数。

DP 显然不太好，考虑贪心，那么贪心尽量让链长。考虑直径一定作为答案的一部分出现，而剩下的就是直径上的分支，分支跨直径配对成路径。考虑这个如何配对，其实就是不同链的叶子两两配对，考虑以直径一端点为根，长链剖分加排序（链长大到小）取 2L−12L-12L−1 个叶子即可。
实现丑了会卡常，请大家注意常数和空间。
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+1520;int n,L,rt,ftot,ans;pir lvf[MN];bool vis[MN];int hd[MN],nxt[MN&lt;&lt;1],to[MN&lt;&lt;1],tot;void add(int u,int v)&#123;to[++tot]=v,nxt[tot]=hd[u],hd[u]=tot;&#125;namespace ZJTree&#123;    struct Node&#123;int u,fa,len;&#125;;    int bfs(int st)&#123;        queue&lt;Node&gt; q;        int ans1=-1e9,ans2=1;        q.push(&#123;st,0,0&#125;);        while(!q.empty())&#123;            auto [u,fa,w]=q.front();q.pop();            if(w&gt;ans1) ans1=w,ans2=u;            for(int i=hd[u];i;i=nxt[i])&#123;                int v=to[i];                if(v==fa) continue;                q.push(&#123;v,u,w+1&#125;);            &#125;        &#125;        return ans2;    &#125;&#125;namespace Tree&#123;    int dep[MN],fa[MN],mxdep[MN],htop[MN],len[MN],hson[MN];    void dfs1(int u,int pre)&#123;        fa[u]=pre;        dep[u]=mxdep[u]=dep[pre]+1;        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==pre) continue;            dfs1(v,u);            if(mxdep[u]&lt;mxdep[v]) mxdep[u]=mxdep[v],hson[u]=v;        &#125;        len[u]=mxdep[u]-dep[u]+1;    &#125;    void dfs2(int u,int ltop)&#123;        htop[u]=ltop;        if(!hson[u])&#123;lvf[++ftot]=pir(len[htop[u]],u);return;&#125;        dfs2(hson[u],ltop);        for(int i=hd[u];i;i=nxt[i])&#123;            int v=to[i];            if(v==fa[u]||v==hson[u]) continue;            dfs2(v,v);        &#125;    &#125;&#125;using namespace Tree;bool cmp(pir x,pir y)&#123;return x.first&gt;y.first;&#125;int main()&#123;    read(n,L);    for(int i=1,u,v;i&lt;n;i++) read(u,v),add(u,v),add(v,u);    rt=ZJTree::bfs(1);    dfs1(rt,0);    dfs2(rt,rt);    sort(lvf+1,lvf+1+ftot,cmp);    for(int i=1;i&lt;=(L&lt;&lt;1)-1;i++)&#123;        if(i==1) vis[rt]=1,ans+=len[rt];        else&#123;            int p=lvf[i].second;            while(!vis[htop[p]]) vis[htop[p]]=1,ans+=len[htop[p]],p=fa[htop[p]];        &#125;    &#125;    put(ans);    return 0;&#125;
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>根号分治</title>
    <url>/posts/6889ca89/</url>
    <content><![CDATA[ 1. 介绍与引入
没有前言，懒得写了。
根号分治，本质是平衡规划思想（大纲 9 级），在预处理和询问复杂度中寻找平衡，我们通常用根号作为问题规模的分界线。我们确定一个界限 BBB，小于 BBB 的暴力预处理，大于的回答一次时间只需要 nB≤n\dfrac{n}{B}\le \sqrt{n}Bn​≤n​ ，那么整个题目就可以做到 O(nn)O(n \sqrt{n})O(nn​)。
根号平衡思想，是平衡规划思想中重要的内容，例如空间平衡，时间平衡，根号滚动数组，都可以用这种思想。
我们以一道例题引入：CF797E Array Queries
这种操作我们发现没有什么很好的性质来维护，因为 apa_{p}ap​ 和变化的 ppp 是有关的。这两个关系是相互制约的，如果我们只关注一个肯定是不行的。怎么办？
首先我们先想暴力，我们有两种想法：

预处理所有 p,kp,kp,k 的答案。
暴力模拟。

第一个虽然可以 O(1)O(1)O(1) 回答但是预处理时间空间复杂度 O(nk)O(nk)O(nk) 无法承受，而暴力算法时间复杂度一次是 O(nk)O(\dfrac{n}{k})O(kn​)，是无法承受的。
我们怎么平衡这一算法呢，通过基本不等式 k+nk≥2b×nk=2nk+\dfrac{n}{k}\ge 2\sqrt{b\times \dfrac{n}{k}}=2\sqrt{n}k+kn​≥2b×kn​​=2n​， 当 k=nk=\sqrt{n}k=n​ 是取等号。也就是我们当 k≤nk\le \sqrt{n}k≤n​，我们可以使用预处理的答案，空间是 O(nn)O(n\sqrt{n})O(nn​)，而 k&gt;nk&gt;\sqrt{n}k&gt;n​ 的时候我们暴力模拟即可。故时间空间复杂度为 O(nn)O(n\sqrt{n})O(nn​)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e5+15,MB=300;int n,m,a[MN],f[MB+15][MN];int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;=MB;i++)&#123;        for(int j=n;j&gt;=1;j--)&#123;            f[i][j]=(j+a[j]+i&gt;n)?1:f[i][j+a[j]+i]+1;        &#125;    &#125;    cin&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int p,k,ans=0;        cin&gt;&gt;p&gt;&gt;k;        if(k&gt;=MB)&#123;            while(p&lt;=n)&#123;                ans++;                p+=a[p]+k;            &#125;        &#125;else ans=f[k][p];        cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
我们简单回顾一下这道题，我们通过将两种看似暴力的算法结合起来，形成了一个时间复杂度为 O(nn)O(n\sqrt{n})O(nn​) 的高效的算法，相互制约的关系我们很难用常规的数据结构进行处理，因为只关心一个的话另一个就会制约你的复杂度。这个时候我们利用平衡规划思想，我们通过制约关系设计出两种算法：O(nk)O(nk)O(nk) 与 O(n2k)O(\dfrac{n^2}{k})O(kn2​) 的算法，但是我们通过基本不等式算出分界点，通过这个分界点来进行所谓的 “分治”，数据小的跑预处理，大的进行暴力。
这一类思想，就是根号分治的思想，平衡规划。而一般制约关系，或同时涉及两个集合的关系，如果没有特殊性质，基本不能 polylog\text{polylog}polylog 去做，但是我们通过根号分治就可以做。
接下来我们来看几道例题：
 2. 例题
 CF1039D You Are Given a Tree
先考虑 O(n2)O(n^2)O(n2) 的情况下怎么做，也就是说我们枚举 kkk，让后一次查询必须是 O(n)O(n)O(n)。有一个想法就是暴力贪心，从叶子向根合并，搜到长为 kkk 的链直接取，证明考虑反证法即可。
让后考虑如何优化，由样例手摸不难发现几个特性：

答案随 kkk 的增大单调不升。
答案不超过 ⌊nk⌋\lfloor \dfrac{n}{k} \rfloor⌊kn​⌋。

答案不超过 ⌊nk⌋\lfloor \dfrac{n}{k} \rfloor⌊kn​⌋？那么我们能不能从这里下手呢？由基本不等式可以得到答案不超过 2n2\sqrt{n}2n​，不难想到 2n&lt;n2\sqrt{n}&lt; n2n​&lt;n，那么也就是说答案是重复的，进一步推广，当 k&gt;nk&gt;\sqrt{n}k&gt;n​ 的时候答案取值是很少的，而 k≤nk\le \sqrt{n}k≤n​ 的答案取值是较多的。哎，一会多，一会少，平衡规划？出动！我们对 k≤nk\le \sqrt{n}k≤n​ 直接做是 O(nn)O(n\sqrt{n})O(nn​)。考虑 k&gt;nk&gt;\sqrt{n}k&gt;n​ 的答案是连续是连续的一段，并且答案具有优秀的单调不升的特性，我们可以通过二分找出下一个答案取值的区间，我们只需要跑 O(n)O(\sqrt{n})O(n​) 次就可以了，时间复杂度是 O(nnlog⁡n)O(n\sqrt{n} \log n)O(nn​logn)。
你说得对，但是我学过基本不等式，上面的操作都是假设块长为 n\sqrt{n}n​，我们考虑基本不等式，设分治阈值为 BBB，那么第一块是 nBnBnB，第二块是 n2log⁡nB\dfrac{n^2 \log n}{B}Bn2logn​，由基本不等式有 B=nlog⁡nB=\sqrt{n\log n}B=nlogn​ 时取最优时间。
代码如下：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,bl,fa[MN],ans[MN],f[MN],dfn[MN],dtot;vector&lt;int&gt; adj[MN];void dfs(int u,int pre)&#123;    fa[u]=pre;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs(v,u);    &#125;    dfn[++dtot]=u;&#125;int solve(int k)&#123;    int ret=0;    for(int i=1;i&lt;=n;i++) f[i]=1;    for(int i=1;i&lt;=n;i++)&#123;        int u=dfn[i],pre=fa[u];        if(pre&amp;&amp;f[u]!=-1&amp;&amp;f[pre]!=-1)&#123;            if(f[u]+f[pre]&gt;=k)&#123;                ret++;                f[pre]=-1;            &#125;else f[pre]=max(f[pre],f[u]+1);        &#125;    &#125;    return ret;&#125;int main()&#123;    cin&gt;&gt;n;    bl=sqrt(n*__lg(n));    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    dfs(1,0);    ans[1]=n;    for(int i=2;i&lt;=bl;i++)&#123;        ans[i]=solve(i);    &#125;    for(int i=bl+1;i&lt;=n;i++)&#123;        int tmp=solve(i);        int l=i,r=n,cnt=i;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(solve(mid)==tmp)&#123;                cnt=max(cnt,mid);                l=mid;            &#125;else r=mid;        &#125;        for(;i&lt;=cnt;i++) ans[i]=tmp;        i--;    &#125;    for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 [IOI2009] Regions
完蛋啦，又是制约关系，同时涉及两个集合的关系，并且颜色点数与总颜色数相互制约如果我们都考虑显然是不行的。根据我们前面提到的，我们考虑一下根号分治如何去做。
有两个暴力的想法：

分别枚举两个颜色中所有点，利用 DFN 判定是不是在子树内。
将一个颜色所有点加入数据结构，让后枚举另一个颜色所有点，看有多少点在当前子树。

第一个想法时间复杂度 O(n2)O(n^2)O(n2)，第二个空间复杂度时 O(n2)O(n^2)O(n2) 但是时间很好。并且我们前面提到了制约关系，考虑根号分治，我们确定一个阈值 BBB，颜色点数 &gt;B&gt;B&gt;B 的我们称之为重颜色，而 ≤B\le B≤B 的我们称之为轻颜色（对应重儿子和轻儿子 www），考虑分类讨论。

重颜色作为祖先节点：考虑预处理答案，时间复杂度容易做到 O(nnlog⁡n)O(n\sqrt{n \log n})O(nnlogn​)，空间 O(nn)O(n\sqrt{n})O(nn​)。
轻颜色作为祖先节点：枚举轻颜色所有点，考虑对于每一个颜色开 vector 按 DFN 将所有点排序，根据 DFN 顺序判断是否在子树即可，利用二分找边界即可。时间复杂度 O(nnlog⁡n)O(n\sqrt{n \log n})O(nnlogn​)。

故总时间复杂度 O(nnlog⁡n)O(n\sqrt{n \log n})O(nnlogn​)，空间复杂度 O(nn)O(n\sqrt{n})O(nn​)。
至于为什么我用 DFN，答案是因为一开始我想的虚树，这和我说的加数据结构其实差不太多，因为虚树本身也算一种数据结构吗 www。当然每一次建虚树不如用 DFN 好写啦。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e5+15,ML=30,MK=2.5e4+15;int n,r,q,ccnt[MN],fid[MN],id[MN],cf[MN],MB;int ans[520][MK];vector&lt;int&gt; adj[MN],col[MN],dcol[MN];namespace Tree&#123;    int dfn[MN],siz[MN],dtot;    void dfs(int u,int pre)&#123;        dfn[u]=++dtot;        siz[u]=1;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs(v,u);            siz[u]+=siz[v];        &#125;    &#125;    int cmpdfn(int x,int y)&#123;        return dfn[x]&lt;dfn[y];    &#125;&#125;using namespace Tree;bool cmp(int x,int y)&#123;    return ccnt[x]&gt;ccnt[y];&#125;signed main()&#123;    ios::sync_with_stdio(0);    cin&gt;&gt;n&gt;&gt;r&gt;&gt;q;    MB=sqrt(n*__lg(n)*2);    for(int i=1;i&lt;=n;i++)&#123;        int fa,color;        if(i!=1)&#123;            cin&gt;&gt;fa;            adj[fa].push_back(i);        &#125;        cin&gt;&gt;color;        col[color].push_back(i);        ccnt[color]++;    &#125;    for(int i=1;i&lt;=r;i++) id[i]=i;    sort(id+1,id+1+r,cmp);    dfs(1,0);    for(int i=1;i&lt;=r;i++)&#123;        fid[id[i]]=i;        for(auto p:col[i]) dcol[i].push_back(dfn[p]);        sort(dcol[i].begin(),dcol[i].end());    &#125;    for(int i=1;i&lt;=r&amp;&amp;ccnt[id[i]]&gt;=MB;i++)&#123;        for(int i=1;i&lt;=n+1;i++) cf[i]=0;        for(auto p:col[id[i]])&#123;            cf[dfn[p]]++;            cf[dfn[p]+siz[p]]--;        &#125;        for(int i=1;i&lt;=n+1;i++)&#123;            cf[i]+=cf[i-1];        &#125;        for(int j=1;j&lt;=r;j++)&#123;            for(auto p:col[j])&#123;                ans[i][j]+=cf[dfn[p]];            &#125;        &#125;    &#125;    while(q--)&#123;        int x,y;        cin&gt;&gt;x&gt;&gt;y;        if(ccnt[x]&lt;MB)&#123;            long long ret=0;            for(auto p:col[x])&#123;                ret+=upper_bound(dcol[y].begin(),dcol[y].end(),dfn[p]+siz[p]-1)-lower_bound(dcol[y].begin(),dcol[y].end(),dfn[p]);            &#125;            cout&lt;&lt;ret&lt;&lt;endl;        &#125;else cout&lt;&lt;ans[fid[x]][y]&lt;&lt;endl;    &#125;        return 0;&#125;
 [JRKSJ R2] 你的名字
这种复杂的取模操作，我们一般会利用根号分治来解决这一类问题。
模数不是给定的，这种情况下很难搞，因为我们直接维护模数不固定的数据时很难搞的。
首先，静态区间询问考虑莫队，注意到给出了一个 k&gt;103k&gt;10^3k&gt;103 的包。考虑在 kkk 很大的情况下取模所构成的循环节长度很长，并且值域只有 10510^5105，我们可以通过利用 bitset 来暴力跑循环节，时间复杂度为 O(nm+maω+mak)O(n\sqrt{m}+\dfrac{ma}{\omega}+\dfrac{ma}{k})O(nm​+ωma​+kma​)，实现用 find_first 可以偷懒循环节。
但是 kkk 很小不能这么做，但是我们发现 kkk 很小的时候是一个取模数列的 RMQ 啊，可以暴力预处理 kkk 做四毛子（用传统 ST 表会炸杠）。
但是过不了，考虑若 kkk 的询问数量很小，我们还不如和 k≥Bk\ge Bk≥B 的询问一起处理，这样省下暴力计算的时间。我们可以通过确定一些平衡因子让其自适应数据，这样就能卡过了 www，具体如何操作可以看 meyi 的题解。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=3e5+15,MB=1e5+15;struct Query&#123;    int l,r,K,id;&#125;;int n,m,bl,a[MN],b[MN],ans[MN],cnt[MN];bitset&lt;MB&gt; f;vector&lt;Query&gt; qry[MN];namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;bool mdcmp(Query x,Query y)&#123;    if(x.l/bl==y.l/bl)&#123;        if((x.l/bl)&amp;1) return x.r&lt;y.r;        return x.r&gt;y.r;    &#125;    return x.l/bl&lt;y.l/bl;&#125;signed main()&#123;    read(n,m);    for(int i=1;i&lt;=n;i++)&#123;        read(a[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,k;        read(l,r,k);        qry[k].push_back(&#123;l,r,k,i&#125;);    &#125;    for(int i=2;i&lt;MN;i++)&#123;        if(qry[i].empty()) continue;        if(min(MB/i,MB&gt;&gt;6)*qry[i].size()&lt;(n&lt;&lt;2))&#123;            qry[0].insert(qry[0].end(),qry[i].begin(),qry[i].end());            continue;        &#125;        bl=n/sqrt(qry[i].size()+1)+1;        for(int j=1;j&lt;=n;j++)&#123;            b[j]=a[j]%i;        &#125;        sort(qry[i].begin(),qry[i].end(),mdcmp);        int l=1,r=0;        for(auto p:qry[i])&#123;			while(l&gt;p.l) (!cnt[b[--l]]++)&amp;&amp;(f[b[l]]=1);			while(r&lt;p.r) (!cnt[b[++r]]++)&amp;&amp;(f[b[r]]=1);			while(l&lt;p.l) (!--cnt[b[l]])&amp;&amp;(f[b[l]]=0),++l;			while(r&gt;p.r) (!--cnt[b[r]])&amp;&amp;(f[b[r]]=0),--r;            for(int k=0;k&lt;i;k++)&#123;                if(f[k])&#123;                    ans[p.id]=k;                    break;                &#125;            &#125;        &#125;        f.reset();        memset(cnt,0,sizeof(cnt));    &#125;    if(!qry[0].empty())&#123;        bl=n/sqrt(qry[0].size()+1)+1;        sort(qry[0].begin(),qry[0].end(),mdcmp);        int l=1,r=0;        for(auto p:qry[0])&#123;			while(l&gt;p.l) (!cnt[a[--l]]++)&amp;&amp;(f[a[l]]=1);			while(r&lt;p.r) (!cnt[a[++r]]++)&amp;&amp;(f[a[r]]=1);			while(l&lt;p.l) (!--cnt[a[l]])&amp;&amp;(f[a[l]]=0),++l;			while(r&gt;p.r) (!--cnt[a[r]])&amp;&amp;(f[a[r]]=0),--r;            ans[p.id]=1e9;			for(int k=f._Find_first(); ans[p.id]&amp;&amp;k!=f.size(); k=(k/p.K+1)*p.K-1&gt;=f.size()?f.size():f._Find_next((k/p.K+1)*p.K-1)) 				(ans[p.id]&gt;k%p.K)&amp;&amp;(ans[p.id]=k%p.K);        &#125;    &#125;    for(int i=1;i&lt;=m;i++) put(ans[i]);    return 0;&#125;
 [Ynoi2008] rplexq
我们要求的值就是 xxx 子树内 [l,r][l,r][l,r] 点个数的平法减去每个儿子子树内 [l,r][l,r][l,r] 点个数的平方，让后整体除二，即子树两两配对即可。
但是暴力做是 O(n2)O(n^2)O(n2) 的，无法接受，考虑如何优化，注意到瓶颈在枚举儿子的子树。我们从儿子下手，根号分治，对于每个节点按照儿子格式分成 &gt;n&gt;\sqrt{n}&gt;n​ 和 ≤n\le \sqrt{n}≤n​ 两组。
小于 n\sqrt{n}n​ 的我们可以把区间拆成二维数点来动态加点进行维护，这样的点数是 O(n)O(n)O(n) 个，询问时 O(mn)O(m\sqrt{n})O(mn​)，考虑复杂度平衡，我们可以利用分块前缀和的方式进行维护，单点修改时 O(n)O(\sqrt{n})O(n​)，而查询 O(1)O(1)O(1)。时间复杂度 O((n+m)n)O((n+m)\sqrt{n})O((n+m)n​)，但空间是 O(mn)O(m\sqrt{n})O(mn​) 的。注意到同一个点上每个询问的询问区间相同，我们 O(n)O(n)O(n) 的存下每个子树区间扫描线，扫描到一点 xxx 在将询问进行二维数点。
而大于 n\sqrt{n}n​ 这么做直接复杂度螺旋式爆炸上天，考虑涉及另一个算法，我们发现在一个区间的点可以类比于颜色，那么问题就是统计 [l,r][l,r][l,r] 编号内的颜色平方和，考虑对每一个点建立离散化莫队，时间复杂度 O(nm)O(n\sqrt{m})O(nm​)，最终时间复杂度可以平衡到 O(nn+nm+qn)O(n\sqrt{n}+n\sqrt{m}+q\sqrt{n})O(nn​+nm​+qn​)。
但是可怕的是我没卡过，54 pt 代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e5+100,MB=100,MBL=500;struct Query&#123;    int l,r,id;    ll op;&#125;tqry[MN];int n,m,rt,R[MN],tmp[MN],dg[MN],pos[MN],bl;ll ans1,ans2,ans3[MN],sum[MN],cnt[MN],ans[MN];bool vis[MN];vector&lt;int&gt; adj[MN];vector&lt;Query&gt; qry[MN];namespace Tree&#123;    int siz[MN],fa[MN],dfn[MN],dtot;    pir a[MN];        void dfs1(int u,int pre)&#123;        siz[u]=1;        fa[u]=pre;        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs1(v,u);            siz[u]+=siz[v];        &#125;    &#125;    void dfs2(int u,int pre)&#123;        dfn[++dtot]=u;        a[dtot]=pir(u,pre);        for(auto v:adj[u])&#123;            if(v==pre) continue;            dfs2(v,u);        &#125;    &#125;&#125;using namespace Tree;bool cmpsiz(int x,int y)&#123;    return siz[x]&gt;siz[y];&#125;bool cmpmd(Query x,Query y)&#123;    if(pos[x.l]!=pos[y.l]) return pos[x.l]&lt;pos[y.l];    return (pos[x.l]&amp;1)?x.r&lt;y.r:x.r&gt;y.r;&#125;void add(int x,ll op)&#123;    ans1+=1ll*1+cnt[x]*2*op;    cnt[x]+=op;    ans2+=op;&#125;ll query(int x)&#123;    return (x?(R[x]==x?sum[pos[x]]:sum[pos[x]-1]+cnt[x]):0);&#125;void update(int x)&#123;    for(int i=pos[x];i&lt;=pos[n];i++)&#123;        sum[i]++;    &#125;    for(int i=x;i&lt;=R[x];i++) cnt[i]++;&#125;void solve1(int x)&#123;    if(qry[x].empty()) return;    int tmptot=0;    for(auto v:adj[x])&#123;        if(v==fa[x]) continue;        tmp[++tmptot]=v;    &#125;    sort(tmp+1,tmp+1+tmptot,cmpsiz);    dtot=0;    for(int i=MB+1;i&lt;=tmptot;i++)&#123;        dfs2(tmp[i],tmp[i]);        vis[tmp[i]]=1;    &#125;    sort(a+1,a+1+dtot);    sort(dfn+1,dfn+1+dtot);    for(int i=0;i&lt;qry[x].size();i++)&#123;        int ql=lower_bound(dfn+1,dfn+1+dtot,qry[x][i].l)-dfn;        int qr=upper_bound(dfn+1,dfn+1+dtot,qry[x][i].r)-dfn-1;        tqry[i+1]=&#123;ql,qr,qry[x][i].id&#125;;    &#125;    int l=1,r=0,bl=dtot/sqrt(qry[x].size())+1;    for(int i=1;i&lt;=dtot;i++)&#123;        pos[i]=(i+bl-1)/bl;    &#125;    sort(tqry+1,tqry+1+qry[x].size(),cmpmd);    ans1=ans2=0;    for(int i=1;i&lt;=qry[x].size();i++)&#123;        if(tqry[i].l&gt;dtot||tqry[i].r&lt;1) continue;        while(l&lt;tqry[i].l) add(a[l++].second,-1);        while(l&gt;tqry[i].l) add(a[--l].second,1);        while(r&lt;tqry[i].r) add(a[++r].second,1);        while(r&gt;tqry[i].r) add(a[r--].second,-1);        ans[tqry[i].id]-=ans1;        ans3[tqry[i].id]+=ans2;    &#125;&#125;void solve2(int x)&#123;    if(!vis[x]&amp;&amp;fa[x]&amp;&amp;!qry[fa[x]].empty())&#123;        for(int i=0;i&lt;qry[fa[x]].size();i++)&#123;            qry[fa[x]][i].op=query(qry[fa[x]][i].r)-query(qry[fa[x]][i].l-1);        &#125;    &#125;    update(x);    for(auto v:adj[x])&#123;        if(v==fa[x]) continue;        solve2(v);    &#125;    if(!vis[x]&amp;&amp;fa[x]&amp;&amp;!qry[fa[x]].empty())&#123;        for(int i=0;i&lt;qry[fa[x]].size();i++)&#123;            ll qwq=query(qry[fa[x]][i].r)-query(qry[fa[x]][i].l-1)-qry[fa[x]][i].op;            ans[qry[fa[x]][i].id]-=qwq*qwq;            ans3[qry[fa[x]][i].id]+=qwq;        &#125;    &#125;    for(int i=0;i&lt;qry[x].size();i++)&#123;        if(qry[x][i].l&lt;=x&amp;&amp;x&lt;=qry[x][i].r)&#123;            ans[qry[x][i].id]+=ans3[qry[x][i].id]*2;        &#125;    &#125;&#125;signed main()&#123;    read(n,m,rt);    for(int i=1;i&lt;n;i++)&#123;        int u,v;        read(u,v);        adj[u].push_back(v);        adj[v].push_back(u);        dg[u]++,dg[v]++;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,x;        read(l,r,x);        qry[x].push_back(&#123;l,r,i,0&#125;);    &#125;    dfs1(rt,0);    for(int i=1;i&lt;=n;i++)&#123;        if(i!=rt) dg[i]--;        if(dg[i]&gt;MB)&#123;            solve1(i);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        pos[i]=(i+MBL-1)/MBL;        R[i]=min(n,pos[i]*MBL);    &#125;    memset(cnt,0,sizeof(cnt));    solve2(rt);    for(int i=1;i&lt;=m;i++)&#123;        put(((ans3[i]*ans3[i]+ans[i])&gt;&gt;1));    &#125;    return 0;&#125;
 P3591 [POI 2015] ODW
序列跳跃问题可以直接对后继的距离根号分治的。
一个显然的想法就是类似于倍增二分去模拟在树上走路（即倍增求树上 kkk 级祖先，也可以长链剖分做），但是这在 kkk 很大的情况下时可以的，但是 kkk 很小的情况是做不到的。具体来说，步数接近于 nk\dfrac{n}{k}kn​ 的范围附近。坏了又是 nk\dfrac{n}{k}kn​，我们考虑根号分治，设定阈值 BBB，&gt;B&gt;B&gt;B 当然就是我们树上 kkk 级祖先暴力跳，时间复杂度 O(nn)O(n\sqrt{n})O(nn​)。当 k≤Bk\le Bk≤B 的时候我们可以考虑暴力处理 sum(i,j)sum(i,j)sum(i,j) 表示 iii 往上每 jjj 级走一步的答案，查询可以树上差分即可。
时间复杂度 O(nnlog⁡n)O(n\sqrt{n} \log n)O(nn​logn)，预处理 O(nn)O(n\sqrt{n})O(nn​)。利用长链剖分可以做到 O(nlog⁡n+nn)O(n\log n+n\sqrt{n})O(nlogn+nn​)。
但是我写这篇文章的时候我还不会长链剖分？
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e4+15,MB=250;int n,a[MN],b[MN],c[MN],sum[MN],s[MB+5][MN],fa[32][MN],dep[MN];vector&lt;int&gt; adj[MN];void dfs1(int u,int pre)&#123;    dep[u]=dep[pre]+1;    fa[0][u]=pre;    sum[u]=sum[pre]+a[u];    for(int i=1;i&lt;=30;i++)&#123;        fa[i][u]=fa[i-1][fa[i-1][u]];    &#125;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs1(v,u);    &#125;&#125;void dfs2(int u,int pre)&#123;    int p=pre;    for(int i=2;i&lt;=MB;i++)&#123;        p=fa[0][p];        if(p==0) break;        s[i][u]=s[i][p]+a[u];    &#125;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs2(v,u);    &#125;&#125;int lca(int x,int y)&#123;    if(dep[x]&gt;dep[y])&#123;        swap(x,y);    &#125;    for(int i=30;i&gt;=0;i--)&#123;        if(fa[i][y]&amp;&amp;dep[fa[i][y]]&gt;=dep[x]) y=fa[i][y];    &#125;    if(x==y) return x;    for(int i=30;i&gt;=0;i--)&#123;        if(fa[i][x]!=fa[i][y])&#123;            x=fa[i][x],y=fa[i][y];        &#125;    &#125;    return fa[0][x];&#125;int getfa(int x,int k)&#123;    for(int i=30;i&gt;=0;i--)&#123;        if((k&gt;&gt;i)&amp;1) x=fa[i][x];    &#125;    return x;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i];    &#125;    for(int i=1;i&lt;n;i++) cin&gt;&gt;c[i];    dfs1(1,0);    dfs2(1,0);    for(int i=1;i&lt;n;i++)&#123;        int u=b[i],v=b[i+1],k=c[i];        int lcaa=lca(u,v);        if(k==1)&#123;            cout&lt;&lt;sum[u]+sum[v]-sum[lcaa]-sum[fa[0][lcaa]]&lt;&lt;&#x27;\n&#x27;;        &#125;        else if(k&lt;=MB)&#123;            int ans=s[k][u],dis=(dep[u]-dep[lcaa])%k;            if(dis==0) dis=k;            for(int i=30;i&gt;=0;i--)&#123;                if(fa[i][u]&amp;&amp;dep[fa[i][u]]-dep[lcaa]&gt;=dis) u=fa[i][u];            &#125;            ans+=a[u]-s[k][u];            if(dep[u]+dep[v]-(dep[lcaa]&lt;&lt;1)&gt;=k)&#123;                dis=k-dep[u]+dep[lcaa];                u=v;                for(int i=30;i&gt;=0;i--)&#123;                    if(fa[i][u]&amp;&amp;dep[fa[i][u]]-dep[lcaa]&gt;=dis) u=fa[i][u];                &#125;                dis=(dep[v]-dep[u])%k;                if(dis!=0) ans+=a[v];                v=getfa(v,dis);                ans+=s[k][v]-s[k][u]+a[u];            &#125;else ans+=a[v];            cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;        &#125;else&#123;            int ans=0;            while(dep[u]-dep[lcaa]&gt;k)&#123;                ans+=a[u];                u=getfa(u,k);            &#125;            ans+=a[u];            if(dep[u]+dep[v]-(dep[lcaa]&lt;&lt;1)&gt;=k)&#123;                int dis=k-dep[u]+dep[lcaa];                u=v;                for(int i=30;i&gt;=0;i--)&#123;                    if(fa[i][u]&amp;&amp;dep[fa[i][u]]-dep[lcaa]&gt;=dis) u=fa[i][u];                &#125;                dis=(dep[v]-dep[u])%k;                if(dis!=0) ans+=a[v];                v=getfa(v,dis);                while(dep[v]-dep[u]&gt;=k)&#123;                    ans+=a[v];                    v=getfa(v,k);                &#125;                ans+=a[v];            &#125;else ans+=a[v];            cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;
 [Ynoi2011] 初始化
如果你看了论文的话，这个就是第一题的双倍经验。
大多数的数据结构都适合连续区间的询问，但是不擅长这种间隔离散的询问，步数与项数相互制约关系，我们考虑根号分治，设定一个阈值 BBB，对于 &gt;B&gt;B&gt;B 的想法当然是暴力处理啦，但是 ≤B\le B≤B 很难受。
分析性质，我们每一次修改都是对整个序列进行修改，对于 x,yx,yx,y 相同的修改我们可以累加贡献，但是我们查询要对所有 xxx 的都进行一次查询，我们要做到单次 O(1)O(1)O(1)。考虑我们维护每个 x,yx,yx,y 的前缀后缀和，我们一次询问相当于把序列按 xxx 分块，我们借用 YLWang 的 P5309 题解的图片：

那么之间完整段会被所有含 xxx 的操作修改，而两端会被部分修改，询问同理，我们利用前面提到的前缀后缀即可快速维护即可。
#include&lt;bits/stdc++.h&gt;#define pos(x) ((x-1)/BL+1)using namespace std;constexpr int MN=2e5+5,MOD=1e9+7,BL=128;int n,m,bl,a[MN],sum[MN],L[MN],R[MN],pre[BL+15][BL+15],suf[BL+15][BL+15];inline void upd(int &amp;x)&#123;x+=x&gt;&gt;31&amp;MOD;&#125;void init()&#123;    bl=(n-1)/BL+1;    for(int i=1;i&lt;=bl;i++)&#123;        L[i]=(i-1)*BL+1;        R[i]=i*BL;    &#125;    R[bl]=n;    for(int i=1;i&lt;=bl;i++)&#123;        sum[i]=0;        for(int j=L[i];j&lt;=R[i];j++)&#123;            sum[i]+=a[j];            upd(sum[i]-=MOD);        &#125;    &#125;&#125;int query(int l,int r)&#123;    int ql=pos(l),qr=pos(r),ret=0;    if(ql==qr)&#123;        for(int i=l;i&lt;=r;i++)&#123;ret+=a[i];upd(ret-=MOD);&#125;        return ret;    &#125;    for(int i=l;i&lt;=R[ql];i++)&#123;ret+=a[i];upd(ret-=MOD);&#125;    for(int i=ql+1;i&lt;qr;i++)&#123;ret+=sum[i];upd(ret-=MOD);&#125;    for(int i=L[qr];i&lt;=r;i++)&#123;ret+=a[i];upd(ret-=MOD);&#125;    return ret;&#125;void add(int x,int y,int z)&#123;    z-=MOD;upd(z);    if(x&gt;=BL)&#123;        for(int i=y;i&lt;=n;i+=x)&#123;            a[i]+=z;upd(a[i]-=MOD);            sum[pos(i)]+=z;upd(sum[pos(i)]-=MOD);        &#125;    &#125;else&#123;        for(int i=x;i&gt;=y;i--)&#123;pre[x][i]+=z;upd(pre[x][i]-=MOD);&#125;        for(int i=1;i&lt;=y;i++)&#123;suf[x][i]+=z;upd(suf[x][i]-=MOD);&#125;    &#125;&#125;signed main()&#123;    read(n);read(m);    for(int i=1;i&lt;=n;i++)read(a[i]);    init();    while(m--)&#123;        int op,x,y,z,l,r;        read(op);        if(op==1)&#123;            read(x);read(y);read(z);            add(x,y,z);        &#125;else&#123;            read(l);read(r);            int ret=query(l,r);            for(int i=1;i&lt;BL;i++)&#123;                int blkL=(l-1)/i+1,blkR=(r-1)/i+1;                if(blkL==blkR)&#123;                    ret+=pre[i][(r-1)%i+1];upd(ret-=MOD);                    ret-=pre[i][(l-1)%i];upd(ret);                &#125;else&#123;                    ret+=(blkR-blkL-1LL)*pre[i][i]%MOD;upd(ret-=MOD);                    ret+=pre[i][(r-1)%i+1];upd(ret-=MOD);                    ret+=suf[i][(l-1)%i+1];upd(ret-=MOD);                &#125;            &#125;            put(ret);        &#125;    &#125;    return 0;&#125;
 CF1056H Detect Robots
令 s=∑lens=\sum\limits lens=∑len。
考虑我们答案到底是怎么算的，其实就是枚举一个串两个字符 A→C→⋯→BA\to C \to \dots \to BA→C→⋯→B，如果之前出现过 A→D→⋯→BA \to D \to \dots \to BA→D→⋯→B 的路径，检查 CCC 是否等于 DDD 即可，若不等于输出 Human。一个显然的想法就是枚举 A,BA,BA,B 轻松 O(s3)O(s^3)O(s3)，但是我们可以只需要枚举一个，比如枚举 BBB 让后拓展即可，这样的时间复杂度 O(s2)O(s^2)O(s2)。如果 sss 过大直接就爆炸了，考虑一个关键性质：数据范围 3×1053 \times 10^53×105，考虑到长为 kkk 的路径最多有 nk\dfrac{n}{k}kn​ 个，考虑根号分治，按串长分治。小串对小串暴力即可。
大串我们可以暴力枚举，记 posipos_{i}posi​ 表示 iii 在大串中的位置，对于其他串从后往前扫，判断当前字母的 pos&lt;mxposipos&lt;mxpos_{i}pos&lt;mxposi​ 是否成立即可，时间复杂度 O(ss)O(s\sqrt{s})O(ss​)。
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=1e6+15;int T,n,m,B,pos[MN],vis[MN];vector&lt;int&gt; a[MN];vector&lt;pir&gt; v[MN];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        v[i].clear();        vis[i]=pos[i]=0;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        a[i].clear();        int K;        cin&gt;&gt;K;        for(int j=1;j&lt;=K;j++)&#123;            int x;            cin&gt;&gt;x;            a[i].push_back(x);        &#125;        if(a[i].size()&lt;=B)&#123;            for(int j=0;j&lt;a[i].size();j++)&#123;                for(int k=j+1;k&lt;a[i].size();k++)&#123;                    v[a[i][k]].push_back(pir(a[i][j],a[i][j+1]));                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=m;i++)&#123;        if(a[i].size()&lt;=B) continue;        for(int j=1;j&lt;=n;j++) pos[j]=-1;        for(int j=0;j&lt;a[i].size();j++) pos[a[i][j]]=j;        for(int j=i+1;j&lt;=m;j++)&#123;            int r=-1;            for(int k=a[j].size()-1;k&gt;=0;k--)&#123;                if(pos[a[j][k]]==-1) continue;                if(pos[a[j][k]]&gt;r)&#123;                    r=pos[a[j][k]];                &#125;                else if(a[j][k+1]!=a[i][pos[a[j][k]]+1])&#123;                    cout&lt;&lt;&quot;Human\n&quot;;                    return;                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(auto p:v[i])&#123;            if(vis[p.first]&amp;&amp;vis[p.first]!=p.second)&#123;                cout&lt;&lt;&quot;Human\n&quot;;                return;            &#125;            vis[p.first]=p.second;        &#125;        for(auto p:v[i]) vis[p.first]=0;    &#125;    cout&lt;&lt;&quot;Robot\n&quot;;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    B=sqrt(300000)/2;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 CF587F Duff is Mad
暴力的想法就是重新建 AC 自动机，不得不承认这个想法及其糟糕。
考虑直接对所有串建立 AC 自动机，那么答案就是将 s∈[l,r]s\in [l,r]s∈[l,r] 上串对应 Fail 树上的权值加一后求权值和，考虑离线下来加根号分治，阈值为 BBB，对于 ∣Sk∣&gt;B|S_k|&gt;B∣Sk​∣&gt;B 的考虑将每个串询问做差，顺序扫过即可，时间复杂度 O(nn)O(n\sqrt{n})O(nn​)。
对于 ∣Sk∣≤B|S_{k}| \le B∣Sk​∣≤B 考虑扫描线，扫到一个串就权值加一，让后暴力查询即可，其实这两个操作都是在 DFS 序上区间加单点查，树状数组即可，时间房租啊都 O(nlog⁡m+QTlog⁡m)O(n \log m+QT\log m)O(nlogm+QTlogm)。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int N=1e5+7;int n,q,sumlen,MB,ans[N];string s[N];vector&lt;int&gt; adj[N];vector&lt;pir&gt; L1[N],R1[N],L2[N],R2[N];struct BIT&#123;    int t[N];    int lowbit(int x)&#123;        return x&amp;-x;    &#125;    void modify(int x,int k)&#123;        while(x&lt;N)&#123;            t[x]+=k;            x+=lowbit(x);        &#125;    &#125;    int query(int x)&#123;        int ret=0;        while(x)&#123;            ret+=t[x];            x-=lowbit(x);        &#125;        return ret;    &#125;&#125;bit;namespace ACAuto&#123;    int trie[N][26],fail[N],fa[N],ed[N],tot=1;    int sum[N],siz[N],dfn[N],dtot;    void insert(string s,int id)&#123;        int p=1;        for(auto c:s)&#123;            int k=c-&#x27;a&#x27;;            if(!trie[p][k]) trie[p][k]=++tot,fa[tot]=p;            p=trie[p][k];        &#125;        ed[id]=p;    &#125;    void build()&#123;        queue&lt;int&gt; q;        for(int i=0;i&lt;26;i++)&#123;            if(trie[1][i]) fail[trie[1][i]]=1,q.push(trie[1][i]);            else trie[1][i]=1;        &#125;        while(!q.empty())&#123;            int x=q.front();            q.pop();            for(int i=0;i&lt;26;i++)&#123;                if(trie[x][i])                    fail[trie[x][i]]=trie[fail[x]][i],q.push(trie[x][i]);                else trie[x][i]=trie[fail[x]][i];            &#125;        &#125;        for(int i=2;i&lt;=tot;i++) adj[fail[i]].push_back(i);    &#125;    void dfs1(int u)&#123;        for(auto v:adj[u])&#123;            dfs1(v);            sum[u]+=sum[v];        &#125;    &#125;    void dfs2(int u)&#123;        siz[u]=1;        dfn[u]=++dtot;        for(auto v:adj[u])&#123;            dfs2(v);            siz[u]+=siz[v];        &#125;    &#125;&#125;using namespace ACAuto;signed main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;s[i];        sumlen+=s[i].length();        insert(s[i],i);    &#125;    build();    MB=sumlen/sqrt(q*log2(sumlen));        for(int i=1;i&lt;=q;i++)&#123;        int l,r,k;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        if(s[k].length()&gt;MB)&#123;            L1[k].emplace_back(l,i);            R1[k].emplace_back(r,i);        &#125;else&#123;            L2[l].emplace_back(k,i);            R2[r].emplace_back(k,i);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(s[i].length()&gt;MB)&#123;            int p=ed[i];            while(p!=1) sum[p]=1,p=fa[p];            dfs1(1);            sort(L1[i].begin(),L1[i].end());            sort(R1[i].begin(),R1[i].end());            reverse(L1[i].begin(),L1[i].end());            reverse(R1[i].begin(),R1[i].end());            int tmp=0;            for(int j=1;j&lt;=n;j++)&#123;                while(L1[i].size()&amp;&amp;L1[i].back().first==j)&#123;                    ans[L1[i].back().second]-=tmp;                    L1[i].pop_back();                &#125;                tmp+=sum[ed[j]];                while(R1[i].size()&amp;&amp;R1[i].back().first==j)&#123;                    ans[R1[i].back().second]+=tmp;                    R1[i].pop_back();                &#125;            &#125;            for(int i=2;i&lt;=tot;i++) sum[i]=0;        &#125;    &#125;    dfs2(1);    for(int i=1;i&lt;=n;i++)&#123;        for(auto [k,id]:L2[i])&#123;            int p=ed[k];            while(p!=1) ans[id]-=bit.query(dfn[p]),p=fa[p];        &#125;        bit.modify(dfn[ed[i]],1);        bit.modify(dfn[ed[i]]+siz[ed[i]],-1);        for(auto [k,id]:R2[i])&#123;            int p=ed[k];            while(p!=1) ans[id]+=bit.query(dfn[p]),p=fa[p];        &#125;    &#125;    for(int i=1;i&lt;=q;i++) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
 3. 后言
根号分治，做那么多题其实就是根号平衡时空复杂度。注意分治后的情况下具有的性质，同时对次数分类讨论就可以了。
 4. 参考

zxy的思维技巧 - C202044zxy
分治与根号算法 - qAlex_Weiq - 博客园
Hanx16Kira 的 P5901 题解
根号算法_不只是分块——2014国家集训队 王悦同
暴力美学——浅谈根号分治 - 洛谷专栏
YLWang 的 P5309 题解

]]></content>
      <categories>
        <category>离线</category>
      </categories>
      <tags>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>浅学竞赛图</title>
    <url>/posts/e9f975f5/</url>
    <content><![CDATA[ 1. 定义
竞赛图，即任意两点之前有且仅有一条边的有向图。即有向完全图，有 (n2)\dbinom{n}{2}(2n​) 条边。
至于为什么叫竞赛图，就是赢得点向输的点连边，一个边代表的是胜负关系。
 2. 性质
 兰道定理（竞赛图判定）
我们定义比分序列为将每个点的出度 sis_{i}si​ 从小到大排序的序列。
那么若满足 ∑i=1ksi≥(k2)\sum\limits_{i=1}^k s_{i}\ge \dbinom{k}{2}i=1∑k​si​≥(2k​) 且当 k=nk=nk=n 时取等（即 ∑s=(n2)\sum\limits s=\dbinom{n}{2}∑s=(2n​)），则一定能够造出一种竞赛图，反之不能。
必要性显然，考虑充分性证明，我们构造初始图，对于 j&lt;ij&lt;ij&lt;i 则 i→ji\to ji→j 连边，设此时比分序列为 aaa，这个序列显然在上述条件能够取到等号。保持 ∑i=1kai≤∑i=1ksi\sum\limits_{i=1}^k a_{i}\le \sum\limits_{i=1}^k s_{i}i=1∑k​ai​≤i=1∑k​si​，不断调整图直到 a=sa=sa=s。
未构造完成时开头必然是一段等于后面接一个 al&lt;sla_{l}&lt;s_{l}al​&lt;sl​，为了让后面的方法修改后使得 aaa 仍然有序，我们找到最后一个 al=aua_{l}=a_{u}al​=au​ 的 uuu，显然有 au&lt;sua_{u}&lt;s_{u}au​&lt;su​。因为总和固定，必然能找到第一个 vvv 使得 av&gt;sva_{v}&gt;s_{v}av​&gt;sv​。
此时有 au&lt;su≤sv&lt;ava_{u}&lt;s_{u}\le s_{v}&lt;a_{v}au​&lt;su​≤sv​&lt;av​，有 av≥au+2a_{v}\ge a_{u}+2av​≥au​+2。
当 ∃v→u\exists v \to u∃v→u，考虑翻转这条边，否则必然存在 ppp 使得 v→p→uv \to p \to uv→p→u，那么把路径反转。因为 au&lt;su,ai≤si,∀i∈(u,v)a_{u}&lt;s_{u},a_{i}\le s_{i},\forall i \in (u,v)au​&lt;su​,ai​≤si​,∀i∈(u,v)，不难证明反转后的序列仍然保持性质（∑a≤s\sum\limits a \le s∑a≤s）这样构造下去一定有解。
注意，这里定理都是存在，对于同一个比分序列可能对应本质不同的竞赛图。
 兰道定理实质
兰道定理的实质是在一个序列和一定时，可以对于任意两个有关系（边）的位置进行相等量的调整（si←si+v,sj←sj−vs_{i}\leftarrow s_{i}+v,s_{j}\leftarrow s_{j}-vsi​←si​+v,sj​←sj​−v），那么要判定任意一个值的序列是否与序列值的下界形式一样时，只需要判断是否每个前缀和都大于等于下界，以及最后的和与预期相等即可。证明考虑构造法不断调整。
 竞赛图强连通分量个数（推论）
即：
∑i=1n[∑j=1isj=(i2)]\sum\limits_{i=1}^n [\sum\limits_{j=1}^i 
s_{j}=\binom{i}{2}]i=1∑n​[j=1∑i​sj​=(2i​)]
其中 sss 还是比分序列。证明如下：
GGG 缩点后形成了一条链，拓扑序上靠后的强连通分量里节点的出度一定严格小于靠前的强连通分量里节点的出度。考察链上相邻两个强连通分量 S,TS, TS,T，不妨假设 SSS 在拓扑序上比 TTT 靠前。我们一定能找到一个唯一的 xxx，使得 p1p_1p1​ 到 pxp_xpx​ 一一对应着 TTT 以及在拓扑序上比 TTT 更靠后的强连通分量里节点的出度。显然，∑i=1xpi=(x2)\sum_{i=1}^x p_i = \binom{x}{2}∑i=1x​pi​=(2x​)，因此 ∑i=1n[∑j=1ipj=(i2)]\sum_{i=1}^n \left[ \sum_{j=1}^i p_j = \binom{i}{2} \right]∑i=1n​[∑j=1i​pj​=(2i​)] 不小于 GGG 的强连通分量个数。
同时，∀x∈[1,n−1]∩Z\forall x \in [1, n-1] \cap \mathbb{Z}∀x∈[1,n−1]∩Z，∑i=1xpi=(x2)\sum_{i=1}^x p_i = \binom{x}{2}∑i=1x​pi​=(2x​)，px+1p_{x+1}px+1​ 到 pnp_npn​ 对应的节点都向 p1p_1p1​ 到 pxp_xpx​ 对应的节点连边，所以 xxx 也唯一对应着链上相邻两个强连通分量的分界，因此 ∑i=1n[∑j=1ipj=(i2)]\sum_{i=1}^n \left[ \sum_{j=1}^i p_j = \binom{i}{2} \right]∑i=1n​[∑j=1i​pj​=(2i​)] 不大于 GGG 的强连通分量个数。考虑如果说一个强连通分量被分成了两半，如果后一半和后继的度数和等于 (n2)\binom{n}{2}(2n​) 的话说明后一半的出度达到了最小值，就不能向前一半有连边，所以前一半和后一半就缺少了构成强连通分量的桥梁，所以通过反证法不成立。
综上，∑i=1n[∑j=1ipj=(i2)]\sum_{i=1}^n \left[ \sum_{j=1}^i p_j = \binom{i}{2} \right]∑i=1n​[∑j=1i​pj​=(2i​)] 等于 GGG 的强连通分量个数。在求出出度序列后，通过桶排，我们可以 O(n)O(n)O(n) 求解一个 nnn 阶竞赛图的强连通分量个数。
 缩点后呈链状
这是一个很重要的性质，所有与环，SCC相关的问题都可以用这个性质解决。
即竞赛图强连通缩点后的 DAG 呈链状, 拓扑序小的点向所有拓扑序比它大的点连边，如下图。

证明考虑归纳，考虑一个一个加入连通块。目前假设有一条链，设插入的为块为 xxx。若 xxx 连向所有点，放头，若所有点连向 xxx，放尾。否则找分界点插到中间即可（如果不能查到中间的话会成环）。

 推论

若不存在位置 iii 满足如下条件，则为强连通图：

∑j=insi=(n−i+1)×(i−1)+(n−i+12)\sum\limits_{j=i}^n s_{i} =(n-i+1)\times (i-1)+\binom{n-i+1}{2}
j=i∑n​si​=(n−i+1)×(i−1)+(2n−i+1​)

在同一个SCC中在比分序列上是一个区间，根据比分序列可以完成拓扑排序。

利用拓扑序小的点向所有拓扑序比它大的点连边，从后向前扫，用一个和上面判断 SCC本质相同（只是左右端点不同）的式子判定即可。
 竞赛图存在一条哈密顿路径
证明，先缩点，如图构造：

 竞赛图任意一个 SCC 存在一条哈密顿回路
考虑归纳, 逐点加入目前有一条链, 链上的每个强连通块都存在哈密顿回路，插入一个新点 xxx，只需证明新图中的强连通块都存在哈密顿回路即可。如果不产生新连通块, 就是呈链中讨论的情况, 否则一定存在一条 xxx 的出边在 xxx 入边左边, 随便找一对
如果是连到不同连通块, 见左图.
如果是同一连通块, 必定存在符合环的走向的相邻的一入一出, 见右图.

强连通竞赛图也算整体一个 SCC，也就是强连通竞赛图有哈密顿回路。
 竞赛图若有环一定存在三元环
考虑找到任意一个环，讨论一下顺时针还是逆时针。
例如顺时针，考虑环中的边，若为逆，直接结束有三元环。若为顺向的边可以看做环少了因这条边存在而绕过的点。
始终不出现逆向的边，最后一条边处构成三元环。
 竞赛图的k&gt;=3个点的SCC中一定存在[3,k]元环
归纳法证明即可，作者懒了不证明了。
 3. 例题
 3.1 计数
 不知名题

求 nnn 个点的强连通竞赛图个数。

考虑容斥，设 f(i)f(i)f(i) 表示 iii 个点竞赛图个数，显然 f(i)=2i(i−1)2f(i)=2^{\frac{i(i-1)}{2}}f(i)=22i(i−1)​，设 g(i)g(i)g(i) 表示 iii 个点强连通竞赛图个数。
考虑转移，将图分成两部分，第一个部分是一个 SCC ，另外一个部分至少是一个 SCC ，枚举一个 jjj 个点的 SCC 进行转移。
g(i)=f(i)−∑j=1i−1g(j)×(ii−j)×f(i−j)g(i)=f(i)-\sum\limits_{j=1}^{i-1} g(j) \times \binom{i}{i-j}\times f(i-j)
g(i)=f(i)−j=1∑i−1​g(j)×(i−ji​)×f(i−j)
 CF850D Tournament Construction
mmm 及其小，而且值域很少，设一个图有 nnn 个点，则边数上界就是 30n30n30n，有 n(n−1)2≤30n\dfrac{n(n-1)}{2}\le 30n2n(n−1)​≤30n，解得 n≤61n\le 61n≤61。
用兰顿定理可以判断是否合法，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示能否用集合前 iii 个元素，构造出 jjj 个点 kkk 条边的图，转移方程有：
f(i,j,k)=f(i−1,j−1,k−am)or⁡f(i,j−1,k−am)f(i,j,k)=f(i-1,j-1,k-a_{m}) \operatorname{or} f(i,j-1,k-a_{m})
f(i,j,k)=f(i−1,j−1,k−am​)orf(i,j−1,k−am​)
让后考虑如何构造，发现可以发现一个竞赛图删除一个点以及它的所有边后仍然是一个竞赛图，那么避免冲突每次选择最小出度的点 更新边以及其他点的出度即可。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=80,MM=2520;int m,n=1,a[MN],ret[MM],tmp[MM],ans[MN][MN];bool f[MN][MN][MM];bool cmp(int x,int y)&#123;    return ret[x]&lt;ret[y];&#125;void dfs(int x,int y,int z)&#123;    if(!x) return;    ret[x]=a[y];    z-=a[y];    x--;    if(f[x][y][z]) dfs(x,y,z);    else dfs(x,y-1,z);&#125;void getans()&#123;    for(int i=1;i&lt;=n;i++) tmp[i]=i;    for(int i=1;i&lt;=n;i++)&#123;        sort(tmp+i,tmp+n+1,cmp);        for(int j=i+1;j&lt;=i+ret[tmp[i]];j++)&#123;            ans[tmp[i]][tmp[j]]=1;        &#125;        for(int j=i+ret[tmp[i]]+1;j&lt;=n;j++)&#123;            ans[tmp[j]][tmp[i]]=1;            ret[tmp[j]]--;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;a[i];    &#125;    sort(a+1,a+1+m);    f[1][1][a[1]]=1;    while(n&lt;62&amp;&amp;(n&lt;m||!f[n][m][n*(n-1)/2]))&#123;        n++;        for(int i=1;i&lt;=m;i++)&#123;            for(int j=(n-1)*(n-2)/2;j&lt;=(n-1)*a[m];j++)&#123;                if(f[n-1][i][j])&#123;                    f[n][i][j+a[i]]=1;                    if(i+1&lt;=m) f[n][i+1][j+a[i+1]]=1;                &#125;            &#125;        &#125;    &#125;    if(n&gt;61)&#123;        cout&lt;&lt;&quot;=(&quot;;        return 0;    &#125;    dfs(n,m,n*(n-1)/2);    getans();    cout&lt;&lt;n&lt;&lt;&#x27;\n&#x27;;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cout&lt;&lt;ans[i][j];        &#125;        cout&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 BZOJ 5219 最长路径 竞赛图组合计数

计数从 1 出发的最长简单路径经过点数恰好为 iii 的竞赛图个数。i∈[1,n],1≤n≤2000i\in [1,n],1\le n \le 2000i∈[1,n],1≤n≤2000

竞赛图有个很好的性质：一定存在一条哈密尔顿路径。
考虑设 f(i,j)f(i,j)f(i,j) 表示 iii 个点，最长路径为 jjj 的竞赛图数量。
显然有 f(i,i)f(i,i)f(i,i) 为强连通竞赛图，但是这里我们可以不用像上面不知名题求，就用容斥 f(i,i)=2i(i−1)2−∑j=1i−1f(i,j)f(i,i)=2^{\frac{i(i-1)}{2}}-\sum\limits_{j=1}^{i-1} f(i,j)f(i,i)=22i(i−1)​−j=1∑i−1​f(i,j) 即可。
考虑 f(i,1)f(i,1)f(i,1) 可以构造出所有 1 号点的边连向 1 号点即可，有 f(i,1)=2(i−1)(i−2)2f(i,1)=2^{\frac{(i-1)(i-2)}{2}}f(i,1)=22(i−1)(i−2)​。
那么剩下的怎么求，考虑将图划分为两个块，一个块是供 1 走的块，剩下的块不给 1 走，但是可能不存在不给 1 走的块。
那么有 f(i,j)=f(j,j)×(i−1j−1)×2(i−j)(i−j−1)2f(i,j)=f(j,j) \times \binom{i-1}{j-1} \times 2^{\frac{(i-j)(i-j-1)}{2}}f(i,j)=f(j,j)×(j−1i−1​)×22(i−j)(i−j−1)​，考虑 jjj 个点连通块的连边方式，让后要选点，在把剩下的连边即可。
时间复杂度 O(n2)O(n^2)O(n2)，但是可怕的是 BZOJ 挂了，有谁好心传个原题？
 CF913F
令 p=abp=\dfrac{a}{b}p=ba​。
考虑倒推答案，设 f(i)f(i)f(i) 表示 iii 个点的期望答案，g(i)g(i)g(i) 表示形成大小为 iii 的 SCC 概率，h(i,j)h(i,j)h(i,j) 表示 iii 个人打比赛，其中 jjj 个人被 (i−j)(i-j)(i−j) 个人打赢的概率。
最后一个 SCC 的大小，有：
f(i)=∑j=1ig(j)⋅h(i,j)⋅(f(j)+f(i−j)+(j2)+j(i−j))f(i)=\sum\limits_{j=1}^i g(j)\cdot h(i,j)\cdot(f(j)+f(i-j)+\binom{j}{2}+j(i-j))
f(i)=j=1∑i​g(j)⋅h(i,j)⋅(f(j)+f(i−j)+(2j​)+j(i−j))
但是 f(i)f(i)f(i) 会转移到自己，要解方程，这里不过多叙述。
考虑 gig_{i}gi​ 如何求，考虑只要图中没有点被其它点都吊打的情况它就是强联通图，那么转移：
g(i)=1−∑j=1i−1g(j)h(i,j)g(i)=1-\sum\limits_{j=1}^{i-1}g(j) h(i,j)
g(i)=1−j=1∑i−1​g(j)h(i,j)
考虑 hhh，对于新加入一个点，如果在 jjj 中那么输给 i−ji-ji−j，反之要赢 jjj 个点，那么有：
h(i,j)=(1−p)jh(i−1,j)+pi−jh(i−1,j−1)h(i,j)=(1-p)^j h(i-1,j)+p^{i-j}h(i-1,j-1)
h(i,j)=(1−p)jh(i−1,j)+pi−jh(i−1,j−1)
时间 O(n2)O(n^2)O(n2)。
 3.2 SCC 及其拓展
 CF1268D
两个结论：

对于 n≥4n\ge 4n≥4，nnn 阶强联通竞赛图具有 n−1n-1n−1 阶强联通子图。
对于 n≥7n\ge 7n≥7，nnn 阶竞赛图存在一种翻转方案使得只需要翻转一个结点就能让它强联通。

对于 n≤6n\le 6n≤6，暴力枚举翻转结点即可，对于 n&gt;6n&gt;6n&gt;6 考虑枚举每个位置翻转并检查就好了。我们可以用兰顿定理的推论（上面有讲）来快速判断是否强连通。
证明可以看其他题解：题解 CF1268D 【Invertation in Tournament】
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2520,MOD=998244353;int n,cf[MN],h[MN];bool mp[MN][MN];bool check()&#123;    sort(cf+1,cf+1+n);    for(int i=2;i&lt;=n;i++) cf[i]+=cf[i-1];    for(int i=1;i&lt;n;i++)&#123;        if(cf[i]==i*(i-1)/2) return 0;    &#125;    return 1;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            char c;            cin&gt;&gt;c;            mp[i][j]=c-&#x27;0&#x27;;            h[i]+=mp[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++) cf[i]=h[i];    if(check())&#123;        cout&lt;&lt;&quot;0 1&quot;;        return 0;    &#125;    int ret=0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++) cf[j]=h[j];         for(int j=1;j&lt;=n;j++)&#123;            cf[i]-=mp[i][j]*2-1;            cf[j]+=mp[i][j]*2-1;        &#125;        if(check()) ret++;    &#125;    if(ret)&#123;        cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;ret;        return 0;    &#125;    if(n==4) cout&lt;&lt;-1;    if(n==6) cout&lt;&lt;&quot;2 18&quot;;    return 0;&#125;
 P3561 [POI 2017] Turysta 
定理上面都讲完了，先缩点，然后对于每个强连通分量，求哈密顿回路。然后就可以对任意一个强连通分量任意点进，任意点出了。
怎么构造可以去看其他题解的构造。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=2e3+15;int n,tcnt,nxt[MN],a[MN][MN],in[MN],tpos[MN],pos[MN];vector&lt;int&gt; adj[MN],G[MN],dcc[MN],ans[MN];namespace Tarjan&#123;    int dfn[MN],low[MN],s[MN],col[MN],ctot,top,dtot;    bool vis[MN];    void tarjan(int u)&#123;        low[u]=dfn[u]=++dtot;        s[++top]=u;        vis[u]=1;        for(auto v:adj[u])&#123;            if(!dfn[v])&#123;                tarjan(v);                low[u]=min(low[u],low[v]);            &#125;else if(vis[v])&#123;                low[u]=min(low[u],dfn[v]);            &#125;        &#125;        if(low[u]==dfn[u])&#123;            ctot++;            int p;            do&#123;                p=s[top--];                col[p]=ctot;                vis[p]=0;            &#125;while(p!=u);        &#125;    &#125;&#125;using namespace Tarjan;void toposort()&#123;    queue&lt;int&gt; q;    for(int i=1;i&lt;=ctot;i++)&#123;        if(!in[i]) q.push(i);    &#125;    while(!q.empty())&#123;        int u=q.front();        q.pop();        tpos[++tcnt]=u;        pos[u]=tcnt;        for(auto v:G[u])&#123;            in[v]--;            if(!in[v]) q.push(v);        &#125;    &#125;&#125;void getham(int c)&#123;    if(dcc[c].size()==1) return;    int s=dcc[c][0],t=s;    for(int i=1;i&lt;dcc[c].size();i++)&#123;        int x=dcc[c][i];        if(a[t][x]) nxt[t]=x,t=x;        else if(a[x][s]) nxt[x]=s,s=x;        else&#123;            for(int j=s;j!=t;j=nxt[j])&#123;                if(a[j][x]&amp;&amp;a[x][nxt[j]])&#123;                    nxt[x]=nxt[j];                    nxt[j]=x;                    break;                &#125;            &#125;        &#125;    &#125;    t=0;    for(int i=nxt[s];i;i=nxt[i])&#123;        if(t)&#123;            if(a[i][s])&#123;                t=i;                continue;            &#125;            for(int j=s,k=nxt[s];j!=t;j=k,k=nxt[k])&#123;                if(a[i][k])&#123;                    nxt[j]=nxt[t];                    nxt[t]=s;                    s=k;                    t=i;                    break;                &#125;            &#125;        &#125;else if(a[i][s]) t=i;    &#125;    nxt[t]=s;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i-1;j++)&#123;            int x;            cin&gt;&gt;x;            if(x)&#123;                adj[j].push_back(i);                a[j][i]=1;            &#125;else&#123;                adj[i].push_back(j);                a[i][j]=1;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(!dfn[i]) Tarjan::tarjan(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        dcc[col[i]].push_back(i);    &#125;    for(int u=1;u&lt;=n;u++)&#123;        for(auto v:adj[u])&#123;            if(col[u]!=col[v])&#123;                G[col[u]].push_back(col[v]);                in[col[v]]++;            &#125;        &#125;    &#125;    toposort();    for(int i=1;i&lt;=tcnt;i++)&#123;        getham(tpos[i]);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        int lst=i,now=pos[col[i]];        while(&#x27;QWQ&#x27;)&#123;            if(dcc[tpos[now]].size()==1)&#123;                ans[i].push_back(lst);                if(now==tcnt) break;                lst=dcc[tpos[++now]][0];                continue;            &#125;            ans[i].push_back(lst);            for(int j=nxt[lst];j!=lst;j=nxt[j])&#123;                ans[i].push_back(j);            &#125;            if(now==tcnt) break;            lst=dcc[tpos[++now]][0];        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;ans[i].size()&lt;&lt;&#x27; &#x27;;        for(auto p:ans[i]) cout&lt;&lt;p&lt;&lt;&quot; &quot;;        cout&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 4. 参考

竞赛图的一些性质 - _zwl - 博客园
【CF913F】Strongly Connected Tournament - heyujun - 博客园
竞赛图专题突破 - Compound_Interest - 博客园
由竞赛图的分数序列构造出竞赛图 - yspm - 博客园
竞赛图小记 - 洛谷专栏

]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈FFT与NTT在字符串匹配中的应用</title>
    <url>/posts/d9450503/</url>
    <content><![CDATA[ 0. 前言
记录做题中遇见的一些好玩的科技。
 1. 含通用符的字符串匹配问题
在没有通用符的字符串匹配问题中，我们一般使用 O(n+m)O(n+m)O(n+m) 的 KMP，多模匹配下我们会考虑 AC 自动机。但是，我们还有令玩意中做法：
设 P(x)=∑i=0m−1(Ai−Bx+i)P(x)=\sum\limits_{i=0}^{m-1} (A_{i}-B_{x+i})P(x)=i=0∑m−1​(Ai​−Bx+i​)。
但是 Ai−Bx+iA_{i}-B_{x+i}Ai​−Bx+i​ 是没有正负性这一说的，所以我们要将其平方，有：
P(x)=∑i=0m−1(Ai−Bx+i)2=∑i=0m−1(Ai2−2AiBx+i+Bx+i2)\begin{aligned}
P(x) &amp; =\sum\limits_{i=0}^{m-1} (A_{i}-B_{x+i})^2 \\
&amp; =\sum\limits_{i=0}^{m-1} (A_{i}^2-2A_{i}B_{x+i}+B_{x+i}^2)
\end{aligned}
P(x)​=i=0∑m−1​(Ai​−Bx+i​)2=i=0∑m−1​(Ai2​−2Ai​Bx+i​+Bx+i2​)​
其中 Ai2,Bx+i2A_{i}^2,B_{x+i}^2Ai2​,Bx+i2​ 可以快速预处理，但是 AiBx+iA_{i}B_{x+i}Ai​Bx+i​ 不太好处理。一般对于这种式子需要改写成卷积的形式，不妨将 AAA 反转，那么匹配函数 P(x)=∑i=0m−1(Am−i−12−2Am−i−1Bx−m+i−1+Bx−m+i+12)P(x)=\sum\limits_{i=0}^{m-1}(A_{m-i-1}^2 - 2A_{m-i-1}B_{x-m+i-1}+B_{x-m+i+1}^2)P(x)=i=0∑m−1​(Am−i−12​−2Am−i−1​Bx−m+i−1​+Bx−m+i+12​)。发现 Am−i−1Bx−m+i+1A_{m-i-1}B_{x-m+i+1}Am−i−1​Bx−m+i+1​ 是卷积形式，用 FFT 求解，时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)。
 P4173 残缺的字符串
这题出现了可以代替一个字符的通用符，可以将通用符的权值设为 0，再乘上权值即可。
P(x)=∑i=0m−1(Am−i−1−Bx−m+i+1)2Am−i−1Bx−m+i+1=∑i=0m−1(Am−i−13Bx−m+i+1−2Am−i−12Bx−m+i+12+Am−i−1Bx−m+i+13)\begin{aligned}
P(x)&amp;=\sum\limits_{i=0}^{m-1} (A_{m-i-1}-B_{x-m+i+1})^2A_{m-i-1}B_{x-m+i+1} \\ 
&amp; =\sum\limits_{i=0}^{m-1} (A_{m-i-1}^3B_{x-m+i+1}-2A_{m-i-1}^2B_{x-m+i+1}^2+A_{m-i-1}B_{x-m+i+1}^3)
\end{aligned}
P(x)​=i=0∑m−1​(Am−i−1​−Bx−m+i+1​)2Am−i−1​Bx−m+i+1​=i=0∑m−1​(Am−i−13​Bx−m+i+1​−2Am−i−12​Bx−m+i+12​+Am−i−1​Bx−m+i+13​)​
做三次 FFT 即可，代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MN=1e7+15,MR=MN&lt;&lt;2;const double pi=acos(-1);using compd=complex&lt;double&gt;;int n,m,len,s[MN],tot;int rev[MN],A[MN],B[MN];compd a[MN],b[MN],ans[MN];string s1,s2;void dorev(compd f[],int len)&#123;    for(int i=0;i&lt;len;i++)&#123;        rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;        if(i&amp;1)&#123;            rev[i]|=len&gt;&gt;1;        &#125;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(i&lt;rev[i]) swap(f[i],f[rev[i]]);    &#125;&#125;void fft(compd f[],int len,int mode)&#123;    dorev(f,len);    for(int i=2;i&lt;=len;i&lt;&lt;=1)&#123;//处理的区间长度        compd wn(cos(2*pi/i),sin(2*pi*mode/i));        for(int j=0;j&lt;len;j+=i)&#123;//步长为i            compd w(1,0);            for(int k=j;k&lt;j+i/2;k++)&#123;// 蝶形优化                compd u=f[k];//左区间                compd t=w*f[k+i/2];//右区间                f[k]=u+t;                f[k+i/2]=u-t;                w=w*wn;            &#125;        &#125;    &#125;    if(mode==-1)&#123;        for(int i=0;i&lt;len;i++)&#123;            f[i]/=len;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;    reverse(s1.begin(),s1.end());    len=1;    while(len&lt;=n+m) len&lt;&lt;=1;    for(int i=0;i&lt;m;i++)&#123;        A[i]=(s1[i]!=&#x27;*&#x27;)?(s1[i]-&#x27;a&#x27;+1):0;    &#125;    for(int i=0;i&lt;n;i++)&#123;        B[i]=(s2[i]!=&#x27;*&#x27;)?(s2[i]-&#x27;a&#x27;+1):0;    &#125;    for(int i=0;i&lt;=len;i++)&#123;        a[i]=compd(A[i]*A[i]*A[i],0);        b[i]=compd(B[i],0);    &#125;    fft(a,len,1);    fft(b,len,1);    for(int i=0;i&lt;=len;i++) ans[i]=ans[i]+a[i]*b[i];    for(int i=0;i&lt;=len;i++)&#123;        a[i]=compd(A[i],0);        b[i]=compd(B[i]*B[i]*B[i],0);    &#125;    fft(a,len,1);    fft(b,len,1);    for(int i=0;i&lt;=len;i++) ans[i]=ans[i]+a[i]*b[i];    for(int i=0;i&lt;=len;i++)&#123;        a[i]=compd(A[i]*A[i],0);        b[i]=compd(B[i]*B[i],0);    &#125;    fft(a,len,1);    fft(b,len,1);    for(int i=0;i&lt;=len;i++) ans[i]=ans[i]+a[i]*b[i]*compd(-2,0);    fft(ans,len,-1);    for(int i=m-1;i&lt;n;i++)&#123;        if(fabs(ans[i].real())&lt;=0.5) s[++tot]=i-m+2;    &#125;    cout&lt;&lt;tot&lt;&lt;&#x27;\n&#x27;;    for(int i=1;i&lt;=tot;i++) cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;    return 0;&#125;
 2.关于位置对称的问题
 P4199 万径人踪灭
设 fi=∑j=0i[sj=s2×i−j]f_i=\sum\limits_{j=0}^i [s_j=s_{2\times i-j}]fi​=j=0∑i​[sj​=s2×i−j​]。
如果不管不能是连续的一段的限制，那么每一个 iii 的答案就是 2fi−12_{f_i}-12fi​​−1。
是连续的一段的限制直接用 Manacher 做（其实也可以二分+哈希）。
发现 fi=∑j=0i[sj=s2×i−j]f_i=\sum\limits_{j=0}^i [s_j=s_{2\times i-j}]fi​=j=0∑i​[sj​=s2×i−j​] 是卷积形式。
设 aia_iai​ 表示 sis_isi​ 是否为 a，bib_ibi​ 表示 sis_isi​ 是否为 b。
那么 f=a∗a+b∗bf=a*a+b*bf=a∗a+b∗b。
FFT 直接做即可，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;using compd=complex&lt;double&gt;;constexpr int MN=3e5+15,MOD=1e9+7;int n,x[MN],p[MN],s[MN],ans[MN],ret;string st;compd A[MN],B[MN];namespace PolyFFT&#123;    const double pi=acos(-1);    constexpr int MXREV=1e6;    using compd=complex&lt;double&gt;;    int rev[MXREV];    void dorev(compd f[],int len)&#123;        for(int i=0;i&lt;len;i++)&#123;            rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;            if(i&amp;1)&#123;                rev[i]|=len&gt;&gt;1;            &#125;        &#125;        for(int i=0;i&lt;len;i++)&#123;            if(i&lt;rev[i]) swap(f[i],f[rev[i]]);        &#125;    &#125;    void fft(compd f[],int len,int mode)&#123;        dorev(f,len);        for(int i=2;i&lt;=len;i&lt;&lt;=1)&#123;//处理的区间长度            compd wn(cos(2*pi/i),sin(2*pi*mode/i));            for(int j=0;j&lt;len;j+=i)&#123;//步长为i                compd w(1,0);                for(int k=j;k&lt;j+i/2;k++)&#123;// 蝶形优化                    compd u=f[k];//左区间                    compd t=w*f[k+i/2];//右区间                    f[k]=u+t;                    f[k+i/2]=u-t;                    w=w*wn;                &#125;            &#125;        &#125;        if(mode==-1)&#123;            for(int i=0;i&lt;len;i++)&#123;                f[i]/=len;            &#125;        &#125;    &#125;        // F is the out ans    void Mul(compd F[],compd G[],int n,int m)&#123;        int len=1;        while(len&lt;=n+m) len&lt;&lt;=1;        fft(F,len,1);        fft(G,len,1);        for(int i=0;i&lt;len;i++) F[i]=F[i]*G[i];        fft(F,len,-1);    &#125;    // Ans is the out,The second state is the len    pair&lt;compd*,int&gt; MulAns(compd F[],compd G[],compd Ans[],int n,int m)&#123;        int len=1;        while(len&lt;=n+m) len&lt;&lt;=1;        fft(F,len,1);        fft(G,len,1);        for(int i=0;i&lt;len;i++) Ans[i]=F[i]*G[i];        fft(Ans,len,-1);        return pair&lt;compd*,int&gt;(Ans,len);    &#125;&#125;int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void manacher()&#123;    int r=0,c=0;    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        if(i&lt;r) p[i]=min(p[c*2-i],r-i);        else p[i]=1;        while(x[i+p[i]]==x[i-p[i]]) p[i]++;        if(p[i]+i&gt;r)&#123;            r=p[i]+i;            c=i;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;st;    n=st.length();    for(int i=0;i&lt;n;i++) s[i+1]=(st[i]==&#x27;a&#x27;);    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        if(i&amp;1) x[i]=2;        else x[i]=s[i&gt;&gt;1];    &#125;    x[0]=-1,x[(n+1)&lt;&lt;1]=-2;    for(int i=1;i&lt;=n;i++)&#123;        A[i]=B[i]=compd(s[i],0);    &#125;    PolyFFT::Mul(A,B,n,n);    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        ans[i]+=(llround(A[i].real())-((i&amp;1)^1));    &#125;    memset(A,0,sizeof(A));    memset(B,0,sizeof(B));    for(int i=1;i&lt;=n;i++)&#123;        A[i]=B[i]=compd((s[i]^1),0);    &#125;    PolyFFT::Mul(A,B,n,n);    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        ans[i]+=(llround(A[i].real())-((i&amp;1)^1));    &#125;    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        ans[i]=((ans[i]+((i&amp;1)^1))&gt;&gt;1)+((i&amp;1)^1);    &#125;    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        ans[i]=(ksm(2,ans[i])-1+MOD)%MOD;    &#125;    manacher();    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        ans[i]=(ans[i]-(p[i]&gt;&gt;1)+MOD)%MOD;    &#125;    for(int i=1;i&lt;=(n&lt;&lt;1)+1;i++)&#123;        (ret+=ans[i])%=MOD;    &#125;    cout&lt;&lt;ret;&#125;
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈一类带限制的排列计数问题</title>
    <url>/posts/51b0c72c/</url>
    <content><![CDATA[可能更洛谷的阅读体验
 0.前言
2025.6.11 UPD：更新了枚举最大值转移 DP，删除了杂项，大幅重写文章。
引用蓝书的一句话：

在求解计数类动态规划问题时，通常要找到一个 “基准点”，围绕这个基准点构造一个不可划分的整体，以避免子问题之间的重叠。

在解决排列限制类问题，我们关键就是找到一种生成顺序，使得生成部分不需要逐个记录，而只需要少量的状态即可记录。
 1. 顺序扫描线与插入法
当遇到相邻项限制的排列计数问题，可能第一次做脑子就一头蒙，因为如果直接算排列会算重，想容斥但是限制不好容斥，于是就没招数了 www。
事实上，我们可以把这个长为 nnn 的排列元素都拿出来，让后我们可以一个元素一个元素类似于插入的方式进行 DP 的转移，通过这种一个一个插入的方式我们就能打破题目中转移限制的壕沟。事实上，插入法，实际上就是顺序扫描线，通过逐个插入满足特殊的限制。 有的时候我们一个一个元素的转移，而有的时候只考虑关键点，其他元素利用组合数进行转移。
而在插入过程中，因为我们要考虑相邻项的限制条件。为了方便转移，我们在插入的同时也许要维护插入项的相对数值或者是绝对数值，通常来说就是在 DP 数组内加上一个状态来维护当前项的相对大小或绝对大小，我们按照维护的状态和扫描顺序归结为下类 4 种 DP：




绝对数值（预定）
相对数值（插入）




下表遍历
从左往右逐一确定值
从左往右逐一确定排名


值域遍历
从小到大逐一确定位置
从小到大注意插入排列



我们利用插入法，一个一个元素来看，将每一个元素作为基准点，并利用基准点，围绕限制构造一个不可划分的整体，通过这样，我们就能够避免子问题的重叠。
一般而言，当我们限制方向和 DP 转移方向一致的时候，我们可以考虑记录绝对数值（因为可以优化），反之考虑插入法。
接下来，我们一个一个来看每一类问题：
 从左往右逐一确定值
这种做法显而易见的弊端就是容易出现重复元素，考虑状压记录某个值是否出现过，通常会出现容斥原理来进行优化，在第四章我们提到。
 从小到大逐一确定位置
同上利用状压记录是否填写过，优化状态，我做的题太少还没有见到这一类，有的话欢迎在评论区分享 OvO。
 从左往右逐一确定排名
这一类题是偏多的。
AT_dp_t
对排列的 DP，可以选择按照序列顺序或值域顺序确定具体数值或相对数值。
这个题给定的是相邻项的限制，直接做容斥不太好做，我们不妨考虑上面的思想，我们考虑插入法。
我们考虑 DP 需要维护什么，首先因为我们是一个扫描线的遍历方式，所以我们的 DP 数组需要 iii 一个维护来维护当前我们扫到当前位置的答案。我们考虑从小到大填写。
我们很容易得到一个状态 f(i,j)f(i,j)f(i,j) 表示当前扫到第 iii 个数，当前填写的数是 jjj 的方案数。
然而实际上你仔细考虑发现算重的条件太多了，因为限制关系只关心大小而并非实际的数据。我们考虑我们需要什么，我们需要统计的排列，相邻项的限制只关心其相对大小关系，而与其具体大小无关，所以我们应当采用维护值的排名。
故，设 f(i,j)f(i,j)f(i,j) 表示我们当前扫到第 iii 个位置，当前项填写数在已经填写的数里面的相对大小是 jjj 的总方案数。
转移是显然的，我们考虑从 f(i,&lt;j)f(i,&lt;j)f(i,&lt;j) 和 f(i,&gt;j)f(i,&gt;j)f(i,&gt;j) 转移过来，这样的时间复杂度是 O(n3)O(n^3)O(n3)，不妨考虑前缀和优化，时间复杂度 O(n2)O(n^2)O(n2)。
等会，如果状态这么设置，那初始化 f(1,1)f(1,1)f(1,1) 不应该是 nnn 吗，为啥题解设置的都是 111？实质上是没有理解为什么我们要设置相对大小而不是绝对大小
我们第一个加入的数可以随便填写，而后面扫描的时候插入是会限制的，所以我们不能考虑这个数的值不然，我们考虑排名，在不断往后插的过程，值是动态的，每插入一个数，前 iii 个数是 [1,i][1,i][1,i] 的排列所构成的。不断扫描到 nnn，这个时候我们的答案的排列就是原来长为 nnn 的排列。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3520,MOD=1e9+7;int f[MN][MN],sum[MN][MN],n;string s;signed main()&#123;    cin&gt;&gt;n&gt;&gt;s;    s=&#x27; &#x27;+s;    f[1][1]=1;    for(int i=1;i&lt;=n;i++)&#123;        sum[1][i]=1;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            if(s[i-1]==&#x27;&lt;&#x27;) f[i][j]=sum[i-1][j-1]%MOD;            else if(s[i-1]==&#x27;&gt;&#x27;) f[i][j]=(sum[i-1][i-1]-sum[i-1][j-1]+MOD)%MOD;            sum[i][j]=(sum[i][j-1]+f[i][j])%MOD;        &#125;    &#125;    cout&lt;&lt;sum[n][n];    return 0;&#125;
abc282g
不难注意到题目要求限制就是同大或者同小，没有要求特定值的限制。对于本题，我们按照序列顺序确定相对数值
但是这里的答案要求维护限制的贡献，如果我们不维护发现是无法转移的。我们不妨考虑把这个贡献设进状态。
故 f(i,j,k,l)f(i,j,k,l)f(i,j,k,l) 表示扫到第 iii 个元素，aia_iai​ 在 AAA 中的排名为 jjj，BiB_iBi​ 在 BBB 中的排名为 kkk，有 lll 个位置满足限制即可。
转移仍和上面差不太多，小于大于转移即可，注意到还要用二维前缀和，时间复杂度 O(n3k)O(n^{3} k)O(n3k)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=101;int n,K,MOD,f[MN][MN][MN][MN],sum[MN][MN][MN][MN];signed main()&#123;    cin&gt;&gt;n&gt;&gt;K&gt;&gt;MOD;    f[1][0][1][1]=sum[1][0][1][1]=1;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=0;j&lt;=K;j++)&#123;            for(int k=1;k&lt;=i;k++)&#123;                for(int p=1;p&lt;=i;p++)&#123;                    f[i][j][k][p]=((f[i][j][k][p]+sum[i-1][j-1][k-1][p-1])%MOD+MOD)%MOD;                    f[i][j][k][p]=((f[i][j][k][p]+sum[i-1][j][k-1][i-1]-sum[i-1][j][k-1][p-1])%MOD+MOD)%MOD;                    f[i][j][k][p]=((f[i][j][k][p]+sum[i-1][j][i-1][p-1]-sum[i-1][j][k-1][p-1])%MOD+MOD)%MOD;                    f[i][j][k][p]=((f[i][j][k][p]+sum[i-1][j-1][i-1][i-1]-sum[i-1][j-1][k-1][i-1]-sum[i-1][j-1][i-1][p-1])%MOD+sum[i-1][j-1][k-1][p-1]%MOD+MOD)%MOD;                    sum[i][j][k][p]=(((sum[i][j][k-1][p]+sum[i][j][k][p-1]-sum[i][j][k-1][p-1])%MOD+MOD)%MOD+f[i][j][k][p])%MOD;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;sum[n][K][n][n];    return 0;&#125;
CF995F
等一会这不是排列吗？
我其实一开始只是想做关于排列，但是考虑到这一类思想在许多题目出现，选一些题目来见识见识。
“恰好” 一词很好，我们可以考虑转二项式反演，注意到分配的工资数很多，但实际上最多只能用 nnn 种。我们可以考虑记录相对大小关系。
我们不妨设 f(i,j)f(i,j)f(i,j) 表示以 iii 为根的子树，节点 iii 的权值相对大小是第 jjj 大的合法方案数，不难得出转移方程：
f(i,j)=∏v∈son(i)∑k=1jf(v,k)f(i,j)=\prod_{v\in son(i)} \sum\limits_{k=1}^j f(v,k)
f(i,j)=v∈son(i)∏​k=1∑j​f(v,k)
不难前缀和优化，时间复杂度 O(n2)O(n^2)O(n2)。
然而，注意到这个实际上是至多使用，因为我们可以重复分配同价值的工作，而在根节点 111 号点取道最大值。
我们令 gig_igi​ 表示用 [1,i][1,i][1,i] 的数填进去，恰好用 iii 种权值的方案数，考虑二项式反演，那么容斥方程如下：
gi=f(1,i)−∑j=1i−1(i−1j−1)gjg_{i}=f(1,i)-\sum\limits_{j=1}^{i-1} \binom{i-1}{j-1} g_{j}
gi​=f(1,i)−j=1∑i−1​(j−1i−1​)gj​
最终答案即为：
∑i=1min⁡(n,d)(di)gi\sum\limits_{i=1}^{\min(n,d)} \binom{d}{i} g_{i}
i=1∑min(n,d)​(id​)gi​
时间复杂度 O(n2)O(n^2)O(n2)。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int MN=3000+15,MOD=1e9+7;int n,d,sum1,sum2,g[MN][MN],jc[MN],inv[MN];ll ans;vector&lt;int&gt; adj[MN];int ksm(ll a,int b)&#123;    ll ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret%MOD;&#125;void init()&#123;    jc[0]=1;    for(int i=1;i&lt;MN;i++) jc[i]=1ll*jc[i-1]*i%MOD;    inv[MN-1]=ksm(jc[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=1ll*inv[i+1]*(i+1)%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return 1ll*jc[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;void dfs(int u)&#123;    for(int i=1;i&lt;=n;i++)&#123;        g[u][i]=1;    &#125;    for(auto v:adj[u])&#123;        dfs(v);        int sum=0;        for(int i=1;i&lt;=n;i++)&#123;            sum=(sum+g[v][i])%MOD;            g[u][i]=1ll*g[u][i]*sum%MOD;        &#125;    &#125;&#125;signed main()&#123;    init();    cin&gt;&gt;n&gt;&gt;d;    for(int i=2;i&lt;=n;i++)&#123;        int v;        cin&gt;&gt;v;        adj[v].push_back(i);    &#125;    dfs(1);    for(int i=1;i&lt;=n;i++)&#123;        g[1][i]=(g[1][i]+g[1][i-1])%MOD;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;i;j++)&#123;            g[1][i]=(g[1][i]-1ll*g[1][j]*getC(i,j)%MOD+MOD)%MOD;        &#125;    &#125;    sum1=sum2=1;    for(int i=1;i&lt;=n;i++)&#123;        sum1=1ll*sum1*(d-i+1)%MOD;        sum2=1ll*sum2*i%MOD;        ans=(ans+1ll*sum1*ksm(sum2,MOD-2)%MOD*g[1][i]%MOD)%MOD;    &#125;    cout&lt;&lt;ans%MOD;    return 0;&#125;
 从小到大逐一确定值
与确切的位置无关，与位置相对关系有关，在接下来的枚举最大值转移会介绍到，请读者一定要坚持啊啊啊。
 2. 连续段DP
连续段利用的是插入法的思想。
连续段 DP 主要用来解决一类计数问题，不光是排列计数问题，这类问题通常的特点是，如果只考虑在序列的两端插入，问题将容易解决（或者说有更简便的状态记录方式），状态转移的过程可能和相邻已插入元素的具体信息相关。
我们可以依次插入每个元素，连续段 dp 的元素插入操作只会在连续段的两端进行。
连续段起手 DP 式子：fi,jf_{i,j}fi,j​ 表示插入到第 iii 个数，划分出 jjj 个连续段的方案数。
转移考虑：

当前元素新开一个连续段。
接在已有连通块的首或尾。
元素用于连接两个连续段。

连续段 dp 的方式是将其理解为建立笛卡尔树的过程。新开一个连通块就是新建叶子节点，合并就是把两颗子树合并为一颗并以当前节点为根，接在首/尾就是选一颗子树作为当前节点的儿子，这样当前节点只会有一个儿子。当然，这只是一种理解方式，请不要和下面枚举最大值转移搞混。
连续段 dp 之所以能够避免记录信息的问题，是因为元素的插入，连续段的合并等操作均在连续段的两端进行，而在这类题目中，这种策略能使得状态维护变得简单。
而对于连续段的定义，每个题都有不同的设计方案，接下来我们通过例题一道一道来体会连续段的设计。
CF1515E Phoenix and Computers
我们手玩样例，不难发现一种组合方案：“ABABA” 其中 “A” 代表手动开启，“B” 代表依赖两边来开启。而方案中我们也可以打破这种，例如 ：”ABABAA“。
不难发现这是一个类似于连续段的形式，不妨考虑连续段 DP，设 f(i,j)f(i,j)f(i,j) 表示插入到第 iii 个数，划分出 jjj 个连续段的方案数。我们考虑分类讨论上面提到的 3 种情况：

新建段：显然由 f[i−1][j−1]f[i-1][j-1]f[i−1][j−1] 转移过来，这个连续段可以里面随便找位置插进去，一共 jjj 个空。乘法原理即可。

f[i][j]=f[i−1][j−1]×jf[i][j]=f[i-1][j-1]\times j
f[i][j]=f[i−1][j−1]×j

合并段：两个情况，第一个是中间空 2 个格子，随便加上一个另一个就能配对。第二种就是中间空了三个格子，这种情况加入中间的那个就可以连起来了。

f[i][j]=f[i−1][j+1]×2×jf[i][j]=f[i-1][j+1]\times 2 \times j
f[i][j]=f[i−1][j+1]×2×j
f[i][j]=f[i−3][j+1]×jf[i][j]=f[i-3][j+1]\times j
f[i][j]=f[i−3][j+1]×j

插段里：因为没有生成新的段，由 f[i−1][j]f[i-1][j]f[i−1][j] 转移过来，因为每一个段两端都可以加，直接乘上 j×2j\times 2j×2 即可。第二个就是隔一个加入，这样又会有一个自动生成，相当于加了 2 个。

f[i][j]=f[i−1][j]×j×2f[i][j]=f[i-1][j]\times j \times 2
f[i][j]=f[i−1][j]×j×2
f[i][j]=f[i−2][j]×2×jf[i][j]=f[i-2][j]\times 2 \times j
f[i][j]=f[i−2][j]×2×j
上面的情况结合起来即可，时间复杂度 O(n2)O(n^2)O(n2)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=520;int f[MN][MN],n,MOD;signed main()&#123;    cin&gt;&gt;n&gt;&gt;MOD;    f[0][0]=1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;=i;j++)&#123;            f[i+1][j+1]=(f[i+1][j+1]+f[i][j]*(j+1)%MOD)%MOD;            f[i+1][j]=(f[i+1][j]+f[i][j]*2*j%MOD)%MOD;            f[i+2][j]=(f[i+2][j]+f[i][j]*2*j%MOD)%MOD;            if(j&gt;=2)&#123;                f[i+2][j-1]=(f[i+2][j-1]+f[i][j]*(j-1)%MOD*2%MOD)%MOD;                f[i+3][j-1]=(f[i+3][j-1]+f[i][j]*(j-1)%MOD)%MOD;            &#125;        &#125;    &#125;    cout&lt;&lt;f[n][1]&lt;&lt;&#x27;\n&#x27;;    return 0;&#125;
CEOI 2016kangaroo

有多少长为 nnn 的排列 ppp 使得 ∀i∈(1,n)\forall i \in (1,n)∀i∈(1,n)，pip_ipi​ 两边的数同时小于或大于 pip_ipi​，且 p1=s,pn=tp_1=s,p_n=tp1​=s,pn​=t。

还是这种特殊限制，我们不妨考虑插入法。
不难手玩样例发现连续段的形式：大小大小大小大小。
我们设状态：fi,jf_{i,j}fi,j​ 表示插入到第 iii 个数，划分出 jjj 个连续段的方案数。我们考虑从小到大插入。

新建块：注意到后加入一定比 iii 大，所以后面插入在 iii 两边的数一定比 iii 大，所以不用考虑新开一段与前面段的大小限制。但是我们要考虑 p1p_{1}p1​ 与 pnp_{n}pn​ 的限制，如果 i&gt;si&gt;si&gt;s 不能，同理 i&gt;ti&gt;ti&gt;t，故转移为：f[i][j]=f[i−1][j−1]×(j−[i&gt;s]−[i&gt;t])f[i][j]=f[i-1][j-1]\times (j-[i&gt;s]-[i&gt;t])f[i][j]=f[i−1][j−1]×(j−[i&gt;s]−[i&gt;t])。
插入块两端：如果有这种情况的话，那么后面一定会有一个 &gt;i&gt;i&gt;i 的数接在 iii 另一侧，但是这样的话这不就是合并成一个块了吗，与题意不符。
合并块：转移是显然的和上面一样：f[i][j]=f[i−1][j+1]×jf[i][j]=f[i-1][j+1]\times jf[i][j]=f[i−1][j+1]×j。

时间复杂度 O(n2)O(n^2)O(n2)，故代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e3+15,MOD=1e9+7;int n,s,t,f[MN][MN];signed main()&#123;    cin&gt;&gt;n&gt;&gt;s&gt;&gt;t;    f[1][1]=1;    for(int i=2;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            if(i!=s&amp;&amp;i!=t)&#123;                f[i][j]=((j*f[i-1][j+1])%MOD+f[i-1][j-1]*(j-(i&gt;s)-(i&gt;t))%MOD)%MOD;            &#125;            else f[i][j]=(f[i-1][j]+f[i-1][j-1])%MOD;        &#125;    &#125;    cout&lt;&lt;f[n][1];    return 0;&#125;
接下来我们来看不同种类的连续段设计类型：
COCI 2021/2022 #2 Magneti
样例 3 解释提示的很明显了吧。
我们还是考虑插入法，先按照特定顺序插入，例如从小到大插，根据 rir_iri​ 排序。
注意到样例 3 的解释中，图示是一个连续段的形式，自己手模以一下发现确实是这样的。
考虑连续段 DP，但是这样设状态是不太对的，因为我们还有不相互吸引的条件，如果不设置一个空位状态的话是无法处理限制的，所以我们要多设置空位的状态。
即：设 fi,j,kf_{i,j,k}fi,j,k​ 表示到第 iii 个位置，形成了 jjj 个连续段，空位使用了 kkk 个的方案数。
转移方法还是我们上面的分类讨论：

成新段：f[i][j][k]=f[i−1][j−1][k−1]f[i][j][k]=f[i-1][j-1][k-1]f[i][j][k]=f[i−1][j−1][k−1]。
接在段两端：f[i][j][k]=f[i][j][k]+f[i−1][j][k−ri]×j×2f[i][j][k]=f[i][j][k]+f[i-1][j][k-r_{i}]\times j \times 2f[i][j][k]=f[i][j][k]+f[i−1][j][k−ri​]×j×2。
合并段：f[i][j][k]=f[i−1][j+1][k−2]×ri+1]×j×(j+1)f[i][j][k]=f[i-1][j+1][k-2]\times r_{i}+1]\times j \times (j+1)f[i][j][k]=f[i−1][j+1][k−2]×ri​+1]×j×(j+1)。

最后统计答案考虑插板法，贡献为 fn,1,i×(l−i+nn)f_{n,1,i}\times \binom{l-i+n}{n}fn,1,i​×(nl−i+n​)，时间复杂度 O(n2l)O(n^{2}l)O(n2l)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=55,ML=1e4+5,MOD=1e9+7;int n,l,r[MN],f[MN][MN][ML],pw[ML],inv[ML];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;ML;i++) pw[i]=pw[i-1]*i%MOD;    inv[ML-1]=ksm(pw[ML-1],MOD-2);    for(int i=ML-2;i&gt;=0;i--) inv[i]=inv[i+1]*(i+1)%MOD;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;signed main()&#123;    init();    cin&gt;&gt;n&gt;&gt;l;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;r[i];    &#125;    sort(r+1,r+1+n);    f[0][0][0]=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            for(int k=1;k&lt;=l;k++)&#123;                f[i][j][k]=f[i-1][j-1][k-1];                if(k&gt;=r[i]) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-r[i]]*2*j%MOD)%MOD;                if(k&gt;=2*r[i]-1)&#123;                    f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-2*r[i]+1]*j%MOD*(j+1)%MOD)%MOD;                &#125;            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=l;i++)&#123;        ans=(ans+f[n][1][i]*getC(l-i+n,n)%MOD)%MOD;    &#125;    cout&lt;&lt;ans%MOD;    return 0;&#125;
排列游戏
课上 yy 半天。
首先第一个不难发现的点，f(p)=12∑∣i−pi∣f(p)=\frac{1}{2} \sum\limits |i-p_{i}|f(p)=21​∑∣i−pi​∣，通过手模样例即可。
证明考虑首先每次操作代价如果为 xxx，那么最多使得 w(p)=∑∣i−pi∣w(p)=\sum\limits|i-p_{i}|w(p)=∑∣i−pi​∣ 减少 2x2x2x。并且总存在一种用 xxx 的方案使得将 w(p)w(p)w(p) 减少 2x2x2x。
接下来有一个很经典的 Trick，我们考虑将 i→pii\rightarrow p_ii→pi​ 连边，那么会出现如下奇妙的性质：

我们注意到， 每一个元素都构成了一个环，而且环内元素是可以相互置换的。总的来说会形成几个置换环，而对于置换环上的每个边 (u,v)(u,v)(u,v) 都有 ∣u−v∣|u-v|∣u−v∣ 的贡献。注意到这个置换环也是一个连续整段的性质，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示已经插入到第 iii 个数，当前形态的置换环（或者连续段）个数为 jjj，贡献和为 kkk 的方案数。
考虑怎么转移。新插入有如下可能：

新开环，这个又分成是否连成自环两种。
把一个没有封口的置换环变成了一个完整的环。
直接接在某个还未封口的置换环的开头或结尾。
接在某个未封口的结尾和另一个的开头，合并。

这样的时间复杂度是 O(nm2)O(nm^2)O(nm2)，加点至多把 iii 相邻的至多两条边计入贡献。
我们可以把每条边的贡献进一步细化到值域上，如果当前 jjj 条边还没有接续，如果想要达成 jjj 个置换环，总权值至少为 2+4+⋯+2j=j22+4+\dots+2j=j^22+4+⋯+2j=j2 级别，开 m\sqrt{m}m​ 即可，时间复杂度 O(nmm)O(nm\sqrt{m})O(nmm​)。
双倍经验：ABC134F
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=520,QM=80,MM=10005,MOD=1e9+7;int T,n,m,now,inv2=(MOD+1)/2,f[2][MN][MM],ans[MN][MM],pw[MM],inv[MM];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void initpw()&#123;    pw[0]=1;    for(int i=1;i&lt;MM;i++)&#123;        pw[i]=pw[i-1]*i%MOD;    &#125;    inv[MM-1]=ksm(pw[MM-1],MOD-2);    for(int i=MM-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;int getpw(int x)&#123;    if(x&amp;1) return MOD-1;    else return 1;&#125;void dodp()&#123;    initpw();    f[now][0][0]=1;    for(int i=1;i&lt;MN;i++)&#123;        now^=1;        for(int j=0;j&lt;=min(i,QM);j++)&#123;            for(int k=(j-1)*j;k&lt;MM;k+=2)&#123;                f[now][j][k]=0;                if(j&gt;0) f[now][j][k]=(f[now^1][j-1][k-2*(j-1)]+f[now][j][k]+MOD)%MOD;                if(k&gt;=2*j) f[now][j][k]=(f[now][j][k]+f[now^1][j][k-2*j]*(2*j+1)+MOD)%MOD;                if(k&gt;=2*(j+1)) f[now][j][k]=(f[now][j][k]+f[now^1][j+1][k-2*(j+1)]*(j+1)%MOD*(j+1)%MOD)%MOD;            &#125;        &#125;        for(int j=0;j&lt;MM;j++)&#123;            if(j&amp;1) continue;            int k=j/2,ret=f[now][0][j];            if(k&lt;=i)&#123;                (ret+=(getpw((i&amp;1)+(k&amp;1))*getC(i-1,k)))%=MOD;            &#125;            ret=ret*inv2%MOD;            ans[i][j]=((j&gt;0?ans[i][j-2]:0)+ret)%MOD;        &#125;    &#125;&#125;signed main()&#123;    dodp();    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n&gt;&gt;m;        cout&lt;&lt;ans[n][m*2]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
摩天大楼 / Skyscraper
考虑插入法，从小到大插入可以逃掉绝对值的课。
我们把贡献拆开，考虑每一个 BiB_iBi​ 的贡献，发现会有三种可能：−2Bi,0,2Bi-2B_{i},0,2B_{i}−2Bi​,0,2Bi​。而具体选哪个取决于左右两侧的数是否比他大。
我们按照值域的顺序来插入，从小到大插，这个时候我们要确定的是绝对位置。f(i,j,k)f(i,j,k)f(i,j,k) 表示当前到第 iii 个值，形成 jjj 个连续段，当前所有数贡献为 kkk 的方案数。
转移时还是三个讨论情况，但新的数两侧是否紧贴着连续段就代表了两侧的数是否比他大。由于序列的两侧不能再插入元素，因此还需要记录两个 0/1 变量表示当前序列的左右两侧是否已经被占据了。
还是接着讨论三个情况，时间复杂度 O(n3L)O(n^3L)O(n3L)，但是代码写了 1145 行，于是不放了 www。
 3. 枚举最大值转移DP
枚举最大值转移 DP，实际上就是排列在笛卡尔树结构上的 DP（注意不是真正的笛卡尔树），有点类似于分治的思想。其作用就是用来解决一类取最大值和最小值的排列计数题型。接下来均以最大值来举例子：
我们利用的是一个笛卡尔树的性质：我们设一个区间 [l,r][l,r][l,r] 最大值的位置为 pospospos，发现可以把区间分成 [l,pos][l,pos][l,pos] 和 [pos,r][pos,r][pos,r] 两个区间，并且两个区间互不影响，也就是说我左边怎么乱搞放数也不会影响右边的区间。这个时候全局最大值作为区间的端点出现。

我们可以自底向上类似 “树形 DP” 来合并区间，然而实际上我们在计数 DP 里大多数情况并不能真的建立笛卡尔树跑 DP。通常来说，我们会枚举这个区间最大值（即笛卡尔树的 “根节点”）的位置出现在哪里，我们在这里不妨设位置为 kkk，区间长度为 iii，枚举之后，会从左儿子即 k−1k-1k−1 和右儿子 i−ki-ki−k 转移过来（注意这里舍弃了中间最大值的元素），但我们仍要考虑分配左儿子权值的情况，也就是说我们要乘上 (i−1k−1)\binom{i-1}{k-1}(k−1i−1​) 分配的情况。
其本质就是类似于笛卡尔树的分治结构，我们在合并时确定相对大小，把组合数乘起来，但要注意的是，我们这种方法其实是从小到大逐一确定值的扫描线顺序。
PA2018 Skwarki
首先考虑计数 DP，但是直接做发现不太好做，我们思考能否对删除操作进行进一步转化成好的条件取做。
对于原题目的限制，即只要一个数左右两侧一旦有一个大的就会被删，既有位置限制和数值限制。一步很妙的转化的就是将这个思想转成笛卡尔树，那么删除操作就是在笛卡尔树上删有儿子的点。
我们不妨设 gug_{u}gu​ 表示删空 uuu 子树（包括 uuu 号点）的所需次数，因为题意表明删除操作是同时进行的，不难有如下转移：
gu=max⁡{gls,grs,min⁡(gls,grs)+1}g_{u}=\max\left\{ g_{\text{ls}},g_{\text{rs}},\min(g_{\text{ls}},g_{\text{rs}})+1 \right\}
gu​=max{gls​,grs​,min(gls​,grs​)+1}
其中 ls 表示左儿子，rs 表示右儿子，注意在没有左儿子和右儿子的时候要特判。
方程表明如下情况：

gls,grsg_{\text{ls}},g_{\text{rs}}gls​,grs​：因为操作是并行的，我们可以直接对左右儿子删除操作取 max⁡\maxmax 即可。
某一子树删除完毕后，花一次操作删根节点 uuu 让后把剩下子树接上去。

注意到删除最多删除树的一半节点，也就是当删除操作数量 k≤log⁡(n)k\le \log(n)k≤log(n) 时才可能有解。
验证考虑分类讨论，讨论左右子树操作次数相同和不同的情况即可简明验证。不难发现的一点是答案一定是全局的最大值，并且一定作为叶子节点出现。
接下来我们考虑如何把它搬到计数 DP 上，真的在笛卡尔树上 DP 显然是不现实的，因为树的结构会改变，考虑我们上面所提到的，我们可以这么设置方程：设 f(i,j,0/1)f(i,j,0/1)f(i,j,0/1) 表示共 iii 个元素的排列，恰好 jjj 次删空，全局最大值是否在区间的端点。
对于 f(i,j,0)f(i,j,0)f(i,j,0) 的转移，根据我们上面所述的笛卡尔树的节点，我们需要枚举区间的最大值的位置来进行转移，对于每个位置 kkk 在分配左儿子的方案有 (i−1k−1)\binom{i-1}{k-1}(k−1i−1​) 种方案给乘起来，左儿子 f(k−1,l,0)f(k-1,l,0)f(k−1,l,0) 右儿子 f(i−k,r,0)f(i-k,r,0)f(i−k,r,0)，其中 l,rl,rl,r 是枚举儿子区间最大值的位置，转移即可。
考虑 f(i,j,1)f(i,j,1)f(i,j,1) 的转移，我们不考虑区间端点到底在哪里，因为排列的对称性可以完全统计答案，那么转移只需统计左儿子或者右儿子任一出现最大值的方案数即可，再乘上 (i−1k−1)\binom{i-1}{k-1}(k−1i−1​) 即可。
转移的 jjj 需要通过上面的 ggg 单独计算，答案统计仍枚举最大值转移即可，见代码，时间复杂度 O(n2k2)O(n^{2}k^{2})O(n2k2)。
注意到 kkk 最大为 log⁡(n)\log(n)log(n)，那么时间复杂度就是 O(n2log⁡2n)O(n^2 \log^{2} n)O(n2log2n)，这个复杂度下会被卡常，需要减少取模操作。注意到转移方程可以前缀和优化，那么时间复杂度即为 O(n2log⁡n)O(n^{2} \log n)O(n2logn)，这里就不用关心了。
CF1580B
O(n5)O(n^5)O(n5) 很幽默吗？
考虑笛卡尔树排列 DP，问题转化为求笛卡尔树深度为 mmm 的点有 kkk 个排列的个数，考虑 DP，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示共 iii 个数，笛卡尔树上深度为 jjj 的节点有 kkk 个，考虑枚举最大值转移，枚举左侧有 qqq 个深度为 jjj 个节点，贡献为 f(p−1,j−1,q)×f(i−p,j−1,k−q)×(i−1p−1)f(p-1,j-1,q)\times f(i-p,j-1,k-q) \times \binom{i-1}{p-1}f(p−1,j−1,q)×f(i−p,j−1,k−q)×(p−1i−1​)，O(n5)O(n^5)O(n5) 卡常即可，实在不行因为很多答案为 000，考虑设 g(i,j)g(i,j)g(i,j) 表示共 iii 个数，深度为 jjj 的节点最多有多少个，简单 DP 即可，时间复杂度 O(n3)O(n^3)O(n3)。
不要开 long long！
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=101;int f[MN][MN][MN],C[MN][MN];int g[MN][MN],pw[MN],inv[MN],n,m,K,MOD;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++) pw[i]=1ll*pw[i-1]*i%MOD;    for(int i=0;i&lt;=n;i++)&#123;        C[i][0]=C[i][i]=1;        for(int j=1;j&lt;i;j++)&#123;            C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;        &#125;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b||a&lt;0||b&lt;0) return 0;    return C[a][b];&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;K&gt;&gt;MOD;    init();    g[1][1]=1;    for(int i=2;i&lt;=n;i++)&#123;        g[i][1]=1;        for(int j=2;j&lt;=i;j++)&#123;            for(int k=1;k&lt;=i;k++)&#123;                g[i][j]=max(g[i][j],g[k-1][j-1]+g[i-k][j-1]);            &#125;        &#125;    &#125;    if(K&gt;g[n][m])&#123;        cout&lt;&lt;0;        return 0;    &#125;    f[1][1][1]=1;    for(int i=0;i&lt;=n;i++) f[0][i][0]=1;    for(int i=0;i&lt;=n;i++) f[1][i][0]=1;    f[1][1][0]=0;    for(int i=2;i&lt;=n;i++)&#123;        f[i][1][1]=pw[i];        for(int j=2;j&lt;=min(i,m);j++)&#123;            for(int k=0;k&lt;=min(i-j+1,K);k++)&#123;                for(int p=1;p&lt;=i;p++)&#123;                    for(int l=0;l&lt;=k;l++)&#123;                        (f[i][j][k]+=(long long)f[p-1][j-1][l]*f[i-p][j-1][k-l]%MOD*getC(i-1,p-1)%MOD)%=MOD;                    &#125;                &#125;            &#125;        &#125;        for(int j=min(i,m)+1;j&lt;=m;j++) f[i][j][0]=pw[i];    &#125;    cout&lt;&lt;f[n][m][K];    return 0;&#125;
 4. 容斥原理与反演
这里的容斥原理与反演就是泛指题型了，主要思想还是利用扫描线或插入法的思想，但是我们利用上述技巧来统计答案或者优化，这一类题型比较偏向于上述的从左往右逐一确定与从小到大逐一确定排名。
例题 P3349小星星
暴力的想法就是定义 f(i,j,S)f(i,j,S)f(i,j,S) 表示节点 iii 编号为 jjj，子树内编号集合为 SSS，时间复杂度 O(n3×3n)O(n^3 \times 3^n)O(n3×3n)，不能通过。
Trick：可以把一个 111 到 nnn 的排列可以看作每个元素至少出现一次或至多出现一次。
考虑扫描线确定值，定义 f(i,j)f(i,j)f(i,j) 表示节点 iii 编号为 jjj 的方案数，注意到有重复元素，套路的进行状压，钦定树上每个点的编号必须是 SSS 的子集，考虑容斥记录答案，即 S(n)−S(n−1)+S(n−2)−…S(n)-S(n-1)+S(n-2)-\dotsS(n)−S(n−1)+S(n−2)−…，时间复杂度 O(n3×2n)O(n^3\times 2^n)O(n3×2n)。
或者钦定某些元素不能出现，设为集合 SSS，做 O(n3)O(n^3)O(n3) 的树形 DP，这里还是定义 f(i,j)f(i,j)f(i,j) 表示节点 iii 编号为 jjj 的方案数，但是要求 j∉Sj \notin Sj∈/S，设得到的答案为 g(S)g(S)g(S)，答案为 ∑(−1)∣S∣g(S)\sum\limits (-1)^{|S|} g(S)∑(−1)∣S∣g(S)，复杂度同上。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=18;int n,m,f[MN][MN],ans;vector&lt;int&gt; adj[MN],lst;bool mp[MN][MN];void init()&#123;    memset(f,0,sizeof(f));    lst.clear();&#125;void dfs(int u,int pre)&#123;    for(auto p:lst) f[u][p]=1;    for(auto v:adj[u])&#123;        if(v==pre) continue;        dfs(v,u);    &#125;    for(auto p:lst)&#123;        for(auto v:adj[u])&#123;            if(v==pre) continue;            int sum=0;            for(auto q:lst)&#123;                if(!mp[p][q]) continue;                sum+=f[v][q];            &#125;            f[u][p]*=sum;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        mp[u][v]=mp[v][u]=1;    &#125;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;        init();        for(int j=1;j&lt;=n;j++)&#123;            if(!((i&gt;&gt;(j-1))&amp;1)) lst.push_back(j);        &#125;        dfs(1,0);        int sum=0;        for(auto p:lst) sum+=f[1][p];         ans+=sum*(((__builtin_popcount(i))&amp;1)?-1:1);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
练习：LOJ575 不等关系（分治 NTT）
 5.总结
到了这里，我们可以基本了解对于排列令项限制问题的基本形式，基本思路以及基本套路。
事实上，对于限制的排列计数问题，其核心思想是围绕着插入法来进行操作的。除插入法的核心操作之外，我们还有一些优化技巧，例如连续段和枚举最大值转移。对于容斥原理是扫猫线上的一类统计答案的技巧，通过一些计数技巧来优化时间复杂度或者统计答案。
可能一些题和类型我还是没见过的，欢迎大家在讨论区分享。

参考：


YeahPotato的dp 题方法总汇


ListenSnow的CF995F题解


ChroneZ的浅谈一类处理状态转移依赖邻项的排列计数问题的 dp 策略


Cultreborn的组合数学知识简明大全


蓝书


云浅之处的容斥与反演技巧


看在这么用心的文章上，求留个赞再走吧！awa
哦对这是我的博客不是洛谷，好像不能点赞www，那就求贯注主播谢谢喵~。
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>点分治</title>
    <url>/posts/34afe2f1/</url>
    <content><![CDATA[ 点分治
点分治，又称淀粉质，淀粉脂。是用来解决树上路径问题。
 1.例题引入
P3806 点分治板子

给定一棵有 n 个点的树，询问树上距离为 k 的点对是否存在。

就是求无根树中长度为k的路径数目
暴力做法：考虑枚举每个点，每一次都统计距离路径。时间复杂度O(n2)O(n^2)O(n2)
我们假设一个点为根节点rtrtrt，把它先转化为有根树
考虑对每个路径进行统计，路径统计可以分为2类路径，一个路径是过当前点rtrtrt，一个路径是不过当前点rtrtrt。
这样分类是显然正确的，而且对于不经过ttt的路径，它们一定在ttt的某个子节点所构成的子树中。
对于前者，设dis[u]dis[u]dis[u]表示从节点uuu到根节点rtrtrt的路径长度，则uuu到vvv的路径长度就是dis[u]+dis[v]dis[u]+dis[v]dis[u]+dis[v]
对于后者，我们可以考虑重新统计子树，找到子树的根，让后再子树求第一类路径。
就是分治的思想，点分治途径中每一层所有递归都对点仅处理一次，即时间复杂度O(T×N)O(T\times N)O(T×N) ，TTT即子树大小。
若树退化为一条链，那么T=nT=nT=n，总时间复杂度降为O(n2)O(n^2)O(n2)。那怎么选根节点呢？
我们观察时间复杂度，NNN是固定的，我们只需要让TTT平均小即可。
那么这个时候就要请出——树的重心
树的重心有一个性质，就是它的最大子树大小不大于整颗树大小的一半，也就是说刚好能满足我们即不能退化为链又能满足平均更小

我们可以先求树的重心，代码如下
void dfs(int u,int fa)&#123;    //siz即子树大小，maxp即最大子树大小    // sum即总节点数    siz[u]=1;    maxp[u]=0;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==fa||vis[v]) continue;        dfs(v,u);        siz[u]+=siz[v];        maxp[u]=max(maxp[u],siz[v]);    &#125;    maxp[u]=max(maxp[u],sum-siz[u]);    //考虑与u相邻节点子树的大小    if(maxp[u]&lt;maxp[rt]) rt=u;&#125;
我们在分治的时候每次选取子树的重心为子树的树根进行处理，这样的TTT就不会超过logNlogNlogN层，故时间复杂度为O(nlog⁡n)O(n\log n)O(nlogn)
回到本题，本题可以离线询问，并在分治中处理答案。
对于每一次处理子树，我们需要处理每个节点到rtrtrt的深度。
令judge[dis]judge[dis]judge[dis]表示在子树中是否存在某个点到rtrtrt距离为disdisdis
离线询问用queryqueryquery数组记录。
若当前询问距离为query[j]query[j]query[j]
如果judge[query[j]−rem[i]]=1judge[query[j]-rem[i]]=1judge[query[j]−rem[i]]=1，那么表明存在这个点。则代表询问的路径存在，其实就是将子树内的节点进行配对，看是否有满足询问的条件。
配对完后继续下一个子树的处理。
记得查询完后清空judge，我们发现数组太长每次memset会炸时间，那么就考虑记录rem中出现的数，考虑用sss数组维护出现个数，这样每一次就不用memset只需要遍历数组赋值就好了。
故代码如下
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=1e5+15;const int INF=1e9;int n,m,query[MN],sum,siz[MN],dis[MN],maxp[MN],rt;int s[MN],top,rem[MN];bool test[MN],judge[MN],vis[MN];struct edge&#123;    int v,w;&#125;;vector&lt;edge&gt; adj[MN];void dfs(int u,int fa)&#123;    //siz即子树大小，maxp即最大子树大小    siz[u]=1;    maxp[u]=0;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==fa||vis[v]) continue;        dfs(v,u);        siz[u]+=siz[v];        maxp[u]=max(maxp[u],siz[v]);    &#125;    maxp[u]=max(maxp[u],sum-siz[u]);    //考虑与u相邻节点子树的大小    if(maxp[u]&lt;maxp[rt]) rt=u;&#125;void getdis(int u,int fa)&#123;    rem[++rem[0]]=dis[u];    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==fa||vis[v]) continue;        dis[v]=dis[u]+w;        getdis(v,u);    &#125;&#125;void clac(int u)&#123;    int p=0;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(vis[v]) continue;        rem[0]=0,dis[v]=w;        getdis(v,u);//重新计算深度        for(int i=rem[0];i&gt;=1;i--)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(query[j]&gt;=rem[i])&#123;                    test[j]|=judge[query[j]-rem[i]];                    //要特判是否大于rem[i]                &#125;            &#125;        &#125;        for(int i=rem[0];i&gt;=1;i--)&#123;            s[++p]=rem[i];            judge[rem[i]]=1;//记录距离出现过        &#125;    &#125;    for(int i=1;i&lt;=p;i++)&#123;        judge[s[i]]=0;    &#125;&#125;void solve(int u)&#123;    vis[u]=1;//当前节点已经处理    judge[0]=1;//初始化    clac(u);//计算以当前节点为根的子树贡献    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(vis[v]) continue;        sum=siz[v];        maxp[rt=0]=INF;        dfs(v,0);//找出子树重心        solve(rt);//solve！    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;n;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);        adj[v].push_back(&#123;u,w&#125;);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;query[i];    &#125;    maxp[rt]=sum=n;    dfs(1,0);    solve(rt);    for(int i=1;i&lt;=m;i++)&#123;        if(test[i]) cout&lt;&lt;&quot;AYE\n&quot;;        else cout&lt;&lt;&quot;NAY\n&quot;;    &#125;    return 0;&#125;
 2.P4178 Tree

给定一棵 n个节点的树，每条边有边权，求出树上两点距离小于等于 k 的点对数量。

我们发现这个题和上一道唯一一点不同在于这个题是小于等于。
当然我们可以和上一题一样算dis，但是在枚举路径的时候很麻烦。
我们考虑在一条合法路径上，路径上的点肯定都能满足条件贡献答案。

现在问题在于如何快速统计路径答案？题目要求是len≤klen \le  klen≤k ,那么我们可以考虑对求的的深度进行排序。
在处理出来disdisdis数组后，我们可以利用其对子树节点进行排序，设处理出来后的节点数组为scntscntscnt，排序后可以考虑双指针，左右指针分别在数组一端，若dis[scnt[l]]+dis[scnt[r]]&gt;kdis[scnt[l]]+dis[scnt[r]]&gt;kdis[scnt[l]]+dis[scnt[r]]&gt;k 则缩小右指针
直到dis[scnt[l]]+dis[scnt[r]]≤kdis[scnt[l]]+dis[scnt[r]]\le kdis[scnt[l]]+dis[scnt[r]]≤k 显然答案贡献为r−lr-lr−l，之后不断右移左指针直到相遇，这样的时间复杂度是O(n)O(n)O(n)。
但是这样会有一个问题，如果单个节点重复贡献，有没有这种情况发生？有的兄弟有的。

很丑，但大概是这么个意思，当计算clac(u,0)的时候，这个函数统计的是所有在u的分治区域内，距离之和&lt;=k的点对。这其中包括了同一子树内的点对，这些点对虽然它们的路径可能在子树内部，但因为当前的根是u，所以在计算的时候，它们的路径会被错误地认为经过u。但实际上，这些点对应该属于该子树的内部问题，会在后续递归处理该子树时被正确计算。因此，为了避免重复计算，需要将这些情况减去。
如何解决？考虑容斥原理，很容易发现这种情况下每个节点的答案都会算至多2次（你不可能有好几个根节点吧…)，总的结果是当前根的所有可能点对，减去各个子树内部的情况。所以我们可以在solvesolvesolve函数中先统计完以uuu为根的答案，让后不更新深度，遍历子节点v时，计算v子树中节点到u的距离（初始化为w，即u到v的边权），并统计这些点对。这些点对属于同一子树，其路径不经过u，会被后续递归处理。此处减去以避免重复计数。
故代码如下
#include&lt;bits/stdc++.h&gt;using namespace std;const int MN=1e5+15,INF=1e9;int n,m,siz[MN],maxp[MN],sum,dis[MN],rem[MN],rt,res;bool vis[MN];struct edge&#123;    int v,w;&#125;;vector&lt;edge&gt; adj[MN];bool cmp(int x,int y)&#123;    return dis[x]&lt;dis[y];&#125;void dfs(int u,int fa)&#123;    siz[u]=1;    maxp[u]=0;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(vis[v]||v==fa) continue;        dfs(v,u);        siz[u]+=siz[v];        maxp[u]=max(maxp[u],siz[v]);    &#125;    maxp[u]=max(maxp[u],sum-siz[u]);    if(maxp[u]&lt;maxp[rt]) rt=u;&#125;void getdis(int u,int fa)&#123;    rem[++rem[0]]=u;    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(v==fa||vis[v]) continue;        dis[v]=dis[u]+w;        getdis(v,u);    &#125;&#125;int clac(int u,int w)&#123;    rem[0]=0;    dis[u]=w;    getdis(u,0);    sort(rem+1,rem+rem[0]+1,cmp);    int l=1,r=rem[0],ans=0;    while (l&lt;=r)&#123;        if(dis[rem[l]]+dis[rem[r]]&lt;=m)&#123;            ans+=r-l;            l++;        &#125;else r--;    &#125;    return ans;&#125;void solve(int u)&#123;    vis[u]=1;    res+=clac(u,0);    for(auto e:adj[u])&#123;        int v=e.v,w=e.w;        if(vis[v]) continue;        res-=clac(v,w);        sum=siz[v];        rt=0;        maxp[rt]=INF;        dfs(v,u);        solve(rt);    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;n;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);        adj[v].push_back(&#123;u,w&#125;);    &#125;    cin&gt;&gt;m;    maxp[rt]=sum=n;    dfs(1,0);    solve(rt);    cout&lt;&lt;res;    return 0;&#125;
 3. P2664 树上游戏

lrb 有一棵树，树的每个节点有个颜色。给一个长度为 nnn 的颜色序列，定义 s(i,j)s(i,j)s(i,j) 为 iii 到 jjj 的颜色数量。以及
sumi=∑j=1ns(i,j)sum_i=\sum_{j=1}^n s(i, j)
sumi​=j=1∑n​s(i,j)
求出所有的sumisum_isumi​

求单个路径上的颜色数量，我们可以像之前的题一样在remremrem数组中维护颜色信息，但是问题出现在了合并答案，合并信息很难合并因为rem数组中的数据满足DFSDFSDFS序，但是仅凭dfs序无法知道是否处于同一路径。
我们考虑能否转化sumsumsum，对于sumsumsum来说影响他的只有经过边的点颜色在不同的时候有贡献，并且统计的颜色数量是要求不相同的。
设cnt[j]cnt[j]cnt[j]表示颜色为jjj的情况下，以iii为端点包含jjj颜色的路径数量，我们显然可以得到
sum=∑j∈color(u,v)cntjsum=\sum\limits_{j\in color(u,v)}{cnt_j}
sum=j∈color(u,v)∑​cntj​
其中color就是在路径上是否有这个颜色，如果没有默认我们置cnt[j]=0cnt[j]=0cnt[j]=0。
显然我们可以在dfs子树是可以统计以rt为根节点到子树的答案。时间复杂度O(nlog⁡n)O(n\log n)O(nlogn)
但是跨子树的答案如何统计？显然这个时候rtrtrt根节点就是路径的拐点。
考虑对当前根节点的一个字节点ddd，ddd的子树中任取一个点为vvv
考虑(u,v)(u,v)(u,v)路径上出现的颜色，数量设为nownownow，uuu除了ddd以外其他子树的总大小为siz1siz1siz1，那么贡献即为num×siz1num\times siz1num×siz1
考虑没有出现过的颜色jjj，它的贡献来自于uuu除了ddd以外其他所有子树的cntjcnt_jcntj​，那么这部分的答案就是∑j∉(u,v)cntj\sum\limits_{j\notin (u,v)}{cnt_j}j∈/(u,v)∑​cntj​
代码也就呼之欲出了
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int MN=1e5+15,INF=1e9;// sum就是题面意思的sum答案,summ即节点总数// visc即表示这个颜色已经访问过了// cnt即子树对当前节点的贡献,下表应为颜色。siz即子树大小ll n,c[MN];int vis[MN];ll cnt[MN],siz[MN],sum,summ,ans[MN],visc[MN];vector&lt;int&gt; adj[MN];ll rt,maxp[MN];void dfs(int u,int fa)&#123;    siz[u]=1;    maxp[u]=0;    for(auto v:adj[u])&#123;        if(v==fa||vis[v]) continue;        dfs(v,u);        siz[u]+=siz[v];        maxp[u]=max(maxp[u],siz[v]);    &#125;    maxp[u]=max(maxp[u],summ-siz[u]);    if(maxp[u]&lt;maxp[rt])&#123;        rt=u;    &#125;&#125;void getdis(int u,int fa,int now)&#123;    // now即当前路径（不含u）的颜色数    siz[u]=1;    if(!visc[c[u]])&#123;        sum-=cnt[c[u]];        now++;    &#125;    visc[c[u]]++;    ans[u]+=sum+now*siz[rt];    // 前面是其他颜色到当前节点的贡献    // 后面是跨rt（就是跨子树,相当于rt就是路径拐点）的贡献    for(auto v:adj[u])&#123;        if(v==fa||vis[v]) continue;        getdis(v,u,now);        siz[u]+=siz[v];    &#125;    visc[c[u]]--;    if(!visc[c[u]])&#123;        sum+=cnt[c[u]];// 回溯防止处理下一个子树出问题    &#125;&#125;void getcnt(int u,int fa)&#123;    if(!visc[c[u]])&#123;        // 统计答案        cnt[c[u]]+=siz[u];        sum+=siz[u];    &#125;    visc[c[u]]++;    for(auto v:adj[u])&#123;        if(v==fa||vis[v]) continue;        getcnt(v,u);    &#125;    visc[c[u]]--;&#125;void clear(int u,int fa,int now)&#123;    if(!visc[c[u]])&#123;        now++;    &#125;    visc[c[u]]++;    ans[u]-=now;//减去重复贡献    ans[rt]+=now;//加上贡献    for(auto v:adj[u])&#123;        if(v==fa||vis[v]) continue;        clear(v,u,now);    &#125;    visc[c[u]]--;    cnt[c[u]]=0;&#125;void clearcnt(int u,int fa)&#123;    cnt[c[u]]=0;    for(auto v:adj[u])&#123;        if(v==fa||vis[v]) continue;        clearcnt(v,u);    &#125;&#125;void solve(int u)&#123;    vis[u]=1;    ans[u]++;    rt=u;    siz[u]=sum=cnt[c[u]]=1;    visc[c[u]]++;    for(auto v:adj[u])&#123;        if(vis[v]) continue;        getdis(v,u,0);        getcnt(v,u);        siz[u]+=siz[v];        cnt[c[u]]+=siz[v];        sum+=siz[v];    &#125;    clearcnt(u,0);    //逆序处理是为了保证所有子树对路径的贡献都被覆盖    siz[u]=sum=cnt[c[u]]=1;    for(int i=adj[u].size()-1;i&gt;=0;i--)&#123;        int v=adj[u][i];        if(vis[v]) continue;        getdis(v,u,0);        getcnt(v,u);        siz[u]+=siz[v];        cnt[c[u]]+=siz[v];        sum+=siz[v];    &#125;    visc[c[u]]--;    clear(u,0,0);//清理并统计2次的答案    //继续分治    for(auto v:adj[u])&#123;        if(vis[v]) continue;        summ=siz[v];        rt=0;        maxp[rt]=INF;        dfs(v,u);        solve(rt);    &#125;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;c[i];    &#125;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    summ=n;    maxp[rt]=n+1;    dfs(1,0);    solve(rt);    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 3.总结
在面对不同点分治题型的时候，要设计不同的clac函数。

]]></content>
      <categories>
        <category>图论</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>点分治优化DP</title>
    <url>/posts/2e160504/</url>
    <content><![CDATA[ 1. 一类连通块问题的优化
 1.1 介绍
对于一类树上连通块或路径问题，合并子树（可以看作卷积）的复杂度很高，但是插入一个点和自己与自己合并（可以看作点积）的复杂度可以用点分治来进行优化。
以一道例题引入：Ridiculous Netizens - HDU 6643
首先你会想到用树形背包来做，但是问题在于如果你直接设置为 f(u,i)f(u,i)f(u,i) 表示为 uuu 子树内乘积为 iii 的方案数，但是直接做会出现两个问题：

你无法保证你选取的方案子树是连通的。
在不考虑乘积的情况下，你的合并是 O(mm)O(m\sqrt{m})O(mm​) 的，因为你要枚举约数。

先保证状态是 O(nm)O(nm)O(nm)，然后我们考虑把第一点解决掉，第一点的问题就是在于我们一般树形背包是自底向上合并的，但是这样可能中途就会断掉。
转化思路，我们考虑每个点作为连通块内部的贡献，我们先考虑强制这个连通块经过根，可以发现在这种情况下，如果一个点在连通块中，那么它的父亲必须也在。
自此，由于选取一个点就必须选它的父亲，所以要去选一个子树就必须选这个子树的根。我们可以把原命题转化为一个单点加入问题。
设 f(u,i)f(u,i)f(u,i) 表示  内加入点的构成的子树，乘积为 iii 的方案数。先定根，然后我们从根开始自上往下进行 DFS，对于每个点进行选或者不选的决策，如果不选那就不从父亲计算贡献，新开 DP 方案；如果选那就维护从父亲转移过来的贡献，然后 dfs 儿子，最后合并儿子的答案，我们就得到了这个点子树内的答案，对于每一个点枚举其作为连通块的根，然后每个点都暴力跑 DFS 对子树（根节点不能遍历父节点）求出答案。
如果认为自顶向下的 DP 比较难想，当然我们可以在 DFS 序上进行 DP，这样选择一个结点就是转移到 DFS 上的下一个，而跳过一个结点就相当于跳过整棵子树，快速跳转即可。设 f(i,j)f(i,j)f(i,j) 表示 uuu 子树内 DFS 序考虑到前 iii 个节点，乘积为 jjj 的方案数，同理对于每一个点暴力求出 DFS 序然后进行规划求出答案。
时间复杂度都是 O(n2mm)O(n^2m\sqrt{m})O(n2mm​) 的。
然后考虑第二个情况，我们不考虑乘积暴力合并是 O(mm)O(m\sqrt{m})O(mm​) 的，我们的目标是要优化到 O(nm)O(n\sqrt{m})O(nm​) 的状态。看起来很难做，考虑发掘性质，注意到我们枚举约数中使得 i←i+1i\leftarrow i+1i←i+1 的时候，所管辖的区间有很多重叠的部分，同时又注意不到，⌊xnm⌋=⌊xnm⌋\lfloor \dfrac{x}{nm} \rfloor=\lfloor \dfrac{\dfrac{x}{n}}{m} \rfloor⌊nmx​⌋=⌊mnx​​⌋，可以用整除可以把 mmm 整除 iii 的值定义到状态里面。根据整除分块状态数变成 O(m)O(\sqrt{m})O(m​)，根据结论值相同在以后的转移方法也相同所以正确性得到保证，那么状态就变为 O(nm)O(n\sqrt{m})O(nm​) 了，但是这不是文章的重点。
说了这么多的求解，终于到优化了。由于上面的统计连通块包含根节点的情况复杂度会到达 O(n2m)O(n^2\sqrt{m})O(n2m​)，瓶颈在于子树大小过大，我们考虑如何减小子树规模，发现我们枚举根的情况可以等价于不包含根就分裂成若干个互不相同的子树，变成子问题，重复以上操作。这种情况我们可以思考点分治，降低分割出来的子树大小，可以将复杂度降低到 O(nmlog⁡n)O(n\sqrt{m} \log n)O(nm​logn)。

复个小盘，点分治优化 DP 的关键就是在于减小子树规模，降低 DP 的复杂度。一般来说，点分治优化 DP 要求满足以下的条件：

问题是根独立的，即问题的答案不依赖选定的根。
问题可以通过合并子树的答案得到。
合并子树复杂度大，但是处理单个节点的贡献可以快速计算。

要对于每个连通块求一个什么东西，我们先考虑强制这个连通块经过根，可以发现在这种情况下，如果一个点在连通块中，那么它的父亲必须也在。所以我们先从根自上向下进行 DP，对于每个点进行选/不选的决策，如果不选那就新开一份 dp 去做；如果选那就操作维护父亲对 dp 的贡献，然后 DFS 儿子；最后把儿子的 DP 值的答案合并上来，我们就得到了这个点子树内的答案。当然最后要强制选重心。
以下直接 DFS 实现版本，若 DFN 可以参考 crashed 的题解。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=2e3+15,MM=1e6+15,INF=1e18,MOD=1e9+7;int n,m,a[MN],w[MN],st[MM],ctot,ans,f[MN][MN];vector&lt;int&gt; adj[MN];namespace Tree&#123;    int dep[MN],maxp[MN],siz[MN],dfn[MN],rt,sum;    bool vis[MN];    void dfs1(int u,int pre)&#123; // getrt        siz[u]=1;        maxp[u]=0;        for(auto v:adj[u])&#123;            if(v==pre||vis[v]) continue;            dfs1(v,u);            siz[u]+=siz[v];            maxp[u]=max(maxp[u],siz[v]);        &#125;        maxp[u]=max(maxp[u],sum-siz[u]);        if(maxp[u]&lt;maxp[rt]) rt=u;    &#125;    void dfs2(int u,int pre)&#123;        for(int i=1;i&lt;=ctot;i++) f[u][i]=0;        for(int i=1;i&lt;=ctot;i++)&#123;            if(w[i]&gt;=a[u])&#123;                (f[u][st[w[i]/a[u]]]+=f[pre][i])%=MOD;            &#125;        &#125;        for(auto v:adj[u])&#123;            if(vis[v]||v==pre) continue;            dfs2(v,u);            for(int i=1;i&lt;=ctot;i++)&#123;                (f[u][i]+=f[v][i])%=MOD;            &#125;        &#125;    &#125;    void calc(int u)&#123;        f[0][ctot]=1;        dfs2(u,0);        for(int i=1;i&lt;=ctot;i++)&#123;            (ans+=f[u][i])%=MOD;        &#125;        f[u][ctot]=0;    &#125;    void solve(int u)&#123;        vis[u]=1;        calc(u);        for(auto v:adj[u])&#123;            if(vis[v]) continue;            sum=siz[v];            maxp[rt=0]=INF;            dfs1(v,0);            solve(rt);        &#125;    &#125;&#125;using namespace Tree;void init()&#123;    rt=ans=0;    sum=0;    for(int i=1;i&lt;=n;i++)&#123;        adj[i].clear();        vis[i]=0;        a[i]=0;        dfn[i]=maxp[i]=dep[i]=siz[i]=dfn[i]=0;    &#125;    for(int i=1;i&lt;=ctot;i++)&#123;        st[w[i]]=0;        w[i]=0;    &#125;    ctot=0;&#125;void prework()&#123;    for(int i=m,ls=0;i&gt;=1;i--)&#123;        int x=m/i;        w[st[x]=x!=ls?++ctot:ctot]=x;        ls=x;    &#125;    for(int i=0;i&lt;=n;i++)&#123;        for(int j=0;j&lt;=ctot;j++)&#123;            f[i][j]=0;        &#125;    &#125;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    init();    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;n;i++)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        adj[u].push_back(v);        adj[v].push_back(u);    &#125;    prework();    maxp[rt=0]=sum=n;    dfs1(1,0);    solve(rt);    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
 1.2 例题
 HDU 5909
有点眼熟啊，不是吗，只不过换成了异或。
但是我知道，这不位运算吗？我会 FWT！这个背包显然你一开始就说是卷积，我用脚都会，时间复杂度 O(nmlog⁡m)O(nm\log m)O(nmlogm)，轻松水过。
但显然我不是要讲这个做法，考虑到这个玩意直接做背包很难，但是单独加入一个点的复杂度近乎 O(1)O(1)O(1)，并且一个点选了，其儿子才能选，否则其儿子不能选，一眼连通块加树上依赖背包。直接转 DFS 序上 DP。设 f(i,j)f(i,j)f(i,j) 表示 uuu 子树内 DFS 序考虑到前 iii 个节点，异或和为 jjj 的方案数，暴力显然是 O(n2m)O(n^2m)O(n2m) 的，但是点分治就能够做到 O(nmlog⁡n)O(nm\log n)O(nmlogn)。
 CodeChef SUBWAY
注意有中文题面，首先这是一颗有重边的树，可以看成每条边选择一个颜色，让相邻边不同的最多。
然后考虑分析性质，发现一个树有很多重边甚是卑鄙，考虑简化问题。我们发现如果一条边有三种颜色，那么这条边一定可以选出一种颜色使得于另外两边颜色都不相同，所以可以看成只有一种以前没有出现过的颜色。所以每条边我们至多保留两个颜色即可。
其次，我们求的是同色路径，如果我们直接自底向上进行合并的话会因为要求联通而不行，我们还是和上面一样的方法，枚举根 rtrtrt 也就是起点，让后自上向下进行拓展，用 DP 计算方案，设 f(i,j,k)f(i,j,k)f(i,j,k) 表示当前到 iii 点，从 rtrtrt 进入包含 iii 点子树选择的边颜色为第 jjj 个（共两个，取值 0/10/10/1），父亲到 iii 点选择边颜色为第 kkk 种，仍为 0/10/10/1 变量。这样状态设计可以很方便地满足我们自上向下进行拓展。转移暴力拓展其子树即可，时间复杂度 O(n2)O(n^2)O(n2)，无法通过。但是注意到本问题和根选择无关，只需要确定一种顺序即可，我们可以通过点分治优化这一过程，时间复杂度 O(nlog⁡n)O(n\log n)O(nlogn)。
同时本题显然存在倍增 DP 做法，状态同上但是加入了倍增必须的 2j2^j2j，我写了，我大输特输，直接当场暴毙。
 2.参考
求赞 QwQ。

Querainy 的点分治优化 dp 学习笔记；
HDU6643 题解 C202044zxy。

]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/posts/f36e10f6/</url>
    <content><![CDATA[ 0.前言
位运算记不记得？
(n&gt;&gt;k)&amp;1 取出非负数n的第k位
n&amp;((1&lt;&lt;K)-1) 取出非负数n的后k位
n^(1&lt;&lt;k)把非负数n的第k位取反
n^(1&lt;&lt;k)把非负数的第k位取反

 1.定义与例题引入

状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。       ——oiwiki

那么怎么个状态压缩法呢？
例如这个题：  P1896 [SCOI2005] 互不侵犯

在 N×NN \times NN×N 的棋盘里面放 KKK 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 888 个格子。(1≤N≤9,0≤K≤N×N1\le N \le 9,0\le K \le N\times N1≤N≤9,0≤K≤N×N)

这里我们发现好像我们可以设几个状态，分别是放到第几行，放了多少个国王，和如何放置的。前两个都好说，但是第三个却让我们很头疼。如果按照常规思路来想，我们肯定会开一个非常非常大的数组来表示这个放置状态，而且甚至移动方向是8个方向，更头疼，怎么办？
状态压缩就是来干这种事的，我们可以用一个二进制数来表示国王放置的状态。设一个二进制数，当它的一个数位表示1的时候就表明放置的国王，如果表示0就表示没有放置国王，如下图。

这样的话我们只需要一个十进制整数就可以对应唯一一个放置国王的状态，也就不需要开那么多的空间啦。
但是对于一个状态来说，有可能合法，也有可能并不合法，并且在判断的时候我们还要处理出攻击范围以及放置了多少个国王，很麻烦。。。。？
我们可以预处理啊！
cin&gt;&gt;n&gt;&gt;k;int tt=1&lt;&lt;n;for(int i=0;i&lt;tt;i++)&#123;//i的二进制位表示一列上国王的摆放状态    isok[i]=((i&amp;(i&lt;&lt;1))==0)&amp;&amp;((i&amp;(i&gt;&gt;1))==0);//状态是否合法    attack[i]=i|(i&lt;&lt;1)|(i&gt;&gt;1);//攻击范围    cnt1[i]=cnt1[i&gt;&gt;1]+(i&amp;1);//总共多少个1（国王数量）&#125;
接下来我们来看isokisokisok这个数组怎么判断的，还是上面那个图，我们对i &amp; (i&lt;&lt;1)做一下解释。

如果有非法的情况呢？

右移同理。
那么attackattackattack攻击范围如何处理呢，如下图：

对于1的统计cntcntcnt，这个就不多说了自己画图吧（逃
那么开始dp，其实之前已经说出来转移方程了，这一贴一个oiwiki的

故有代码如下：
f[0][0][0]=1;for(int i=0;i&lt;n;i++)&#123;//枚举行数    for(int j=0;j&lt;tt;j++)&#123;//枚举状态        for(int l=0;l&lt;=k;l++)&#123;//枚举放多少个国王            if(f[i][j][l])&#123;//如果当前位置有放置的话                for(int p=0;p&lt;tt;p++)&#123;                    if(isok[p]&amp;&amp;(attack[p]&amp;j)==0)&#123;                        //如果状态合法并且攻击范围不在j的状态表示内                        f[i+1][p][l+cnt1[p]]+=f[i][j][l];                        //对下一行执行操作累加答案                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;
让后拼装以下，就有了AC代码
#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int MN=(1&lt;&lt;10)+15;int isok[MN],attack[MN],cnt1[MN],n,k;ll ans,f[121][MN][121];int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    int tt=1&lt;&lt;n;    for(int i=0;i&lt;tt;i++)&#123;//i的二进制位表示一列上国王的摆放状态        isok[i]=((i&amp;(i&lt;&lt;1))==0)&amp;&amp;((i&amp;(i&gt;&gt;1))==0);//状态是否合法        attack[i]=i|(i&lt;&lt;1)|(i&gt;&gt;1);//攻击范围        cnt1[i]=cnt1[i&gt;&gt;1]+(i&amp;1);//总共多少个1（国王数量）    &#125;    f[0][0][0]=1;    for(int i=0;i&lt;n;i++)&#123;//枚举行数        for(int j=0;j&lt;tt;j++)&#123;//枚举状态            for(int l=0;l&lt;=k;l++)&#123;//枚举放多少个国王                if(f[i][j][l])&#123;//如果当前位置有放置的话                    for(int p=0;p&lt;tt;p++)&#123;                        if(isok[p]&amp;&amp;(attack[p]&amp;j)==0)&#123;                            //如果状态合法并且攻击范围不在j的状态表示内                            f[i+1][p][l+cnt1[p]]+=f[i][j][l];                            //对下一行执行操作累加答案                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    for(int i=0;i&lt;tt;i++)&#123;        ans+=f[n][i][k];    &#125;    cout&lt;&lt;ans;    return 0;&#125;
当然最后统计答案的时候需要一个一个枚举状态。
 例题1:  P1879 [USACO06NOV] Corn Fields G

农场主 John\rm JohnJohn 新买了一块长方形的新牧场，这块牧场被划分成 MMM 行 NNN 列 (1≤M≤12,1≤N≤12)(1 \le M \le 12, 1 \le  N \le 12)(1≤M≤12,1≤N≤12)，每一格都是一块正方形的土地。 John\rm JohnJohn 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。
遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 John\rm JohnJohn 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。
John\rm JohnJohn 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）
输入样例将给出每一格的贫瘠和肥沃的状态

根据上面的思想，我们可以很容易设计出来状态转移方程。
设f[i][j]f[i][j]f[i][j]表示前iii行已经种完，开始种第iii行，按照jjj的状态进行种植能获得的方案
故有f[i][j]=f[i][j]+f[i−1][k]f[i][j]=f[i][j]+f[i-1][k]f[i][j]=f[i][j]+f[i−1][k]，其中kkk是枚举上一行的的种植状态
我们显然可以知道，对于种植状态，判断条件有2个，第一个是该土地是否肥沃（能否种植），第二个是种植时不能出现相邻，如下，橙色为种植点，红色为不能种植点。
对于该一行的种植很简单，和之前一样照常写isokisokisok就可以了，但是竖直方向怎么
处理？很简单我们发现如果有覆盖种植的话那么与起来一定会出现一个大于0的数，没有那么一定为0。

放码过来吧！
注意这里的isok写法不同
#include&lt;iostream&gt;using namespace std;const int MN=15,MK=1&lt;&lt;MN,MOD=1e8;int n,m,map[MN][MN],st[MK],isok[MK],f[MN][MK],ml;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    ml=(1&lt;&lt;m);    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            cin&gt;&gt;map[i][j];        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            st[i]=(st[i]&lt;&lt;1)+map[i][j];        &#125;    &#125;    for(int i=0;i&lt;ml;i++)&#123;        isok[i]=((i&amp;(i&lt;&lt;1))==0);    &#125;    f[0][0]=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=0;j&lt;ml;j++)&#123;            if(isok[j]&amp;&amp;((j&amp;st[i])==j))&#123;                for(int k=0;k&lt;ml;k++)&#123;                    if(!(j&amp;k))&#123;                        f[i][j]=(f[i][j]+f[i-1][k])%MOD;                    &#125;                &#125;            &#125;        &#125;    &#125;    int ans=0;    for(int i=0;i&lt;ml;i++)&#123;        ans=(ans+f[n][i])%MOD;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 例题2: P10963 Islands and Bridges

给定一张由岛屿和连接这些岛屿的桥梁构成的地图，众所周知，哈密顿路径是沿着桥梁的路径，能够恰好访问每个岛屿一次。在我们的地图中，每个岛屿还关联一个正整数值。我们定义一种哈密顿路径为 最佳三角形哈密顿路径，其最大化以下描述的值。
假设有 nnn 个岛屿。哈密顿路径 C1,C2,…,CnC_1,C_2,\dots,C_nC1​,C2​,…,Cn​ 的值分为三部分计算。设 ViV_iVi​ 为岛屿 CiC_iCi​ 的值。第一部分为路径中每个岛屿的 ViV_iVi​ 值的总和。第二部分，对于路径中的每条边 CiCi+1C_i C_{i+1}Ci​Ci+1​，加上 Vi×Vi+1V_i \times V_{i+1}Vi​×Vi+1​ 的积。第三部分，对于路径中的每三个连续岛屿 Ci,Ci+1,Ci+2C_i, C_{i+1}, C_{i+2}Ci​,Ci+1​,Ci+2​，如果它们在地图中形成一个三角形（即 CiC_iCi​ 和 Ci+2C_{i+2}Ci+2​ 之间有桥），加上 Vi×Vi+1×Vi+2V_i \times V_{i+1} \times V_{i+2}Vi​×Vi+1​×Vi+2​ 的积。
最佳三角形哈密顿路径很可能（但不一定）包含多个三角形。可能会存在多个最佳三角形哈密顿路径。你的第二个任务是找出这样的路径的数量。

对于三角形路径，在DP中如果考虑枚举端点拼凑，那么时间复杂度是不可承受的，我们可以直接在状态中加上2个点，枚举第3个点即可。
那就设fi,j,Sf_{i,j,S}fi,j,S​表示枚举2个点i,ji,ji,j，之前加入点的集合为SSS。用邻接矩阵存图判断起来好一点…
这里邻接矩阵设为mpmpmp
转移方程也很简单，枚举3个点，就有：
fi,j,s=max⁡mp[i][j]=1,mp[j][k]=1fj,k,S⊕2i−1+Vi+Vi×Vj+{Vi×Vj×Vkmp[i][k]=10mp[i][k]=0f_{i,j,s}=\max\limits_{mp[i][j]=1,mp[j][k]=1}f_{j,k,S\oplus 2^{i-1}}+V_i+V_i \times V_j+\begin{cases} V_{i}\times V_{j} \times V_{k} &amp; mp[i][k]=1 \\ 0 &amp; mp[i][k]=0 \end{cases}
fi,j,s​=mp[i][j]=1,mp[j][k]=1max​fj,k,S⊕2i−1​+Vi​+Vi​×Vj​+{Vi​×Vj​×Vk​0​mp[i][k]=1mp[i][k]=0​
路径数怎么统计，如果用pre数组记录直接爆炸，那么直接考虑dp数量，设gi,j,Sg_{i,j,S}gi,j,S​，字母含义见上，有：
gi,j,S={gj,k,S⊕2i−1fi,j,S&lt;fj,k,S⊕2i−1+tgj,k,S⊕2i−1+gi,j,Sfi,j,S=fj,k,S⊕2i−1+tgi,j,Sfi,j,S&gt;fj,k,S⊕2i−1+tg_{i,j,S}=\begin{cases} g_{j,k,S\oplus2^{i-1}} &amp; f_{i,j,S}&lt;f_{j,k,S\oplus2^{i-1}}+t \\  g_{j,k,S\oplus2^{i-1}}+g_{i,j,S} &amp; f_{i,j,S} = f_{j,k,S\oplus2^{i-1}}+t \\ g_{i,j,S} &amp; f_{i,j,S}&gt;f_{j,k,S\oplus2^{i-1}}+t \end{cases}
gi,j,S​=⎩⎪⎪⎨⎪⎪⎧​gj,k,S⊕2i−1​gj,k,S⊕2i−1​+gi,j,S​gi,j,S​​fi,j,S​&lt;fj,k,S⊕2i−1​+tfi,j,S​=fj,k,S⊕2i−1​+tfi,j,S​&gt;fj,k,S⊕2i−1​+t​
故有代码如下：
#include&lt;bits/stdc++.h&gt;#define int long long  // 定义 int 为 long long 类型，避免溢出using namespace std;const int MN = 14;  // 最大岛屿数量int T;  // 测试用例的数量int f[MN][MN][1 &lt;&lt; MN], g[MN][MN][1 &lt;&lt; MN], v[MN], n, m;  // DP 数组、岛屿值、岛屿数量、桥梁数量bool mp[MN][MN];  // 邻接矩阵，表示岛屿之间是否有桥梁void solve() &#123;    // 初始化变量    memset(v, 0, sizeof(v));  // 初始化岛屿值数组    memset(f, 0, sizeof(f));  // 初始化 DP 值数组    memset(g, 0, sizeof(g));  // 初始化 DP 计数数组    memset(mp, 0, sizeof(mp));  // 初始化邻接矩阵    cin &gt;&gt; n &gt;&gt; m;  // 输入岛屿数量和桥梁数量    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; v[i];  // 输入每个岛屿的值    &#125;    // 输入桥梁信息并构建邻接矩阵    for (int i = 1; i &lt;= m; i++) &#123;        int u, v;        cin &gt;&gt; u &gt;&gt; v;        mp[u][v] = mp[v][u] = 1;  // 标记双向桥梁    &#125;    // 特殊情况处理：只有一个岛屿    if (n == 1) &#123;        cout &lt;&lt; v[1] &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; &#x27;\n&#x27;;  // 输出该岛屿的值和路径数量        return;    &#125;    // 初始化 DP 数组：处理长度为 2 的路径    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (i == j || !mp[i][j]) continue;  // 跳过相同岛屿或没有桥梁的情况            f[i][j][(1 &lt;&lt; (i - 1)) | (1 &lt;&lt; (j - 1))] = v[i] * v[j] + v[i] + v[j];  // 计算路径值            g[i][j][(1 &lt;&lt; (i - 1)) | (1 &lt;&lt; (j - 1))] = 1;  // 初始化路径数量        &#125;    &#125;    // DP 状态转移：处理更长的路径    for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123;  // 遍历所有状态        for (int j = 1; j &lt;= n; j++) &#123;  // 遍历所有可能的当前岛屿            if (!((i &gt;&gt; (j - 1)) &amp; 1)) continue;  // 跳过未访问的岛屿            for (int k = 1; k &lt;= n; k++) &#123;  // 遍历所有可能的上一个岛屿                if (j == k || !mp[j][k] || !((i &gt;&gt; (k - 1)) &amp; 1)) continue;  // 跳过无效情况                for (int p = 1; p &lt;= n; p++) &#123;  // 遍历所有可能的下一个岛屿                    if (!((i &gt;&gt; (p - 1)) &amp; 1) || j == p || k == p || !mp[k][p] || !g[k][p][i ^ (1 &lt;&lt; (j - 1))]) continue;  // 跳过无效情况                    int val = f[k][p][i ^ (1 &lt;&lt; (j - 1))] + v[j] + v[j] * v[k] + (mp[j][p]) * v[j] * v[k] * v[p];  // 计算新路径值                    if (val == f[j][k][i]) g[j][k][i] += g[k][p][i ^ (1 &lt;&lt; (j - 1))];  // 更新路径数量                    else if (val &gt; f[j][k][i]) &#123;  // 如果新路径值更大                        f[j][k][i] = val;  // 更新最大路径值                        g[j][k][i] = g[k][p][i ^ (1 &lt;&lt; (j - 1))];  // 更新路径数量                    &#125;                &#125;            &#125;        &#125;    &#125;    // 计算最终结果    int ans = 0, cnt = 0;  // 最大路径值和路径数量    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            if (!mp[i][j] || !g[i][j][(1 &lt;&lt; n) - 1] || i == j) continue;  // 跳过无效情况            if (ans &lt; f[i][j][(1 &lt;&lt; n) - 1]) &#123;  // 如果找到更大的路径值                ans = f[i][j][(1 &lt;&lt; n) - 1];  // 更新最大路径值                cnt = g[i][j][(1 &lt;&lt; n) - 1];  // 更新路径数量            &#125; else if (ans == f[i][j][(1 &lt;&lt; n) - 1]) &#123;  // 如果路径值相同                cnt += g[i][j][(1 &lt;&lt; n) - 1];  // 累加路径数量            &#125;        &#125;    &#125;    // 输出结果，路径数量除以 2 是因为路径的顺序反转被视为相同的路径    cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; (cnt &gt;&gt; 1) &lt;&lt; &#x27;\n&#x27;;&#125;signed main() &#123;    cin &gt;&gt; T;  // 输入测试用例数量    while (T--) &#123;        solve();  // 处理每个测试用例    &#125;    return 0;&#125;
 2.状压DP的另一种状压——枚举子集
例题如下：P5911 [POI 2004] PRZ

有nnn个人需要过桥，第iii的人的重量为wiw_iwi​，过桥用时为tit_iti​这些人过桥时会分成若干组，只有在某一组的所有人全部过桥后，其余的组才能过桥。桥最大承重为WWW，问这些人全部过桥的最短时间。
100≤W≤400100\le W \le400100≤W≤400 ，1≤n≤161\le n\le 161≤n≤16，1≤t≤501\le t\le501≤t≤50，10≤w≤10010\le w\le10010≤w≤100。

数据范围较小，可以进行状压，我们发现这题的关键就是分组别的规划。故我们可以设状态f[i]f[i]f[i]，表示状态为iii下过桥最少要用的时间。
状态iii表示把每个人选或不选压为二进制。
故有f[i]=min{f[j]+mt[i xor j]}f[i]=min\{ f[j]+mt[i\,xor\,j]\}f[i]=min{f[j]+mt[ixorj]}
其中i xor ji\,xor\,jixorj表示iii种除jjj外剩余的子集，前提jjj是iii的子集
但是我们对于每个状态要统计他们的最大重量和和时间，每个状态都是二进制数，怎么分别取出有没有人在其中呢？
这就是这章要讲的——枚举子集。
怎么枚举？先看代码。
int ml=1&lt;&lt;n;    for(int i=0;i&lt;ml;i++)&#123;        for(int j=i;;j=(j-1)&amp;i)&#123;	        // j是i的一个非空子集		    // ...        &#125;    &#125;
我怎么证明这个是对的呢？
我们枚举一下，看下图。

详细证明如下：

遍历子集的时间复杂度是O(3n)O(3^n)O(3n)
故我们可以得到转移代码如下：
for(int i=0;i&lt;ml;i++)&#123;    for(int j=i;;j=(j-1)&amp;i)&#123;        if(mw[i^j]&lt;=w)&#123;            f[i]=min(f[i],f[j]+mt[i^j]);        &#125;        if(!j) break;    &#125;&#125;
拼装一下，AC代码如下
#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MN=450,MF=(1&lt;&lt;16)+15;int w,n;int t[MN],wei[MN],ml,f[MF],mt[MF],mw[MF];int main()&#123;    cin&gt;&gt;w&gt;&gt;n;    ml=(1&lt;&lt;n);    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;t[i]&gt;&gt;wei[i];    &#125;    for(int i=0;i&lt;ml;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(i&amp;(1&lt;&lt;(j-1)))&#123;                mt[i]=max(mt[i],t[j]);                mw[i]+=wei[j];            &#125;        &#125;    &#125;    memset(f,0x3f,sizeof(f));    f[0]=0;    for(int i=0;i&lt;ml;i++)&#123;        for(int j=i;;j=(j-1)&amp;i)&#123;            if(mw[i^j]&lt;=w)&#123;                f[i]=min(f[i],f[j]+mt[i^j]);            &#125;            if(!j) break;        &#125;    &#125;    cout&lt;&lt;f[ml-1];    return 0;&#125;
 3.状压DP的拓展，三进制优化+DFS（例题引入）
来看题
P7689

给定N×MN \times MN×M的矩形，让你在上面放尽量多的2×32\times 32×3的矩形（或3×23\times 23×2，就是横着竖着都可以放），矩形上有一些坏点，放置的矩形不能覆盖这些坏点，求最多能放多少个矩形。
多组测试数据，1≤T≤5,1≤N≤150,1≤M≤101\le T\le 5,1\le N \le 150,1\le M \le 101≤T≤5,1≤N≤150,1≤M≤10
内存限制：8MB;时间限制：2s

我们不难可以用类似P1879或炮兵阵地类似的思想，也就是平面覆盖问题。但是这里出现一个问题，这里的宽是2或3！如果单纯用二进制枚举的话转移方程会十分甚至九分的复杂，而且状态还不好表示。
那我们就可以使用三进制，三进制的一个好处就是数字拓展到0,1,20,1,20,1,2，那么对于这个题来说，我们使用三进制枚举，按行自上往下递推。
那么就是以下2个合法状态：

我们从右往左按列枚举当前行，记当前位置为pospospos，分2种情况：

如果枚举到pospospos位，如果上一行对应的不是0，那么我们就要根据上图，填写相应的数，就是2→1,1→02\rightarrow 1,1\rightarrow 02→1,1→0。如果当前位置是坏的无法填写，那么排除。
如果是0，那么我们3种情况

填0直接跳过
填1，前提是右边3个都能够填写上1，这里判断方法其实和上面是一样的。
填2，右边2个要都能填写上2，同上



但是这么麻烦的情况，转移方程真的不太好得出。
没关系，DP2种实现方式，一种叫迭代，另一种叫记忆化搜索。
这里我们定义f[i][j]f[i][j]f[i][j]表示第iii行填写的状态为jjj(jjj为三进制数)
那么就可以从i−1i-1i−1转移过来，但是这里的内存限制是8MB，没关系滚一滚就好了。
#include&lt;bits/stdc++.h&gt;using namespace std;// 定义常量与全局变量constexpr int MN=16; // 最大列数（题目中M≤10，此处设为16足够）constexpr int NINF=-1061109567; // 极大负数，用于初始化DP数组int T,n,m,k; // 测试用例数，硅片的行数，列数，坏块数量int f[2][1&lt;&lt;MN]; // DP数组，滚动数组存储前两行状态，2表示滚动，1&lt;&lt;MN是三进制状态数上限int pw[MN]; // 3的幂次数组，用于三进制位运算bool isbad[MN][MN]; // 标记硅片中坏块的位置// 获取三进制数的第pos位数值（0/1/2）int getn(int x,int pos)&#123;    return x%pw[pos]/pw[pos-1];&#125;// 判断当前位置是否可以放置芯片bool isok(int x,int lst,int pos)&#123;    // 当前位置非坏块，且上一行对应位置为0    if(!isbad[x][pos]&amp;&amp;!getn(lst,m-pos+1)) return 1;    return 0;&#125;// 深度优先搜索生成当前行的合法状态并更新DP值void dfs(int x,int lst,int now,int pos,int cnt)&#123;    if(!pos)&#123; // 所有列处理完毕        // 更新当前行now状态的最大芯片数：前一行lst的值 + 当前cnt        f[x%2][now] = max(f[x%2][now], f[(x-1)%2][lst] + cnt);        return;    &#125;    // 处理上一行当前列非0的情况（受约束）    if(getn(lst,pos))&#123;        // 当前列损坏则无法放置        if(isbad[x][m-pos+1]) return;        // 根据上一列的值决定当前列只能为1或0        if(getn(lst,pos)==2) dfs(x,lst,now*3+1,pos-1,cnt); // 上一列是2 → 当前列必须为1        else dfs(x,lst,now*3,pos-1,cnt); // 上一列是1 → 当前列必须为0    &#125;else&#123;        // 不放置任何芯片，直接跳过        dfs(x,lst,now*3,pos-1,cnt);        // 尝试放置3×2竖直芯片（需要连续两列）        if(pos&gt;=2 &amp;&amp;            isok(x,lst,m-pos+1) &amp;&amp;            isok(x,lst,m-pos+2))&#123;            dfs(x,lst,(now*3+2)*3+2,pos-2,cnt+1);        &#125;        // 尝试放置2×3水平芯片（需要连续三列）        if(pos&gt;=3 &amp;&amp;            isok(x,lst,m-pos+1) &amp;&amp;            isok(x,lst,m-pos+2) &amp;&amp;            isok(x,lst,m-pos+3))&#123;            dfs(x,lst,((now*3+1)*3+1)*3+1,pos-3,cnt+1);        &#125;    &#125;&#125;// 处理单个测试用例void solve()&#123;    memset(isbad,0,sizeof(isbad)); // 清空坏块标记    memset(f,-0x3f3f3f3f,sizeof(f)); // 初始化DP数组为极小值    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=1;i&lt;=k;i++)&#123; // 读取坏块坐标        int x,y;        cin&gt;&gt;x&gt;&gt;y;        isbad[x][y]=1;    &#125;    f[0][0]=0; // 初始状态：0行0状态对应0芯片    for(int i=0;i&lt;n;i++)&#123; // 处理每一行（从0到n-1对应第1到第n行）        for(int j=0;j&lt;pw[m];j++)&#123; // 清空下一行的DP值            f[(i+1)%2][j]=NINF;        &#125;        for(int j=0;j&lt;pw[m];j++)&#123; // 遍历上一行所有可能状态            if(f[i%2][j]&lt;0) continue; // 跳过无效状态            dfs(i+1,j,0,m,0); // 从当前行初始状态开始递归生成        &#125;    &#125;    cout&lt;&lt;f[n%2][0]&lt;&lt;&#x27;\n&#x27;; // 输出最终结果：最后一行状态0的最大值&#125;int main()&#123;    pw[0]=1; // 初始化3的0次幂    for(int i=1;i&lt;MN;i++)&#123; // 预计算3的幂次数组        pw[i]=pw[i-1]*3;    &#125;    cin&gt;&gt;T;    while (T--)&#123;        solve(); // 处理每组数据    &#125;    return 0;&#125;
一般来说，三进制优化DP使用DFS来进行编写。
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>猫树分治</title>
    <url>/posts/e9478aba/</url>
    <content><![CDATA[猫树，整体二分与线段树分治的结合，前者我快忘了，后者更是学都没学过 www。
说人话，就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。构造要执行 O(nlog⁡n)O(n\log n)O(nlogn) 次合并操作，而查询可以加速到 O(1)O(1)O(1) 次合并操作。
猫树问题可以适用于离线解决以下类型的数据结构问题：

与序列有关，且询问是一段区间。
序列静态，即，不涉及修改操作。

当然离不离线都可以，由于其过程类似于点分治，所以在线的情况可通过类似于建出建出点分治的情况动态维护。
我们通过一道例题来进行引入：

给你一个长为 nnn 的序列 aaa，有 qqq 次询问，每次询问区间 [l,r][l,r][l,r] 的最大值和最大值个数，可以离线。
1≤n≤2×105,1≤q≤7×106,1≤l≤r≤n,1≤ai≤1091\le n\le 2\times 10^5,1\le q \le 7\times 10^6,1\le l\le r\le n,1\le a_{i}\le 10^91≤n≤2×105,1≤q≤7×106,1≤l≤r≤n,1≤ai​≤109。

显然你会线段树，但是在 q≤7e6q\le 7e6q≤7e6 的等级下你还是别想了，也就是说我们必须严格 O(1)O(1)O(1) 回答每一次询问，但是我们预处理的时间复杂度算是比较充裕的 O(nlog⁡n)O(n\log n)O(nlogn)。
先离线询问，然后我们考虑一种序列分治的思想，即我们对于一个序列取中点 midmidmid 进行分治，那么会分成 [l,mid][l,mid][l,mid] 和 [mid+1,r][mid+1,r][mid+1,r] 的两个部分。对于询问区间在左部分和右部分的我们可以让递归下去的分治解决。那么现在就剩下一种了，就是跨 midmidmid 的询问区间。
我们考虑怎么处理询问，有一种思路就是我们从 midmidmid 开始，向左预处理后缀最大值数组 sufsufsuf，向右预处理前缀最大值数组 preprepre，同理最大值个数，这里不再提及。那么我们处理查询的时候只需要将 suflsuf_{l}sufl​ 和 prerpre_{r}prer​ 的答案合并起来就可以了……没了？
我们分析下复杂度，我们发现每次操作都是 O(n)O(n)O(n) 的，然后递归复杂度是 T(n)=2T(n/2)+O(n)T(n)=2T(n/2)+O(n)T(n)=2T(n/2)+O(n)，答案是显然的 O(nlog⁡n)O(n\log n)O(nlogn)，离线状态下的空间复杂度也是优秀的 O(log⁡n)O(\log n)O(logn)，但每次处理询问是 O(1)O(1)O(1) 的！
这个就是猫树，我们下面详细解释实现：具体的，考虑分治区间 [l,r][l, r][l,r] 时，将所有满足 [L,R]⊆[l,r][L, R] \subseteq [l, r][L,R]⊆[l,r] 的区间压入一个 vector。
如果 l=rl = rl=r，那答案一般是比较好求的，直接算就行了。
否则设 mid=⌊l+r2⌋mid = \left\lfloor \frac{l + r}{2} \right\rfloormid=⌊2l+r​⌋，然后对于 i∈[l,mid]i \in [l, mid]i∈[l,mid] 扫一遍处理 [i,mid][i, mid][i,mid] 的答案，再对 i∈[mid+1,r]i \in [mid + 1, r]i∈[mid+1,r] 扫一遍处理 [mid+1,i][mid + 1, i][mid+1,i] 的答案，这样处理某个询问 [L,R][L, R][L,R] 时：

如果 [L,R]⊆[l,mid][L, R] \subseteq [l, mid][L,R]⊆[l,mid]，则把它放到左边区间的 vector 里递归；
如果 [L,R]⊆[mid+1,r][L, R] \subseteq [mid + 1, r][L,R]⊆[mid+1,r]，则把它放到右边区间的 vector 里递归；
如果 L∈[l,mid],R∈[mid+1,r]L \in [l, mid], R \in [mid + 1, r]L∈[l,mid],R∈[mid+1,r]，则将 [l,mid][l, mid][l,mid] 和 [mid+1,r][mid + 1, r][mid+1,r] 的答案合并即可。

不难发现，在上述做法中，我们通过分治把 log⁡n\log nlogn 的复杂度和单次插入的复杂度摊到了一起，这样每次询问时只用合并一次。如果我们记插入的复杂度为 Tinsert(n)T_{\text{insert}}(n)Tinsert​(n)，那么上述算法的复杂度就是：nlog⁡n⋅Tinsert(n)+q⋅Tmerge(n)n \log n \cdot T_{\text{insert}}(n) + q \cdot T_{\text{merge}}(n)nlogn⋅Tinsert​(n)+q⋅Tmerge​(n)
当然如果强制在线也做得了，直接对每一层分治记录下 [i,mid],[mid+1,j][i, mid], [mid + 1, j][i,mid],[mid+1,j] 的答案，这样可以做到强制在线，复杂度为：nlog⁡n⋅Tinsert(n)+qlog⁡n⋅Tmerge(n)n \log n \cdot T_{\text{insert}}(n) + q \log n \cdot T_{\text{merge}}(n)nlogn⋅Tinsert​(n)+qlogn⋅Tmerge​(n)当然这种空间可能略有点危，如果记我们单个合并的信息的空间复杂度为 M(n)M(n)M(n)，那么该做法空间复杂度为：nlog⁡n⋅M(n)n \log n \cdot M(n)nlogn⋅M(n)。具体的，将序列长度扩充至 222 的幂（维护区间为 [1,2h][1, 2^h][1,2h]），我们考虑将这个区间建成一颗分治树。虽然这是一颗满二叉树，那么我们要找的节点必然是 [l,l][l, l][l,l] 和 [r,r][r, r][r,r] 的 LCA。我们采用堆式存储，即节点 iii 的左儿子编号为 2i2i2i，右儿子为 2i+12i+12i+1。观察其二进制形式，不难发现：每一个左儿子的编号相当于父结点编号左移一位，右儿子则是左移一位加一。所以代表 [l,l][l, l][l,l] 和 [r,r][r, r][r,r] 这两个区间的两个节点的 LCA 必然是两者编号在二进制下的最长相同前缀（只适用于在同一深度的节点）。至于这两点的编号是多少，我们可以在预处理时提前存储，这样，我们单次查询的时间复杂度为 O(1)O(1)O(1)。假设节点编号分别为 x,yx, yx,y，那么他们的 LCA 编号便是：
x&gt;&gt;log⁡2(x⊕y)x &gt;&gt; \log_2(x \oplus y)
x&gt;&gt;log2​(x⊕y)
这里 log⁡2[k]\log_2[k]log2​[k] 存储的是 kkk 在二进制表示下有多少位。
当然离线询问更好写，这里贴以下来自[数据结构入门]分治树（猫树） - Dfkuaid - 博客园 的在线的区间最大子段和：
/*SPOJ GSS1 https://www.spoj.com/problems/GSS1/ */const int N = 1000100;const int INF = 0x3fffffff;int loc[N],a[N],n,m,len = 1;int s[25][N],p[25][N],lg[N];/*s 是不能与 mid 断开的前后缀，p 是可与 mid 断开的最大子段*/inline int Max(const int &amp;a,const int &amp;b)&#123;    return a &gt; b ? a : b;&#125;inline void build(int k,int l,int r,int d)&#123;    if (l == r) &#123;loc[l] = k;return;&#125; //叶节点，记录编号    int mid = (l + r) &gt;&gt; 1;    int pre,sm;    /*维护 mid 左边*/    s[d][mid] = a[mid],p[d][mid] = a[mid];    pre = sm = a[mid];sm = sm &gt; 0 ? sm : 0;    for (int i = mid - 1;i &gt;= l;i --)&#123;        pre += a[i],sm += a[i];        s[d][i] = Max(s[d][i + 1],pre),        p[d][i] = Max(p[d][i + 1],sm);        sm = sm &gt; 0 ? sm : 0;        /*如果小于零了，后面的维护可以        从中断开，保证最大值*/    &#125;    /*维护 mid 右边*/    s[d][mid + 1] = a[mid + 1],    p[d][mid + 1] = a[mid + 1];    pre = sm = a[mid + 1];  sm = sm &gt; 0 ? sm : 0;    for (int i = mid + 2;i &lt;= r;i ++)&#123;        pre += a[i],sm += a[i];        s[d][i] = Max(s[d][i - 1],pre);        p[d][i] = Max(p[d][i - 1],sm);        sm = sm &gt; 0 ? sm : 0;    &#125;    build(k &lt;&lt; 1,l,mid,d + 1);    build(k &lt;&lt; 1 | 1,mid + 1,r,d + 1);&#125;inline int query(int l,int r)&#123;    if (l == r) return a[l];    int d = lg[loc[l]] - lg[loc[l] ^ loc[r]];    return Max(Max(p[d][l],p[d][r]),s[d][l] + s[d][r]);&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    while (len &lt; n) len &lt;&lt;= 1;    for (int i = 1;i &lt;= n;i ++)      scanf(&quot;%d&quot;,&amp;a[i]);    for (int i = 1;i &lt;= len &lt;&lt; 1;i ++)      lg[i] = lg[i &gt;&gt; 1] + 1;    build(1,1,len,1);    scanf(&quot;%d&quot;,&amp;m);    while (m --)&#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        printf(&quot;%d\n&quot;,query(l,r));    &#125;    return 0;&#125;
P6240 好吃的题目
猫树分治背包，直接做即可，复杂度是 O(nVlog⁡n+qV)O(nV\log n+qV)O(nVlogn+qV)：
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e5+15,MV=255;int suf[MN][MV],pre[MN][MV],n,m,ql[MN],qr[MN],qt[MN],h[MN],w[MN],ans[MN];vector&lt;int&gt; qry;void solve(int l,int r,const vector&lt;int&gt; &amp;qry)&#123;    if(!qry.size()) return;    if(l==r)&#123;        for(auto p:qry)&#123;            if(qt[p]&gt;=h[l]) ans[p]=w[l];            else ans[p]=0;        &#125;        return;    &#125;    int mid=(l+r)&gt;&gt;1;    for(int i=l;i&lt;=r;i++)&#123;        memset(suf[i],0,sizeof(suf[i]));        memset(pre[i],0,sizeof(pre[i]));    &#125;    for(int i=mid;i&gt;=l;i--)&#123;        memcpy(suf[i],suf[i+1],sizeof(suf[i]));        for(int j=h[i];j&lt;MV;j++)&#123;            suf[i][j]=max(suf[i][j],suf[i+1][j-h[i]]+w[i]);        &#125;    &#125;    for(int i=mid+1;i&lt;=r;i++)&#123;        memcpy(pre[i],pre[i-1],sizeof(pre[i]));        for(int j=h[i];j&lt;MV;j++)&#123;            pre[i][j]=max(pre[i][j],pre[i-1][j-h[i]]+w[i]);        &#125;    &#125;    vector&lt;int&gt; qryl,qryr;    for(auto p:qry)&#123;        if(qr[p]&lt;=mid) qryl.push_back(p);        else if(ql[p]&gt;mid) qryr.push_back(p);        else&#123;            for(int i=0;i&lt;=qt[p];i++)&#123;                ans[p]=max(ans[p],suf[ql[p]][i]+pre[qr[p]][qt[p]-i]);            &#125;        &#125;    &#125;    solve(l,mid,qryl);    solve(mid+1,r,qryr);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;h[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;w[i];    &#125;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;ql[i]&gt;&gt;qr[i]&gt;&gt;qt[i];        qry.push_back(i);    &#125;    solve(1,n,qry);    for(int i=1;i&lt;=m;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;            return 0;&#125;
P6109 [Ynoi2009] rprmq1
先考虑没有修改怎么做，用 ST 表或者二维 BIT 简单维护即可。考虑有单点修改怎么做，ST 表当场坠机不过二维 BIT 还建在！考虑区间修改怎么做，发现极其难以直接进行维护。
注意到题目可以离线，而且一个很神秘的一点就是修改操作时小于查询的操作的，同时如果不仔细看，难发现所有查询操作在修改操作之后！
我们考虑这个矩形加 vvv 的操作怎么维护，我们发现这个玩意可以扫描线，例如 (l1,r1,l2,r2,v)(l1,r1,l2,r2,v)(l1,r1,l2,r2,v) 操作，可以对 [l1,r1][l1,r1][l1,r1] 进行扫描线，实现中我们将询问转化为两个区间端点上的修改即可，用历史和线段树维护 [l2,r2][l2,r2][l2,r2] 的范围，用历史和是因为我们求得是矩形最大值，用历史最大值可以表示一个矩形面内的答案。
但是问题在于如果我们要求的是一个时间段内的信息，历史和最大值比较难以做到多次撤销回退，快速对一个时间段求历史最大值做不了，但是可以对一个时间 lll 开始往后求 [l,r][l,r][l,r] 时间中的历史最大值。
考虑猫树分治，具体的，我们将所有询问对应的 l1,r1l1,r1l1,r1 挂到猫树上，从 mid 开始正反做两遍历史最大值即可求出所有挂在该节点的询问答案。 具体的就是我们现将 [l,mid][l,mid][l,mid] 的操作加入，在 mid+1mid+1mid+1 时刻清空历史最大值，从 [mid+1,r][mid+1,r][mid+1,r] 开始做历史最大值，并处理对应询问。接着猫树上递归 [mid+1,r][mid+1,r][mid+1,r]。对于左边 [l,mid][l,mid][l,mid] 同样不过就是反过来了，注意撤销 [mid+1,r][mid+1,r][mid+1,r] 的遗留答案，时间复杂度 O(mlog⁡2n+(n+q)log⁡n)O(m\log^2 n+(n+q)\log n)O(mlog2n+(n+q)logn)。
CF1100F Ivan and Burgers
线性鸡猫猫好题。
这道题我们可以直接把询问离线，然后上猫树分治。
具体地，我们用 O(log⁡∣V∣)O(\log |V|)O(log∣V∣) 的暴力预处理 [l,mid][l,mid][l,mid] 和 [mid+1,r][mid+1,r][mid+1,r] 的线性基，然后在合并的时候用 O(log⁡2∣V∣)O(\log^2 |V|)O(log2∣V∣) 的暴力合并跨越 midmidmid 的两个线性基答案，时间复杂度是 O(nlog⁡nlog⁡∣V∣+qlog⁡2∣V∣)O(n\log n\log |V|+q\log^2 |V|)O(nlognlog∣V∣+qlog2∣V∣)。
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>珂朵莉树</title>
    <url>/posts/e28fd031/</url>
    <content><![CDATA[ 0.前情提要

在学长的课上听到了颜色段覆盖问题，顺手讲了个ODT，当时的我以为就是一个可爱的数据结构，但是学下来发现确实很可爱(｡・ω・｡)
CF896C——ODT的起源


你需要知道——STL的set怎么用（cppreference）
对就这些。
 1.什么是珂朵莉树
珂朵莉树，又称ODT（老司机树），是一种利用set的暴力数据结构，用于解决区间问题的数据结构。
 2.珂朵莉树可以解决什么问题
区间推平问题出现的时候我们就可以用珂朵莉树了。她高效的基础是当数据随机生成的时候，复杂度是正确的（见下文），但是若没说，你就要开赌，这个很容易被构造数据卡掉。
 3.珂朵莉树的构造
借用一下大佬的图

对于珂朵莉树的节点，我们维护的是一个数值相同的区间，如上图。我们考虑维护一个三元组(l,r,val)(l,r,val)(l,r,val)，其中l和r是数值相同区间的左右端点，val就是这个区间对应的数值，那么每个相同数列的区间就可以浓缩为一个节点，如下图

当然在维护区间的时候我们要满足区间左端点和右端点都样单调递增，这里只需要比较左端点就可以了。
代码如下
当然对于CF896C我们一开始维护n个长度为1的单点
struct kdltree&#123;    int l,r;    mutable ll val;//set里面的元素一般不可修改，用mutable修饰就珂以修改    kdltree(int L,int R=-1,ll V=0)&#123;        //构造函数，左端点是必须有，若后面不添加R和V（就是val）默认就是单独的一个端点[pos,pos]        l=L,r=R,val=V;    &#125;    bool operator&lt;(const kdltree&amp;a)const&#123;        return l&lt;a.l;    &#125;&#125;;set&lt;kdltree&gt; odt;
 4.split分裂区间
如果我们想要的修改范围对于一个大区间来说小的话，我们就需要把区间拆开成我们想要的
split就是干这个的，他的唯一一个需要的参数就是pos，代表意义就是把一个[L,R][L,R][L,R]的区间劈成[L,pos−1][L,pos-1][L,pos−1],[pos,R][pos,R][pos,R]
很显然利用set的平衡树特性，我们可以用lower_bound函数找到其对应的区间节点
接下来分类讨论，其实也挺简单的

如果pos刚好是区间节点的左端点（就是找到pos的具体数值了），那么分裂都不用分，直接返回即可
如果不是，那么因为lower_bound是≥\ge≥的操作，那么这里返回的是pos右边对应的区间节点，那么我们只需要将获取到的迭代器it–就可以获得其对应的节点，让后一刀劈成[L,pos−1][L,pos-1][L,pos−1],[pos,R][pos,R][pos,R]

代码如下
//分割区间，把区间分成[l,pos-1],[pos,r]auto split(int pos)&#123;    auto it=odt.lower_bound(kdltree(pos));//找第一个左端点不小于pos的的区间    if(it!=odt.end()&amp;&amp;it-&gt;l==pos)&#123;        return it;//pos是左端点是无需分裂    &#125;    it--;//pos一定在前一个区间；    int l=it-&gt;l,r=it-&gt;r;    ll val=it-&gt;val;    odt.erase(it);//删除原来的区间    odt.insert(kdltree(l,pos-1,val));    return odt.insert(kdltree(pos,r,val)).first;//这里返回的是指向[pos,r]这个区间的迭代器&#125;
 5.区间推平
其实在构造区间节点的时候我们发现，这个数据结构其实就是天生适合区间推平这个操作的，因为她刚好存储的就是一个区间相同的值的。

例如我们将[2,8][2,8][2,8]这个区间推平改为666，set里面有4个区间节点。首先我们发现[8,10][8,10][8,10]是一个区间，那么要先split(8+1),拆成[8,8][8,8][8,8]和[9,10][9,10][9,10]两个区间。同理，[1,2][1,2][1,2]这个区间我们要拆成[1,1][1,1][1,1]和[2,2][2,2][2,2]
//合并区间并赋值xvoid merge(int l,int r,ll val)&#123;    //注意顺序！先右端点后左端点不然可能会RE！    auto itr=split(r+1);    auto itl=split(l);    odt.erase(itl,itr);//删除[l,r]区间内所有元素    //其实这里是[l,r+1)(由于set删除特性经典左闭右开)    //但是r+1取不到也就只能取到r了    odt.insert(kdltree(l,r,val));//插入大区间&#125;
注意这里不能先分左再分右！

先分左再分右，你会发现这个itr和itl指向的东西出事了，如果你erase就会出问题，直接RE
但是问题在于这个顺序反了也有可能会AC，这个RE的概率是大约1%，随机RE。十分的“珂”学。最好还是先右再左
 6.更新查询操作
对于任意的更新查询操作我们可以套如下的模板

先split右，在split左把区间[l,r][l,r][l,r]搞出来
暴力，启动！

这里我们贴上CF896C的几个操作，体会一下模板的套用(ﾟ∀。)

区间加

void add(int l,int r,ll val)&#123;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        it-&gt;val+=val;//这就是为啥用mutable的原因    &#125;&#125;
2.区间第k小
typedef pair&lt;ll,int&gt; kdl;//前人种树后人看动漫//区间第k小ll topk(int l,int r,int k)&#123;    vector&lt;kdl&gt; a;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        a.push_back(kdl(it-&gt;val,it-&gt;r-it-&gt;l+1));        //sort会先比较val，如果val相同则比较区间长度        //升序保证第k小，第k大倒序即可    &#125;       sort(a.begin(),a.end());    for(auto it=a.begin();it!=a.end();it++)&#123;        k-=it-&gt;second;        if(k&lt;=0)&#123;            return it-&gt;first;//找到了        &#125;    &#125;    return -1;//不好没找到&#125;

区间幂次和（这里使用的是快速幂）

ll fastpow(ll x,ll y,ll mod)&#123;    ll res=1;    x%=mod;    while (y&gt;0)    &#123;        if(y&amp;1)&#123;            res=res*x%mod;        &#125;        x=x*x%mod;        y&gt;&gt;=1;    &#125;    return res;&#125;ll sum(int l,int r,int x,int y)&#123;    ll ans=0;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        ans=(ans+fastpow(it-&gt;val,x,y)*(it-&gt;r-it-&gt;l+1))%y;    &#125;  
 7.时间复杂度
这里前提条件是数据随机情况下复杂度正确，如果数据不随机会出现O(nm)O(nm)O(nm)的错误时间复杂度
一般来说仅区间推平这一个区间操作的时间复杂度是均摊O(log2log2n)O(log_2log_2n)O(log2​log2​n),如果有暴力操作就是O(log2n)O(log_2n)O(log2​n),我们发现这个数据结构能够高效的关键在于区间推平，区间推平能把小区间合并成一个大区间，这是珂朵莉树高效的关键，也是她适用范围小的原因。
很容易被构造数据卡掉，导致变成一个一个散点。
 8.代码
#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define ll long longusing namespace std;const int MOD=1000000007,MN=1e5+15;ll n,m,seed,vmax;ll a[MN];ll rnd()&#123;    ll ret=seed;    seed=(seed*7+13)%MOD;    return ret;&#125;struct kdltree&#123;    int l,r;    mutable ll val;//set里面的元素一般不可修改，用mutable修饰就珂以修改    kdltree(int L,int R=-1,ll V=0)&#123;        //构造函数，左端点是必须有，若后面不添加R和V（就是val）默认就是单独的一个端点[pos,pos]        l=L,r=R,val=V;    &#125;    bool operator&lt;(const kdltree&amp;a)const&#123;        return l&lt;a.l;    &#125;&#125;;set&lt;kdltree&gt; odt;//分割区间，把区间分成[l,pos-1],[pos,r]auto split(int pos)&#123;    auto it=odt.lower_bound(kdltree(pos));//找第一个左端点不小于pos的的区间    if(it!=odt.end()&amp;&amp;it-&gt;l==pos)&#123;        return it;//pos是左端点是无需分裂    &#125;    it--;//pos一定在前一个区间；    int l=it-&gt;l,r=it-&gt;r;    ll val=it-&gt;val;    odt.erase(it);//删除原来的区间    odt.insert(kdltree(l,pos-1,val));    return odt.insert(kdltree(pos,r,val)).first;//这里返回的是指向[pos,r]这个区间的迭代器&#125;//合并区间并赋值xvoid merge(int l,int r,ll val)&#123;    //注意顺序！先右端点后左端点不然可能会RE！    auto itr=split(r+1);    auto itl=split(l);    odt.erase(itl,itr);//删除[l,r]区间内所有元素    //其实这里是[l,r+1)(由于set删除特性经典左闭右开)    //但是r+1取不到也就只能取到r了    odt.insert(kdltree(l,r,val));//插入大区间&#125;//所有的区间操作可以套一个模板//先split右，在split左把区间[l,r]搞出来//让后直接暴力！//区间加void add(int l,int r,ll val)&#123;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        it-&gt;val+=val;//这就是为啥用mutable的原因    &#125;&#125;typedef pair&lt;ll,int&gt; kdl;//前人种树后人看动漫//区间第k小ll topk(int l,int r,int k)&#123;    vector&lt;kdl&gt; a;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        a.push_back(kdl(it-&gt;val,it-&gt;r-it-&gt;l+1));        //sort会先比较val，如果val相同则比较区间长度        //升序保证第k小，第k大倒序即可    &#125;       sort(a.begin(),a.end());    for(auto it=a.begin();it!=a.end();it++)&#123;        k-=it-&gt;second;        if(k&lt;=0)&#123;            return it-&gt;first;//找到了        &#125;    &#125;    return -1;//不好没找到&#125;ll fastpow(ll x,ll y,ll mod)&#123;    ll res=1;    x%=mod;    while (y&gt;0)    &#123;        if(y&amp;1)&#123;            res=res*x%mod;        &#125;        x=x*x%mod;        y&gt;&gt;=1;    &#125;    return res;&#125;ll sum(int l,int r,int x,int y)&#123;    ll ans=0;    auto itr=split(r+1);    auto itl=split(l);    for(auto it=itl;it!=itr;it++)&#123;        ans=(ans+fastpow(it-&gt;val,x,y)*(it-&gt;r-it-&gt;l+1))%y;    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;vmax;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=rnd()%vmax+1;        odt.insert(kdltree(i,i,a[i]));    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int op=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y;        if(l&gt;r) swap(l,r);        if(op==3)&#123;            x=rnd()%(r-l+1)+1;        &#125;else x=rnd()%vmax+1;        if(op==4) y=rnd()%vmax+1;        if(op==1)&#123;            add(l,r,x);        &#125;else if(op==2)&#123;            merge(l,r,x);        &#125;else if(op==3)&#123;            cout&lt;&lt;topk(l,r,x)&lt;&lt;endl;        &#125;else cout&lt;&lt;sum(l,r,x,y)&lt;&lt;endl;    &#125;    return 0;&#125;
 10.拓展
ODT映射思想的推广
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂优化DP</title>
    <url>/posts/d1a4963/</url>
    <content><![CDATA[ 0. 前言
本文章还是不太完善的，这篇文章也只是我个人的一个经验总结，希望能帮助到后人学习。
 1.矩阵小芝士
矩阵优化是干啥的啊？
有的时候，你会发现你设计了一个极好的 DP 状态，没有后效性，没有重叠，你很开心，你去看数据范围就会炸掉！你死活都想不出来怎么优化，感觉去掉这个状态之后就感觉 “不完美” 了，让后点开题解，发现一堆密密麻麻的数学公式和矩阵，开心的点进去，郁闷的叉掉，那么怎么解决这种郁闷心情呢？当然就是学矩阵优化啦
好端端的那么优美的递推式子我们为什么要用矩阵来转移呢？答案很简单，因为矩阵乘法有结合律，可以快速幂！当转移式子固定的时候，我们可以通过快速幂，设置好初始矩阵和转移矩阵，通过矩阵快速幂就能轻轻松松的将复杂度变成 log⁡\loglog，是不是很好？（怎么可能？）
我们介绍一下矩阵乘法：
设 A=(ai,j)m×n,B=(bi,j)n×sA=(a_{i,j})_{m\times n},B=(b_{i,j})_{n\times s}A=(ai,j​)m×n​,B=(bi,j​)n×s​，定义 C=A×B=(ci,j)m×sC=A\times B=(c_{i,j})_{m\times s}C=A×B=(ci,j​)m×s​，其中
ci,j=∑k=1nai,kbk,jc_{i,j}=\sum_{k=1}^na_{i,k}b_{k,j}
ci,j​=k=1∑n​ai,k​bk,j​
即 AAA 的第 iii 行与 BBB 的第 jjj 列相乘得到 CCC 的 (i,j)(i,j)(i,j) 元素。
向量可以视为 1×n1\times n1×n 或 n×1n\times 1n×1 的矩阵，类似定义向量和矩阵的乘法。
矩阵乘法满足结合律和分配律，但不满足交换律。
不只是普通乘法，我们还有广义矩阵乘法！
一些约定：

⊗\otimes⊗ 有交换律：a⊗b=b⊗aa\otimes b=b\otimes aa⊗b=b⊗a；
⊗\otimes⊗ 有结合律：(a⊗b)⊗c=a⊗(b⊗c)(a\otimes b)\otimes c=a\otimes (b\otimes c)(a⊗b)⊗c=a⊗(b⊗c)；
⊗\otimes⊗ 对 ⊕\oplus⊕ 有分配律：a⊗(b⊕c)=(a⊗b)⊕(a⊗c)a\otimes (b\oplus c)=(a\otimes b)\oplus(a\otimes c)a⊗(b⊕c)=(a⊗b)⊕(a⊗c)；

若 ⊗\otimes⊗ 满足交换律、结合律，⊗\otimes⊗ 对 ⊕\oplus⊕ 有分配律，那么我们就有广义矩阵乘法：
(A×B)i,j=⨁k(Ai,k⊗Bj,k)(A\times B)_{i,j}=\bigoplus_{k}(A_{i,k}\otimes B_{j,k})
(A×B)i,j​=k⨁​(Ai,k​⊗Bj,k​)
广义矩阵乘法也同样满足普通矩阵乘法的结合律、分配律。
例如 ⊕\oplus⊕ 是 min⁡\minmin 或 max⁡\maxmax，⊗\otimes⊗ 是 +++。
广义上说，只要我们内层的运算具有结合律，外层的运算对于内存运算有分配律，并且状态转移递推恒定，并且发现转移来的状态数少但转移次数极大，我们就可以考虑矩阵优化DP。
严谨的讲，其实矩阵优化的本质就是线性递推 DP 方程，也就是从 iii 推到 i+1i+1i+1 的状态。比如说 f(i,j)f(i,j)f(i,j) 我们对 jjj 一维优化，通过转移矩阵我们可以将 f(i,j)→f(i,j+1)f(i,j) \rightarrow f(i,j+1)f(i,j)→f(i,j+1)。
设矩阵规模为 n×nn\times nn×n，转移阶段为 mmm，则复杂度为 n3log⁡mn^3 \log mn3logm，瓶颈在矩阵快速幂。
我们这里给出一个封装好的矩阵，其中 MN 需要额外定义常量。
struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=0)&#123;        memset(mat,0,sizeof(mat));        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;Matrix ksm(Matrix a,int b)&#123;    Matrix ret(1);    while(b)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;
 2.矩阵优化操作手册
Luogu P1962 斐波那契数列
斐波那契数列是满足如下性质的一个数列：
fn={1 (n≤2)fn−1+fn−2 (n≥3)f_n = \left\{\begin{aligned} 1 \space (n \le 2) \\ f_{n-1}+f_{n-2} \space (n\ge 3) \end{aligned}\right.
fn​={1 (n≤2)fn−1​+fn−2​ (n≥3)​
请你求出 fn mod 109+7f_n \bmod 10^9 + 7fn​mod109+7 的值。
这个题看起来还挺简单的，不就是斐波那契数列递推吗，直接 O(n)O(n)O(n) 乱搞就可以了。
但是 nnn 太大了怎么办？
我们发现，如果你想递推出 fnf_nfn​ 你需要用到 fn−1,fn−2f_{n-1},f_{n-2}fn−1​,fn−2​ 的数据，而且这个也类似于一个 “DP转移”，而且不难发现每一次只用到上面两个的数据，转移来的状态极少，我们就可以考虑矩阵优化喽。
通过简单的例题我们来介绍以下矩阵优化的 “操作手册”。
 写出转移方程，判断优化类型
对于一般的矩阵优化方程，它的转移方程一般是不难写出来的，但是你会通常会发现其中一个维度数量极其大，转移十分困难，空间也十分困难，而且一个特征就是转移的式子很简单，近似于线性递推而且转移来的状态数量极少，这种就是矩阵优化的鲜明特征。
这里我们的方程就是：
fn={1 (n≤2)fn−1+fn−2 (n≥3)f_n = \left\{\begin{aligned} 1 \space (n \le 2) \\ f_{n-1}+f_{n-2} \space (n\ge 3) \end{aligned}\right.
fn​={1 (n≤2)fn−1​+fn−2​ (n≥3)​
然而有的时候你可能看不出来维度数量极其大，这种我的建议就是你在设计 DP 的时候要写全，就是方程写出来，初始化设置好，计算好空间。
 确定优化维度
我们要确定我们是要对哪一维度，普遍都是对那些数极其大的状态维度进行优化，有的时候可能不太一样，需要自行判断。
这里的优化维度显然就是 fnf_nfn​ 的 nnn。
 根据转移方程需要的量，确定初始矩阵
确定初始矩阵实际上就是我们到底在转移需要什么数据才能转移到 iii，这些数据可以通过转移方程来知道。
注意到，我们的转移方程需要的是前两个数，于是我们的初始矩阵可以这么设置：
[fnfn−1]\begin{bmatrix}
 f_n &amp; f_n-1
\end{bmatrix}[fn​​fn​−1​]
你这不对吧，fn−2f_{n-2}fn−2​ 呢？
事实上，你应当回忆第一节后面我们讲的，矩阵优化的本质就是线性递推 DP 方程。我们从 fnf_nfn​ 推到 fn+1f_{n+1}fn+1​ 需要什么数据呢？回看转移方程，我们需要 fnf_{n}fn​ 和 fn−1f_{n-1}fn−1​，所以我们在初始矩阵这样设置。
那么初始设置就是 [1,1][1,1][1,1]，与方程对应。
初始矩阵的实质？它是动态规划中递推起点的状态值所构成的急诊，必须包含递推所需的全部初始状态，只有包含这些初始状态才能推到后面的状态。
一般来说，我们的初始矩阵大多是是一个向量的形式存在，我们的初始矩阵其实就是用来存状态的。
大多数时候初始矩阵的如果不填则默认为 0，但有的时候因为运算的限制我们需要填写负无穷（例如出现负数的时候或者取 max⁡\maxmax 操作）
 设计转移矩阵
难点来了，我们考虑如何设计转移矩阵。
我们回忆一下矩阵乘法的操作：

图画的不好，请见谅，但大体上是这个操作，我们考虑我们的转移方程该怎么操作。
首先明确目标，我们是要从 fnf_nfn​ 递推到 fn+1f_{n+1}fn+1​。我们目前有转移到 fn+1f_{n+1}fn+1​ 的必须数据——前两项。
接下来我们确定转移后的数据，转移后我们要递推 fn+2f_{n+2}fn+2​，就需要 fn+1,fnf_{n+1},f_nfn+1​,fn​ 的数据，而原来矩阵的 fn−1f_{n-1}fn−1​ 的数据以及没用了，我们就可以舍弃，那么我们列出初始矩阵和转移后的目标矩阵。
接下来是填空时间！请读者自行填空。若感到吃力可以看上面我们矩阵运算的示意图。答案下面会给出

我们总结一下这个步骤：

确定转移矩阵大小。
确定初始矩阵转移后的目标矩阵。
根据转移方程和目标矩阵，列出转移矩阵。
利用转移矩阵模拟运算后是否能得出目标矩阵的结果。

答案如下：

 确定转移顺序，确定快速幂的幂数
我们不妨设初始矩阵为 AAA，转移矩阵为 GGG。
那么求 fnf_nfn​ 的过程就是 A×G×G×⋯×GA\times G \times G \times \dots \times GA×G×G×⋯×G。
注意到一开始说矩阵乘法是有结合律的，考虑直接把后面结合起来，注意到是一个幂的形式，于是我们就可以快速幂了！
那为什么需要这一步呢，是因为有的时候转移过程中因为题目条件矩阵转移顺序有所变化，所以我们可能需要中断转移改变转移矩阵，这里下面的例题会讲到。
在这里我们需要确定矩阵快速幂的幂数，注意到我们初始矩阵是 [f2,f1][f_2,f_1][f2​,f1​] （不能用 f0f_0f0​ 因为就没有第 0 项），那么我们总共需要递推 n−2n-2n−2 次，所以快速幂的幂数就是 n−2n-2n−2。
 根据初始矩阵设计，确定答案统计范围
这个一般需要你通过初始矩阵设计来确定，可能是矩阵的某一项，或者矩阵一个范围。
 写代码，注意细节。
写代码的时候尤其要注意矩阵初始化的赋值，到底是 0 还是 -INF 还是 INF。一般来说矩阵都需要开 long long，注意__int128 的时候。
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int MOD=1e9+7,MT=5;struct matrix&#123;    ll mt[MT][MT]&#123;&#125;;    matrix operator *(const matrix &amp;x)&#123;        matrix ret;        for(int i=1;i&lt;=2;i++)&#123;            for(int j=1;j&lt;=2;j++)&#123;                for(int k=1;k&lt;=2;k++)&#123;                    ret.mt[i][j]+=mt[i][k]*x.mt[k][j]%MOD;                    // ret.mt[i][j]%=MOD;                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;ll n;matrix qp(matrix x,matrix ans,ll k)&#123;    while (k)    &#123;        if(k&amp;1)&#123;            ans=ans*x;        &#125;        x=x*x;        k&gt;&gt;=1;    &#125;    return ans;&#125;matrix ans,base;int main()&#123;    cin&gt;&gt;n;    if(n&lt;2)&#123;        cout&lt;&lt;n;        return 0;    &#125;    base.mt[1][1]=base.mt[1][2]=base.mt[2][1]=1;    ans.mt[1][1]=ans.mt[1][2]=1;    cout&lt;&lt;qp(base,ans,n-2).mt[1][1]%MOD;    return 0;&#125;
 3. 例题与TRICK
接下来是例题时间，对于每一个例题我们后面都会有对应的 TRICK 进行讲解。
 USACO07NOV Cow Relays G——Floyd倍增转移

给定一张 TTT 条边的无向连通图，求从 SSS 到 EEE 经过 NNN 条边的最短路长度。

你真的理解 Floyd 了吗？
我们回忆图的邻接矩阵，邻接矩阵的本质是矩阵，它原始表示图两点之间经过 111 条边的路径数量。
我们考虑 Floyd 算法本质上是在干什么，对于 3 层循环 (k,i,j)(k,i,j)(k,i,j)，其中 kkk 我们在枚举中间点，我们来看 Floyd 的转移：mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);。你会发现，这有点类似于广义矩阵乘法啊！
事实上，Floyd 枚举中间点的转移，事实上对于原来的邻接矩阵来说，从经过 1 条边到2 条边，从经过 2 条边到经过 3 条边，如此下去将所有边遍历完就能求出多源最短路了！
以下我们改写以下方程：
c[i][j]=min⁡(c[i][j],a[i][k]+b[k][j])c[i][j]=\min(c[i][j],a[i][k]+b[k][j])
c[i][j]=min(c[i][j],a[i][k]+b[k][j])
根据 Floyd ，aaa 矩阵是经过 xxx 条边的最短路，而 bbb 为经过 yyy 条边的最短路，那么 ccc 矩阵就是经过 x+yx+yx+y 的最短路，那么我们根据初始输入的数组，一开始是经过 111 条边的，那么转移 n−1n-1n−1 次就是我们想要的答案了，我们显然不能暴力转移，注意到满足广义矩阵乘法进行快速幂即可，注意实现细节。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=520;int n,t,s,e,tot;struct Matrix&#123;    int mt[MN][MN];    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ans;        memset(ans.mt,0x3f,sizeof(ans.mt));        for(int k=1;k&lt;=tot;k++)&#123;            for(int i=1;i&lt;=tot;i++)&#123;                for(int j=1;j&lt;=tot;j++)&#123;                    ans.mt[i][j]=min(ans.mt[i][j],mt[i][k]+x.mt[k][j]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;dis,ans;unordered_map&lt;int,int&gt; ump;Matrix ksm()&#123;    n--;    ans=dis;    while(n)&#123;        if(n&amp;1)&#123;            ans=ans*dis;        &#125;        dis=dis*dis;        n&gt;&gt;=1;    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;t&gt;&gt;s&gt;&gt;e;    memset(dis.mt,0x3f,sizeof(dis.mt));    for(int i=1;i&lt;=t;i++)&#123;        int u,v,w;        cin&gt;&gt;w&gt;&gt;u&gt;&gt;v;        if(!ump[u]) ump[u]=++tot;        if(!ump[v]) ump[v]=++tot;        dis.mt[ump[u]][ump[v]]=dis.mt[ump[v]][ump[u]]=w;    &#125;    cout&lt;&lt;ksm().mt[ump[s]][ump[e]];        return 0;&#125;
 经典图例题

给定一个 nnn 个点，mmm 条边的有向图，对于两个点之间要么不连边，要么边权为 111，求从起点出发长度为 kkk 到达终点的路径方案数（n≤500,m≤250n \le 500,m\le 250n≤500,m≤250，kkk 极大）。

先不考虑数据范围，我们可以用 DP 来解决。
设 f(i,j)f(i,j)f(i,j) 表示到第 iii 个点，路径长度为 jjj 的路径条数，注意到边权为 1 我们可以考虑直接通过相邻边转移即可，时间复杂度 O(mk)O(mk)O(mk)。
注意到 kkk 极大但 mmm 很小，也就是转移过来的状态数量极少，自然想到矩阵优化，那么我们根据什么列转移矩阵呢？我们可以考虑邻接矩阵，我们利用邻接矩阵类似floyd的方法来进行转移，时间复杂度 O(n3log⁡k)O(n^3 \log k)O(n3logk)。
 SCOI2009迷路——边权拆点

给定一个 nnn 个点，mmm 条边的有向图，边权为 www，求从 1 号点出发长度为 kkk 到达 nnn 号点的路径方案数（n≤10,w≤9n \le 10,w \le 9n≤10,w≤9，k≤109k\le 10^9k≤109）。

注意到这里边权为 www。我们矩阵的一个要求就是线性递推，从 k−1→kk-1 \rightarrow kk−1→k，但是这里因为有边权就不满足了，如何处理？
这里我们用到一个技巧叫做边权拆点，矩阵的要求就是线性递推，那么为了满足线性递推的要求，我们把一条边拆成一个一个边权为 1 的小边，同时我们把一个节点拆成 9 个点，分别表示周围边权为 1 到周围边权为9。对于拆点内部，我们让 (u,i)→(u,i+1)(u,i)\rightarrow (u,i+1)(u,i)→(u,i+1) 连边；对于拆点外部，我们让 (u,w)→(v,1)(u,w) \rightarrow (v,1)(u,w)→(v,1)。
例如 u→v,w=4u\rightarrow v,w=4u→v,w=4 这条边，我们就是将 (u,4)(u,4)(u,4) 连向 (v,1)(v,1)(v,1) 号节点。如此，这样构建能够保证当前图和原图等价，于是直接跑矩阵加速即可。
使用这个技巧的的前提是边权很小，这样我们才能用边权拆点。
拆点实际上就是将原图换为一个于此等价的图，使得题目中的特殊性质被满足，从而达到简化题目的目的。
我们其实也可以拆边，把边拆为点，但是我们应当在尽量满足题意的情况下尽量减少点的数量，从而减低复杂度，时间复杂度为 O((9n)3log⁡k)O((9n)^3 \log k)O((9n)3logk)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=100,MOD=2009;int n,t,tot,idx[MN][10];struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=0)&#123;        memset(mat,0,sizeof(mat));        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;     &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                    ret.mat[i][j]%=MOD;                &#125;            &#125;        &#125;        return ret;    &#125;&#125;A,G;Matrix ksm(Matrix a,int b)&#123;    Matrix ret(1);    while(b)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;void initG()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=9;j++)&#123;            idx[i][j]=++tot;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;9;j++)&#123;            G.mat[idx[i][j]][idx[i][j+1]]=1;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;t;    initG();    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            char c;            int num;            cin&gt;&gt;c;            num=c-&#x27;0&#x27;;            if(num&gt;0)&#123;                G.mat[idx[i][num]][idx[j][1]]=1;            &#125;        &#125;    &#125;    A=ksm(G,t);    cout&lt;&lt;A.mat[1][idx[n][1]]%2009;    return 0;&#125;
 SDOI2009 HH去散步——点边转化，超级源点

给定 nnn 个点，mmm 条无向边的图，边权均为 1，求从 S→TS\rightarrow TS→T 的路径上有多少长度为 ttt 的路径，满足上一步走过的路下一步不能重复走。答案对 459894598945989 取模。
1≤n≤50,1≤m≤60,t≤230,0≤S,T1\le n \le 50,1\le m \le 60,t\le 2^{30},0\le S,T1≤n≤50,1≤m≤60,t≤230,0≤S,T。

考虑DP，设 f(i,j)f(i,j)f(i,j) 表示走到第 iii 个点，路径长度为 jjj 的路径条数，显然有转移方程：
f(u,j)=∑v∈son(u)f(v,j−1)\begin{aligned} f(u,j)=\sum\limits_{v\in son(u)} f(v,j-1) \end{aligned}
f(u,j)=v∈son(u)∑​f(v,j−1)​
那你这方程也不对啊，题目说了满足上一步走过的路下一步不能重复走。那么接下来怎么在图上转移？
卡住了……但是我们发现边数极小！当然我们需要构造一个新图使得能够满足这个限制，考虑怎么构造？
注意到边数极小，我们可以利用点边互换的技巧！点边互换的核心思想是：把原图中的某些点看作边，或者把原图中的某些边看作点 ，从而构造一个新的图来满足题目中的限制。
边可以转为点，而点也可以转为边，这样的代价就是我们必须增加点的数量或边的数量。
那么我们修改一下转移方程，转移方程基本不变，但是转移有区别。
f(u,j)=∑v∈to(u)f(v,j−1)f(u,j)=\sum\limits_{v\in to(u)} f(v,j-1)
f(u,j)=v∈to(u)∑​f(v,j−1)
其中 to(u)to(u)to(u) 表示能够到达 uuu 点的边集，那么这个边集怎么搞呢，我们可以考虑割点！把每个点拆成相邻边数个点，第 iii 个点代表第 iii 条相邻的边走过来得点，让后该点向除第 iii 条边以外所连的点连一条单向边即可构造出新图。
但是 SSS 节点可能向周围任意一个点前进，不好在矩阵掌控，不妨考虑超级源点 0 号点，0 号点向 SSS 连边，只需要把 f0f_0f0​ 初始化为 1 即可跑矩阵优化。
对于每一个点，期望连边 2 条，都会割出 2 个点，最多 120120120 个点，时间复杂度 (m3log⁡k)(m^3 \log k)(m3logk)。
割点其实就是将每个点的不同状态放大化，使其“人格分裂”，从而将【节点的转移】转化为【状态的转移】，从而达到实现满足特殊条件约束的目的。 ——Ydtz的教程
 HAOI2015 数字串拆分——指数高精？发掘性质！
自己看题吧。
注意到 fff 可以 DP 求出，根据题意列出转移方程。
f(i)=∑j=max(i−m,0)i−1f(j)f(i)=\sum\limits_{j=max(i-m,0)}^{i-1} f(j)
f(i)=j=max(i−m,0)∑i−1​f(j)
初始 f(0)=1f(0)=1f(0)=1。
注意到 mmm 极小，而 ∣s0∣|s_0|∣s0​∣ 及其大，考虑矩阵优化，注意到这个和斐波那契数列的转移有点类似，不过要的是前 mmm 个数。
但是你会发现这个 ggg 的划分及其奇怪，并且转移的 1050010^{500}10500 太大了要指数高精，而且暴力划分 ggg 最大会有 2∣s0∣2^{|s_0|}2∣s0​∣ 种。
考虑分析 ggg 的划分形式，首先矩阵满足一个性质：
An+m=An×AmA^{n+m}=A^n \times A^m
An+m=An×Am
正确性是很显然的，例如 g(123)g(123)g(123) 可以分解为：
g(123)=f(1+2+3)+f(12+3)+f(1+23)+f(123)=f(1+2)×3+f(12)×f(3)+f(1)×f(23)+f(123)\begin{aligned} g(123) &amp; =f(1+2+3)+f(12+3)+f(1+23)+f(123) \\ &amp; = f(1+2) \times 3+f(12) \times f(3) +f(1) \times f(23)+f(123) \end{aligned}
g(123)​=f(1+2+3)+f(12+3)+f(1+23)+f(123)=f(1+2)×3+f(12)×f(3)+f(1)×f(23)+f(123)​
考虑按数位递推求解 ggg，设 gi′g_i&#x27;gi′​ 表示对于 sss 中前 iii 位数字的答案 ggg，考虑算 g(123)g(123)g(123) 时 g(12),g(1)g(12),g(1)g(12),g(1) 已经算过，考虑改写有：
g(123)=f(1+2)×3+f(12)×f(3)+f(1)×f(23)+f(123)=f(123)+g1′×f(23)+g2′×f(3)\begin{aligned} g(123) &amp; = f(1+2) \times 3+f(12) \times f(3) +f(1) \times f(23)+f(123) \\ &amp; = f(123) + g&#x27;_{1} \times f(23) +g&#x27;_{2} \times f(3)   \end{aligned}
g(123)​=f(1+2)×3+f(12)×f(3)+f(1)×f(23)+f(123)=f(123)+g1′​×f(23)+g2′​×f(3)​
答案即为 gn′g&#x27;_ngn′​。
问题转化为如何求出一个后缀字符串的 fff 值，考虑 fi,j′f&#x27;_{i,j}fi,j′​ 表示 sss 第 iii 位数字第 jjj 位数字组成的 fff 的转移矩阵，通过 fi,j′=f(10n−i)si×fi+1,j′f&#x27;_{i,j}=f(10^{n-i})^{s_{i}}\times f&#x27;_{i+1,j}fi,j′​=f(10n−i)si​×fi+1,j′​ 即可转移，预处理 f(10i)f(10^i)f(10i) 即可，其中 sis_isi​ 表示代表 sss 中第 iii 个数字的矩阵。
当我们发现指数需要高精，心中默念 “这题绝对不是让我指数高精，一定题目中有什么其他的特性在里面，如果山穷水尽可能我们还有特殊快速幂”，关于这个特殊快速幂我们下文会提到。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5,MOD=998244353;int m,len,ans;string s;struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=0)&#123;        memset(mat,0,sizeof(mat));        if(x==0) return;        for(int i=0;i&lt;MN;i++)&#123;            mat[i][i]=x;        &#125;    &#125;    void init(int x)&#123;        memset(mat,0,sizeof(mat));        if(x==0) return;        for(int i=0;i&lt;MN;i++)&#123;            mat[i][i]=x;        &#125;    &#125;    void initf()&#123;        for(int i=0;i&lt;m;i++) mat[i][m-1]=1;        for(int i=1;i&lt;m;i++) mat[i][i-1]=1;    &#125;        Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j]%MOD;                    ret.mat[i][j]%=MOD;                &#125;            &#125;        &#125;        return ret;    &#125;    Matrix operator+(const Matrix &amp;x)const&#123;        Matrix ret;         for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                ret.mat[i][j]=(mat[i][j]+x.mat[i][j])%MOD;            &#125;        &#125;        return ret;    &#125;&#125;pw[520],f[520][520],g[520];Matrix ksm(Matrix a,int b)&#123;    Matrix ret(1);    while(b&gt;0)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;signed main()&#123;    cin&gt;&gt;s&gt;&gt;m;    len=s.length();    s=&#x27; &#x27;+s;    pw[0].initf();    for(int i=1;i&lt;len;i++) pw[i]=ksm(pw[i-1],10);    for(int i=1;i&lt;=len;i++)&#123;        for(int j=i;j&gt;=1;j--)&#123;            if(i!=j)&#123;                f[j][i]=f[j+1][i]*ksm(pw[i-j],s[j]-&#x27;0&#x27;);            &#125;else&#123;                f[j][i]=ksm(pw[0],s[j]-&#x27;0&#x27;);            &#125;        &#125;    &#125;    g[0].init(1);    for(int i=1;i&lt;=len;i++)&#123;        for(int j=0;j&lt;i;j++)&#123;            g[i]=g[i]+(g[j]*f[j+1][i]);        &#125;    &#125;    for(int i=0;i&lt;m;i++) ans=(ans+g[len].mat[0][i])%MOD;    cout&lt;&lt;ans;    return 0;&#125;
 NOI2013 矩阵游戏——指数高精与费马小定理，10进制快速幂。
F[1,1]=1F[i,j]=a×F[i,j−1]+b,j≠1F[i,1]=c×F[i−1,m]+d,i≠1\begin{aligned}
F[1, 1] &amp;= 1 \\
F[i, j] &amp;=a\times F[i, j-1]+b, &amp;j\neq 1 \\
F[i, 1] &amp;=c\times F[i-1, m]+d, &amp;i\neq 1 \\
\end{aligned}F[1,1]F[i,j]F[i,1]​=1=a×F[i,j−1]+b,=c×F[i−1,m]+d,​j=1i=1​
不难发现是线性递推，考虑设置两个转移方程 M1,M2M1,M2M1,M2 分别表示转移列的和转移行的。
转移方程已经写出来了，我们考虑怎么设置初始转移，我们不难发现这个矩阵转移常数项怎么处理，对于常数项的处理我们一般是在初始矩阵中加一位列单独设置为 1，让后在之后的转移一直设置为 1，如果需要常数项我们就将对应位置改成 bbb 或 ddd 即可。
矩阵如下,列转移：
[f1]×[a0b1]=[f′1]\begin{bmatrix}
 f &amp; 1
\end{bmatrix}

\times \begin{bmatrix}
 a &amp; 0\\
 b &amp; 1
\end{bmatrix}

=
\begin{bmatrix}
 f&#x27; &amp; 1
\end{bmatrix}[f​1​]×[ab​01​]=[f′​1​]
行转移：
[f1]×[c0d1]=[f′1]\begin{bmatrix}
 f &amp; 1
\end{bmatrix}

\times \begin{bmatrix}
 c &amp; 0\\
 d &amp; 1
\end{bmatrix}

=
\begin{bmatrix}
 f&#x27; &amp; 1
\end{bmatrix}[f​1​]×[cd​01​]=[f′​1​]
对于转移实际上就是 A×(M1m−1×M2)n−1×M1m−1A \times ({M1}^{m-1}\times M2)^{n-1} \times {M1}^{m-1}A×(M1m−1×M2)n−1×M1m−1
注意到 n,mn,mn,m 的范围及其离谱，log⁡2\log_2log2​ 都搞不了。
等会 log⁡2\log_2log2​ 不行其他的 log⁡x\log_xlogx​ 是不是可以，我们可以考虑 10进制快速幂，让后就可以了！
显然我没写 10进制快速幂，心中默念是不是有没有什么性质。
注意到这个矩阵对于列的转移，其中 aaa 总共被乘上了 am−1a^{m-1}am−1 次，同理与 cn−1c^{n-1}cn−1，而注意到模数为质数，可以考虑费马小定理取模，模上 φ(MOD)\varphi(MOD)φ(MOD)即可。
注意到，当 a=c=1a=c=1a=c=1 时不能用费马小定理，考虑直接矩阵快速幂幂取模原来模数。
#include&lt;bits/stdc++.h&gt;#define int __int128using namespace std;constexpr int MN=15,MOD=1e9+7;int n,m,a,b,c,d,base0,base1;string sn,sm;struct Matrix&#123;    int mat[MN][MN];    // INIT THE MATRIX    Matrix(int x=0)&#123;        memset(mat,0,sizeof(mat));        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                    ret.mat[i][j]%=MOD;                &#125;            &#125;        &#125;        return ret;    &#125;&#125;M1,M2;Matrix ksm(Matrix A,int B)&#123;    Matrix ret(1);    while(B&gt;0)&#123;        if(B&amp;1) ret=ret*A;        A=A*A;        B&gt;&gt;=1;    &#125;    return ret;&#125;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;signed main()&#123;    read(sn,sm,a,b,c,d);    base0=(a==1?MOD:MOD-1);    for(auto p:sm)&#123;        m=((m&lt;&lt;3)+(m&lt;&lt;1)+(p^48))%(base0);    &#125;    Matrix ans;    M1.mat[0][0]=a,M1.mat[0][1]=b,M1.mat[1][1]=1;    M2.mat[0][0]=c,M2.mat[0][1]=d,M2.mat[1][1]=1;    ans.mat[0][0]=ans.mat[1][0]=1;    Matrix d=ksm(M1,(m+base0-1)%base0)*M2;    int base1;    if(d.mat[0][0]==1) base1=MOD;    else base1=MOD-1;    for(auto p:sn)&#123;        n=((n&lt;&lt;3)+(n&lt;&lt;1)+(p^48))%(base1);    &#125;    ans=ksm(d,(n+base1-1)%base1)*ksm(M1,(m+base0-1)%base0)*ans;    put(ans.mat[0][0]);    return 0;&#125;
 CF576D Flights for Regular Customers——强制中断，bitset优化
又是特殊限制，我们还是设DP。
设 f(i,j)f(i,j)f(i,j) 表示在第 iii 个点，在走过的边数为 jjj 的情况下是否能够到达（取值为0/1），由 j−1j-1j−1 可以转移过来，并且矩阵味很重，转移是或的关系，可以考虑矩阵优化。
考虑无解的情况怎么做，不妨假设 1 号节点边都可以走，如果都可以走的情况下还是到不了那就GG。
我们根据操作手册，发现在第五步就炸了，因为每一次 did_idi​ 的更新都需要重新设置转移矩阵，考虑根据 did_idi​ 的变化量进行快速幂，每一次中断跑多源BFS更新答案，让后就做完了。
我们不难发现 fff 的取值只有 0 或 1，可以利用 bitset优化，写的时候如下：
struct Matrix&#123;    bitset&lt;MN&gt; mat[MN];    Matrix(int x=0)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                mat[i][j]=0;            &#125;        &#125;        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int k=0;k&lt;MN;k++)&#123;                if(mat[i][k])&#123;// 把j省去了                    ret.mat[i]|=x.mat[k];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=250,INF=1e18;struct Edge&#123;    int u,v,d;&#125;e[MN];int n,m,ans,dis[MN];struct Matrix&#123;    bitset&lt;MN&gt; mat[MN];    Matrix(int x=0)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                mat[i][j]=0;            &#125;        &#125;        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int k=0;k&lt;MN;k++)&#123;                if(mat[i][k])&#123;                    ret.mat[i]|=x.mat[k];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;a,G;Matrix ksm(Matrix a,int b)&#123;    Matrix ret(1);    while(b&gt;0)&#123;        if(b&amp;1) ret=ret*a;        a=a*a;        b&gt;&gt;=1;    &#125;    return ret;&#125;bool cmp(Edge x,Edge y)&#123;    return x.d&lt;y.d;&#125;void bfs()&#123;    for(int i=1;i&lt;=n;i++) dis[i]=INF;    queue&lt;int&gt; q;    for(int i=1;i&lt;=n;i++)&#123;        if(a.mat[1][i]) q.push(i),dis[i]=0;    &#125;    while(!q.empty())&#123;        int f=q.front();        cerr&lt;&lt;f&lt;&lt;&#x27;\n&#x27;;        q.pop();        for(int i=1;i&lt;=n;i++)&#123;            if(G.mat[f][i]&amp;&amp;dis[i]==INF)&#123;                dis[i]=dis[f]+1;                q.push(i);            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].d;    &#125;    sort(e+1,e+1+m,cmp);    a.mat[1][1]=1,ans=INF,dis[n]=INF;    for(int i=1,lst=0;i&lt;=m;i++)&#123;        if(ans&lt;e[i].d) break;        int dt=e[i].d-lst;        lst=e[i].d;        a=a*ksm(G,dt);        G.mat[e[i].u][e[i].v]=1;        if(i==m||e[i+1].d!=e[i].d) bfs();        ans=min(ans,lst+dis[n]);    &#125;    if(ans==INF) cout&lt;&lt;&quot;Impossible&quot;;    else cout&lt;&lt;ans;    return 0;&#125;
 NOI2020 美食家——强制中断，二进制分组快速幂！

给定一张 nnn 个点 mmm 条边的有向图，有重边，边有时间 wiw_iwi​。每一个点有价值 ccc，走到点 iii 可以获得 cic_ici​ 的价值。
初始时间为 000，你需要从起点 111 开始走，恰好在 TTT 时间回到起点 111。最终得到的价值为所有经过的点的价值 ccc 的和，点可以被重复经过而且价值也可以重复累加。
不能在任何一个点停留，也就是说 ttt 时间到达一个点 t+1t+1t+1 时间必须往其他点走。
现在有 kkk 个特殊时间点，形式为三个参数 (ti,xi,yi)(t_i,x_i,y_i)(ti​,xi​,yi​)。表示恰好在 tit_iti​ 时间点到达点 xix_ixi​ 时可以得到 yiy_iyi​ 的额外价值。
求最终能获得的最大价值和，若无法在 TTT 时间回到起点，输出 −1-1−1。
1≤n≤50,n≤m≤500,0≤k≤2001\le n\le 50,n\le m \le 500,0 \le k \le 2001≤n≤50,n≤m≤500,0≤k≤200
1≤ti≤T≤109,1≤wi≤5,1≤ci≤52501,1≤yi≤1091\le t_{i}\le T \le 10^9,1\le w_{i}\le 5,1\le c_{i}\le 52501,1\le y_{i}\le 10^91≤ti​≤T≤109,1≤wi​≤5,1≤ci​≤52501,1≤yi​≤109
数据保证所有 tit_iti​ 互不相同，图一定联通。

一眼 DP（因为我也想不出来如何用贪心做www），考虑设 f(i,j)f(i,j)f(i,j) 表示到达第 iii 个点，当前时间为 jjj 的最大价值和，因为没有停留甚至都不用设置是否停留的状态太好啦。转移方程是显然的：
f(u,j)=max⁡v=fa(u)f(v,j−1)+w(u,v)\begin{aligned}
f(u,j)=\max\limits_{v=fa(u)}f(v,j-1)+w(u,v)
\end{aligned}
f(u,j)=v=fa(u)max​f(v,j−1)+w(u,v)​
这是转移方程，我们可以写成递推的形式，就不写出了。考虑特殊时间，直接用 map 存下来特判即可，这样我们就能拿到高贵的 40 分（环特判时间即可），对于性质 A 是一个大环直接瞎做即可，就有50分。
首先特别重要的一点，1≤wi≤5,n≤m≤5001\le w_{i} \le 5,n\le m \le 5001≤wi​≤5,n≤m≤500。如果这个图是一个完全图则对应的边数也太少了，每个点期望连边的边数很小，也就是说 DP 方程转移过来的状态数量极小，并且 wiw_iwi​ 极小，有因为取 max⁡\maxmax 和内部操作满足广义矩阵乘法，考虑矩阵优化+边权拆点。
不对啊，还是卡在了第五步，因为有特殊时间点的存在，我们可以想上面题一样强制中断快速幂，更新矩阵后再次快速幂，ok啊，写完，交上去发现只有75分（拼好分版本）。
怎么回事呢，原来是 kkk 太炸裂了，这样的时间复杂度为 O(k×(5n)3log⁡T)O(k\times (5n)^3 \log T)O(k×(5n)3logT)，只能过 k≤10k\le 10k≤10。
我们考虑怎么优化，发现每次中断转移后重新转移的Δt\Delta tΔt，Δt\Delta tΔt中有一些幂我们是重复在乘上的。
我们考虑对 Δt\Delta tΔt 进行二进制分解，首先我们写预处理转移矩阵 GGG
的幂 pw[i]pw[i]pw[i] ，(G1,G2,G4,…,G229)(G^1,G^2,G^4,\dots,G^{2^{29}})(G1,G2,G4,…,G229)，预处理的时间复杂度就是 O((5n)3log⁡T)O((5n)^3 \log T)O((5n)3logT)。让后我们每一次快速幂转移的时候，我们将 Δt\Delta tΔt 做二进制分解，将对应二进制数上的幂对应预处理的转移矩阵幂。让后我们让初始矩阵乘上这些 pw[i]pw[i]pw[i]，就可以了。
分析复杂度，不难发现我们的初始矩阵是一个 1 行 5n5n5n 列的向量，复杂度为 O(k×(5n)2log⁡T)O(k \times (5n)^2 \log T)O(k×(5n)2logT)，可以通过。
类似于这种凑 kkk 的多次询问或者需要多次用到凑 kkk，如果求解二进制整数幂答案的时间复杂度较低，可以考虑倍增+二进制拆分求解。
注意转矩阵乘法后千万不要思维定势，因为这里是取 max⁡\maxmax 操作，所有无用项和初始值为 -INF 而非 0。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=260,NINF=-1e18;struct Festival&#123;    int t,u,y;&#125;fst[MN];int logt,n,m,T,K,tot,idx[MN][MN],c[MN];struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=NINF)&#123;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                if(i==j) mat[i][j]=x;                else mat[i][j]=NINF;            &#125;        &#125;    &#125;    Matrix operator*(const Matrix &amp;x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    if(mat[i][k]==NINF||x.mat[k][j]==NINF) continue;                    ret.mat[i][j]=max(ret.mat[i][j],mat[i][k]+x.mat[k][j]);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;pw[55],A,B;void initA()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=5;j++)&#123;            idx[i][j]=++tot;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;5;j++)&#123;            A.mat[idx[i][j]][idx[i][j+1]]=0;           &#125;    &#125;&#125;void initpw(Matrix x)&#123;    pw[0]=x;    for(int i=1;i&lt;=logt;i++) pw[i]=pw[i-1]*pw[i-1];&#125;bool cmp(Festival x,Festival y)&#123;    return x.t&lt;y.t;&#125;Matrix ksmpw(Matrix a,int b)&#123;    for(int i=0;i&lt;=logt;i++)&#123;        if((b&gt;&gt;i)&amp;1)&#123;            Matrix ret;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    if(a.mat[1][k]==NINF||pw[i].mat[k][j]==NINF) continue;;                    ret.mat[1][j]=max(ret.mat[1][j],a.mat[1][k]+pw[i].mat[k][j]);                &#125;            &#125;            a=ret;        &#125;    &#125;    return a;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;T&gt;&gt;K;    logt=__lg(T);    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;c[i];    &#125;    initA();    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        A.mat[idx[u][w]][idx[v][1]]=c[v];    &#125;    for(int i=1;i&lt;=K;i++)&#123;        cin&gt;&gt;fst[i].t&gt;&gt;fst[i].u&gt;&gt;fst[i].y;    &#125;    sort(fst+1,fst+1+K,cmp);    initpw(A);    B.mat[1][idx[1][1]]=c[1];    int lst=0;    for(int i=1;i&lt;=K;i++)&#123;        B=ksmpw(B,fst[i].t-lst);        if(B.mat[1][idx[fst[i].u][1]]!=NINF) B.mat[1][idx[fst[i].u][1]]+=fst[i].y;        lst=fst[i].t;    &#125;    if(lst!=T) B=ksmpw(B,T-lst);    if(B.mat[1][idx[1][1]]==NINF) cout&lt;&lt;-1;    else cout&lt;&lt;B.mat[1][idx[1][1]];    return 0;&#125;
 POI 2015 WYC——倍增二分思想

给定一个 nnn 个点，mmm 条边的有向图，无自环有重边，边权为 www，求第 kkk 小路径长度（1≤n≤40,1≤m≤1000,1≤w≤31\le n \le 40,1\le m\le 1000,1 \le w \le 31≤n≤40,1≤m≤1000,1≤w≤3，k≤1018k\le 10^{18}k≤1018）。

A* ? 痴人说梦啊。
注意到又是经典的 n,wn,wn,w 极小，kkk 极大，稍微分析以下满足矩阵的特点，考虑矩阵递推+边权拆点，因为有重边所以不能单纯的矩阵设为 1，应当为G.mat[idx[u][c]][idx[v][1]]++;。但是我们怎么统计一个状态有多少路径呢？我们发现可以利用超级源点的思想，0 号点向他们连边，边权为0，这样就能够统计0 号点的路径了。
注意到我们需要找第 kkk 小，也就是凑 kkk，我们就可以利用前面提到的思想。注意到这个是一个倍增的形式，我们可以利用倍增二分的技巧找 kkk，时间复杂度就是O(n3log⁡k)O(n^3 \log k)O(n3logk)
注意开__int128
#include&lt;bits/stdc++.h&gt;#define int __int128using namespace std;constexpr int MN=150;int n,m,k,lgk,tot,idx[MN][5];struct Matrix&#123;    int mat[MN][MN];    Matrix(int x=0)&#123;        memset(mat,0,sizeof(mat));        if(!x) return;        for(int i=0;i&lt;MN;i++) mat[i][i]=x;    &#125;    Matrix operator*(const Matrix x)const&#123;        Matrix ret;        for(int i=0;i&lt;MN;i++)&#123;            for(int j=0;j&lt;MN;j++)&#123;                for(int k=0;k&lt;MN;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;a,G,pw[70];namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;void initG()&#123;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=3;j++) idx[i][j]=++tot;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;3;j++)&#123;            G.mat[idx[i][j]][idx[i][j+1]]++;        &#125;        G.mat[idx[i][1]][0]++;        a.mat[0][idx[i][1]]++;    &#125;    G.mat[0][0]++;&#125;signed main()&#123;    read(n,m,k);    initG();    for(int i=1;i&lt;=m;i++)&#123;        int u,v,c;        read(u,v,c);        G.mat[idx[u][c]][idx[v][1]]++;    &#125;    int i;    pw[0]=G;    for(i=1;;i++)&#123;        pw[i]=pw[i-1]*pw[i-1];        Matrix ret=a*pw[i];        if(ret.mat[0][0]-n&gt;=k) break;        if(i&gt;62)&#123;            cout&lt;&lt;-1;            return 0;        &#125;    &#125;    int ans=0;    for(;i&gt;=0;i--)&#123;        Matrix ret=a*pw[i];        if(ret.mat[0][0]-n&lt;k)&#123;            a=ret;            if(ret.mat[0][0]-n&lt;k) ans+=(1ll&lt;&lt;i);        &#125;    &#125;    put(ans);    return 0;&#125;
 CF1067D Computer Game——矩阵优化与斜率优化，倍增二分思想
首先这个升级显然是吓唬你的，因为我可以一直选一个游戏 van，所以我只需要看 bipib_{i}p_{i}bi​pi​ 最大就可以了。但是这里我们并不能考虑贪心，因为在时间短的情况下可能升级升不了，还是要 dp 的。
不难有 dp 方程如下，设 f(t)f(t)f(t) 表示还剩下 ttt 秒的最大期望，vvv 表示 bipib_{i}p_ibi​pi​ 的最大值：
f(t+1)=max⁡i=1n{pi(tv+ai)⏟升级成功+（1−pi)ft⏟升级失败}f(t+1)= \max_{i=1}^n \left\{ \underbrace{p_{i}(tv+a_i)}_{\text{升级成功}} +  \underbrace{（1-p_{i})f_t}_{\text{升级失败}}  \right\}
f(t+1)=i=1maxn​⎩⎪⎨⎪⎧​升级成功pi​(tv+ai​)​​+升级失败（1−pi​)ft​​​⎭⎪⎬⎪⎫​
时间复杂度 O(nt)O(nt)O(nt)
不难看出来可以斜率优化啊，但是我们要变下形式：
f(t+1)=max⁡i=1n{pi(tv+ai)+(1−pi)ft}=pitv+piai+ft−pift=pi(tv−ft)+piai+ft\begin{aligned}
f(t+1) &amp; = \max_{i=1}^n \left\{ p_{i}(tv+a_i) +  (1-p_{i})f_t  \right\} \\
&amp; = p_{i}tv+p_{i}a_{i}+f_t-p_{i}f_{t} \\
&amp; = p_{i}(tv-f_t)+p_{i}a_{i}+f_t
\end{aligned}
f(t+1)​=i=1maxn​{pi​(tv+ai​)+(1−pi​)ft​}=pi​tv+pi​ai​+ft​−pi​ft​=pi​(tv−ft​)+pi​ai​+ft​​
因为 ftf_{t}ft​ 是已知的，所以这个就是一个显然的斜率优化式子，通过将 pip_ipi​ 排序可以满足 kkk 单调，但是 xxx 呢？其实也是一样的：
tv−ft≥(t−1)v−ft−1tv−ft≥tv−v−ft−1ft−1−ft≤v\begin{aligned}
tv-f_{t}&amp; \ge (t-1)v-f_{t-1} \\
tv-f_{t}&amp; \ge tv-v-f_{t-1} \\
f_{t-1}-f_{t} &amp; \le v
\end{aligned}tv−ft​tv−ft​ft−1​−ft​​≥(t−1)v−ft−1​≥tv−v−ft−1​≤v​
因为两个游戏之间获得的收益不可能比玩最大收益（最大的 bipib_{i}p_{i}bi​pi​ 的游戏）还大，所以式子成立，xxx 单调不降。
故单调队列优化，时间复杂度 O(t+n)O(t+n)O(t+n)…t≤1010t\le 10^{10}t≤1010？
这个数据范围已经不行了，必须出矩阵优化…等会矩阵怎么斜率优化？
首先我们先把转移的矩阵搞出来，推啊推：
[fi−1i−11]×[(1−pi)00piv10(pi−ai)11]=[fii1]\begin{bmatrix}
 f_{i-1} &amp; i-1 &amp; 1 
\end{bmatrix}
\times 
\begin{bmatrix}
 (1-p_i) &amp; 0 &amp; 0\\
 p_i v &amp; 1 &amp; 0\\
 (p_i-a_i) &amp; 1 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
 f_{i} &amp; i &amp; 1 
\end{bmatrix}[fi−1​​i−1​1​]×⎣⎢⎡​(1−pi​)pi​v(pi​−ai​)​011​001​⎦⎥⎤​=[fi​​i​1​]
其实也不是很难推，有啥加啥，因为少个 1 直接加上去就行。
如果我们想找出来有哪些游戏是我们在斜率优化需要的，可以利用单调栈（不能用单调队列我们要存下来的）来记录我们斜率从那些点转移过来，现在问题在于如何确定什么时候从一个点转移到另一个点。
回忆一下这张图：

在斜率优化上，我们能用单调队列来做是因为对于每一个点上的斜率，它有一定转移的边界，在这之前是这个斜率，在之后就不是了。
说的好听矩阵怎么做？首先一个游戏的转移矩阵肯定不会变。问题在于我们怎么像单调队列优化一样找到所谓的边界呢？
首先单调队列不太行因为它不适用于矩阵这种玩意，那怎么办，矩阵这玩意也不能上斜率不单调三小将…………二分？

但其实维护凸壳的时候斜率函数单调递增，我们可以借助这个二分，找到顶点就可以了，其实二分也可以套在 kkk 与 xxx 同单调的地方，芝士没有那么优罢了

我们可以二分矩阵快速幂的幂，到哪个幂的时候转移是最优的！这样的时间复杂度是 O(nlog⁡2t)O(n \log^2 t)O(nlog2t)，可以通过。
我们不妨快点，不难发现幂其实是一个倍增的形式，我们可以利用倍增的形式二分，首先预处理矩阵快速幂后的各个幂对应的矩阵，从大到小枚举倍增的幂，不断检查是否合法（即是否 &lt;t&lt;t&lt;t )，让后检查是否更优，直接赋值即可！时间复杂度 O(nlog⁡t)O(n \log t)O(nlogt)，其中 log⁡t=33\log t=33logt=33 可以通过。
代码如下，注意精度！！！！！
#include&lt;bits/stdc++.h&gt;#define ll long long#define double long doubleusing namespace std;constexpr int MN=6e5+15;constexpr double eps=1e-13;struct Node&#123;    double k,b;&#125;ln[MN],cl[MN],s[MN];ll n,t,top,tot,now;double v;struct Matrix&#123;    double mat[5][5];    Matrix operator *(const Matrix &amp;x)const&#123;        Matrix ret;        memset(ret.mat,0,sizeof(ret.mat));        for(int i=1;i&lt;=3;i++)&#123;            for(int j=1;j&lt;=3;j++)&#123;                for(int k=1;k&lt;=3;k++)&#123;                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];                &#125;            &#125;        &#125;        return ret;    &#125;&#125;g[40],f;bool cmp(Node x,Node y)&#123;    if(fabs(x.k-y.k)&lt;eps) return x.b&lt;y.b;    return x.k&lt;y.k;&#125;int ck(double x)&#123;    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;&#125;double gety(Node x,Node y)&#123;    return (x.b-y.b)/(y.k-x.k);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;t;    for(int i=1;i&lt;=n;i++)&#123;        double a,b,p;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;        v=max(v,b*p);        ln[i].k=p;        ln[i].b=p*a;    &#125;    sort(ln+1,ln+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;	    // 先把那些相等斜率的全排了        if(i == n || ck(ln[i].k - ln[i+1].k) != 0) cl[++tot]=ln[i];    &#125;    for(int i=1;i&lt;=tot;i++)&#123;	    // 单调栈处理转移的点        while(top&gt;1&amp;&amp;ck(gety(s[top],s[top-1])-gety(cl[i],s[top-1]))&gt;=0) top--;        s[++top]=cl[i];    &#125;    // f 为 初始矩阵    f.mat[1][3]=1;    for(int i=1;i&lt;=top;i++)&#123;        double x=now*v-f.mat[1][1];        while(i&lt;top&amp;&amp;ck(x-gety(s[i],s[i+1]))&gt;=0) i++;// 先把过时决策排了        if(i&lt;top) x=gety(s[i],s[i+1]);        g[0].mat[1][2]=g[0].mat[1][3]=g[0].mat[2][3]=0;        g[0].mat[2][2]=g[0].mat[3][2]=g[0].mat[3][3]=1;        g[0].mat[1][1]=1-s[i].k,g[0].mat[2][1]=s[i].k*v,g[0].mat[3][1]=s[i].b;// 初始化矩阵        for(int j=1;j&lt;=35;j++) g[j]=g[j-1]*g[j-1];        for(int j=35;j&gt;=0;j--)&#123;            ll np=now+(1ll&lt;&lt;j);            if(np&gt;=t) continue;            // 如果决策更优或已经到头了即可转移            if(i==top||ck(x-np*v+(f*g[j]).mat[1][1])&gt;=0)&#123;                f=f*g[j];                now=np;            &#125;        &#125;        f=f*g[0];        now++;        if(now==t) break;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;f.mat[1][1];    return 0;&#125;
 4.后言
总结下来，矩阵优化的特征分为如下：

数据范围既有极大又有极小
具有线性递推特征，或者转移过来的状态数量偏小。
DP式子可以写成矩阵并且矩阵规模小
转移规模极大

用途就2种，一个优化转移，一个优化边权较小图上的统计问题，基本步骤就是根据操作手册来就行。
转移过程中还是有一些trick的：

如果题目中有一些关键节点会改变转移矩阵，考虑到向量乘矩阵和矩阵乘矩阵不同复杂度，可以考虑强制中断，二进制分组处理。
如果转移矩阵仅由0/1构成，考虑bitset优化。
若图有边权，边权极小，可以考虑拆点
如果涉及到指数高精，想想性质或者10进制快速幂
矩阵快速幂也满足倍增的思想，可以考虑倍增二分

个人理解，矩阵优化的本质就是线性递推，其实回看所有拆点操作，都是将这些转移满足 i→i+1i\rightarrow i+1i→i+1 的形式，只有这样才能进行矩阵加速递推。
而对于操作手册是自己根据刷题经验总结出来的一些步骤，大家可以根据这几个步骤灵活调用。
完结撒花！
]]></content>
      <categories>
        <category>DP优化</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP优化</tag>
      </tags>
  </entry>
  <entry>
    <title>私有笔记与课件</title>
    <url>/posts/da4314dd/</url>
    <content><![CDATA[
  a0048e2418083c29588730b2cab069400a4d4017da86ba28de13cb4d7ea8922d8fdb546300f46184887b1ee1af5123268869ac42bd4d166b55d9d6729528e62cd9ffad4c627485ea30d02211187eec439e7e5eafa8c217d64309dc6a593b9d244e784bf781845ed7806904709d610c20d549c8efaeb4fbb1bcd970cfd412bff356a92d080ad6d96eccd224eb8dfa6aa118027253425380447f8543a078a71429c385d540de472b88db72cd2e5da3210a948eb2b0fa569510cb51662c607efea6e4036b3d367070dcd0e4fec5df49b0200d4f42e8b959209ba2f9d8118796730fe6ea7df1b0162f3486fdee730a977a5f65b4adbc0fe143df55a9be4c89208974659ca663c4db66da5f5f32e27a29fe27417b9c5f0528b48f1954039d126459b3ccf25e6b9066102a6ca66ed21f3db5fc3cef717cbafdb7f52650f20f146e86c9743a3d7147742bf9f54e2bb6bdbd91e1210cde43e5da43cebc8cf4eed62e0c33
  
    
      
      
        您好, 这里需要密码.
      
    
  

]]></content>
  </entry>
  <entry>
    <title>线性基</title>
    <url>/posts/fa56ba17/</url>
    <content><![CDATA[ 1. 介绍
我们称一个 nnn 维向量组是线性无关的，当且仅当不存下不全为 0 的一组数 cic_ici​，使得 ∑ciai=0\sum c_i a_i =0∑ci​ai​=0。
而线性基认为是一个 nnn 维向量集合中极大的线性无关向量子集，可以证明任何向量集合存在线性基，且一个向量集合的任意线性基大小相同。
最坏情况下线性基会有 nnn 个元素，即全部都线性无关。我们可以通过维护一个向量数组 aia_iai​（i∈[1,n]i\in [1,n]i∈[1,n]）来表示最终得到的线性基。
依次加入每一个向量 vvv，从高到低扫描每一位，如果 vvv 的第 iii 位非零，那么就检查 aia_iai​：

若 aia_iai​ 不存在，那么令 ai←va_i \leftarrow vai​←v，结束循环。
若 aia_iai​ 存在，那么令 v←vxai,xaiv \leftarrow \dfrac{v_x}{a_{i,x}}a_iv←ai,x​vx​​ai​，继续循环下一位。

上述算法时间复杂度为 O(n2m)O(n^2 m)O(n2m)，其中 mmm 为加入的向量数量。溶蚀如果一个向量可以通过上面的过程循环到最后一位，最终变为零向量的话，说明这个向量可以被这一组线性基所表示。
在 OI 中，相较于上面我们我们所说的 nnn 维实线性空间 Rn\mathbb{R}^nRn 下的实数线性基，一般的我们研究的更多的是布尔线性空间下的异或线性基。
那么在异或线性基中，一个把一个数的二进制位看做一个向量，即一个向量等价于一个 [0,2n)[0,2^n)[0,2n) 内的整数。
其中加法等价于按位异或，数乘等价于且。
那么同等于上面，异或线性基中的数线性无关等价于异或和不为 0。一个数如果能够被线性基表示，那么等价于被表示成数集中若干个数的异或和，也就是数集的子集异或和。
异或线性基的插入其实和实数线性基是差不太多。
我们加入一个数 vvv，从高到低扫描每一个二进制位，如果 vvv 的第 iii 位非零，那么检查 aia_iai​：

若 aia_iai​ 不存在，那么令 ai←va_i\leftarrow vai​←v，结束。
如果 aia_iai​ 存在，那么令 v←vxor⁡aiv\leftarrow v \operatorname{xor} a_iv←vxorai​，继续循环。

时间复杂度为 O(n2mω)O(\dfrac{n^2 m}{\omega})O(ωn2m​)，但是我们位运算的话在位数 n&lt;64n&lt;64n&lt;64 的情况下一般认为是 O(nm)O(nm)O(nm)。
代码如下：
void insert(int x)&#123;    for(int i=52;i&gt;=0;i--)&#123;        if((x&gt;&gt;i)&amp;1)&#123;            if(!p[i])&#123;                p[i]=x;                break;            &#125;            x^=p[i];        &#125;    &#125;&#125;
线性基有一些性质，这里我们举例异或线性基，性质同样适用于实数线性基：

原序列的任意一个数都可以由线性基内部的一些数异或得到。
线性基内部的任意数异或起来都不能得到 0。
线性基内部的数个数唯一；且在保持性质一的前提下，数的个数是最少的。

证明如下：

显然。因为我们是极大线性无关集，那么把线性无关的都放进去，剩下了向量一定能被线性表示出来。
线性无关也就是说互相不能线性表示出来，根据最开头我们提到的线性无关定义是显然的。
若去掉线性基里面的任一个数，都会使得原序列里的数无法通过用线性基里的元素线性表示得到，没有多余的元素。所以线性基的元素个数在保持性质一的前提下，一定是最少的。

 2.线性基操作
 插入
上面提到了：
void insert(int x)&#123;    for(int i=52;i&gt;=0;i--)&#123;        if((x&gt;&gt;i)&amp;1)&#123;            if(!p[i])&#123;                p[i]=x;                break;            &#125;            x^=p[i];        &#125;    &#125;&#125;
 求最大值
考虑贪心，初始答案为 0，从线性基的最高位开始，若当前答案异或线性基可以让这个答案变得更大，那就异或它。根据性质 1 容易证明这是对的：
int getmx()&#123;    int ans=0;    for(int i=52;i&gt;=0;i--)&#123;        if((ans^p[i])&gt;ans) ans^=p[i];    &#125;    return ans;&#125;
 求最小值
如果求的是线性基 ppp 能表示出的异或的最小值，那么就是最小的 pip_ipi​，原因是线性无关且异或是不进位加法。
如果是整个序列，要另外检查有没有元素不能插入线性基，如果有，那么最小值就是 0，否则依然是最小的 pip_ipi​。
 求第 k 小
从一个序列中取任意元素进行异或，求能异或出的所有数字中第 kkk 小的那个。
收先预处理线性基 ppp，对于每一个 pip_ipi​，枚举 j=i∼1j=i\sim 1j=i∼1，如果 pip_ipi​ 二进制第 jjj 位为 1，那么让 pip_ipi​ 异或上 pj−1p_{j-1}pj−1​。
将 kkk 转为二进制，假如第 iii 位为 1，则 ansansans 异或线性集中第 iii 个元素。
 能否被异或
尝试把一个数插入线性基，如果可以插入说明不能，反之可以。
 线性基求并
一个线性基元素插入到另一个线性基即可。时间复杂度 O(log⁡2∣V∣)O(\log^2 |V|)O(log2∣V∣)，其中 VVV 为值域。
求交不太会呜呜。
 3. 前缀线性基
例题：CF1100F
询问相当于求区间 [l,r][l,r][l,r] 内 cic_ici​ 构成的一组线性基。
当然我们可以通过线段树维护，时间复杂度 O(nlog⁡2∣V∣+qlog⁡nlog⁡2∣V∣)O(n \log^2 |V|+q\log n \log^2 |V|)O(nlog2∣V∣+qlognlog2∣V∣)，很那泵。
我们先想一想，为什么区间查的线性基不能用全局的维护，某种意义上也就是为什么线性基不支持删除。
答案是我们根本不知道线性基每一位数是如何组成的，我们不知道线性基上每一位数的位置，这就导致我们不知道在区间查询的时候能不能选择某一位。
一般构造线性基的方法是增量构造，也就是我们上面所说的一个一个插入。枚举 i=1∼ni=1\sim ni=1∼n，依次尝试把 aia_iai​ 插入到线性基中。
那么在加入 ara_rar​ 之后，当前线性基对应的就是 [1,r][1,r][1,r] 构成的线性基。如果此时能够想办法仅考虑 l≤il\le il≤i 的 aia_iai​，那么也就得到了 [l,r][l,r][l,r] 构成的线性基。
说人话就是我们希望当前的线性基中 aia_iai​ 的 iii 尽可能大，加入的时间尽可能晚。
那么在前面构造线性基的方法中，如果我们当前加入的是 vvv，会在 aia_iai​ 存在的时候直接对 vvv 进行修改，但是由于 vvv 加入的时间比 aia_iai​ 晚，而 v,aiv,a_iv,ai​ 在当前位置的地位是等价的，所以我们可以将 ai,va_i,vai​,v 进行交换，让加入时间更晚的 vvv 留下，让原本线性基中的 aia_iai​ 代替 vvv 去做接下来的处理。
那么我们可以维护线性基的同时，维护线性基内每一个元素对应的原数下表 timitim_itimi​，那么区间查询的时候只考虑那些 timi≥ltim_i \ge ltimi​≥l 的元素即可，时间复杂度是 O(log⁡∣V∣)O(\log |V|)O(log∣V∣)。
这样的结构，我们叫做前缀线性基或者时间戳线性基。
总时间复杂度 O((n+q)log⁡∣V∣)O((n+q)\log |V|)O((n+q)log∣V∣)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=5e5+15,MP=32;int n,q,a[MN];struct prexxj&#123;    int num,pos[MN][MP],p[MN][MP];    void insert(int x)&#123;        num++;        for(int i=0;i&lt;MP;i++)&#123;            p[num][i]=p[num-1][i];            pos[num][i]=pos[num-1][i];        &#125;        int P=num;        for(int i=MP-1;i&gt;=0;i--)&#123;            if((x&gt;&gt;i)&amp;1)&#123;                if(!p[num][i])&#123;                    p[num][i]=x;                    pos[num][i]=P;                    break;                &#125;else&#123;                    if(pos[num][i]&lt;P)&#123;                        swap(pos[num][i],P);                        swap(p[num][i],x);                    &#125;                    x^=p[num][i];                &#125;            &#125;        &#125;    &#125;    int getmx(int l,int r)&#123;        int ans=0;        for(int i=31;i&gt;=0;i--)&#123;            if(pos[r][i]&lt;l) continue;            if((ans^p[r][i])&gt;ans) ans^=p[r][i];        &#125;        return ans;    &#125;&#125;pxj;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin&gt;&gt;x;        pxj.insert(x);    &#125;    cin&gt;&gt;q;    while(q--)&#123;        int x,y;        cin&gt;&gt;x&gt;&gt;y;        cout&lt;&lt;pxj.getmx(x,y)&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 4. 例题
 P4301 新 Nim 游戏
没有第一回合那就是传统的 Nim 游戏，先手有必胜策略当且仅当所有 aia_iai​ 异或起来不为 0。
那么考虑第一回合后后手的操作，假设第一回合后石子的集合是 SSS，那么其可以保留该石子集合的任意子集。而后手只需要是的保留的子集异或和为 0，他就可以获得胜利。
所以第一回合先手要想获胜，必须让 SSS 集合不能存在任何一个非空子集使得里面所有元素异或和为 000。
由异或线性基的性质，元素异或和不为 0。我们可以通过这个性质入手，但是同时由于先手第一回合要尽可能少地取
石子，那么也就要让 SSS 中的元素和尽可能大。
那么可以得到 SSS 是元素和最大的那一组线性基，我们每一次贪心的将 aia_iai​ 从大到小贪心的加入线性基，那么最后得到的线性基就是 ∑ai\sum a_i∑ai​ 最大的线性基。
时间复杂度 O(klog⁡∣V∣)O(k\log |V|)O(klog∣V∣)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e5+15;int n,a[MN],p[MN],ans;bool cmp(int x,int y)&#123;    return x&gt;y;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    sort(a+1,a+1+n,cmp);    for(int i=1;i&lt;=n;i++)&#123;        int x=a[i];        for(int j=30;j&gt;=0;j--)&#123;            if((x&gt;&gt;j)&amp;1)&#123;                if(!p[j])&#123;                    p[j]=x;                    break;                &#125;else x^=p[j];            &#125;        &#125;        if(!x)&#123;            ans+=a[i];        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
 CF895C
完全平方数有一个性质，就是在质因数分解下的表示，所有质因数的指数都是偶数。
而本题目只需要让我们判断是否质因子全为偶数即可，根据奇偶性的表示，就是一个 0/1 表示。
考虑到 ∣V∣≤70|V|\le 70∣V∣≤70，也就是说质数一共只有 19 个，考虑每一个数对应一个 19 维的布尔向量，那么问题转化为有多少种线性组合的方式使得异或和为 0.
先建异或线性基，那么不在线性基里面的元素一定能够被线性基内的元素所线性组合切以一一对应，那么线性组合后异或的和为 0.
设线性基内元素数量为 kkk，则最终答案不在线性基内元素任选的方案数，为 2n−k−12^{n-k}-12n−k−1（把所有元素都不选的去掉）。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=55,MOD=1e9+7;int n;int pri[30] = &#123; 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 &#125; ;struct xxj&#123;    int p[MN];    void insert(int x)&#123;        for(int i=19;i&gt;=0;i--)&#123;            if((x&gt;&gt;i)&amp;1)&#123;                if(!p[i])&#123;                    p[i]=x;                    break;                &#125;                x^=p[i];            &#125;        &#125;    &#125;&#125;xj;int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int x,ret=0;        cin&gt;&gt;x;        for(int j=0;j&lt;19;j++)&#123;            if(x%pri[j]==0)&#123;                int now=0;                while(x%pri[j]==0)&#123;                    x/=pri[j];                    now^=1;                &#125;                ret^=(now&lt;&lt;j);            &#125;        &#125;        xj.insert(ret);    &#125;    for(int i=0;i&lt;=19;i++)&#123;        if(xj.p[i]) n--;    &#125;    cout&lt;&lt;(ksm(2,n)-1)%MOD;        return 0;&#125;
 P4570 元素
和上面例题一样，按顺序尝试将每个元素插入线性基中，如果能插入就累加答案。
#include&lt;bits/stdc++.h&gt;#define int long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int mp=65,mn=1520;int n;pir a[mn];struct xxj&#123;    int p[mp],ans=0;    void insert(int x,int y)&#123;        for(int i=63;i&gt;=0;i--)&#123;            if((x&gt;&gt;i)&amp;1)&#123;                if(!p[i])&#123;                    p[i]=x;                    ans+=y;                    break;                &#125;                x^=p[i];            &#125;        &#125;    &#125;&#125;xj;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i].second&gt;&gt;a[i].first;    &#125;    sort(a+1,a+1+n);    for(int i=n;i&gt;=1;i--)&#123;        xj.insert(a[i].second,a[i].first);    &#125;    cout&lt;&lt;xj.ans;    return 0;&#125;
 P4151 WC2011 最大 XOR 和路径
我们先从一条 1→n1\to n1→n 的路径，让后向外拓展。显然只有环对答案有影响，因为非环的边一定会走两次，异或和为 0。
因为图是连通的，所以可以经过任意环，把所有的环的异或值扔到线性基里，然后再考虑选择哪一条路径。注意到，若从 111 到 nnn 有多条路径，其实这些路径也构成了环，也会被加入到线性基里，这时候随便选一条路径即可。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e5+15,MP=65;struct Edge&#123;    int v,w;&#125;;int n,m,ans,dis[MN];bool vis[MN];vector&lt;Edge&gt; adj[MN];struct xxj&#123;    int p[MP];        void insert(int x)&#123;        for(int i=63;i&gt;=0;i--)&#123;            if((x&gt;&gt;i)&amp;1)&#123;                if(!p[i])&#123;                    p[i]=x;                    break;                &#125;                x^=p[i];            &#125;        &#125;    &#125;    int getmx(int x)&#123;        int ans=x;        for(int i=63;i&gt;=0;i--)&#123;            if((ans^p[i])&gt;ans) ans^=p[i];        &#125;        return ans;    &#125;&#125;xj;void dfs(int u,int fa)&#123;    vis[u]=1;    for(auto e:adj[u])&#123;        if(vis[e.v]) xj.insert(dis[e.v]^e.w^dis[u]);        else dis[e.v]=dis[u]^e.w,dfs(e.v,u);    &#125;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        adj[u].push_back(&#123;v,w&#125;);        adj[v].push_back(&#123;u,w&#125;);    &#125;    dfs(1,0);    cout&lt;&lt;xj.getmx(dis[n]);    return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树理论笔记</title>
    <url>/posts/dba6cc97/</url>
    <content><![CDATA[ 0.前言
侧重于理论以及做题大方向，方法论的指导。
本博客若没有特殊说明，所有变量默认取值范围为 Z\mathbb{Z}Z。
 1.半群线段树
 1.1 定义
我们都说，线段树能维护具有结合律的信息，不能维护没有结合律的信息，那么为什么线段树只能维护有结合律的信息呢？这里我们可以利用半群线段树的理论来进行说明。
首先要定义什么是半群，半群是一个二元组 (S,×)(S,\times)(S,×)，其中：

SSS 是一个非空集合；
×\times× 是一个定义在 SSS 上的运算，即 x∈S,y∈S,x×y=z,z∈Sx\in S,y\in S,x\times y=z,z\in Sx∈S,y∈S,x×y=z,z∈S，即满足封闭性。
这个 ×\times× 运算满足结合律，即 (x×y)×z=x×(y×z)(x\times y)\times z=x\times(y\times z)(x×y)×z=x×(y×z)。

注意这里上面的 ×\times× 不是乘法，是抽象代数中的集合运算，这里用乘法符号让读者更好理解。同时要注意，半群并不要求拥有单位元和逆元。
而半群线段树是一种数据结构，可以维护一个序列 a1,a2,…,ana_1,a_2,\dots,a_na1​,a2​,…,an​，其中 ai∈Sa_i \in Sai​∈S，(S,×)(S,\times)(S,×) 是一个半群，支持操作：

单点修改，即给定 x,k(1≤x≤n,k∈S)x,k(1\le x \le n,k\in S)x,k(1≤x≤n,k∈S)，令 ax←ka_x \leftarrow kax​←k。
区间查询，即给定 l,r(1≤l≤r≤n)l,r(1\le l \le r \le n)l,r(1≤l≤r≤n)，求 al×al+1×⋯×ara_l \times a_{l+1} \times  \dots \times a_ral​×al+1​×⋯×ar​。

而对于实现的时候我们当然就是用线段树的结构啦，代表区间 [l,r][l,r][l,r] 的节点 iii 上记录了 al×al+1×⋯×ara_l \times a_{l+1} \times  \dots \times a_ral​×al+1​×⋯×ar​ 的信息。修改的时候单点修改，从叶子自底向上，按照 ti=tlson×trsont_i=t_{lson}\times t_{rson}ti​=tlson​×trson​ 的顺序从底往上合并（就是我们写的 pushup 函数），假设我们一次运算 ×\times× 的时间复杂度是 kkk，那么一次查询和修改的时间复杂度就是 O(klog⁡n)O(k\log n)O(klogn)。
而对于半群线段树的实现，我们可以把节点写成一个结构体的形式，让后重载运算符，这样的话你每一次写半群线段树的形式代码时候，就可以真正的按照 “模板” 来去写了。
当然要注意的一点，我们这里定义的乘法运算是没有交换律的，所以你不能瞎 pushup，根据上面定义可以知道 ti≠trson×tlsont_i \neq t_{rson}\times t_{lson}ti​=trson​×tlson​，大家做题应该体会过 pushup 写错の痛。
这里我们并没有说懒标记，其实懒标记从一开始我们学习线段树的时候，它的出现其实就是将许多的单点修改转化为了一次对于区间上的单点修改，所以对于懒标记来说，我们同样需要满足结合律和封闭性，但是我们没有必要满足交换律，我们通过及时地 pushdown 记都是将当前懒标记对应的操作序列接在原懒标记对应的操作序列之后，即我们按时间顺序处理所有懒标记。
对于懒标记线段树,他不一定满足我们上面所提到半群的性质，我们第二章会提到。
相对的，区间修改要维护的信息可能会比单点修改要更多。
 1.2 应用
应用比如说有区间和，区间最大最小值，维护矩阵乘法，维护哈希值等。
 区间求和与区间求积

我不知道 2+32+32+3 等于几，但是我知道 2+3=3+22+3=3+22+3=3+2，因为实数集上的加法运算构成阿贝尔群。

实数和加法当然构成群啦，因为加法即满足结合律，也满足交换律，所以我们可以通过线段树来维护加法操作，乘法当然也是同理的。
 线段树维护矩阵乘法
不知道大家有没有做过动态 DP，那个题就是通过线段树加树剖维护矩阵来进行 O(log⁡n)O(\log n)O(logn) 的 DP 的。矩阵和矩阵乘法当然满足结合律，而且大家都知道，矩阵乘法满足结合律不满足交换律
 线段树维护字符串哈希
这个想必大家在学习字符串哈希的时候应该是见过的，其实字符串哈希的计算过程如下：
H(s)=(∑i=0n−1si⋅basen−i−1)mod  mH(s) = \left( \sum_{i=0}^{n-1} s_i \cdot base^{n-i-1} \right) \mod m
H(s)=(i=0∑n−1​si​⋅basen−i−1)modm
那么我们定义哈希值上的二元运算 ⊕\oplus⊕，我们令 SSS 集合中每一个元素为一个二元组 (h,len)(h,len)(h,len)，其中表示如下：

hhh：字符串哈希值。
lenlenlen：字符串长度

那么运算定义如下：
(h1,l1)⊗(h2,l2)=((h1⋅basel2+h2)mod  m,  l1+l2)(h_1, l_1) \otimes (h_2, l_2) = \left( (h_1 \cdot base^{l_2} + h_2) \mod m,\; l_1 + l_2 \right)
(h1​,l1​)⊗(h2​,l2​)=((h1​⋅basel2​+h2​)modm,l1​+l2​)
可以理解为拼接哈希的过程，下面是我们证明线段树可以通过半群线段树维护哈希值，即证明上述是否能为一个半群，如果你能理解拼接哈希具有结合律和封闭性那么就不用看 www。
封闭性是显然成立的，因为对任意 $ (h_1, l_1), (h_2, l_2) \in \mathcal{S} $：

$ h_1 \cdot b^{l_2} + h_2 \mod m \in \mathbb{Z}_m $
$ l_1 + l_2 \in \mathbb{N} $

所以 $ (h_1, l_1) \otimes (h_2, l_2) \in \mathcal{S} $，封闭性成立。
考虑结合律，我们要证明：
((h1,l1)⊗(h2,l2))⊗(h3,l3)=(h1,l1)⊗((h2,l2)⊗(h3,l3))((h_1, l_1) \otimes (h_2, l_2)) \otimes (h_3, l_3) = (h_1, l_1) \otimes ((h_2, l_2) \otimes (h_3, l_3))
((h1​,l1​)⊗(h2​,l2​))⊗(h3​,l3​)=(h1​,l1​)⊗((h2​,l2​)⊗(h3​,l3​))
算左边：
先算 $ (h_1, l_1) \otimes (h_2, l_2) $：
=(h1⋅bl2+h2,  l1+l2)= (h_1 \cdot b^{l_2} + h_2, \; l_1 + l_2)
=(h1​⋅bl2​+h2​,l1​+l2​)
再与 $ (h_3, l_3) $ 合并：
=((h1⋅basel2+h2)⋅basel3+h3,  (l1+l2)+l3)=(h1⋅basel2+l3+h2⋅basel3+h3,  l1+l2+l3)= \left( (h_1 \cdot base^{l_2} + h_2) \cdot base^{l_3} + h_3, \; (l_1 + l_2) + l_3 \right)
= \left( h_1 \cdot base^{l_2 + l_3} + h_2 \cdot base^{l_3} + h_3, \; l_1 + l_2 + l_3 \right)
=((h1​⋅basel2​+h2​)⋅basel3​+h3​,(l1​+l2​)+l3​)=(h1​⋅basel2​+l3​+h2​⋅basel3​+h3​,l1​+l2​+l3​)
算右边：
先算 $ (h_2, l_2) \otimes (h_3, l_3) $：
=(h2⋅basel3+h3,  l2+l3)= (h_2 \cdot base^{l_3} + h_3, \; l_2 + l_3)
=(h2​⋅basel3​+h3​,l2​+l3​)
再与 $ (h_1, l_1) $ 合并：
=(h1⋅basel2+l3+(h2⋅basel3+h3),  l1+(l2+l3))=(h1⋅basel2+l3+h2⋅basel3+h3,  l1+l2+l3)= \left( h_1 \cdot base^{l_2 + l_3} + (h_2 \cdot base^{l_3} + h_3), \; l_1 + (l_2 + l_3) \right)
= \left( h_1 \cdot base^{l_2 + l_3} + h_2 \cdot base^{l_3} + h_3, \; l_1 + l_2 + l_3 \right)
=(h1​⋅basel2​+l3​+(h2​⋅basel3​+h3​),l1​+(l2​+l3​))=(h1​⋅basel2​+l3​+h2​⋅basel3​+h3​,l1​+l2​+l3​)
左右两边相等，结合律成立。
然而都知道拼接哈希的时间复杂度是 O(1)O(1)O(1)，所以可以 O(log⁡n)O(\log n)O(logn) 支持查询和单点修改。
 1.3 一般性的可合并信息
上面都是一般性的问题，但是如果你做过一些仅通过线段树维护的题目的话，你会发现并不想上面一样简单，因为有一些信息它甚至一般情况下都不是传统的乘除加减运算，但是他们的共性就是满足结合律，这个时候我们需要一个更一般性的结论。
我们定义这种可合并的信息，还是从半群的角度入手，设这些信息构成集合 SSS，那么有映射（不知道映射的可以理解为函数）f:([1,n]∩Z)2→Sf:([1,n]\cap \mathbb{Z})^2 \to Sf:([1,n]∩Z)2→S，说人话就是 f(x,y)→S(x,y∈[1,n],Zf(x,y) \to S (x,y \in [1,n],\mathbb{Z}f(x,y)→S(x,y∈[1,n],Z。同时定义运算 ×\times× 满足 S×S→SS \times S \to SS×S→S。若满足 f(l,m)=x,f(m+1,r)=yf(l,m)=x,f(m+1,r)=yf(l,m)=x,f(m+1,r)=y，那么 f(l,r)=x×yf(l,r)=x\times yf(l,r)=x×y。直观理解就是每一个区间对应的都是唯一的值，并且这个运算对于于相邻区间的合并，即 pushup，且封闭性满足能够让我们能够从 f(l,m),f(m+1,r)f(l,m),f(m+1,r)f(l,m),f(m+1,r) 能够推出 f(l,r)f(l,r)f(l,r)。
那么我们根据上面的定义的话，一个区间的信息无论怎么选取 mmm 拆分为自取件，按照什么顺序合并起来，只要你左右顺序一致的，那么就还能满足 al×al+1×⋯×ara_l \times a_{l+1} \times  \dots \times a_ral​×al+1​×⋯×ar​ 这样的结果，这说明这种一般性的可合并取件信息也是构成半群的，可以用我们的半群线段树来去做。
 1.4 做题的大方向
那么我们上面说了这么多的例子，感觉好像就是在重新讲一遍单点修改区间查询的线段树，其实不然，我们可以通过给信息设计半群的结构来进行操作。
一般的来说，我们在做类似于线段树的题中我们要考虑的是以下的几步：

观察题目性质。
我需要维护什么？
这种信息是不是什么常见类型，若不是，我能不能通过构造信息和操作，让它构成一个半群？
如果可以的话，我们可不可以通过线段树来进行维护，并且定义的运算符操作是否高效。

最难的地方在于观察题目性质，设计信息和思考信息的合并，下面给出几道例题。
 1.5 例题
 维护最大子段和
例如区间最大子段和，根据上面我们提出过的一般性的可合并信息的维护。
首先我们分析性质，我们维护的信息要具有结合律和封闭性，通过 f(l,mid),f(mid+1,r)f(l,mid),f(mid+1,r)f(l,mid),f(mid+1,r) 的信息推出 f(l,r)f(l,r)f(l,r)。
一个显然的想法就是维护 ansansans 为区间最大子段和，让后从左右区间传递上来，但是这样的操作是不满足封闭性的，因为我们丢弃了跨区间 midmidmid 的合并信息。而注意到跨过 midmidmid 的区间是通过 [l,mid][l,mid][l,mid] 的最大后缀以及 [mid+1,r][mid+1,r][mid+1,r]的最大前缀拼在一起，那么我们可以考虑维护区间最大前后缀和 pre,sufpre,sufpre,suf，这样的话我们 ansansans 就可以这么合并：
ans←max⁡{ansls,ansrs,sufls+prers}ans\leftarrow \max\{ ans_{ls},ans_{rs},suf_{ls}+pre_{rs} \}
ans←max{ansls​,ansrs​,sufls​+prers​}
现在 ansansans 满足我们性质的，并且好处是这个运算显然是满足结合律与封闭性的，但是我们现在要考虑维护 pre,sufpre,sufpre,suf 了 www。
考虑 pre,sufpre,sufpre,suf，前缀后缀和当然也是要考虑跨区间的贡献，注意到跨区间的贡献，例如 preprepre，一定是 prelspre_{ls}prels​ 或者 sumls+prerssum_{ls}+pre_{rs}sumls​+prers​ 所构成的，其中 sumsumsum 是区间和，同理于 sufsufsuf，这样的信息合并设计也是满足结合律的。
总结一下我们需要维护什么信息：

ansansans：区间最大子段和，合并为 ans←max⁡{ansls,ansrs,sufls+prers}ans\leftarrow \max\{ ans_{ls},ans_{rs},suf_{ls}+pre_{rs} \}ans←max{ansls​,ansrs​,sufls​+prers​}。
preprepre：区间最大前缀和，合并为 pre←max⁡{prels,sumls+prers}pre\leftarrow \max \{ pre_{ls},sum_{ls}+pre_{rs} \}pre←max{prels​,sumls​+prers​}。
sufsufsuf：区间最大后缀和，合并基本同上，这里不再给出。
sumsumsum：区间和，合并不给出。

读者可以感受我们上面所提出的设计信息构造半群的流程，我们首先要从我们所求出的答案开始，让后考虑答案如何从子区间的信息合并上来，再一开始的时候可能是不满足半群所要求的封闭性，为此我们要敢于构造信息以满足封闭性，让后我们再考虑构造出来的信息如何从子区间合并上来。
重复上面的过程，直到我们的半群合并并且信息封闭，这种方法比我们一开始要想出所有要维护的信息是更简单的。
 CF1076G
区间修改和区间查询，但是我们要维护的是一个博弈论的状态，首先我们肯定不是从线段树来去思考，而是先去思考我们维护信息的特殊性质。
我们先考虑 [1,n][1,n][1,n] 的时候该怎么做，显然有一个 DP，设 fif_ifi​ 表示跳到第 iii 个格子的时候是先手必胜还是先手必败，考虑倒过来 DP，注意到我们的信息只关注就行即可，那么有转移：

当 aia_iai​ 为奇数的时候，fi=1f_i=1fi​=1。这时显然无论怎么跳后手一定是跳出去的。
当 aia_iai​ 为偶数的时候，fif_ifi​ 能否先手必赢当且仅当后面 mmm 个格子中没有先手必败状态。

时间复杂度为 O(nmq)O(nmq)O(nmq) 无法通过。
考虑优化，本题目的瓶颈在于我们要知道后面 mmm 个格子中有没有先手必败，同时观察到我们要维护的信息是一个 0/1 序列，而且 mmm 极小，考虑状压 DP 值，对于线段树上每一个区间，记录 [r+1,r+m][r+1,r+m][r+1,r+m] 的 DP 状态状压为 SSS，让后考虑我们 [l,l+m−1][l,l+m-1][l,l+m−1] 的 DP 信息是什么，合并考虑到结合律是显然的（因为是这么定义的 www），封闭性同理，可以用线段树维护。
让后考虑区间修改，我们维护的信息只具有奇偶性，区间加偶数显然没有任何卵用，但是区间加奇数会使得区间奇偶性翻转，我们考虑维护一个区间翻转 tag，同时答案维护两份，一份是正常的答案，一份是反转过后的，区间翻转奇偶性的时候交换两份答案即可。但是注意到一次合并信息的时间复杂度过高，考虑优化运算操作，注意到我们每次都要便利这个 SSS 的状态，其实我们只需要知道 SSS 中第一个 0 的位置就可以了，这样就足够高效了，时间复杂度为 O(qmlog⁡n)O(qm\log n)O(qmlogn)。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=5e5+15;int n,m,q,a[MN];struct Segment&#123;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1    struct QWQ&#123;        int pos[11];                QWQ operator +(const QWQ &amp;x)const&#123;            QWQ ret;            for(int i=1;i&lt;=m+1;i++)&#123;                ret.pos[i]=pos[x.pos[i]];            &#125;            return ret;        &#125;    &#125;;    struct Node&#123;        int l,r;        int isrev;        QWQ val[2];    &#125;t[MN&lt;&lt;2];    void dorev(int p)&#123;        swap(t[p].val[1],t[p].val[0]);        t[p].isrev^=1;    &#125;    void pushdown(int p)&#123;        if(t[p].isrev)&#123;            dorev(ls);            dorev(rs);            t[p].isrev=0;        &#125;    &#125;    void pushup(int p)&#123;        t[p].val[0]=t[ls].val[0]+t[rs].val[0];        t[p].val[1]=t[ls].val[1]+t[rs].val[1];    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r)&#123;            for(int i=1;i&lt;=m;i++)&#123;                t[p].val[0].pos[i]=t[p].val[1].pos[i]=i+1;            &#125;            if(a[l]==1)&#123;                t[p].val[1].pos[m+1]=m+1;                t[p].val[0].pos[m+1]=1;            &#125;else&#123;                t[p].val[1].pos[m+1]=1;                t[p].val[0].pos[m+1]=m+1;            &#125;            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void modify(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            dorev(p);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modify(ls,fl,fr);        if(mid&lt;fr) modify(rs,fl,fr);        pushup(p);    &#125;    QWQ query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].val[1];        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&lt;fl) return query(rs,fl,fr);        if(mid&gt;=fr) return query(ls,fl,fr);        return query(ls,fl,fr)+query(rs,fl,fr);    &#125;&#125;sg;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        a[i]=(a[i]&amp;1)^1;    &#125;    sg.build(1,1,n);    while(q--)&#123;        int op,l,r,x;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;        if(op==1)&#123;            cin&gt;&gt;x;            if(x&amp;1) sg.modify(1,l,r);        &#125;else&#123;            auto ret=sg.query(1,l,r);            if(ret.pos[m+1]==1)&#123;                cout&lt;&lt;&quot;2\n&quot;;            &#125;else cout&lt;&lt;&quot;1\n&quot;;        &#125;    &#125;    return 0;&#125;
 CF1149C
还是我们的套路，我们不可能一次就想着把所有信息的设计完毕，我们先从听我们要维护的信息的特殊性质入手，让后我们再进行信息的设计使其能够满足半群的性质。
此处的 ( 和 ) 本质上可以看做欧拉序中通过一条边搜索以及回溯的过程，对应深度分别自增或者自减。
那么我们把 ( 看做深度加 1，而 ) 看作为深度减 1，计算前缀和数组 pip_ipi​，那么 pip_ipi​ 对应的就是欧拉序中第 i+1i+1i+1 点的深度（第一个点是根）。
那么对于欧拉序上第 lll 个点 uuu 和第 rrr 个点 vvv，设 w=lca⁡(u,v)w=\operatorname{lca}(u,v)w=lca(u,v)，那么有：
depu=pl−1,depv=pr−1,depw=min⁡i=l−1r−1pidis(u,v)=depu+depv−2depw=pl−1+pr−1−2min⁡i=l−1r−1pi\begin{aligned}
dep_u &amp;= p_{l-1},dep_v =p_{r-1},dep_w =\min_{i=l-1}^{r-1}p_i \\
dis(u,v)&amp;=dep_u +dep_v -2dep_w=p_{l-1}+p_{r-1}-2\min_{i=l-1}^{r-1} p_i
\end{aligned}
depu​dis(u,v)​=pl−1​,depv​=pr−1​,depw​=i=l−1minr−1​pi​=depu​+depv​−2depw​=pl−1​+pr−1​−2i=l−1minr−1​pi​​
注意到一次修改会修改一个后缀并且让区间加减 2，考虑维护如下操作：

对所有的 1≤l≤r≤2n−11\le l \le r \le 2n-11≤l≤r≤2n−1 求 pl−1+pr−1−2min⁡i=l−1r−1pip_{l-1}+p_{r-1}-2\min_{i=l-1}^{r-1} p_ipl−1​+pr−1​−2mini=l−1r−1​pi​ 的最大值。

考虑用线段树维护答案，首先我们肯定需要维护一个区间最小深度，即 mnmnmn，区间最大深度 mxmxmx，和当前区间的答案 ansansans。
当然 ansansans 是不封闭的，因为如果我们合并两个区间的答案的话就忽略了 lcalcalca 在哪个的问题。
我们考虑我们维护的信息 pl−1+pr−1−2min⁡i=l−1r−1pip_{l-1}+p_{r-1}-2\min_{i=l-1}^{r-1} p_ipl−1​+pr−1​−2mini=l−1r−1​pi​ 可以拆分为 (x−2min⁡i=l−1r−1pi)+y(x-2\min_{i=l-1}^{r-1} p_i)+y(x−2mini=l−1r−1​pi​)+y，考虑维护前半部分，这样好处就是我们可以方便的处理 LCA 的问题。
考虑对于每一个区间维护 pl−1−wmin⁡i=l−1r−1pi,pr−1−wmin⁡i=l−1r−1pip_{l-1}-w\min_{i=l-1}^{r-1} p_i,p_{r-1}-w\min_{i=l-1}^{r-1} p_ipl−1​−wmini=l−1r−1​pi​,pr−1​−wmini=l−1r−1​pi​，记作 lmx,rmxlmx,rmxlmx,rmx。那么 ansansans 转移是有：
ans←max⁡{ansls,ansrs,rmxls+mxrs,mxls+lmxrs}ans\leftarrow \max \{ ans_{ls},ans_{rs},rmx_{ls}+mx_{rs},mx_{ls}+lmx_{rs} \}
ans←max{ansls​,ansrs​,rmxls​+mxrs​,mxls​+lmxrs​}
区间操作打标记即可，时间复杂度 O(mlog⁡n)O(m\log n)O(mlogn)。
#include&lt;bits/stdc++.h&gt;using namespace std;constexpr int MN=1e6+15;int n,q,a[MN],sum[MN];struct Segment&#123;    #define ls p&lt;&lt;1    #define rs p&lt;&lt;1|1    struct Node&#123;        int l,r,mx,mn,lmx,rmx,ans,add;    &#125;t[MN&lt;&lt;2];    void pushup(int p)&#123;        t[p].mx=max(t[ls].mx,t[rs].mx);        t[p].mn=min(t[ls].mn,t[rs].mn);        t[p].lmx=max(&#123;t[ls].lmx,t[rs].lmx,t[rs].mx-2*t[ls].mn&#125;);        t[p].rmx=max(&#123;t[ls].rmx,t[rs].rmx,t[ls].mx-2*t[rs].mn&#125;);        t[p].ans=max(&#123;t[ls].ans,t[rs].ans,t[ls].mx+t[rs].lmx,t[rs].mx+t[ls].rmx&#125;);    &#125;    void doadd(int p,int k)&#123;        t[p].add+=k;        t[p].mx+=k,t[p].mn+=k;        t[p].lmx-=k;        t[p].rmx-=k;    &#125;    void pushdown(int p)&#123;        if(t[p].add)&#123;            doadd(ls,t[p].add);            doadd(rs,t[p].add);            t[p].add=0;        &#125;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r)&#123;            t[p].mx=t[p].mn=sum[l];            t[p].lmx=t[p].rmx=-sum[l];            t[p].ans=0;            return;        &#125;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);        pushup(p);    &#125;    void modify(int p,int pos,int k)&#123;        if(t[p].l==t[p].r)&#123;            doadd(p,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=pos)&#123;            modify(ls,pos,k);            doadd(rs,k);        &#125;else modify(rs,pos,k);        pushup(p);    &#125;&#125;sg;int main()&#123;    cin&gt;&gt;n&gt;&gt;q;    n=(n&lt;&lt;1)-1;    for(int i=2;i&lt;=n;i++)&#123;        char qwq;        cin&gt;&gt;qwq;        a[i]=(qwq==&#x27;(&#x27;?1:-1);    &#125;    a[1]=1;    for(int i=1;i&lt;=n;i++)&#123;        sum[i]=sum[i-1]+a[i];    &#125;    sg.build(1,1,n);    cout&lt;&lt;sg.t[1].ans&lt;&lt;&#x27;\n&#x27;;    while(q--)&#123;        int x,y;        cin&gt;&gt;x&gt;&gt;y;        ++x,++y;        if(a[x]==1)&#123;            sg.modify(1,x,-2);            a[x]=-1;        &#125;else&#123;            sg.modify(1,x,2);            a[x]=1;        &#125;        if(a[y]==1)&#123;            sg.modify(1,y,-2);            a[y]=-1;        &#125;else&#123;            sg.modify(1,y,2);            a[y]=1;        &#125;        cout&lt;&lt;sg.t[1].ans&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 2. 环线段树
这里的环可不是图论的环，环指的是一个元素集合和乘法、加法运算，乘法满足结合律，加法满足结合律、交换律，乘法与加法满足分配率，我们写作 (S,×,+)(S,\times,+)(S,×,+)。
特别注意上面的加法操作是具有交换律的。
而环线段树对应一种数据结构，可以维护一个序列 a1,a2,…,ana_1,a_2,\dots,a_na1​,a2​,…,an​，其中 ai∈Sa_i \in Sai​∈S，(S,×,+)(S,\times,+)(S,×,+) 是一个环，支持操作：

区间修改：给定 l,r,xl,r,xl,r,x，对于所有 l≤i≤rl\le i \le rl≤i≤r，令 ai←x×aia_i \leftarrow x\times a_iai​←x×ai​。
区间查询，即给定 l,r(1≤l≤r≤n)l,r(1\le l \le r \le n)l,r(1≤l≤r≤n)，求 al+al+1+⋯+ara_l + a_{l+1} +  \dots + a_ral​+al+1​+⋯+ar​。

这种线段树就是我们所说的 LazyTag 线段树。相比于半群线段树在环线段树上的节点 iii 除了要维护所谓的 si∈Ss_i \in Ssi​∈S 上之外，还要维护 ti∈St_i \in Sti​∈S 代表 “懒标记”，其意味着节点 iii 的子树尚有一些修改没有下穿，这些修改等效于左乘 TiT_iTi​。
修改，查询的时候可能需要将标记下传。当要查询左右儿子的时候，我们将懒标记下传至左右儿子更新 s,ts,ts,t，让后将当前节点的 tit_iti​ 重置为所谓的 “单位元”。
通常而言，若一次运算的时间复杂度为 O(k)O(k)O(k)，那么修改查询时间复杂度为 $O(k\log n)。
 2.1 将 val 和 tag 分离
有的时候，环线段树并不能很好地描述我们所要做的事情，而是我们要把所谓的 val 和 tag 认为是不同的东西。
具体来说，就是我们要把线段树所存储的值集合 DDD 和标记集合分开，设标记集合为 EEE，那么有运算：

×\times×：E⊕D→DE\oplus D \to DE⊕D→D，表示给某个值下传标记的结果。
×\times×：E⊕E→EE\oplus E \to EE⊕E→E，表示标记的下传，有结合律。
+++：D⊕D→DD \oplus D \to DD⊕D→D，表示值得求和，与 E,DE,DE,D 见乘法有分配律。

如果要直观理解的话，那么就是 DDD 为 nnn 维向量的集合，EEE 为 n×nn\times nn×n 矩阵的集合。
那么对应到修改为区间左乘 x(x∈E)x(x\in E)x(x∈E)，而查询为求区间值和。
 2.2 应用
间加区间和、区间加乘区间和、区间加区间历史最大值、区间加区间历史版本和都
可以 “环线段树” 做。
接下来我们会大量设计矩阵操作，用于演示 val 和 tag 分离的操作，可以看下面的图来显理解：

 区间加乘区间和
观察区间加乘的本质其实是什么：

加：ai←ai+x=ai+1×xa_i \leftarrow a_i +x=a_i +1\times xai​←ai​+x=ai​+1×x（这里的 ×\times× 就是乘号）。
乘：ai←kaia_i \leftarrow ka_iai​←kai​。

这两个都是线性变换耶，我们可以考虑维护一个向量：[ai,1][a_i,1][ai​,1]，，那么每次修改相当于就是乘上一个 2×22\times 22×2 的矩阵。而矩阵与其乘法加法都是构成环的（满足分配律），所以可以用环线段树来去做。
 区间加区间历史版本和
考虑维护向量序列 [ai,hi,1][a_i,h_i,1][ai​,hi​,1]，表示原序列值，历史版本和，和方便用的常数。那么操作就是：

加：a_i \lfetarrow a_i +x\times 1，显然线性变换。
累加历史版本：hi←hi+aih_i\leftarrow h_i+a_ihi​←hi​+ai​，显然线性变换。

所以也是可以用环线段树做的。
然而实际上你会发现几乎很少人会真的去那么写，因为矩阵实在是太慢了，有一个 333^333 的常数摆在那里。
但是这种想法，矩阵当然是很好想的啦，总比想不出来好吧，毕竟可以骗骗分，让后根据矩阵的特性进行优化 blablalba。
 2.3 例题
做题时的重心仍然要放在观察性质与构造信息上，但是因为我们有了懒标记，所以要考虑的比半群线段树要更多一些。
 [NOIP2022] 比赛
询问过于逆天，正难则反，考虑每个 ai,bia_i,b_iai​,bi​ 会在哪些区间作为最大值，这个区间信息我们可以通过单调栈 O(n)O(n)O(n) 求出。
我们把区间看成平面上的一个点。每个点上维护向量 [mxa,mxb,v,1][mx_a,mx_b,v,1][mxa​,mxb​,v,1]，其中 mxa⋅mxbmx_a \cdot mx_bmxa​⋅mxb​，那么有修改：

矩形范围内 mxamx_amxa​ 加 xxx：mxa←mxa+x⋅1,v←v+x⋅mxbmx_a \leftarrow mx_a +x \cdot 1,v\leftarrow v+x \cdot mx_bmxa​←mxa​+x⋅1,v←v+x⋅mxb​。
矩形范围内 mxbmx_bmxb​ 加 xxx：mxb←mxb+x⋅1,v←v+x⋅mxamx_b \leftarrow mx_b +x \cdot 1,v\leftarrow v+x \cdot mx_amxb​←mxb​+x⋅1,v←v+x⋅mxa​。

都是线性变化，而查询查询的就是矩形范围内 vvv 的和，矩形范围求和我们可以用过对一维差分，转化为两个区间历史版本和，说人话就是扫描线。
历史版本和是显然的，在向量上加一个维度就可以了，这里不在细说，代码根据矩形特征仍可以约去一大堆没用的信息。
我们还有构造双半群的做法，不过我不会 www。
代码如下：
#include&lt;bits/stdc++.h&gt;#define int long long#define ull unsigned long long#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e5+15;int T,n,q,top1,top2,a[MN],b[MN],s1[MN],s2[MN];ull ans[MN];vector&lt;pir&gt; qry[MN];struct Segment&#123;#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1    struct&#123;        ull l,r,hsum,sum,suma,sumb,adda,addb,hadda,haddb,haddab,hcnt;    &#125;t[MN&lt;&lt;2];    void doadd(int p,int va,int vb)&#123;        t[p].sum+=t[p].sumb*va;        t[p].suma+=(t[p].r-t[p].l+1)*va;        t[p].adda+=va;        t[p].sum+=t[p].suma*vb;        t[p].sumb+=(t[p].r-t[p].l+1)*vb;        t[p].addb+=vb;    &#125;    void dohadd(int p,int cnt,int va,int vb,int vab)&#123;        t[p].hsum+=t[p].sum*cnt+t[p].suma*vb+t[p].sumb*va+vab*(t[p].r-t[p].l+1);        t[p].hcnt+=cnt;        t[p].hadda+=t[p].adda*cnt+va;        t[p].haddb+=t[p].addb*cnt+vb;        t[p].haddab+=t[p].adda*t[p].addb*cnt+t[p].adda*vb+t[p].addb*va+vab;    &#125;    void pushup(int p)&#123;        t[p].sum=t[ls].sum+t[rs].sum;        t[p].suma=t[ls].suma+t[rs].suma;        t[p].sumb=t[ls].sumb+t[rs].sumb;        t[p].hsum=t[ls].hsum+t[rs].hsum;    &#125;    void pushdown(int p)&#123;        dohadd(ls,t[p].hcnt,t[p].hadda,t[p].haddb,t[p].haddab);        dohadd(rs,t[p].hcnt,t[p].hadda,t[p].haddb,t[p].haddab);        doadd(ls,t[p].adda,t[p].addb);        doadd(rs,t[p].adda,t[p].addb);        t[p].adda=t[p].addb=t[p].hadda=t[p].haddb=t[p].haddab=t[p].hcnt=0;    &#125;    void build(int p,int l,int r)&#123;        t[p].l=l;        t[p].r=r;        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(ls,l,mid);        build(rs,mid+1,r);    &#125;    void modifya(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            doadd(p,k,0);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modifya(ls,fl,fr,k);        if(mid&lt;fr) modifya(rs,fl,fr,k);        pushup(p);    &#125;    void modifyb(int p,int fl,int fr,int k)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            doadd(p,0,k);            return;        &#125;        pushdown(p);        int mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) modifyb(ls,fl,fr,k);        if(mid&lt;fr) modifyb(rs,fl,fr,k);        pushup(p);            &#125;    int query(int p,int fl,int fr)&#123;        if(t[p].l&gt;=fl&amp;&amp;t[p].r&lt;=fr)&#123;            return t[p].hsum;        &#125;        pushdown(p);        int ret=0,mid=(t[p].l+t[p].r)&gt;&gt;1;        if(mid&gt;=fl) ret+=query(ls,fl,fr);        if(mid&lt;fr) ret+=query(rs,fl,fr);        return ret;    &#125;    void upd()&#123;        dohadd(1,1,0,0,0);    &#125;#undef ls#undef rs&#125;sg;signed main()&#123;    cin&gt;&gt;T&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i];    &#125;    cin&gt;&gt;q;    for(int i=1;i&lt;=q;i++)&#123;        int l,r;        cin&gt;&gt;l&gt;&gt;r;        qry[r].push_back(pir(l,i));    &#125;    sg.build(1,1,n);    for(int i=1;i&lt;=n;i++)&#123;        while(top1&amp;&amp;a[i]&gt;a[s1[top1]])&#123;            sg.modifya(1,s1[top1-1]+1,s1[top1],-a[s1[top1]]);            top1--;        &#125;        sg.modifya(1,s1[top1]+1,i,a[i]);        while(top2&amp;&amp;b[i]&gt;b[s2[top2]])&#123;            sg.modifyb(1,s2[top2-1]+1,s2[top2],-b[s2[top2]]);            top2--;        &#125;        sg.modifyb(1,s2[top2]+1,i,b[i]);        sg.upd();        s1[++top1]=i;        s2[++top2]=i;        for(auto p:qry[i])&#123;            ans[p.second]=sg.query(1,p.first,i);        &#125;    &#125;    for(int i=1;i&lt;=q;i++)&#123;        cout&lt;&lt;ans[i]&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 3. 特殊线段树
有一类线段树不能简单归类到半群和环线段树，但是通常底层的信息维护都具有一定的相通性。
 3.1 平衡树
平衡树就是支持插入的线段树。
啊？
 3.2 吉司机线段树
这里吉司机可以去网上搜索教程，这里不在叙述。
那么吉司机和环线段树的相通之处，在于环结构需要多维护一个 “仅最小值加 xxx” 的操作，然后寻找修改区间这部分的算法有所改变。所以很多“环线段树”
的方法还是可用的。
 3.3 底层分块
底层分块是一个线段树优化空间的技巧，大致思想就是线段树的叶子节点是 O(log⁡n)O(\log n)O(logn) 而不是 O(1)O(1)O(1) 的区间长度，那么节点数量就减少到了 O(nlog⁡n)O(\dfrac{n}{\log n})O(lognn​)，而修改查询的时间复杂度仍然是 O(log⁡n)O(\log n)O(logn) 的。
这种修改在有很多个线段树，但是储存的底层下标不交的时候有很好的优化效果，例如魔鬼题 [Ynoi2007] rgxsxrs。
这种结构我们只是认为它的结构发生了改变，而底层信息在维护的时候是没有太大变化的，和环线段树差不太多。
 4. 后言
抽象化不是为了变难，而是为了变得更加简便，方便与实践。

“在数学中，进步往往来自于更深刻的抽象，而不是更复杂的计算” ——Alexander Grothendieck

通过抽象化，我们能够总结出线段树解题的一般步骤，以及各个线段树维护复杂信息的一般性与特殊性。
感觉学到很多，故作学习笔记，以摸鱼。
开始时间：2025/7/23 18:34
结束时间：2025/7/23 20:36
字数：5209 字。
 参考

Alex_wei 的线段树进阶
神秘课件

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学乱学</title>
    <url>/posts/b4e7c6f/</url>
    <content><![CDATA[ 0.前言与ntt
组合数学过于差得我，必须重修！
ntt板子？其中MOD，G,INVG需要自行定义
namespace Poly&#123;        int rev[MN];    int ksm(int a,int b)&#123;        int ret=1;        while(b)&#123;            if(b&amp;1) ret=ret*a%MOD;            a=a*a%MOD;            b&gt;&gt;=1;        &#125;        return ret;    &#125;    void dorev(int f[],int len)&#123;        for(int i=0;i&lt;len;i++)&#123;            rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;            if(i&amp;1)&#123;                rev[i]|=len&gt;&gt;1;            &#125;        &#125;        for(int i=0;i&lt;len;i++)&#123;            if(i&lt;rev[i]) swap(f[i],f[rev[i]]);        &#125;    &#125;    void NTT(int f[],int len,int op)&#123;        dorev(f,len);        for(int i=1;i&lt;len;i&lt;&lt;=1)&#123;            int Wn=ksm((op==1?G:INVG),(MOD-1)/(i&lt;&lt;1));            for(int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123;                int w=1;                for(int k=0;k&lt;i;k++,w=(w*Wn)%MOD)&#123;                    int x=f[j+k],y=w*f[j+k+i]%MOD;                    f[j+k]=(x+y)%MOD;                    f[j+k+i]=(x-y+MOD)%MOD;                &#125;            &#125;        &#125;        if(op==-1)&#123;            int invlen=ksm(len,MOD-2);            for(int i=0;i&lt;len;i++) f[i]=f[i]*invlen%MOD;        &#125;    &#125;    // f is the output array    void Mul(int f[],int g[],int n,int m)&#123;        m+=n;        n=1;        while(n&lt;=m) n&lt;&lt;=1;        NTT(f,n,1);        NTT(g,n,1);        for(int i=0;i&lt;=n;i++) f[i]=f[i]*g[i]%MOD;        NTT(f,n,-1);    &#125;&#125;
 1. 二项式反演
 定义与形式
二项式反演用于解决“某个物品恰好若干个”这类计数问题。
两种形式，我们统计 fnf_{n}fn​ 为恰好 nnn 种的方案数量：

至多：gn=∑i=0n(ni)fi⇔fn=∑i=0n(−1)n−i(ni)gig_{n}=\sum\limits_{i=0} ^n \binom{n}{i} f_{i} \Leftrightarrow f_{n}=\sum\limits_{i=0}^n (-1)^{n-i} \binom{n}{i} g_{i}gn​=i=0∑n​(in​)fi​⇔fn​=i=0∑n​(−1)n−i(in​)gi​
至少：gk=∑i=kn(ik)fi⇔fk=∑i=kn(−1)i−k(ik)gig_{k}=\sum\limits_{i=k} ^n \binom{i}{k} f_{i} \Leftrightarrow f_{k}=\sum\limits_{i=k}^n (-1)^{i-k} \binom{i}{k} g_{i}gk​=i=k∑n​(ki​)fi​⇔fk​=i=k∑n​(−1)i−k(ki​)gi​

速记：至少往上走，至多往下走，容斥系数就是组合数上下相减。
有的时候，题目不会明确标出恰好，需要自行探索。
至少和至多的选取根据题目类型来选取，哪个简单那个就可以。
 例题
HDU1465

求长为 nnn 的序列的错排的数量，其中 1≤n≤201\le n \le 201≤n≤20.

设 fnf_nfn​ 表示恰好有 nnn 个位置错开，gng_{n}gn​ 表示至多 nnn 个位置错开，注意到，gng_ngn​ 可以瞎排列即可，所以 gn=n!g_{n}=n!gn​=n!。
答案即为：
fn=∑i=0n(ni)(−1)n−ii!f_{n}=\sum\limits_{i=0}^n \binom{n}{i} (-1)^{n-i} i!
fn​=i=0∑n​(in​)(−1)n−ii!
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=25;int ans,pw[MN],n;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]/(pw[b]*pw[a-b]);&#125;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++)&#123;        pw[i]=pw[i-1]*i;    &#125;&#125;void solve()&#123;    ans=0;    for(int i=0;i&lt;=n;i++)&#123;        ans+=getC(n,i)*((n-i)&amp;1?-1:1)*pw[i];    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    init();    while(cin&gt;&gt;n)&#123;        solve();    &#125;    return 0;&#125;
洛谷P4859 已经没有什么好害怕的了
设 ai&gt;bia_{i}&gt;b_{i}ai​&gt;bi​ 的数量为 xxx 个，所以有 x+(x−k)=nx+(x-k)=nx+(x−k)=n
即 x=n+k2x=\dfrac{n+k}{2}x=2n+k​，也就是说 ai&gt;bia_{i}&gt;b_{i}ai​&gt;bi​ 的对数恰好为 kkk 个。
先两个序列排序，双指针预处理 ai&gt;bia_{i}&gt; b_iai​&gt;bi​ 的个数 cic_{i}ci​
考虑动态规划，我们设 g(i,j)g(i,j)g(i,j) 表示前 iii 个数，强制钦定 jjj 个数使得 ak&gt;bka_{k}&gt;b_{k}ak​&gt;bk​，而其他位置任意，即至少满足形式。
分类讨论得到转移方程：
g(i,j)=g(i−1,j)+g(i−1,j−1)×(ci−(j−1))g(i,j)=g(i-1,j)+g(i-1,j-1)\times(c_{i}-(j-1))
g(i,j)=g(i−1,j)+g(i−1,j−1)×(ci​−(j−1))
那么：
gi=g(n,i)×(n−i)!g_{i}=g(n,i) \times (n-i)!
gi​=g(n,i)×(n−i)!
至少与恰好，二项式反演即可，故代码：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=4090,MOD=1e9+9;int n,K,ans,fc[MN],f[MN][MN],a[MN],b[MN],c[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void init()&#123;    fc[0]=1;    for(int i=1;i&lt;MN;i++)&#123;        fc[i]=fc[i-1]*i%MOD;    &#125;&#125;int getC(int a,int b)&#123;    return fc[a]*ksm(fc[b],MOD-2)%MOD*ksm(fc[a-b],MOD-2)%MOD;&#125;signed main()&#123;    init();    cin&gt;&gt;n&gt;&gt;K;    K=(n+K)/2;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;b[i];    &#125;    sort(a+1,a+1+n);    sort(b+1,b+1+n);    for(int i=1,p=1;i&lt;=n;i++)&#123;        while(p&lt;=n&amp;&amp;b[p]&lt;a[i])&#123;            p++;        &#125;        c[i]=(p-1);    &#125;    for(int i=0;i&lt;=n;i++) f[i][0]=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            f[i][j]=(f[i][j]+f[i-1][j-1]*max(c[i]-j+1,0ll)%MOD+f[i-1][j])%MOD;        &#125;    &#125;    for(int i=K;i&lt;=n;i++)&#123;        int tmp=f[n][i]*fc[n-i]%MOD;         ans=(ans+tmp*getC(i,K)*((i-K)&amp;1?-1:1)%MOD)%MOD;    &#125;    cout&lt;&lt;(ans+MOD)%MOD;    return 0;&#125;
BZOJ2839 组合计数

一个有 NNN 个元素的集合有 2N2^N2N 个不同子集（包含空集），现在要在这 2N2^N2N 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 KKK，求取法的方案数，答案模 109+710^9+7109+7。

设交集元素个数恰好为 kkk 个元素的方案数为 fkf_{k}fk​，观察至多不好求，考虑设至少 gkg_{k}gk​
对于 gkg_{k}gk​ 只需要强制钦定谁为交集元素，首先 (nk)\binom{n}{k}(kn​) 飞上去，让后其他是任意选择的，数量为 2n−k2^{n-k}2n−k。我们要求的是方案数，对于这是一个族，因为集合选择是相互独立的，但是至少要选取一个集合不能为空集，所以方案数即为 22n−k−12^{2^{n-k}}-122n−k−1 个集族，乘法原理：
gk=(nk)(22n−k−1)g_{k}=\binom{n}{k} (2^{2^{n-k}}-1)
gk​=(kn​)(22n−k−1)
二项式反演即可：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=1e6+15,MOD=1e9+7;int n,K,pw[MN],inv[MN],g[MN];int ksm(int a,int b,int P)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%P;        a=a*a%P;        b&gt;&gt;=1;    &#125;    return ret;&#125;void init(int n)&#123;    pw[0]=1;    for(int i=1;i&lt;=n;i++) pw[i]=pw[i-1]*i%MOD;    inv[n]=ksm(pw[n],MOD-2,MOD);    for(int i=n;i&gt;=1;i--)&#123;        inv[i-1]=inv[i]*i%MOD;    &#125;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;namespace ly&#123;    namespace IO    &#123;        #ifndef LOCAL            constexpr auto maxn=1&lt;&lt;20;            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;            #define getchar() (p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)            #define flush() (fwrite(out,1,p3-out,stdout))            #define putchar(x) (p3==out+maxn&amp;&amp;(flush(),p3=out),*p3++=(x))            class Flush&#123;public:~Flush()&#123;flush();&#125;&#125;_;        #endif        namespace usr        &#123;            template&lt;typename type&gt;            inline type read(type &amp;x)            &#123;                x=0;bool flag(0);char ch=getchar();                while(!isdigit(ch)) flag^=ch==&#x27;-&#x27;,ch=getchar();                while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar();                return flag?x=-x:x;            &#125;            template&lt;typename type&gt;            inline void write(type x)            &#123;                x&lt;0?x=-x,putchar(&#x27;-&#x27;):0;                static short Stack[50],top(0);                do Stack[++top]=x%10,x/=10;while(x);                while(top) putchar(Stack[top--]|48);            &#125;            inline char read(char &amp;x)&#123;do x=getchar();while(isspace(x));return x;&#125;            inline char write(const char &amp;x)&#123;return putchar(x);&#125;            inline void read(char *x)&#123;static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            template&lt;typename type&gt;inline void write(type *x)&#123;while(*x)putchar(*(x++));&#125;            inline void read(string &amp;x)&#123;static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&amp;&amp;~ch);&#125;            inline void write(const string &amp;x)&#123;for(int i=0,len=x.length();i&lt;len;++i)putchar(x[i]);&#125;            template&lt;typename type,typename...T&gt;inline void read(type &amp;x,T&amp;...y)&#123;read(x),read(y...);&#125;            template&lt;typename type,typename...T&gt;            inline void write(const type &amp;x,const T&amp;...y)&#123;write(x),putchar(&#x27; &#x27;),write(y...),sizeof...(y)^1?0:putchar(&#x27;\n&#x27;);&#125;            template&lt;typename type&gt;            inline void put(const type &amp;x,bool flag=1)&#123;write(x),flag?putchar(&#x27;\n&#x27;):putchar(&#x27; &#x27;);&#125;        &#125;        #ifndef LOCAL            #undef getchar            #undef flush            #undef putchar        #endif    &#125;using namespace IO::usr;&#125;using namespace ly::IO::usr;signed main()&#123;    read(n,K);    init(n);    int ans=0;    for(int i=K;i&lt;=n;i++)&#123;        int ksmm=ksm(2,ksm(2,n-i,MOD-1),MOD);        int tmp=getC(n,i)*(ksmm-1)%MOD;        ans=(ans+((i-K)&amp;1?-1:1)*tmp%MOD*getC(i,K)%MOD+MOD)%MOD;    &#125;    put((ans+MOD)%MOD);    return 0;&#125;
HAOI2018 染色
这里至少好求，还是上面的恰好与至少。
我们考虑求解 gkg_{k}gk​，首先飞上去一个强制钦定 (mk)\binom{m}{k}(km​)。那么还剩下 n−k×Sn-k\times Sn−k×S 个位置没有染色，这些位置可以看作同一类，方案是 (n−k×S)!(n-k \times S)!(n−k×S)!。注意到我们还有排列，但是观察染色实际上是一个多重集排列的形式，那么公式即为 n!(S!)k(n−k×S)!\dfrac{n!}{(S!)^k (n-k\times S)!}(S!)k(n−k×S)!n!​。这样就满足了约束，但是还有 n−k×Sn-k \times Sn−k×S 空位置啊，也不能剩下，考虑染色方案，那么就是 (m−k)n−k×S(m-k)^{n-k \times S}(m−k)n−k×S。
乘法原理，答案即为：
gk=(mk)n!(S!)k(n−k×S)!(m−k)n−k×Sg_{k}=\binom{m}{k}\dfrac{n!}{(S!)^k (n-k\times S)!}(m-k)^{n-k \times S}
gk​=(km​)(S!)k(n−k×S)!n!​(m−k)n−k×S
设 R=min⁡(m,⌊nS⌋)R=\min(m,\lfloor \dfrac{n}{S} \rfloor)R=min(m,⌊Sn​⌋) 为真正能使用的颜色种类，代入形式二有：
fk=∑i=kR(−1)i−k(ik)gi=∑i=kR(−1)i−ki!k!(i−k)!考虑将 k! 移项有：fk×k!=∑i=kR(−1)i−ki!(i−k)!gi\begin{aligned} f_{k}&amp;=\sum\limits_{i=k}^R  (-1)^{i-k} \binom{i}{k} g_{i} \\ &amp; = \sum\limits_{i=k}^R (-1){i-k} \frac{i!}{k! (i-k)!}  \\

&amp;\text{考虑将 }  k! \text{ 移项有：} \\

f_{k} \times k! &amp; = \sum\limits_{i=k}^R (-1)^{i-k}\frac{i!}{(i-k)!} g_{i}

\end{aligned}fk​fk​×k!​=i=k∑R​(−1)i−k(ki​)gi​=i=k∑R​(−1)i−kk!(i−k)!i!​考虑将 k! 移项有：=i=k∑R​(−1)i−k(i−k)!i!​gi​​
设 Ax=∑i=0Rgii!⋅xi,Bx=∑i=0R=(−1)ii!⋅xiA_x=\sum\limits_{i=0}^R g_{i}i! \cdot x^{i},B_{x}=\sum\limits_{i=0}^R = \dfrac{(-1)^i}{i!} \cdot x^iAx​=i=0∑R​gi​i!⋅xi,Bx​=i=0∑R​=i!(−1)i​⋅xi，差卷积 NTT既得：
#include&lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define int long longusing namespace std;constexpr int MN=1e7+15,MOD=1004535809,MODG=3,MODGinv=334845270;int n,m,s,ans,f[MN],g[MN],pw[MN],rev[MN],inv[MN],w[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;int getC(int a,int b)&#123;    if(a&lt;b) return 0;    return pw[a]*inv[b]%MOD*inv[a-b]%MOD;&#125;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++) pw[i]=pw[i-1]*i%MOD;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;void dorev(int f[],int len)&#123;    for(int i=0;i&lt;len;i++)&#123;        rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;        if(i&amp;1)&#123;            rev[i]|=len&gt;&gt;1;        &#125;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(i&lt;rev[i]) swap(f[i],f[rev[i]]);    &#125;&#125;void NTT(int f[],int len,int op)&#123;    dorev(f,len);    for(int i=1;i&lt;len;i&lt;&lt;=1)&#123;        int Wn=ksm((op==1?MODG:MODGinv),(MOD-1)/(i&lt;&lt;1));        for(int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123;            int w=1;            for(int k=0;k&lt;i;k++,w=(w*Wn)%MOD)&#123;                int x=f[j+k],y=w*f[j+k+i]%MOD;                f[j+k]=(x+y)%MOD;                f[j+k+i]=(x-y+MOD)%MOD;            &#125;        &#125;    &#125;if (op == -1) &#123;    int inv_len = ksm(len, MOD-2);    for (int i = 0; i &lt; len; i++)         f[i] = f[i] * inv_len % MOD;&#125;&#125;int getG(int x)&#123;    return getC(m,x)*pw[n]%MOD*ksm(inv[s],x)%MOD*inv[n-s*x]%MOD*ksm(m-x,n-s*x)%MOD;&#125;signed main()&#123;    init();    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    int lim=min(m,n/s);    for(int i=0;i&lt;=lim;i++)&#123;        f[i]=getG(i)*pw[i]%MOD;        g[i]=(i&amp;1)?MOD-inv[i]:inv[i];    &#125;    reverse(f,f+1+lim);    int len;    for(len=1;len&lt;lim*2+2;len&lt;&lt;=1);    NTT(f,len,1);    NTT(g,len,1);    for(int i=0;i&lt;len;i++)&#123;        f[i]=f[i]*g[i]%MOD;    &#125;    NTT(f,len,-1);    reverse(f,f+lim+1);    for(int i=0;i&lt;=lim;i++)&#123;        int w;        cin&gt;&gt;w;        ans=(ans+f[i]*inv[i]%MOD*w)%MOD;    &#125;    cout&lt;&lt;ans%MOD;    return 0;&#125;
洛谷P9850
[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat

给定 nnn 个点的完全图，其中 mmm 条边为红色边，其余边为蓝色边。
定义以下：
f红色f_{\text{红色}}f红色​ 为四元组 (i,j,k,l)(i,j,k,l)(i,j,k,l)，其中任意两点都有红色边连接的个数。
f蓝色f_{\text{蓝色}}f蓝色​ 为四元组 (i,j,k,l)(i,j,k,l)(i,j,k,l)，其中任意两点都有蓝色边连接的个数。
求 ∣f红色−f蓝色∣|f_{\text{红色}}-f_{\text{蓝色}}|∣f红色​−f蓝色​∣。
其中 1≤n≤105,1≤m≤2×1051\le n \le 10^5,1\le m \le 2\times 10^51≤n≤105,1≤m≤2×105。

赛时没想出正解（废话都没学二项式反演能做？）
发现蓝色很难受，显然可以考虑以下容斥，但是怎么容斥呢？
红色边的信息我们是有的，我们可以通过红色边来容斥。
但是这咋求啊？暴力枚举直接 O(n4)O(n^4)O(n4) 了www。
对于一张存在 jjj 条红色边的图，假设存在 gig_igi​ 个 iii 条边的红色子图，而且只需要满足边颜色都是红色就可以了，那么有 (ji)\binom{j}{i}(ij​) 种选择方法，那么我们不妨设 fif_ifi​ 表示四元组存在 iii 条边的红色子图个数，有下列式子：
gi=∑j=i(ji)fjg_i=\sum\limits_{j=i}\binom{j}{i} f_j
gi​=j=i∑​(ij​)fj​
长的就很二项式反演：
fi=∑j=i(ji)(−1)j−igjf_i=\sum\limits_{j=i}\binom{j}{i} (-1)^{j-i} g_j
fi​=j=i∑​(ij​)(−1)j−igj​
那么 ∣f6−f0∣=∣g0−g1+g2−g3+g4−g5∣|f_6-f_0|=|g_0-g_1+g_2-g_3+g_4-g_5|∣f6​−f0​∣=∣g0​−g1​+g2​−g3​+g4​−g5​∣。不难发现可以一个一个讨论（废话那你怎么求）

g0g_0g0​：不选红色边，瞎选4个点：(n4)\dbinom{n}{4}(4n​)。
g1g_1g1​:选一个的方案数 (m1)\dbinom{m}{1}(1m​)，让后在确定2个端点瞎选：(m1)(n−22)\dbinom{m}{1}\dbinom{n-2}{2}(1m​)(2n−2​)。
g2g_2g2​：分类讨论

如果是一点连两条边，枚举公共点，让后再枚举以该端点出发的两个点，让后再瞎选一个：(n−3)∑i=1n(degi2)(n-3)\sum\limits_{i=1}^{n}\dbinom{deg_i}{2}(n−3)i=1∑n​(2degi​​)，其中 degideg_idegi​ 表示节点 iii 的度数
如果没有公共点，正南则反，就是原图任意选2个边减去有公共点的，即：(m2)−∑i=1n(degi2)\dbinom{m}{2}-\sum\limits_{i=1}^n \dbinom{deg_i}{2}(2m​)−i=1∑n​(2degi​​)。


g3g_3g3​：继续

如果三元环，那就枚举剩下一个点为 (n−3)C3(n-3)C_3(n−3)C3​.
如果是共用一个顶点，那么很简单直接枚举即可，结果 ∑i=1n(n3)\sum\limits_{i=1}^n \binom{n}{3}i=1∑n​(3n​)。
如果是链，注意一下要把三元环的三个情况舍去，结果就是 ∑(u,v)∈E(degu−1)(degv−1)−3C3\sum\limits_{(u,v)\in E}(deg_u-1)(deg_v-1)-3C_3(u,v)∈E∑​(degu​−1)(degv​−1)−3C3​。


g4g_4g4​:

如果四元环，那不用枚举直接 C4C_4C4​.
如果三元环出来一个那就是 ∑i=1nTi(degi−2)\sum\limits_{i=1}^n T_i(deg_i-2)i=1∑n​Ti​(degi​−2)，其中 TiT_iTi​ 为 iii 号点不同三元环的个数


g5g_5g5​ ：只能是两个三元环共用一条边枚举公共边即可，其中 f5=∑i=∈C3(ti2)f_5=\sum\limits_{i=\in \mathbb{C}_3}\binom{t_i}{2}f5​=i=∈C3​∑​(2ti​​) ，其中 C3\mathbb{C}_3C3​ 表示求解三元环完成定向的边集，tit_iti​ 表示覆盖带边 iii 的不同三元环个数。

做完了，直接公式计算即可，注意瓶颈在三元环和四员化计算，不要超过 O(n2)O(n^2)O(n2)：
#include &lt;bits/stdc++.h&gt;#define pir pair&lt;int, int&gt;#define ll long longusing namespace std;constexpr int MN = 1e5 + 15, MM = 2e5 + 15;struct Edge &#123;    int u, v;&#125; e[MM];ll f0, f1, f2, f3, f4, f5;int dg[MN],n,m,top,s[MN],id[MN];ll cp[MN], ce[MM];vector&lt;int&gt; adj[MN];vector&lt;pir&gt; G[MN];ll countthree() &#123;    ll ret = 0;    for (int i = 1; i &lt;= n; i++) &#123;        for (auto p : G[i]) id[p.first] = p.second;        for (auto p : G[i]) &#123;            int v = p.first;            for (auto pv : G[v]) &#123;                int w = pv.first;                if (id[w]) &#123;                    ret++;                    cp[i]++;                    cp[v]++;                    cp[w]++;                    ce[p.second]++;                    ce[pv.second]++;                    ce[id[w]]++;                &#125;            &#125;        &#125;        for (auto p : G[i]) id[p.first] = 0;    &#125;    return ret;&#125;ll countfour() &#123;    memset(id, 0, sizeof(id));    ll ret = 0;    for (int i = 1; i &lt;= n; i++) &#123;        for (int v : adj[i]) &#123;            for (auto p : G[v]) &#123;                int w = p.first;                if (dg[i] &lt; dg[w] || (dg[i] == dg[w] &amp;&amp; i &lt; w)) &#123;                    ret += id[w];                    if (!id[w]) s[++top] = w;                    id[w]++;                &#125;            &#125;        &#125;        for (int j = 1; j &lt;= top; j++) id[s[j]] = 0;        top = 0;    &#125;    return ret;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; e[i].u &gt;&gt; e[i].v;        dg[e[i].u]++;        dg[e[i].v]++;        adj[e[i].u].push_back(e[i].v);        adj[e[i].v].push_back(e[i].u);    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int u = e[i].u, v = e[i].v;        if ((dg[u] == dg[v] &amp;&amp; u &gt; v) || dg[u] &gt; dg[v])            swap(u, v);        G[u].push_back(&#123;v, i&#125;);    &#125;    ll tri = countthree();    ll quad = countfour();    for (int i = 1; i &lt;= n; i++) &#123;        f2+=1LL * dg[i] * (dg[i] - 1) / 2 * (n - 4);        f3+=1LL * dg[i] * (dg[i] - 1) * (dg[i] - 2) / 6;        f4+=1LL * cp[i] * (dg[i] - 2);        for (auto p : G[i]) &#123;            int v = p.first;            f3+=1LL * (dg[i] - 1) * (dg[v] - 1);        &#125;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        f5+=1LL * ce[i] * (ce[i] - 1) / 2;    &#125;    f0=(__int128)n * (n - 1) * (n - 2) * (n - 3) / 24;    f1=1LL * m * (n - 2) * (n - 3) / 2;    f2+=1LL * m * (m - 1) / 2;    f3+=tri * (n - 6);    f4+=quad;    cout &lt;&lt; abs(f0 - f1 + f2 - f3 + f4 - f5);    return 0;&#125;
 2 斯特林数
 小约定
我们有一些小概念，比较简单：

下降幂，即 xn‾=x(x−1)(x−2)…(x−n+1)x^{\underline{n}}=x(x-1)(x-2)\dots(x-n+1)xn​=x(x−1)(x−2)…(x−n+1)

例如 x3‾=x(x−1)(x−2)x^{\underline{3}}=x(x-1)(x-2)x3​=x(x−1)(x−2)。


上升幂，即 xn‾=x(x+1)(x+2)…(x+n−1)x^{\overline{n}}=x(x+1)(x+2)\dots(x+n-1)xn=x(x+1)(x+2)…(x+n−1)。


普通幂，就是 xn=x1×x2⋯×xnx^n=x_1 \times x_2 \dots  \times x_nxn=x1​×x2​⋯×xn​，没啥好说的。


 第一类
 定义与递推
我们定义，[nm]\begin{bmatrix} n \\ m \end{bmatrix}[nm​] 为把 nnn 个元素分成 mmm 个环的方案数，这 mmm 个环不同当且仅当环不能旋转得到另一个环。
递推：
[nm]=[n−1m−1]+(n−1)×[n−1m]\begin{bmatrix} n \\ m \end{bmatrix}=\begin{bmatrix} n-1 \\ m-1 \end{bmatrix} + (n-1) \times \begin{bmatrix} n-1 \\ m \end{bmatrix}
[nm​]=[n−1m−1​]+(n−1)×[n−1m​]
从 n−1n-1n−1 个元素推过来，两个空环肯定是不符合的。
空一个环我们考虑插入元素，插入法即可。
 性质与求法
性质：
与阶乘的关系：

n!=∑i=0n[ni]n! =\sum\limits_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix}n!=i=0∑n​[ni​]

本质就是置换吗。
下降幂与上升幂与普通幂的转化：
下降幂转普通幂：
xn‾=∑i=0n[ni](−1)n−ixix^{\underline{n}}=\sum\limits_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^{i}
xn​=i=0∑n​[ni​](−1)n−ixi
上升幂转普通幂：
xn‾=∑i=0n[ni]xix^{\overline{n}}=\sum\limits_{i=0}^n \begin{bmatrix}n \\ i  \end{bmatrix} x^i
xn=i=0∑n​[ni​]xi
注意，上升幂转普通幂用第一类斯特林数。
证明：

如何求呢？
∑i=0n[ni]xi=∏i=0n−1(x+i)=(x+n−1)!(x−1)!\sum\limits_{i=0} ^n \begin{bmatrix} n \\ i \end{bmatrix} x^i =\prod_{i=0}^{n-1} (x+i)=\frac{(x+n-1)!}{(x-1)!}
i=0∑n​[ni​]xi=i=0∏n−1​(x+i)=(x−1)!(x+n−1)!​
其实就是类似上面的递推式子，我们利用分治 FFT 即可 O(nlog⁡n)O(n \log n)O(nlogn) 求解第一类斯特林数，代码如下。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e5+15,MOD=167772161,MODG=3,MODGinv=55924054;int n,rev[MN],inv[MN],pw[MN],f[MN],g[MN],a[MN],b[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=ret*a%MOD;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret;&#125;void dorev(int f[],int len)&#123;    for(int i=0;i&lt;len;i++)&#123;        rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;        if(i&amp;1)&#123;            rev[i]|=len&gt;&gt;1;        &#125;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(i&lt;rev[i]) swap(f[i],f[rev[i]]);    &#125;&#125;void NTT(int f[],int len,int op)&#123;    dorev(f,len);    for(int i=1;i&lt;len;i&lt;&lt;=1)&#123;        int Wn=ksm((op==1?MODG:MODGinv),(MOD-1)/(i&lt;&lt;1));        for(int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123;            int w=1;            for(int k=0;k&lt;i;k++,w=(w*Wn)%MOD)&#123;                int x=f[j+k],y=w*f[j+k+i]%MOD;                f[j+k]=(x+y)%MOD;                f[j+k+i]=(x-y+MOD)%MOD;            &#125;        &#125;    &#125;if (op == -1) &#123;    int inv_len = ksm(len, MOD-2);    for (int i = 0; i &lt; len; i++)         f[i] = f[i] * inv_len % MOD;&#125;&#125;void Mul(int f[],int g[],int n,int m)&#123;    m+=n,n=1;    while(n&lt;m) n&lt;&lt;=1;    NTT(f,n,1);    NTT(g,n,1);    for(int i=0;i&lt;n;i++) f[i]=f[i]*g[i]%MOD;    NTT(f,n,-1);&#125;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++) pw[i]=pw[i-1]*i%MOD;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;void solve(int f[],int n)&#123;    if(n==1)&#123;        f[1]=1;        return;    &#125;    if(n&amp;1)&#123;        solve(f,n-1);        for(int i=n;i&gt;=1;i--)&#123;            f[i]=(f[i-1]+f[i]*(n-1)%MOD)%MOD;        &#125;        f[0]=f[0]*(n-1)%MOD;    &#125;else&#123;        int m=n/2,ret=1;        solve(f,m);        for(int i=0;i&lt;=m;i++)&#123;            a[i]=f[i]*pw[i]%MOD;            b[i]=ret*inv[i]%MOD;            ret=ret*m%MOD;        &#125;        reverse(a,a+1+m);        Mul(a,b,m+1,m+1);        for(int i=0;i&lt;=m;i++)&#123;            g[i]=inv[i]*a[m-i]%MOD;        &#125;        Mul(f,g,m+1,m+1);        int lim=1;        while(lim&lt;(m+1)&lt;&lt;1) lim&lt;&lt;=1;        for(int i=m+1;i&lt;lim;i++) a[i]=b[i]=g[i]=0;        for(int i=n+1;i&lt;lim;i++) f[i]=0;    &#125;&#125;signed main()&#123;    init();    cin&gt;&gt;n;    solve(f,n);    for(int i=0;i&lt;=n;i++) cout&lt;&lt;f[i]&lt;&lt;&quot; &quot;;    return 0;&#125;
 第二类
 定义
说实话第二类才是用的最多的。
我们定义：{nm}\begin{Bmatrix} n \\ m \end{Bmatrix}{nm​}，或记作 S(n,m)S(n,m)S(n,m)。表示将 nnn 个元素分成 mmm 个互不区分的非空子集的方案数。
递推式子：
S(n,k)=S(n−1,k−1)+k×S(n−1,k)S(n,k)=S(n-1,k-1)+k \times S(n-1,k)
S(n,k)=S(n−1,k−1)+k×S(n−1,k)
其中 S(n,0)=[n=0]S(n,0)=[n=0]S(n,0)=[n=0]。
考虑证明，我们插入一个新元素，用两种方案：

将新元素单独放入一个子集，有 S(n−1,k−1)S(n-1,k-1)S(n−1,k−1) 种方案
将新元素放入一个现有的非空子集，共 k×S(n−1,k)k\times S(n-1,k)k×S(n−1,k) 种方案
加法原理即可。

 性质
性质如下：
mn=∑i=0mS(n,i)×i!×(mi)m^n=\sum\limits_{i=0}^m S(n,i)\times i! \times \binom{m}{i}
mn=i=0∑m​S(n,i)×i!×(im​)
当然可以写成：
mn=∑i=0mS(n,i)×mi‾m^n=\sum\limits_{i=0}^m S(n,i) \times m^{\underline{i}}
mn=i=0∑m​S(n,i)×mi​
反演时写作，即普通幂转下降幂：
mn=∑i=0nS(n,i)×mi‾m^n=\sum\limits_{i=0}^n S(n,i) \times m^{\underline{i}}
mn=i=0∑n​S(n,i)×mi​
可以这么理解，我们将 nnn 个不同小球丢进 mmm 个不同的盒子的方案数，我们枚举有效盒子的个数，从 mmm 个盒子选 iii 个盒子，让后将 nnn 个小球丢进 iii 个盒子（即第二类斯特林数）
然而事实上，这就是第二类斯特林数的生成函数。
那普通幂转上升幂呢：
mn=∑i=0n(−1)n−i×S(n,i)×mi‾m^n=\sum\limits_{i=0}^n (-1)^{n-i} \times  S(n,i)   \times m^{\overline{i}}
mn=i=0∑n​(−1)n−i×S(n,i)×mi
第二类斯特林显然和排列组合有关系：
S(n,m)=1m!∑i=0m(−1)i(mi)(m−i)nS(n,m)=\frac{1}{m!}\sum\limits_{i=0}^m (-1)^i \binom{m}{i} (m-i)^n
S(n,m)=m!1​i=0∑m​(−1)i(im​)(m−i)n
如果空箱子的情况算进去，那么答案就是 mnm!\dfrac{m^n}{m!}m!mn​
选 iii 个空盒子，让后把小球放进其他盒子里。
但我们的答案是有区别的盒子，要乘以 1m!\dfrac{1}{m!}m!1​ 去情况，
 求第二类斯特林数
如何求呢，注意到上面的式子：
S(n,m)=1m!∑i=0m(−1)i(mi)(m−i)n=1m!∑i=0m(−1)im!k!(m−k)!(m−i)n=∑i=0m(−1)k×(m−k)nk!(m−k)!\begin{aligned}

S(n,m) &amp; =\frac{1}{m!}\sum\limits_{i=0}^m (-1)^i \binom{m}{i} (m-i)^n \\

 &amp; =\frac{1}{m!}\sum\limits_{i=0}^m (-1)^i \frac{m!}{k!(m-k)!} (m-i)^n \\

 &amp; = \sum\limits_{i=0}^m (-1)^k \times \frac{(m-k)^n}{k!(m-k)!}

\end{aligned}S(n,m)​=m!1​i=0∑m​(−1)i(im​)(m−i)n=m!1​i=0∑m​(−1)ik!(m−k)!m!​(m−i)n=i=0∑m​(−1)k×k!(m−k)!(m−k)n​​
至此，我们可以实现以 O(nlog⁡n)O(n\log n)O(nlogn) 的时间复杂度求出 S(n)S(n)S(n)这一行的第二类斯特林数。
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=3e6+15,MOD=167772161,MODG=3,MODGinv=55924054;int n,pw[MN],inv[MN],A[MN],B[MN];namespace Poly&#123;    int rev[MN];    int ksm(int a,int b)&#123;        int ret=1;        while(b)&#123;            if(b&amp;1) ret=ret*a%MOD;            a=a*a%MOD;            b&gt;&gt;=1;        &#125;        return ret;    &#125;void dorev(int f[],int len)&#123;    for(int i=0;i&lt;len;i++)&#123;        rev[i]=rev[i&gt;&gt;1]&gt;&gt;1;        if(i&amp;1)&#123;            rev[i]|=len&gt;&gt;1;        &#125;    &#125;    for(int i=0;i&lt;len;i++)&#123;        if(i&lt;rev[i]) swap(f[i],f[rev[i]]);    &#125;&#125;void NTT(int f[],int len,int op)&#123;    dorev(f,len);    for(int i=1;i&lt;len;i&lt;&lt;=1)&#123;        int Wn=ksm((op==1?MODG:MODGinv),(MOD-1)/(i&lt;&lt;1));        for(int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123;            int w=1;            for(int k=0;k&lt;i;k++,w=(w*Wn)%MOD)&#123;                int x=f[j+k],y=w*f[j+k+i]%MOD;                f[j+k]=(x+y)%MOD;                f[j+k+i]=(x-y+MOD)%MOD;            &#125;        &#125;    &#125;if (op == -1) &#123;    int inv_len = ksm(len, MOD-2);    for (int i = 0; i &lt; len; i++)         f[i] = f[i] * inv_len % MOD;&#125;&#125;void Mul(int f[],int g[],int n,int m)&#123;    m+=n,n=1;    while(n&lt;m) n&lt;&lt;=1;    NTT(f,n,1);    NTT(g,n,1);    for(int i=0;i&lt;n;i++) f[i]=f[i]*g[i]%MOD;    NTT(f,n,-1);&#125;&#125;using namespace Poly;void init()&#123;    pw[0]=1;    for(int i=1;i&lt;MN;i++)&#123;        pw[i]=pw[i-1]*i%MOD;    &#125;    inv[MN-1]=ksm(pw[MN-1],MOD-2);    for(int i=MN-2;i&gt;=0;i--)&#123;        inv[i]=inv[i+1]*(i+1)%MOD;    &#125;&#125;signed main()&#123;    init();    cin&gt;&gt;n;    for(int i=0;i&lt;=n;i++)&#123;        A[i]=(i&amp;1?MOD-inv[i]:inv[i]);        B[i]=ksm(i,n)*inv[i]%MOD;    &#125;    Mul(A,B,n,n);    for(int i=0;i&lt;=n;i++) cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;;    return 0;&#125;
 与自然数幂的关系
∑i=0nik=∑j=0kS(k,j)(n+1)j+1j+1\sum\limits_{i=0}^n i^k=\sum\limits_{j=0}^k S(k,j) \frac{(n+1)^{j+1}}{j+1}
i=0∑n​ik=j=0∑k​S(k,j)j+1(n+1)j+1​
证明：

 斯特林反演
斯特林反演：
f(n)=∑k=0nS(n,k)×g(k)⇔g(n)=∑k=0n(−1)n−k[nk]f(k)f(n)=\sum\limits_{k=0}^n S(n,k)\times g(k) \Leftrightarrow g(n)=\sum\limits_{k=0}^n (-1)^{n-k} \begin{bmatrix} n \\ k \end{bmatrix} f(k)
f(n)=k=0∑n​S(n,k)×g(k)⇔g(n)=k=0∑n​(−1)n−k[nk​]f(k)
f(n)=∑k=0n(−1)n−kS(n,k)×g(k)⇔g(n)=∑k=0n[nk]f(k)f(n)=\sum\limits_{k=0}^n (-1)^{n-k} S(n,k)\times g(k) \Leftrightarrow g(n)=\sum\limits_{k=0}^n \begin{bmatrix} n \\ k \end{bmatrix} f(k)
f(n)=k=0∑n​(−1)n−kS(n,k)×g(k)⇔g(n)=k=0∑n​[nk​]f(k)
f(n)=∑i=nS(i,n)g(i)⇔g(i)=∑i=n(−1)i−n[in]f(i)f(n)=\sum\limits_{i=n} S(i,n) g(i) \Leftrightarrow g(i)= \sum\limits_{i=n} (-1)^{i-n} \begin{bmatrix} i \\ n \end{bmatrix} f(i)
f(n)=i=n∑​S(i,n)g(i)⇔g(i)=i=n∑​(−1)i−n[in​]f(i)
f(n)=∑i=n(−1)i−nS(i,n)g(i)↔g(n)=∑i=n[in]f(i)f(n)=\sum\limits_{i=n} (-1)^{i-n} S(i,n) g(i) \leftrightarrow g(n)=\sum\limits_{i=n} \begin{bmatrix} i \\ n \end{bmatrix} f(i)
f(n)=i=n∑​(−1)i−nS(i,n)g(i)↔g(n)=i=n∑​[in​]f(i)
 例题以及应用
题型分类：

函数与斯特林数公式相同
这类问题通常需要自设函数，通过发现与斯特林数的关系利用其性质求解
根据题意运用斯特林函数及公式
这类问题通常隐晦地交代了需要运用斯特林函数求解，存在有效解与无效解的原式
往往需要经验才能快速判断选择并化简原式
直接推式
这类问题会直接给出包含或间接包含斯特林函数的公式，要求简化公式以得到优秀的时间复杂度
斯特林反演的运用
容斥类问题，通常需要自设函数并找到与斯特林数的关系，从而化简求解过程

 3. 贝尔数
贝尔数表示将基数为 nnn 的集合划分方法的数目，划分即将 SSS 划分成两两不相交的非空子集的族。例如 B3=5B_3=5B3​=5。
特别的，B0B_{0}B0​ 为 1 因为空集有一种划分方法。
递推公式如下：
Bn+1=∑k=0n(nk)BkB_{n+1}=\sum\limits_{k=0}^n \binom{n}{k} B_{k}
Bn+1​=k=0∑n​(kn​)Bk​
同时因为每个贝尔数都为相邻第二类斯特林数的和，因为第二类斯特林树是把基数为 nnn 的集合乎分成 kkk 个非空集的方法数目。
即：
Bn=∑k=0n{nk}B_{n}=\sum\limits_{k=0}^n \begin{Bmatrix} n \\ k \end{Bmatrix}
Bn​=k=0∑n​{nk​}
当贝尔数到达第 151515 项时，已经变得非常大。可以细心观察以下数据范围。
 4. Lucas 定理
《初等数论》一书对卢卡斯(Lucas)\texttt{(Lucas)}(Lucas)定理是这么定义的:::

设ppp为素数,a,b∈N∗,,a,b\in N^* ,,a,b∈N∗,并且

a=∑i=0kaipi,b=∑i=0kbipia=\sum\limits_{i=0}^k a_i p^i,b=\sum\limits_{i=0}^k b_i p^i
a=i=0∑k​ai​pi,b=i=0∑k​bi​pi

这里0⩽ai,bi⩽p−10\leqslant a_i,b_i\leqslant p-10⩽ai​,bi​⩽p−1都是整数,i=0,1,2,…,k.i=0,1,2,…,k.i=0,1,2,…,k.则:::

Cab≡∏i=0kCaibi(modp)C_a^b \equiv \prod\limits_{i=0}^k C_{a_i}^{b_i} \pmod{p}
Cab​≡i=0∏k​Cai​bi​​(modp)

或者写成这样:::

Cab≡Cakbk⋅Cak−1bk−1⋅…⋅Ca0b0(modp)C_a^b \equiv C_{a_k}^{b_k} \cdot C_{a_{k-1}}^{b_{k-1}} \cdot … \cdot C_{a_0}^{b_0}\pmod{p}
Cab​≡Cak​bk​​⋅Cak−1​bk−1​​⋅…⋅Ca0​b0​​(modp)
Ps.Ps.Ps.如果bi&gt;ai,b_i&gt;a_i,bi​&gt;ai​,那么Caibi=0.C_{a_i}^{b_i} = 0 .Cai​bi​​=0.
本质上卢卡斯定理就是把组合数的计算拆到模数 ppp 的进制表示里去做。
 性质
该书又介绍了Lucas\texttt{Lucas}Lucas定理的两个性质:::

当且仅当存在i∈{0,1,2,…,k}i \in \{ 0, 1, 2, …,k\}i∈{0,1,2,…,k}使得bi&gt;aib_i &gt; a_ibi​&gt;ai​时,Cab≡0(modp).,C_a^b \equiv 0 \pmod{p}.,Cab​≡0(modp).
CabC_a^bCab​ 为奇数的充要条件为二进制表示下aaa的每一位上的数都不小于bbb相应位上的数，即 bbb 在二进制表示下时 aaa 的子集。

 应用
Lucas\texttt{Lucas}Lucas定理的主要用途在于在O(log⁡pa)O(\log_p a)O(logp​a)的时间求出Cabmod  pC_a^b \mod pCab​modp的结果...显然地,,,有一种方法:::

对于a,a,a,我们预处理出a0,a1,…,ak,a_0,a_1,…,a_k,a0​,a1​,…,ak​,对于bbb同理...然后我们直接算组合数并乘起来,,,注意随时取模...如果ppp较小且询问较多,,,可以考虑预处理组合数...

这听起来很容易,,,但做起来好难啊...
这时候我们把秦九韶请出来,,,可以将
∑i=0kaipi\sum\limits_{i=0}^k a_i p^i
i=0∑k​ai​pi
变成
(((akp+ak−1)p+ak−2)p+…)p+a0(((a_kp+a_{k-1})p+a_{k-2})p+…)p+a_0
(((ak​p+ak−1​)p+ak−2​)p+…)p+a0​
这样的形式,,,对于另一个同理,,,于是我们便可以层层除法+++取模,,,将求解变成了一个递归形式,,,即:::
Lucas(a,b,p)=Lucas(a/p,b/p,p)⋅Ca%pb%p,Lucas(a,b,p)=Lucas(a/p,b/p,p) \cdot C_{a\%p}^{b\%p},
Lucas(a,b,p)=Lucas(a/p,b/p,p)⋅Ca%pb%p​,
这里的Lucas(a,b,p)Lucas(a,b,p)Lucas(a,b,p)即要求的Cabmod  p,C_a^b \mod p ,Cab​modp,
根据我们上面所提到的，组合数的计算拆成 ppp 进制下的计算，实质是这样的：
(nm) mod p=(n/pm/p)×(n mod pm mod p) mod p=(n/p2m/p2)×(n/p mod pm/p mod p)×(n mod pm mod p) mod p=⋯=1×⋯×(n/p mod pm/p mod p)×(n mod pm mod p) mod p\begin{aligned} \dbinom{n}{m} \bmod p &amp;= \dbinom{n/p}{m/p} \times \dbinom{n \bmod p}{m \bmod p} \bmod p \\ &amp;= \dbinom{n/p^2}{m/p^2} \times \dbinom{n/p \bmod p}{m/p \bmod p} \times \dbinom{n \bmod p}{m \bmod p} \bmod p \\ &amp;= \cdots \\ &amp;= 1 \times \cdots \times \dbinom{n/p \bmod p}{m/p \bmod p} \times \dbinom{n \bmod p}{m \bmod p} \bmod p \\ \end{aligned}
(mn​)modp​=(m/pn/p​)×(mmodpnmodp​)modp=(m/p2n/p2​)×(m/pmodpn/pmodp​)×(mmodpnmodp​)modp=⋯=1×⋯×(m/pmodpn/pmodp​)×(mmodpnmodp​)modp​
在上述推导中，可以发现其中每一项都带上了 (modp)\pmod p(modp)，即将每一项都限制在了 ppp 以内，即转化到了 ppp 进制。
 例题
 arc137d
注意到这个贡献的顺序是一个类似于前缀和的形式，如下图：

考虑如何异或只有系数为 1 的时候才能贡献到，注意到系数一定和操作次数有关，并且这个贡献顺序有点类似于格路计数，手摸不难有系数，前面的数对 ana_nan​ 的贡献就是：
an=∑i=0(k+i−1i)an−ia_n =\sum_{i=0} \binom{k+i-1}{i} a_{n-i}
an​=i=0∑​(ik+i−1​)an−i​
其中因为是异或 (k+i−1i)\binom{k+i-1}{i}(ik+i−1​)，不难有这个是在 (mod2)\pmod 2(mod2) 意义下的，根据卢卡斯定理，当 (nm) mod 2=1\binom{n}{m} \bmod 2 =1(mn​)mod2=1 当且仅当 n bitand m=mn \text{ bitand } m=mn bitand m=m。
用高维后缀和实现即可，时间复杂度 O(nlog⁡n)O(n \log n)O(nlogn)。
 P3373 吉夫特
根据我们上面所说的，二进制模数下的组合数要想为 1 当且仅当 mmm 是 nnn 二进制表示下的子集。这道题由于值域很小，可以直接暴力枚举子集，让后就做完了，时间复杂度为 3log⁡∣V∣3^{\log |V|}3log∣V∣。
 P4345 超粒子炮
原式子所求：
∑i=0k(ni)(mod2333)\sum_{i=0}^k \binom{n}{i} \pmod{2333}
i=0∑k​(in​)(mod2333)
注意到 2333 是质数，根据 Lucas 定理有：
p=2333∑i=0k(ni)=∑i=0k(n/pi/p)(n mod pi mod p)(modp)\begin{aligned}
p &amp; = 2333 \\
\sum_{i=0}^k \binom{n}{i} &amp; = \sum_{i=0}^k \binom{n/p}{i/p}\binom{n \bmod p}{i\bmod p} \pmod p
\end{aligned}
pi=0∑k​(in​)​=2333=i=0∑k​(i/pn/p​)(imodpnmodp​)(modp)​
注意到前面的式子类似于整除分块，枚举 i/pi/pi/p 有：
(n/p0)∑i=0p−1(n mod pi mod p)+(n/p1)∑i=0p−1(n mod pi mod p)+⋯+(n/pk/p)∑i=0p−1(n mod pi mod p)(modp)\binom{n/p}{0} \sum_{i=0}^{p-1} \binom{n \bmod p}{i\bmod p}+\binom{n/p}{1} \sum_{i=0}^{p-1} \binom{n \bmod p}{i\bmod p}+\dots+\binom{n/p}{k/p} \sum_{i=0}^{p-1} \binom{n \bmod p}{i\bmod p} \pmod p
(0n/p​)i=0∑p−1​(imodpnmodp​)+(1n/p​)i=0∑p−1​(imodpnmodp​)+⋯+(k/pn/p​)i=0∑p−1​(imodpnmodp​)(modp)
不妨令 f(n,k)=∑i=0k(ni)(modp)f(n,k)=\sum_{i=0}^k \binom{n}{i} \pmod pf(n,k)=∑i=0k​(in​)(modp)，那么有：
f(n,k)=f(n/p,(k/p)−1)⋅f(n mod p,p−1)+(n/pk/p)⋅f(n mod p,k mod p)f(n,k)=f(n/p,(k/p)-1) \cdot f(n\bmod p,p-1)+\binom{n/p}{k/p}\cdot f(n\bmod p,k\bmod p)
f(n,k)=f(n/p,(k/p)−1)⋅f(nmodp,p−1)+(k/pn/p​)⋅f(nmodp,kmodp)
前面就是上面类似于整除分块的地方，后面是遗留的小块单独算。时间复杂度 O(p2+Tlog⁡p2n)O(p^2+T\log_{p}^2 n)O(p2+Tlogp2​n)
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>群论与Burnside定理与Polya定理</title>
    <url>/posts/1005d80f/</url>
    <content><![CDATA[ 0. 前言
抽象代数警告！
你需要有：

集合论芝士
一颗清醒不头痛的大脑

 1. 群
 1.1 群的定义
设 GGG 是非空集合，其上有二元运算 ×\times× （这不是单纯的乘号，这里是抽象代数你应当有这种意识）。若这个运算满足以下四个性质，我们称其为一个群，记为：(G,×)(G,\times)(G,×)。

封闭性


若存在 aaa 和 bbb 满足 a∈G,b∈Ga\in G,b\in Ga∈G,b∈G，则有 a×b∈Ga\times b \in Ga×b∈G。


结合律


对于任意 a,b,c∈G,有(a×b)×c=a×(b×c)a,b,c \in G,\text{有}(a\times b)\times c=a\times (b\times c)a,b,c∈G,有(a×b)×c=a×(b×c)。


单位元


∃e∈G\exists e\in G∃e∈G，满足对于任意 a∈Ga\in Ga∈G，有：a×e=e×a=aa\times e=e\times a=aa×e=e×a=a。
这样的 eee 称为单位元，并且单位元唯一（如果有多个很容易看出来矛盾）


逆元


对于任意 a∈Ga\in Ga∈G，存在a′∈Ga&#x27;\in Ga′∈G，满足a×a′=a′×a=ea\times a&#x27;=a&#x27;\times a=ea×a′=a′×a=e。
a′a&#x27;a′ 也是唯一的。

举个例子，我们比如说实数域上的乘法法则就构成一个群，模意义下的乘法（除0以外）同样是一个群，单位元 e=1e=1e=1 。

（推论）消去律：对于 a,b,c∈Ga,b,c\in Ga,b,c∈G，如果 a×c=b×ca\times c=b\times ca×c=b×c 或c×a=c×bc\times a=c\times bc×a=c×b，那么有 a=ba=ba=b。

还有一些举例，正整数在加法下不够成群，因为正整数没有加法单位元（应为0但是正整数），整数在乘法下不构成群，2整数范围没有乘法逆元。
 1.2 子群
如果 HHH 为 GGG 的一个子集并且 (H,×)(H,\times)(H,×) 构成一个群，那么称 (H,×)(H,\times)(H,×) 为 (G,×)(G,\times)(G,×) 的子群，简记为 H≤GH\le GH≤G（这么记是因为子集包括 GGG）。
如果 GGG 是一个群，且 HHH 是 GGG 的子群，且 g∈Gg\in Gg∈G，那么：

gH=g×h,h∈HgH=g\times h,h\in HgH=g×h,h∈H，称其为 HHH 在 GGG 内关于 ggg 的左陪集。
Hg=h×g,h∈HHg=h\times g,h\in HHg=h×g,h∈H，称其为 HHH 在 GGG 内关于 ggg 的右陪集。

为什么要这么分呢，看上面的性质，我们没有提到交换律，所以这种算数系统交换过来的结果不一定相同，所以我们需要特别规定。
配集的性质（这里只讨论右配集）：

∀g∈G,∣H∣=∣Hg∣\forall g\in G,|H|=|Hg|∀g∈G,∣H∣=∣Hg∣。

根据逆元唯一，那么对于任意的g×h1,g×h2g\times h_{1},g\times h_2g×h1​,g×h2​，一定必然不同。

∀g∈G,g∈Hg\forall g\in G,g\in Hg∀g∈G,g∈Hg。

单位元 e∈Hge\in Hge∈Hg ，证毕。

Hg=H⇔g∈HHg=H \Leftrightarrow g\in HHg=H⇔g∈H。

封闭性即得。

Ha=Hb⇔a×b−1∈HHa=Hb \Leftrightarrow a\times b^{-1}\in HHa=Hb⇔a×b−1∈H

根据陪集运算和逆元可以证明。

Ha∩Hb≠∅⇔Ha=HbHa \cap Hb \ne \varnothing \Leftrightarrow Ha=HbHa∩Hb=∅⇔Ha=Hb。

这个性质很有用，这说明陪集的交集要么是空集么两个相同。

HHH 的全体右陪集并为 GGG 。
显然？因为 HHH 有单位元。

拉格朗日定理：
对于有限群 GGG 与有限群 HHH，若 HHH 为 GGG 的子群，那么有：
∣H∣ 整除 ∣G∣|H|\text{ 整除 } |G|
∣H∣ 整除 ∣G∣
 1.3 群作用
我们对于一个集合 MMM 和群 GGG。
若给定二元函数 μ(a,b)\mu(a,b)μ(a,b)，其中 a∈G,b∈Ma\in G,b\in Ma∈G,b∈M，并且：
μ(e,k)=ke为单位元μ(g,μ(s,k))=μ(g×s,k)g,s∈G,k∈M\begin{aligned}
\mu(e,k)&amp; =k &amp; \text{e为单位元} \\
\mu(g,\mu(s,k)) &amp; = \mu(g\times s,k) &amp; g,s\in G,k\in M
\end{aligned}
μ(e,k)μ(g,μ(s,k))​=k=μ(g×s,k)​e为单位元g,s∈G,k∈M​
那么我们就称 GGG 作用于集合 MMM 。
理解的来说其实就是把 GGG 的运算法则给融合进 集合 MMM 了。
 2. 置换
定义：一个集合 XXX 到自身的双射（一一对应）σ\sigmaσ 称为 XXX 的一个置换。
 2.1 置换的表示
双行表示法，即用两个括号扩起来，令元素从上面一行 “置换” 到下面一行，这个置换就可以用两行来表示。例如下面：
σ=(1234523154)\sigma=
\begin{pmatrix}  
  1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\  
  2 &amp; 3 &amp; 1 &amp; 5 &amp; 4 
\end{pmatrix} σ=(12​23​31​45​54​)
这个意思将排列 1,2,3,4,51,2,3,4,51,2,3,4,5 变为 2,3,1,5,42,3,1,5,42,3,1,5,4 的一个置换，可以理解就是用原本第二个代替第一个，第三个代替第二个，以此类推。
单行表示法，就是把置换后的结果表示出来如下：
σ=(a1,a2,...an)\sigma=(a_1,a_2,...a_n)
σ=(a1​,a2​,...an​)
例如：σ=(2,3,1,5,4)\sigma=(2,3,1,5,4)σ=(2,3,1,5,4)。
我们还有轮换表示，但是我看不懂。
一个长度为 nnn 的不同置换的个数为 n!n!n!，这个很重要！
 2.2 置换的运算
很简单，其实就是 σ×a\sigma \times aσ×a，或者更一般的写作 σ(a)\sigma(a)σ(a)。
运算规则就是：σ(a)=(aσ1,aσ2,....,aσn)\sigma(a)=(a_{\sigma_1},a_{\sigma_2},....,a_{\sigma_n})σ(a)=(aσ1​​,aσ2​​,....,aσn​​)。
还是例如上面的数列 a=(1,2,3,4,5)a=(1,2,3,4,5)a=(1,2,3,4,5)，那么 σ(a)=(2,3,1,5,4)\sigma(a)=(2,3,1,5,4)σ(a)=(2,3,1,5,4)。
我们称这个运算叫做置换的「合成」。
 2.3 置换群
我们不妨设集合 N={1,2,3,...,n}N=\left\{ 1,2,3,...,n \right\}N={1,2,3,...,n}，令集合 MMM 为 NNN 的若干个排列所构成的集合，我们令群 G=(M,×)G=(M,\times)G=(M,×)，其中这个 ×\times× 运算即为上面提到的置换的「合成」，若在此基础上，如果满足群的性质我们称 GGG 为一个置换群。
我们验证上面提到 MMM 是否和 置换合成满足群的性质：

封闭性：显然置换不可能出来新元素。
单位元 eee：显然 σ×e=e×σ=σ\sigma \times e=e\times \sigma=\sigmaσ×e=e×σ=σ。
结合律：容易验证。
逆元：容易构造并验证。

 3. 轨道-稳定子定理
 3.1 轨道与稳定子
我们设一个作用在集合 MMM 上的群 GGG 。MMM 中的一个元素 xxx 的轨道就是通过 GGG 中的元素可以到达的元素的集合。 xxx 的轨道被记为 G(x)G(x)G(x)。
G(x)={g×x∣g∈G}G(x)=\left\{ g \times x | g\in G \right\}
G(x)={g×x∣g∈G}
轨道是 MMM 的一个子集，表示 xxx 在群作用下的“运动范围”。
稳定子指的是 GGG 中固定 xxx 的元素组成的子群，用GxG^xGx 表示：
Gx={g×x=x∣g∈G}G^x=\left\{ g\times x=x| g\in G \right\}
Gx={g×x=x∣g∈G}
稳定子是 GGG 的子群，表示那些不改变 xxx 的群元素。
咱们举个例子，比如说旋转正方形。
我们就定义 GGG 为旋转操作。
G={旋转0°,旋转90°,旋转180°,旋转270°}G=\left\{ \text{旋转0°},\text{旋转90°},\text{旋转180°},\text{旋转270°} \right\}
G={旋转0°,旋转90°,旋转180°,旋转270°}
不妨令集合 MMM 为正方形四个顶点。
M={A,B,C,D}M=\left\{ A,B,C,D \right\}
M={A,B,C,D}
我们选顶点 x=Ax=Ax=A，那么它的轨道根据上面不难推出：

0度：A-&gt;A
90度：A-&gt;B
180度：A-&gt;C
270度：A-&gt;D
那么 G(A)=4G(A)=4G(A)=4。稳定子显然转0度才是固定的，所以 GA=1G^A =1GA=1。

 3.2 轨道-稳定子定理
对于有限群 GGG 作用与集合上 XXX 上，定理指出：
∣G∣=∣Gx∣⋅∣G(x)∣|G|=|G^x|\cdot |G(x)|
∣G∣=∣Gx∣⋅∣G(x)∣
还是上面的例子，根据上面发现 4×1=4=∣G∣4\times 1=4=|G|4×1=4=∣G∣。
为什么是对的？
根据上面我们提到的拉格朗日定理，那么根据上面提到的 GxG^xGx 是 GGG 子群结论，有：
∣Gx∣ 整除 ∣G∣|G^x|\text{ 整除 } |G|
∣Gx∣ 整除 ∣G∣
现在只需要证明 G(x)G(x)G(x) 是上面的 “除数” 即可。
考虑群 GGG 在轨道上的作用。对于任意 g∈Gg \in Gg∈G，我们定理映射：
g⋅x→gG(x)g\cdot x \rightarrow gG(x)
g⋅x→gG(x)
其中G(x)G(x)G(x) 仍为稳定子，轨道中的每个点 g⋅xg\cdot xg⋅x 对应 GGG 的一个左陪集 gG(x)gG(x)gG(x)，这个显然可以证明。
那么 GG(x)\frac{G}{G(x)}G(x)G​ 表示 GGG 所有左配集的集合，这个显然可证明，那就证明完了。
 4. Burnside定理与Polya定理
定义 GGG 为一个群，定义其作用于 XXX，轨道的个数等于群中每个元素对应置换的不动点的平均个数，即：
∣X/G∣=1∣G∣∑g∈G∣Xg∣|X/G|=\frac{1}{|G|}\sum\limits_{g\in G} |X^g|
∣X/G∣=∣G∣1​g∈G∑​∣Xg∣
证明即：
∣X/G∣=∑p∈X/G1∣X/G∣=∑x∈X1∣Gx∣∣X/G∣=1∣G∣∑g∈G∣Xg∣\begin{aligned}
|X/G|&amp; =\sum\limits_{p\in X/G} 1 \\
|X/G| &amp; = \sum\limits_{x\in X}\frac{1}{|Gx|} \\
|X/G|&amp;=\frac{1}{|G|}\sum\limits_{g\in G} |X^g|
\end{aligned}
∣X/G∣∣X/G∣∣X/G∣​=p∈X/G∑​1=x∈X∑​∣Gx∣1​=∣G∣1​g∈G∑​∣Xg∣​
Polya定理是Burnside定理的推论。
对于其中那个不动点解释，并不是要求每个顶点位置都不变，而是要求 “颜色” 分布整体不变，顶点可以移动但是整体的 “颜色” 排列看起来和原来一样
给定群 GGG 在集合 XXX 上的作用和颜色集合 CCC，则不同的染色方案数目为：
∣CX/G∣=1∣G∣∑g∈Gmc(g)|C^X/G|=\frac{1}{|G|}\sum\limits_{g\in G} m^{c(g)}
∣CX/G∣=∣G∣1​g∈G∑​mc(g)
其中，mmm 为颜色数目，c(g)c(g)c(g) 是元素 g∈Gg\in Gg∈G 的置换表示的轮换分解中的轮换数目。
我们啥时候用这个定理，要求比如说计数，并且出现关键词本质不同。
 4.1 小练习热身

用红绿蓝（RGB）三个颜色给 3 个顶点的环染色，求本质不同的方案数（旋转对称）。

首先这环旋转肯定构成一个置换群（如果你想用 Burnside 定理，你的前提这个得构成一个置换群！）
我们分类讨论一下。

旋转0度：瞎染色反正不动：333^333。
旋转120度：这个包括左旋和右旋，只有三个相同的颜色才能做到旋转后不动，所以即 31=33^1=331=3。
旋转240度：同理 333 。

不动点个数即为 333333 。因为就对称群就3个操作，所以本质不同方案数即为：
ans=1∣G∣∑g∈G∣Xg∣=333=11ans=\frac{1}{|G|}\sum\limits_{g\in G} |X^g|=\frac{33}{3}=11
ans=∣G∣1​g∈G∑​∣Xg∣=333​=11
不难验证 11 个方案本质不同。
 4.2 大练习

给定一个 nnn 个点，nnn 条边的环，有 nnn 种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对 109+710^9+7109+7 取模。

4.2是4.1的严格加强版
根据 burnside定理得到：
Ans=1∣G∣∑g∈G∣Xg∣Ans=\frac{1}{|G|}\sum\limits_{g\in G} |X^g|
Ans=∣G∣1​g∈G∑​∣Xg∣
我们考虑将这个环转化成一个置换，我们分类讨论：

若旋转0个点，那么所有集合的点都是不动点，那么数量为：nnn^nnn。
若旋转 kkk 个点，那么一个点是不动点当且仅当这个点在循环节中循环了 kkk 次后还能回到原来位置，说明就是长度能够被 kkk 整除。因为循环的长度能被 nnn 整除。所以其实就是这个长度 dgcd⁡(k,n)≡0(modn)d\gcd(k,n) \equiv 0 \pmod ndgcd(k,n)≡0(modn)

不难发现有 gcd(k,n)gcd(k,n)gcd(k,n) 个循环节，所以不动点集合的大小就是 gcd(k,n)gcd(k,n)gcd(k,n)。
源式即为：
ans=1n∑k=1nngcd(k,n)ans=\frac{1}{n}\sum\limits_{k=1}^n n^{gcd(k,n)}
ans=n1​k=1∑n​ngcd(k,n)
这个怎么做？大力反演！
ans=1n∑k=1nngcd(k,n)ans=1n∑d∣nnd×∑k=1n/d[gcd(k,n)=1]枚举gcdans=1n∑d∣nndφ(nd)\begin{aligned}
ans&amp;=\frac{1}{n}\sum\limits_{k=1}^n n^{gcd(k,n)} \\
ans &amp;= \frac{1}{n}\sum\limits_{d|n}n^d\times \sum\limits_{k=1}^{n/d}[gcd(k,n)=1] &amp; \text{枚举gcd}\\
ans &amp; =\frac{1}{n}\sum\limits_{d|n}n^d\varphi(\frac{n}{d})
\end{aligned}
ansansans​=n1​k=1∑n​ngcd(k,n)=n1​d∣n∑​nd×k=1∑n/d​[gcd(k,n)=1]=n1​d∣n∑​ndφ(dn​)​枚举gcd​
注意到本题可以暴力计算欧拉函数，代码如下：
#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr ll MOD=1e9+7;ll phi(ll n)&#123;    ll ans=n;    for(ll i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            ans=ans/i*(i-1);            while (n%i==0)            &#123;                n/=i;            &#125;        &#125;    &#125;    if(n&gt;=2)&#123;        ans=ans/n*(n-1);    &#125;    return ans;&#125;ll qpow(ll a,ll b)&#123;    ll ret=1;    while(b)&#123;        if(b&amp;1)&#123;            ret=ret*a%MOD;        &#125;        a=a*a%MOD;        b&gt;&gt;=1;    &#125;    return ret%MOD;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        ll n,ans=0;        cin&gt;&gt;n;        for(ll i=1;i*i&lt;=n;i++)&#123;            if(n%i!=0) continue;            ans=(ans+(qpow(n,i)*phi(n/i))%MOD)%MOD;            if(i*i!=n)&#123;                ans=(ans+qpow(n,n/i)*phi(i)%MOD)%MOD;            &#125;        &#125;        ans=ans*qpow(n,MOD-2)%MOD;        cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
 5.经典大例题
蒟蒻计数太菜了www，有很大一部分都是不会求不动点www。
部分题出自省选集训（原深？启动！）。
 5.1 洛谷P1446
不难发现这个洗牌其实就是置换。虽然没说本质不同，但是解释中说明了如果置换后颜色相同那么就说明是相同方案，其实这个代表的就是置换方案。我们后边把 “洗牌” 统一称为 “置换”。
这个置换当然是构成置换群的啦，所以可以搞喽。
考虑用Burnside还是Polya，这个题目限制染色数目了，看来只能用Burnside。
我们公式的 ∣G∣|G|∣G∣ 其实就是 m+1m+1m+1，但是不动点怎么求？我们考虑原题中说明的，如果置换后仍为原来的颜色集合，那么说明相同。这其实和上面的小大练习有点类似。我们可以知道，我们把一个置换拆成若干个循环置换，这些循环置换对应的位置只能有一种颜色，我们和上面的小大练习算算置换的长度。
设一共有 tottottot 个循环置换，第 iii 个循环置换的长度是 lenilen_ileni​，这个问题转化为i：把 lenlenlen 划分成 3 个集合，让三个集合中和分别为 Sr,Sb,SgS_r,S_b,S_gSr​,Sb​,Sg​ 的方案数。这不就是背包问题吗。
设 f(i,j,k,p)f(i,j,k,p)f(i,j,k,p) 表示对于置换 ggg ，考虑到第 iii 个循环置换，三个集合里的和分别为 i,j,ki,j,ki,j,k 的方案数。
边界：f(0,0,0,0)=1f(0,0,0,0)=1f(0,0,0,0)=1.
转移方程如下：
f[0][0][0]=1;for(int i=1;i&lt;=tot;i++)&#123;    for(int j=sr;j&gt;=0;j--)&#123;        for(int k=sb;k&gt;=0;k--)&#123;            for(int p=sg;p&gt;=0;p--)&#123;                if(j&gt;=siz[i])&#123;                    f[j][k][p]=(f[j-siz[i]][k][p]+f[j][k][p])%P;                &#125;                if(k&gt;=siz[i])&#123;                    f[j][k][p]=(f[j][k-siz[i]][p]+f[j][k][p])%P;                &#125;                if(p&gt;=siz[i])&#123;                    f[j][k][p]=(f[j][k][p-siz[i]]+f[j][k][p])%P;                &#125;            &#125;        &#125;    &#125;&#125;
那么每一个洗牌（置换）都跑一遍记录答案就可以了，于是代码如下：
#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;constexpr int MN=520;int sr,sb,sg,n,m,tot,P,f[MN][MN][MN];int a[MN],siz[MN];bool vis[MN];int ksm(int a,int b)&#123;    int ret=1;    while(b)&#123;        if(b&amp;1) ret=(ret*a)%P;        a=(a*a)%P;        b&gt;&gt;=1;    &#125;    return ret;&#125;void getring()&#123;    memset(vis,0,sizeof(vis));    tot=0;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i])&#123;            int p=i,len=0;            while(!vis[p])&#123;                len++;                vis[p]=1;                p=a[p];            &#125;            siz[++tot]=len;        &#125;    &#125;&#125;int clac()&#123;    memset(f,0,sizeof(f));    f[0][0][0]=1;    for(int i=1;i&lt;=tot;i++)&#123;        for(int j=sr;j&gt;=0;j--)&#123;            for(int k=sb;k&gt;=0;k--)&#123;                for(int p=sg;p&gt;=0;p--)&#123;                    if(j&gt;=siz[i])&#123;                        f[j][k][p]=(f[j-siz[i]][k][p]+f[j][k][p])%P;                    &#125;                    if(k&gt;=siz[i])&#123;                        f[j][k][p]=(f[j][k-siz[i]][p]+f[j][k][p])%P;                    &#125;                    if(p&gt;=siz[i])&#123;                        f[j][k][p]=(f[j][k][p-siz[i]]+f[j][k][p])%P;                    &#125;                &#125;            &#125;        &#125;    &#125;    return f[sr][sb][sg];&#125;signed main()&#123;    int ans=0;    cin&gt;&gt;sr&gt;&gt;sb&gt;&gt;sg&gt;&gt;m&gt;&gt;P;    n=sr+sb+sg;    for(int i=1;i&lt;=n;i++)&#123;        a[i]=i;    &#125;    getring();    // for(int i=1;i&lt;=tot;i++)&#123;    //     cout&lt;&lt;siz[i]&lt;&lt;&quot; &quot;;    // &#125;    ans=(ans+clac())%P;    for(int i=1;i&lt;=m;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cin&gt;&gt;a[j];        &#125;        getring();        ans=(ans+clac())%P;    &#125;    cout&lt;&lt;ans*ksm(m+1,P-2)%P;    return 0;&#125;
 5.2 洛谷P4128有色图
哪里有色图！
参考AsunderSquall大佬的题解。
如果是点染色，我们可以像上面一样类似的做，但是这里是给边染色，怎么做？我们的Polya定理只能解决点的置换。
我们知道，一个置换其实可以表示成若干个循环，这里我们可以把一个长度为 nnn 的循环拆成 mmm 个循环，循环长度分别为 a1,a2...ama_1,a_2...a_ma1​,a2​...am​。
因为这里是无标号，我们可以考虑怎样算这样一个拆分对应几个置换。
我们把这些长度当作一个一个区间，往里面填数，但是填数的过程中会发现你填的顺序会造成重复的计算。
注意！以下mmm不是指颜色个数！
我们先把 nnn个数随便排列的方案数是 n!n!n!。
因为起点不重要都一样，我们除掉，即除∏i=1mai\prod\limits_{i=1}^m a_ii=1∏m​ai​
因为两个大小相同的循环相对位置无论怎么放无影响，考虑大小为 kkk 的循环有 cntkcnt_kcntk​个，排列数为 cntk!cnt_k!cntk​!，那么还要除掉 ∏k=1cntk\prod_{k=1} cnt_k∏k=1​cntk​
到这里还是点置换，边置换呢？
考虑一条边，分类讨论：

在循环内，如果循环长度 kkk 为奇数，一共有(k2)\binom{k}{2}(2k​)中可能，一共是k−12\frac{k-1}{2}2k−1​个循环节，所以不动点是 k−12\frac{k-1}{2}2k−1​。如果是偶数，除了上面的情况还有一种情况的循环节是 k2\frac{k}{2}2k​（半个周期并且还是双向边），化简一下出来还是 k2\frac{k}{2}2k​.综上即为⌊k2⌋\lfloor \frac{k}{2} \rfloor⌊2k​⌋
不在循环上，考虑两个循环，他们共处在一个lcm(k1,k2)lcm(k_1,k_2)lcm(k1​,k2​)的循环上（这个也很重要，可以自行搜索），所以一共有 k1×k2lcm(k1,k2)=gcd(k1,k2)\frac{k_{1\times}k_2}{lcm(k_1,k_2)}=gcd(k_1,k_2)lcm(k1​,k2​)k1×​k2​​=gcd(k1​,k2​)个循环节，对于分子就是两个循环节能构成多少个点对。综上，不动点共 gcd(k1,k2)gcd(k_1,k_2)gcd(k1​,k2​) 个。

综上，答案即为：
ans=1n!×n!∏ai∏lencntlen!×k∑i=1m⌊ai2⌋+∑1≤i&lt;j≤mgcd(ai,aj)ans=\frac{1}{n!}\times \frac{n!}{\prod a_{i}\prod_{len}cnt_{len}!} \times k^{\sum\limits_{i=1}^m\lfloor \frac{a_{i}}{2} \rfloor + \sum\limits_{1\le i &lt; j \le m} gcd(a_i,a_j)}
ans=n!1​×∏ai​∏len​cntlen​!n!​×ki=1∑m​⌊2ai​​⌋+1≤i&lt;j≤m∑​gcd(ai​,aj​)
不难发现可以消，于是就做完了。
 6. 后言
还是太菜了，以后有机会会在加进来题的。
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>路线反思</title>
    <url>/posts/a6ad8815/</url>
    <content><![CDATA[
  a0048e2418083c29588730b2cab0694004960e22ef416a7a9665ec25162f9a39f51ba15abacfe2cac4be533f1b2fd11c6bdd05ae8ff49ac0a6683fa12afee919e8739471e0496c8165a1d1598b15875ef7c674dcda5bc7f957d846eabc0adb974f7c8d75b1b38348870e5d8648d1d30a000f7530742ae15e8548fabcf6bb7bbb65000639f3786adb5cb4ebab4fa95ef863d02111f5716d506c5427a6c371b985403eea18a14329c30ffc49eec5628def8ab8151dcfd72bb93b5f986ffcf170354e3352602fc0fe428c1f450d984ada2f81770ccf54eba94c59d48cd2b17314f2e0f4f185ea69be4a78460c789029cde3e2af2a1d250193fa443ac1b61d29058726fd5e7d409cd31ae53e6ddea68e84e8f087126e331e8ba83cbd1f7e71aa499328837d9f5770893feb410b419ebe11503d5739c10ba00647287aadff9dd91939e381dc079481719970b111788de68b8a5555a33e0479bbdc6771c40750eac52d51c4a3a6a9090343633b5167d754c08e925288eda81bb456a773aba1245d07dbf7e6924212e0bb333bd60ebe32492caded1cfceda02cb5985676abb2f8837ca8387c297bc710b2d3d1f01ebc41b84b45470adfc308655495f94d4b8d49440cb230cd478ed52409f9af7285b33438abb8679139fb410de1629d2b5179764e2d41b2eca1502357c8b48e0816292b8920c040145a517fd17904889be7f755682ee4782383ca25c39e7e6cdb8f04e5d505eccbfa48c83b74e474f51f073177b540d20b467f0cea20956320f1322afc44549fef99945ffdb6351b14dcb2976d7b2dc7faa57ca0087d816ee1c90410e548a56a112726e02d476819bd6214b6f9c7b5e28804f6d8c4d77e9a5f6ef58957d96b4e6bbf1dc7b9c316e0f67a8cff7d9320be3c9a57a9e489a24be6abdd30ef179fb471e0f4896448a9ba4cfd95c85796ee010144c3d11939dcc4b0be395e90fcc801e1aecf5d83fce8559cab3092404ad31ef870b248aaf21566442cbc91d6673a30ec1609f8b70e5d3c65e8b42ba6d87f6b192cf96fb208e45f2dc0348bbe6404362b72a45699c21395dbcb1fad4072f70edad23cb2e223dc256abcc18d71729bab9a5ba15d5c02dbdea4e3afa9f98b700be052ad41c90665fc34dbc4669cba9df584c37c1d9e86d2a65218d1aea5499387596f018e319d8c55a79c8bef6214de6c4549f6ae605bc96f9153bfa2bd6e8e10ee9d850ee53b4e5123151b4c92d066b6ec7f1bb25af40c55178ec94c3a36034c7211a98c47a0a2ca9970620b5854a6e5525ce53356ee420b3ce9a60a5864821dfd8220926923430dfc012deffb1a1becaa22b81681f82a3d5ddb3d0b0545377820d3e6520709e6eea99513635b0ba284861e1f8b6570890f1eedd583ec844e66414c8e10e52ecb2ef93d4d13c1e35ad42331f9cece78fa9744f4901c5d6f81d55b38a42a128e4fe8411226525fc0ff2cad3a769b6ef2d7cd1119c026779341745113bd55ac76099c4b349546f6f6b2c52a841dff49d70b2a99e3516edf4cef1f561447552a029a3051912cb51f697672108b40c6629873c3d056964f94d4c85ad05f745f483388f85924905cb3dbbd45307b4507ab5a7184be020405c0120488e7ff359dfc69ffa738890cf9aedea4a14837b4dff414a66101b40bff6ce066ce7e3ab174d53d2a053d9d732994acbcf02a261770060a10429ed667a7f495c321966ebd77d46da9f006fadd63f04b957e4efbdf117693cf49f339070b011445b9ffbdc1b467c11a4a94d413f75f12b72b61b68529755e52956a07574372f444769bcf5961f734fd9822102c956d9b1c4001bab863017fadec7fefd843a855ce69e61a5cdee30d2fd50882b08030272f2aa5dc83ccabdecace4747d2ac82d9f805e4f6bc7aa38293d99ab75a4bc946e39c51966f4b07ecfcef09a7a549583ab52a16f5f7c7feda1807e7d4590e45d9269fa6d597eb2394e9df84023829996e258c45b7ca4f179cca782453cb3b524628d6554d9558e41fe6837f86cc70e542e69d888eb79e19738cf8a09ea0cbb89d1c403681a8b8c3ec6795114d2e2f770eeb8c5fbc73760cb9cc91c878fdcd10bf8a045c7af34218bd50ac524442cdc20406c4a92cb596ee3e1b97602b226f9c0d7d8d65c6ae52eb80e20927e0356a831cddf2e3f03ccbef3406223b6082f8492ec65c0e1a9d03d1565a12cd707ab00e0a5ff630629e0d76d62caee24c3cb490b6d999267fc63a2af569ec75c0beae4c869697b98984334ae4586488737e00f69b4e33959d5b895be8bc67dedf07af3275a027989ebdd82f64dc4156e64f7998d596fd16758373e94f44cbafb30cfe0541b44b214a38b508a51e051d505fb2e8d30771f0e2707feaf7b58291fa8b719703e9e83a6ef550455740dee50d9ae9025c75d166bef4bec7e7d83970161574eedcf7a439981b34cca9931f815058f1f5c852af2eaebcb863d2b53dfb8a7e5f0d9a0bc296cc8891bdeff9103ae76b61c1a9e414b51e3cdc5a3adbfb9af773a398f42c724b27dac7f04b18c5e688fdaf428e7f1349237cf3336bc73e1617b7a99693a00dded0b7906e5f7f308ccb4205cf1915029656d7ddab759af72ab364ca5c4c80a442ca0de5ae9c327f92ce9101440d1b7e29858f9ac14a6424449c27498fe48e0c42055b2b080e9b965cc19330e6193dd1d240cbaf079f9d15ba9ce4f4b9c329784531a03a64920527c14976a5647bc7ebf353a2084322ddc2c8bd4d09cdead9807e0d7d31987eacbfdc4c8edc284214e895a14ac8fc5efb5b67b36fd4ea4dc63e41e0f0332768a7336cc9667095bc7714b0a5de78d2b1c8d1845c7ca90282f3639e496bc1985d8f899a927ceeae44f6e79eb92d0e8b87c5527eb6fc1ad58aecce6e1dde98bdd95d56e100c9bc304f852ec984f072afe7354614464224246ea08dc4d6b5619abaaad22f9ce76bb735e00677f405396dc6ae1edb6a6265514659db48e9938ad2163a9811aea72c9f4cb669e31bd5821a59d60a118f9528d3542af5baa1400249a4b5ccdf8fc24bebe00681995019a16ea0444f5a747874633282269aff7f1e92a8a88f40e4112dc2eccb1c11f0d9a6ecfd20f57d9319c9bcfe308d9da79ecfac4791991eca8c3a85f9ee25fa0e7966e66372156f94714603abf60282850463e85d1f73254b3a999a08c733fef92765861b56f722d9bee445edbcac53ec239fa04e127eb77c8c821adc7caf174430dcf7f19651e2d5ab1b3ff533eeb9f2ccdbff88c75bd2272e6c9932246d5ca9a03686304a863f5d878e08e6d62e1c53f8d44429f772787f3979ee69793d554a7b3841b5bf9eda9fd2dfe0b1a222f6e4e7d144932fa82cd7d1cbd6ab37bd96a45df212405c2b98bbf561b38cb4716d19308c16da7ef5bf10d82026631e8919515c76f83d7dc8cda4564445ba1d3dfedeff6e91c2ea799d3d5217dcb85a6f1b22c80b396571896ab01a404b8daa5043e382bd97fbfb39be16f795af654855a0a5b37f48f282a3327b9484d9e387f2a8592d1c77b0af5d655509459d5c250d1e7c9fd463868134085032994ab51ee824e5565114aa0659f0650a20f1b6bf6440d019e9125a4560190853b8846b5ce9dc2bfb1686708f40d200a4185f1998c7a0e33288804c389a30fbd1c7ee3f0607ecc50c7919bca0f71dbcf1380c436345866c31af14fdb9690d778c398fb20d257bb4fb38afd86302c65eafe5668246adc2544cdd722821b5180e07213a6d79b80abf1a3f42403f746cecd8b304598c1355ecd1cda8a9994712bf66fee47baf7d1e4144416179b03dda49cabc273e0b41d726d1b753eaf7532bc2d60e80c0e940e11718cef76004eb5b66851d9bcb7956c88cd859168a47f14920b47252b2215aef72f6c00c02e8d9bf49f9e9c39d1c40a1eee288bee3b963248795a8436ffe14e744afc8a0e84a842fd8f550cbb4895acb5c4fcc2587a2fa2ff96a88b43eb0031a833cd0a57b853f1c5adb2667ac784205ac28699581c19498d9eb01054574d0a479e230731abe5aa755226409114fa423add0bb88c966c6aad7cccbb196aa1e868a549c48e50acbc84c0f9950bdf7984fb3778e3608fcafb43e6992f2f8a68590f91aa338c833e1cc812e3088ea483eaa7205c615847f9c7a62035c5b58a34abbb7ecc2dcc247cadcac527b5ab079f652ed9353688fd61fc808abf1b9a6e31e2b95671c9be7434c8bf3432a05eb8403eb8a54fc5d02c88ae28e5434e0716756011046431ce64055c8fcbd294b9c099bc20390093d1cd97ff43eb855aff613091004867c80dfd3e8b60ec2d47ee72144d5b40b67a2251304b8604b2b1af6a016bf96e42a1ccf012f914b58ea516030fa248bf78eb5c6f1f481e44230eab4c2ee133a8f2fef5d9b2d60cf6db376bd4deba8e2fb3cc1350836972ae28713b11e6662b0d1e93b1cc7a04281fc146a1f5f6591580ec9086cc17ebd8fa53838d301d9eefacf72b0e88660eac4f9e6ac932fd2f68732ca02cefb5703ea19699d5995d7e1225c1537c8d0bb3cf97bc1a3420de93ae8d6bf2bbafca28d16e74467a2ea6108e22a432347c689c38018af5d4c5a45bfca91e890d474a619cf2527b4167c433bd7b5c7226f3907cc4aab36996f39f472f5f5aa51f0f96e795e364d848c650e0c8c8736283e29a99189060296ab89dff31a069a16699ee1e58240e99336489ea1cecd84d32434370df0c1f500fe3a5d9e4d85661e7e6c2bd6fa3a41cbe30bc1f8c027093eaa601e1876bd1bdb146e9c60ecb71673193ced71914f93996f106d50def7af7d64024f2a659f5fe454fbe8e4e8229d933731e3bb6ebcce778439fd2718e1683bf18291183e9653b4c0014664b31aede143ca563b154a80530d0974c6a41fea2402f7376330743a2a6ee0a357e5beddcf4bb179033bcf4a3cc2ab9e83fc3cd84553b3a039e737c3fc833ca938094658e761517211433e3b44b024667a3ab3bf3a4e9683730345b555ab5d5d391ed5f2b25f6bf3481bf57d1a3409f8d50f171c1bf1ffb7e1f24f6c46d4418c6e524b19433c0455cec376c498d9b68679a321cc326175888e0109d53aa578ecb575f3b8e83bfbfab3d2b94b9111c6eaa2c40537faf3727c5891532f644b1c377e3350e3ad51581feebd62def6206be01329e94d6ab5e7a63afdd45ffc97941caf38cae77b7e8106a4d26540b001bddb935b0f5075946bc7e520f68e52d5533711ac91d6319058dc8da5344f1145720e05a9effac60c064fbbcdd8802e7e2aea8f269ebd9a257d2a227878ec79c19821e6a238d2abeb000bb2256fe003babea431e3c97ef356fd82cc16f68e8875cc431f4c293538f1f36716a08616ab122695b3e31eab9a748bf74f07cdf49fbfcbf02da457c91eeabab3832b1e7ccb4f9c3764f7dba868d4cf282dc200feb35f02dcc92a94cb1fb031d648b0a07a37e0ffacaf44368b1c531b6dd88dc9d26e38761a02486adcb7339219d27b3e510c5a2d7a9a31339839f9dc65a33f0acde3ca4a21a8b017a6559025035d472743a0b2b27a650f20440d3c027889f20b23902039bfcb0bbf1b45d49b8ebefe8020b18fa93c700093dbbb8db4e0cb6c3fb3f1cf26aed9a33968a607674549ff1b64d580fdb505d81805dec3208c2a2001d2576060b8656b51a17402d443bdd324bc420d29052b5c8f7c45e823d5ed5c132969ac648462077feb21e099804063580e131cfe480d272ad8ebc3ac9c67fa7f19438ac0de4e508233da6294e72f4e73cb6cd50a5a218a3df82301d45fb117fb6a5d2302adae2584d18f5996b27fe9a573bb2a682323e092a7859f88568784fd9f46ad7003db9d9ce28d9ff07d4a59ec6a20708c6f06b6d076c94ffdc4dc21f4886bbe2a23ddd120e58d5a96352f3e8db2368863c27b0d2ff51fa0c95404ce620bc9b009dad77984e56dc0ad4fb1d65287209f02a8bb75d7a7676eb7aa3f121f6bb21512fac778111a6d8aa08890b4216395a45c6b43649459fdb0bd8e4963ac1ac81b16c050217ea0df77e89dcbe9e10500a7925ab9f90dfaeaf5083d6e1a881903472bec91ff5569bc415c34ce2c845a4807a427dd4c7999860f0ea32583650e71d534806481c8299d6813b65916d0ac14696f5124f40958e6b39f1aa3058e0493921ebdab67d19ad0334e85928584847b70a145c1e9a6a21e87329a05656d9db0943bf855043f9ab3ccd2fd03f410de92ce9ae8ab2e743b423efa7ed37854bf2115e5bfa73ed2390eb6f9dbf67ff03101e4b7b26dd895da6a1c942de49c0dbffaf11e77fc692c83d5f573144fd59b34c498374185a3e23ed53b06af129e6d54f02f0c668fea73004ff2fd8b6f295c3662b801cd57de86bcb43b369e6b33037cb8159c235fdd7bfbe3c6251664693995937ecca776ae23008d2b479b1abb35dccad6a574e43a1a890721b99be8a76fbfc3113c78fbe852a0d4786f8bb1ef872a07cc2aee608c09ae2b2aca2d360a05caaaa1f324dbd0a88fa61aa3689edd02a198229a78f2d9ddfc11b7b63ed8ff3fc4bacbf1ffc307720ec74b658aded990f40220c3f79dc3dd288deef4e86d4a0ce70695d4d4fefca3cd3ca75df63054b25cb7fe0fdc8dda4d7f5f2bccd2e08ee5c1258fff4f1b6a88eb3fe77169c9fd93793616c9d49673140d7dd6311208ed7bb55b1d02cbbf615dac3ec8a2714ab307c8063cd95e843e845322da1cd42d1402a125fb840819d9e5c40fa5d37360515c3bef26c1e0aa43c7f41f28f965c0a1d0f75b3e0e060eb64e86c577e52b4b5460b48ea7a4f834a85d76548d9f505a26786a636c4cdd7f4169f3f07e051777f696a8eec117b0ecb3ec24d00d01a92b93b3cbdb4eeb951031cfe9e934690e0b8ca4470299f589eec9249e0349867a8f2de4c70fd420a72b9c65f25dc58690aaa2aa8590adda7017192adeb0d61cad9a5742dc21a2ee28c59d7345fdf96501563dab50aee15ab5b58306e9201881bcc7365014680c9b4b3d44388c506f45c3a01cbd6c3d3503a9f47ae0653380ef31668409a15bf055defc63a54d4095babf357c30d98d3013556c5dd3417ccafd2e6535ce3f99c936a68b9b53467b4c506c7361d9efde2b53f8f9ea8dd6b3bc4fd4c9972cf79aa18ef297949ea05ab4299bcda72a74c3887e772819dcda875599a99bf195c9e2a5c8d1cc4ea91f16c56c5e62f09876305f933de2f8b1b58899f3e33d167670bcda64708c79d0c3493ccfb878a979bec175426305db7adcb70592164d178ee4e34f0de58648dd33542dc089f6b0e188e0a27367811bea1fc1b04f9dc4eb849a02cc351218d261fb8452b3b3abea0f3c52dd2d5ccccdbe0a0954a5ca6993949078732a4ce265b0f099d06b505f676fdbc5b86b9b36d51fb9af33cde7bb024ce99865d05e9d5e8d06b36d4833e1c51c4bd86c2dec70e54591d47302895f376b84fa6799e9fb6a82a1e741954023c4c854183027ada9fbdd7fb3c4937578da70a513b6f1b8226bf3147d366280c6ffc28fcc11b87dcc0ebf396dae6f8a15ea2362a6d243d47735c34ef26d8b0b49fbea2d37c83fb6aa7c8aaf866f822603239870ce8207b8fbcfdbe5d28463840aa0808f9b344d2fb5b5b30862fab5714e264988571885c758de37ea2f5333a87ba113355babfb9bcf1d743cc8f6bbb6c311112a596ac14e3b4f4dac98945ae4a801595003e5720c1b9383162d8a7f9770c4a365fa100118ec88be66081f274bf0b62ceb10e5d4f3a9c1edac928a8bd6b997b557e12c7f19546d003cd4150b51cb95266c79be508f1b01d5bc13503ea7554620ec88c92fcbf796d833b1a5bd6b877c19f47a4b4d6d68ee8af6a8b80730ed54a5c21ab0c767476f520d247f2568baa4810846723f5d45731dde4126e2fea29b03151bbbe4b5161ee27dacc88e07eaa5d2d3fa90480fb6325b60a1e531a485136970155e34a5e2cc7f16b8c38787ad8bef1e611c65cf0587cc7c4ce638fc978fe5c748b814c957b3e576143f3d0a557f3bf43b046ea8eab0fd5863cbd29001654f35b59e249b151a9d8d04c09f118ea6f89df501d2ead4b741f0f3a451405e27b09426eb4a8cedb8e64267909c174cc5c4f11b35aa59652a19c9b72e17f71014fa55699395531b385cbf3c3c09ac79246fbdc65b0cfa742606646efa4c35d2be7f89cf4ea73e92566877005a236f3f05170579ce5c0d2f8d5bf5bea26167bd2521e0d040fbc919c534bd4b7247b4a24ea62c2fdfa2a9ebc40e86590966b5a08e37d6ebd924eb29ac49bfd57d26ca87f675ee4b54f80da783d094d9e6eef40b427ea9522b0959b11854b6f44e7a61f279b5d2d26077869ebedfc937e0b75ae9c3b4d107e69933a043f8bad1e1e1b8a11df4a88524088b12c2eeec98efd3737c3973bb7ff539b9c8eaa439466e5fc0de7ee85ab664c50d2c396a00942cf36fc38dd3c327a552a32d1865efaf5209765d8a1abc2abfdbe80d26eaa840e227d78f32dc962d668c2e494e633b227a633661c0338588591ee9f7cd1ccd3b2b84a095958eb8b670e70d86811a047b14435e38c46e3ba958b4fa66e682cb1a7f68935e45a2597fd73a29e50fc5584b96fb9ec8cc92a774140b049d9b75b74a8939b1c6679a09710c065bf1a49951ccf722f86a7d3b5653cf010aa4bff94afc4b17c400fb0c85919ecacb8fb832e617716315dbad56feef420887aaa8e53f62f536d75b7c91727e1fdbc31dc0826a34c7f6a50151e6ad78250f884ef950b294a5a1e97c1b20210efe7d0e89851a01786ec3cdad1f3b92916ab96a421af36f007dab039413236b819cc1f30f9685fd54264d92532060206d2ec962a64ff481a307d21f976202d3823a13593ea4569a8eaeed2f3f5e7bb829027b1f299054c0539a3feef0ba9adb4e8ec1c5e7f9b1ee33ce422ae8f2a9e460c7be3200afaa2d76228e12230045d67779931991136b881ee970afca960f403b45b8d8d8cc6804a48ae3fa6e35888d2207af63db08774dcdad38b3f76c612989bc30f29d8078e2d44876bd5ca6f4f3a226d20077499056ba43f42be628814735e03ab2a82a82acb2a297e27e5aa128f2d0552b34a972d6036ec320d72b8482eecb5f8798eb50aeaa28b5920b3ac5c4d5979095c78d7bf1b61d44b37f64fc2ba82579cf66a85aa089c4cd7731b892d167885bbfee1302f5447b5948d0a8e2e69515a5f2e90d01663c504d158afcd3ae2795ae3c6200fbcb4255e45b0833856a0cf9f8349432bce022e759a55aeb45a458a9154d4f1ff390a16ca6470b5967cb3b075b20bc1ed4bc1f174940b21f55825329f031894726fb88549628c40d95041b501cbbe4a782824cc9311c74f6d7451ee9d22e45d665d5e3138014faee3252fc7cc64e3d0dd4f163d491e40136a281c614ed70a3fd5a1382b3e485d2522232b82827223b2db4e184aa2fa5eb56295a09c54f81d8c8ea4c96675a90a6fa3c50c7981ad9d23d78c9d2fda99ddae33f640e684f1064f96c1c53692d9abcb01b5a56957ac3ca1bb5459e4e1996887faa913817176352c353fb05536520e03965b2dc37a0f3dc35a097e482e982e2d034453c332575ca37e45040f44160a9133584bf3b35c7d699577e4df47dbd23af83cc1e1f3d00fe7518dabf8d6542ca12615b0e2cd4754587c96488a0e176e4f5f26fc7fd7b154a76762d2f9910473b59630b27f297fecedcc3ba50c864d7c35a432ce11da775fa39673f5a3ce531be350c64eaf70bf2ed927470204c9922052a87692e2a7b3f8dee45ef8a346e3acfabb5dc1205ada7e328606e3f9104e4879c8fb8856c057f7cde25c524a6371d2777b67d80d0c184d6c53a3ba338f84d15e2413238044d48bcc7cd1f4b9a7c94b5f31752b95643a6c3f0a5d8631d543c3606ae2155755012f71112c15c9098ca20896ad153f0c8116ddefea03d95dcd2bf7c8a45707fcfc51e5c71618ebc59402c6367969e396f696633ed60f2315b56efeb088dd0c914dfc836c775f426586566337d13b144daebbe7049ded169c6debe26803502c69570aaabcb6370ff23144e453c1a0710bd81bc48668a4982ef95b8aeb817211a117c02ea5bdf06389ca78847f1a31e109765fac65f983b237376878b3e936b415526f3c4b21ee9188d77ee8c06260c76ab98cb1a814010dad2ee09c243d9d7aaf25e76db1410ea4983cf71e95f0471922663a60e6b84fd06a409b668d9971c27c1b1c38e80a9c24f98282395440885a04578e3e13e38e4004d1eef1c96d4efab0347919c74634641bb7e122ded7c54a441eec2ac750db4ab9910252cb0abb9d74cba0e580712df631251bcea2a30211918630bd181acae530213f3022604c25e364d4ab9236bac39afe70cc1dcc232083551d5a1dcc05d3d86eed52c2879182df2e6a8b1e53b1e721a6b7058a7f2caf890220a8a4b49458a50b312c613cfca676c8cfc3b2dbd8317d1f80de65724c64247684ea1200b1b303c3da239d36fa72f2787f033afe2c5d05fe8ab5fcd67b4265526ff1af04aa018bb66b36890d93680dd429dd60ea9e0d569637d05f3d9adccc7c04d8aba6e45ac327ce64abd1957746da0a8dcb10eae04cfd09521cddf1b1f875fd4d3a729b6d57dab61913caa00ef194851e8c422f184f54a0e36ae7d225aa3aa59463e7717143acc3621e4488ca665ee89661d7197027cdc99d83bbfbede4bdef6603d2b94c25486b225d1402a4a60a801cce9629c2b956b8ad7d69b45b9617a7ae74da83837d77cee883153b7ab9a14b0831e0eb10d20af31e617561a027745d13d080a47eb740d6fb71ef45aa394600d6b2110330963053d05eb672a3292616f2d0752a52193bdc477b96d95f67abdc8fad63c4b0861177abbd0808514bb72b072e5ef37d2adc801a2781ecc6396378f375637d445d9c09c3e12d9263dd453bd4ea508231ef8d3ab710593115bdfc6189960d733d30876581780ed8b5a66fa8338cce921461e45b612bd22b04db4240ee7ca20ce69604e9689b319ed65cba253ae1b882059003353e15ddf799496b75a93fbed905997e9726e96f67ee17e67fe35967270a2b74c7e30343f38bf350782d3105bf9dd6111fe1aebbe518c415c57d8fcf6185dbbd5bd4b1207183203b557e6901e11ddabc3e2d2370d69a09576c95dc55152718d09f8a4d6b603c345f695f32c64df38cef482125b8646387b7c321eea56fb55ef6f8290515f93cc8ede08bedd6c49caf49d4a39d2e392b562235af35cc3a373b16991611e6931f99d16d10ddb1224309de32030c2c21f09e188009882c0713bf4aa9014df2184bad41c199e6296da0a90c0920a58ac348d1306bcaac9689fc48a7bbdab5cf69897c591ce3f9bce2094866612159ce5063d61c57da6ce446c77e3c2a4b2db59e8b0ec24dc960297c61dbd973d5b3d9b6765f97aa6492bcdd89125f46cbc6a0a72c911eef0a7d79368ab999177cebfa7ccaa3be58c2b6e98a34d835daf4363c3bbc587d334246a23bac3311fa2299c7a497979a442281945885d92b4da539fa6d9b4f611852e6e5dfd616e468adf38481686861fabd343a3647043cfaf474f989e2369da9b53bafebd08148226eae9b0f70dac3b286a6f7ffaf32e97ca3b0d083f67f9352fc4b43aa40498a1252b23a04998a51b2462ba28a34bff8da1dafc69099eedc957668ca794020af3f1116be1dfa4f8b83b99f10f0ce4d04dfb6c89657920d91ba209943d6dfb548af6a067b740703fcd0b9e4f65ca1228d2aedc7356dac22ade0b6627429c9e217d4dd18d949db2041e4ac3b1c5cab11f0ee5827991a130e4f074e1fd28d5a17dd818830132c346cbb6d4699eda9f36903d3f8c1d290ec8bd5c2e545c59312077da362b56dfc08b401277500a7d377033b9a5d070c6906b4152b2f9b05ce83a1bcd7183ef9de68988b46d88369799823c4b93ea94ecb25fa32e41a07c197b2dfd86a87a29c5864859e866f28753a88bbe46efb4b57df7950a4342b2c5bd98bdad91893e2acc694c46b54522eaa852034407546cfa440ff86551a59c6e3260a4b1429bd928f5baa1d5b0f4449a2d3027d1dbac27e0e2580039725b1c5c0388446067a0243b06deb6dfe872656fbc9a10800e01d959b5cb73a7bb4ee42ac1dd9b2a2bdec68055204e131398c288bf0416310982530a9b0f13abbe1183125cd4c8e19d4a66638e2f2f41d7fcc68d4b109549bb91915c8227f1e908997aca334a6f8ff7cec11970b1bf2e19721e8abec572f7087c1c6608b1bd546025947c8238e89db3ee3f3a74e7f17f7e29cd0690a5fb345992b6c65d6b7803046478204f08d496da0a7fefba6fab46a88fdeebb924ae93ed348998ce8b3647fed52a3a5a6317d37446857ad099ace73a5847e6465b2d7e4f6dde70b07e47c7f30e1c784808b25214a880f4052e73f25a91387642c8e413f29dc251b91fe00685663f9696c734d0e716d24b1051963bd6792781b15e13aae6f72e656438277ac72ec6348301c3fa1289ee554a516ae62f4858f5faf38bd36b7ad294ed6d9b1c4abaad78839c4b48eb295b4530cd819f6e7203985a11d505c49e04cf36c5849c45ff21eeb89acfe2c27c4bf07bb3cf513ba38ec84f052a04d3d4b79b2b8f1c12fc0fc02d2dfbdf24fb4bd130154d3a56ac5fb66bcfe1b9149de836843fe76197b896dab7f4e2e6576f0b3be81f7808ff9af73fdebd03b735dfc0f965e2cd4f7a7a29f025a55cf78f427ee51e8edc8fc9c0421c3b54948bc4e58b2a9f9635ce0f814ac1ce668f25ed417daa01dab3a7c88fe5f7bf2ccd034683a5645c5ad38dcd00ce96be3e4054a7ba4400ed2a3771c3d9831cd4c4960c4fa82b937f52c2f4d2531ca7b12795bd78549d0b5c42941340a7f411a0e4df203d7b870ac16479625d31a5b200176dec3a1e3fe919be17632cc249875379adecbd00f64f49f0f0a9f6bfa8adb56b33cf9910b48520837e34deb5f282f573bf082bc5d1cebd58e6efd3e29fb21c3538a5af7cf078885aae25d2f0d00856528ac1052e1e78d757fea8158fb004f58271e3b4e60f62333114bbab85571626cd718dc80a2e83ad9b5e818335974aa9c9da1e7b9f63fac72a9297a4c02944f5923beeadd116d10ab0d33798cd31f00768767bed1ddf73a62afd7e6b6df46db23f9021518a25f4ae9a85703f6a300011905606b401e4557a0196bb02adeff2024bcf58522afaf0cee70c1459ed33e7ca918328a06e25d147e7a0f083f5a74541d530ec2dacb2ddef86613bf536e664aca60c98126fe5001e5bbdc0d85eae07f6ce5a5becdcb1f176be76bb40eb697fc37c38f33667c36ebc631a29e5abed42ea4f79e3c7781defac7613bddee7375578765e34091542e9a59e10396dc8d7513af72db419c48bd4aba4bba2ebd315640089629af12f90856c9b684611d897c7bd3da97b4e001804af3a4930fbaac29460a11519d8e35d60da202ab7f5ae72e73efa8d270e413332fa987d5384cdb4cb875e2a187c99fdc63a0075bd59531dd9268f6062c5dd5e02b9c03f5053002eaaecc75d5e26972fee98a2dd463b69b71813a764664f6389bbfbbc28fe0db144077e38f84a9bb8c0d3ccbee3c762adca58c3f9341ae282acead73160b7ddf9f86a2f3d270dd65cc02b7c3d9089499a55f702ced796b7127258913c14316997e9d041246fe70319233902fc1c478fa17f0d2e1177ea0b7610486bb3f0fceb6a91f785a1a1fe556b43ae30e7f19f6a598e4f6de05b7ef28fab1abc4e9e01904ccc4d4726b825605545605b5b3bfc75d7fa6ad657d22e5e7c075eb9400622cb3fea30d80e695f0121e5c73f323f0f1a97a5b933b40d9f46391d27057f6d7e840313073f3d2e63c5bf3e8dcd1ee08e3e076f5b930384c134469a9a02a9577e476cac3edd8e5cd68cc6f0068d13cbe233bac0fca995ac8251f866c4d1bfb3b65a28b217fd6c93992689cfd416d38c73f9d89840d10597891fa4422a941950bccd6c054c2eb37183c3e29c5d50b0b74041ac40d7acb3984afda5f7f574c6442534c88a038c0507d69ac95cb58d61c587b77c989655548ffffd94ced6deac05e14e617b4fb3933d74ac9d545638cae8e3d1f77d13a8adcf0a8a4c3ddda1892de9512bf2f0bb76be158a52924c27e5fcb3879436eaa63c8acca6de2d89f1f9d5f9d4020a27a5265b053afa43393df631b20e6c940d84c939ed7217bc2d0b46a6ea68dfd8f1c852fd82a578354fa495e618a248713b4d7eef2d4ec11d2c5d5c2104b7bba09bf7bc6831762321c66ecdb8533c6a6dfbd8a6820e9d958bb11799f088d27efbf8e3689837a1f615ccf17b586fc4af1f084b08e0eb374ee394fb57069d2a36330a3a7dcae920937cc392bcbdcc1391473df77c397eab333bf47e9eb17fab2389eeb4aa082322c1faa7b6f101130835e9cc49b210cff0894cb104b7aa6719b79c48d70e64784fca02e4dcb85e1fbd274a95eccf62157c36a2ad10b8bdf5cf7a86939a79e42196c78b12330c397b85e5d1ac4b43d6f556bbe794508cd3dff562a48f0b1daf7720b64fa3eebf4d430f9589c3b1916c2f98220f5b9897a7bb73cff019ceeb60017a2d98991dda47afe282d73849f92536fb8b7b52f11377c5ec14433538717a7c7e4b3fcbaf66060527065e390309bc14c06b5216ba081ab015d7886ef631c510f674fbdbc49e4af850feb1d2061e755ba0d18b23f3c8a78d54a3886d12f5570213cb34247d5893dc0850ba11dd869b2d3ccfdf33e104cee96d9524463dd1179d346d7138fdd00078e48e9c2fd9f40095312fada8eda96ef8174a02518f63268ee080e75be25ebaed270b121c9270d7b197b00369ab5e215344ea3f629a876ed9bde52d7d6188d44a0c9d51b47098973e2beac2aae810d5bc529b5e364d4f7ab8388baf0d5422f3cbb32a9ac6e1b47fdf5134029ff528dbf40f7be81cb74024789f0df6fbdf4b81bb0b2f43379da25c2c567410a27e9f975cc7354a01b41965f3fb0f5f6b876474ca0f8795114532388d8abd62f4c3207cb206d2dcca7b65165aba7fa5eef639727eee32a5e357c9980e92548f490485d97dc3cd7b004c0ff97867b1a4a642357c20aa0eb6f9d425a24ad95a3295030a93d81b14218890a38229d12513cca789003473ae50df3665eea59dc93c12b5775885d12717300e47005c5f8224097110761bfc93a07334c4b7a92072b99837962a5db0b1d9cc34e5338bf10c34acb17eaf88c79462ebb95f265a8f21400b63e61f49f2df32ae8856100206327c84ec15509766ebe0371322d505ac895060328bac119fea5d3c1b175eb4fd2afd05919d71286c6810c3516da3c2c6dff5f4d7ed42ea2853108bd56ce3698f0380b74c6d68caefcc751b74db1ea5da041af7d1f5bf551e996fc556ecc18f0760ba2be889a95862c3200045bb5b248553a0b247e5bdc1709fafaa22136fbf3ed5453831444f336363399ae7b5bd41035de76457620029d39a35e1f2a1ce575aafef87027b997dac9a6be545d3cab6a00c86bed914d1c32182c87296ce144de6eca1f790c5683dcd168212b188118bff63c902017ee3058e1bd142d1c0a6340e2315238de85831206b197eb5aa50950421db5759c7317faa5f3b21030028b6d51d07d12229ea8f2ad8302fa558be4dd2e806650c1b4770e9868b8a3197c008446cb9c1f6b501e4d9485094c1c428bc3f8c1636d6ed066e09ded886b84b5d14b2dd8a055245e0267e8f4b87399d7ec83b9c2078c130b23cceecf0a90da0b14a7f1b5d78566437c6b6ec0c0239f87745873691e8515ee5a0b1a626bf183cadc059b1d65fee6ee3c11b404b5de276857bec8b052473286c047f2ecd6dee3c955b437e04e2df64c1ae58014365b8a1c98779eb783bcd6d7fac04a7878c5880fb38b2ff75994bec1fad4f978ab8031e697cbda2c62bc6af6adc41e0af4134e227c8ebaebd9f1a69c0b8c98e73a1fdec9250a0d41514f5942dbfd6462dee9bd157dbfdada70ecf5aabc7473ff51dfb2cbb7af8f8f0d409ca1e7cc9829b7ce6a8dbcbc7eb7decd40d4faf72db62ae759b48acb2b5e5c1809f86271e87b2ef3b1e7f386f8dcc76d1158ade89710d018babe8b44644802f010ef4b92fe9e498b8327751e4a43db198e9f38b9f589ef6c489cd55670f4ed2edf05487896bc3e21ff28b9d22055746cf072c2dc79a0aa926216e2be5ee5835928a068967bcea39faeeb7eacb24ca0483dc707ef91d71eeb791ef2f35171baed5ed72b4de280cc26cac68d115240d46c757733b451482ce644967fa6499ae4429faaa28a969ce3f79f8dea2d7920075133c44367a5cd71f4f1055140339cd4f644a78a94b90f2ab02adc22561725bb5f27724e19c6b0129cb22291e8c31b9219535866ab7303992475090611a698e9c960529aeb7a722c3b0724f0bbfa85599262e2791e92f5a4a452cf0c2177257fdfa0628f09593c361b6d29b84a5175e4a571e323356572d6d33ae2e132680dd27007bd62951970a8f24959db882356c82d7b3444f445b40876ba9ba6e1cc5b04efbb404cfcdc9953b9bf0abb14bf515767d1021d520a2321e4fcaa864e89674297e0ee0990a0227fa16833adef200a60841cb72e604009f423bde56a1fcf0083199923c69ca59d3c5b8c5e3ac13bfd91e187d3f795c4426d0de8bbb1b1f3811049e8736aa6492a20e5d3b126a0a751958fb440bd8ee5941fc3db9b44f1b190b4e899ba47c369c94985ea598c6610b13097cc1da93c0bde893cee501e6430df1a7e92afd786178d647d62e8b93267507cacd967f4bb4cf43de157b0d98da9b13d862f59b1c512eda2c3135f9f5f13c9907c5d4229e000e0536e3042eafccb214c49ebe4599a601166476baebe6d9b4d459ef961e90a4febf2d020344d1409814336bec54b19ac4269502c6863fcfba9090a750b1a5b2c7480370a917c3d1ef301fbfbc06d0c19ab4b8e57af516df20a6ee56da0f919bae64ea18cc5dc66a4b4f09a7909b33f4c667bed4fe06b243d78e094977f40a6f3d335fb80653d9b2e8c36873bcb2b7b679e6ed2ba1bc7b06a194ee73baa0e53cc7c2c7898fef7ae4d9991f1a9ff674fb9962e7c1d9437bfe7988a7d0fb3cec16dc85f9a9651e847a82d6076d941285d1c59ad568047b87b4bbd3f7b2d569925b7595b1163701e5ef8208331e4b37d1322c87ec942e1bbd4e0af88350c71048cb01ac7ca6e5e58cecbc87b249c3f0b31333614badbe17632ca75660ad71d2c7143b4b1bfa12abe880c6ed452b65105803a24c2dfa4d9147324a0000a27397c0149cdd7ab298fdce1811f1fe82290261c01637fe2f3a08f106660c638e717deeb1ab7983987c46f85e070678e67a612a34261f8b1b1500041498123b0d8e7d9ad762d949861afca9683d763d72195fd99be19b62336d7122f70dcb6e6b4119e81bd64aa53adb5dbdbef3f9252414903dae55b754c1f79c3a1bc108ee62a308ff483840a3f2b21ed7035fc12a153b6920c86a26bdf9f766162ae48e891fe53dd762874766b57dcbbbf08f89426d95e0d648c9538e6f5814a1d4f9ba5821903474c05701a098be1693e7f14c1644534fb3f3afd55199b4c9479697ead44fdb45c674879cd3f8210425d3d7d5cf05f513aa529c040055d6756e46a4f80ba47b82917be1d11ce2aa1ec1c60f71029041a0f8b620a15cfb80f7b494de54561c20fcc4a3bdb77b075f3fd9b458af10272e82fd86e177ceec5c64404478d49d5ed486d6a71e234ed5d602f0674637e8d9eaf29c450562c149286d2312705c411be85539ead597b45d148b44912e71c2a367642852403c40f784096dacc65411a8507f7056b6b68b0f278621a6a187d5a95a2c080883c22c7872ea9a86dd11e5fa88188521225a53bee2449fd9e1d9f52567ca84d121464f8bfb7ac963f8112acce34f8e925898780d83b44ca50abd9dcf3040c36dc5fa6a5bb45e312cce01dcb6a6002093e6fc86261db928d5f7eb163dc6f38e53fdc9c81c94de5c6ae560c94a682eb1ec9f5f433a18c27c3dddc2d906be22dac87c8eba5fc44fd57f3c987c964d750c1017b1e9d8cbfdecbf6ce3d3c831403f90e78a3f68a5bd3240ef819d945f1c19e899ae648f20b0264603c0ab5fac5024ce7b7d14a3d175057d866fd66b698312c1410ec3e4acdc39986f52d9214af1eb9c5a9f85adae04fb43cd6da9306eafb3cfb614dc481cf13402c638cdf604fb45726d30e2f386879b10309ebfa0a387852c0063257f555a58acc588057c991f7505f43fd514a0693a13971eec139f0b7fb7ddeb1e3e349be1cc7fbec2d6f3eb26063eac1ed64e20242de849f555b7dcd39c0eecc5df87b7012e42ef9987af38f777319dd5b1c0526b84a9c81b97522848b4ec949334e3cece9aaf9ed5a8c096ab2bb9857f8544d42e0f8909a7bcc6923daa997c9fada7a1956ad60c75fe180ab638e7014354ec1919dd9dfbc25fec10d78cdb7604eae003659364e303653d32ad469d915ffff19c0eee03e4db3ffd6ac2a4fe5c83fec0911caa1659393600fd4d22f5cd56d08e117c5231a68403e568529b18be40d803acace73d725cc5c4834c8ae9832c34b0f2083c8722837bd1b05fa26e9ec4c15b76be47a8deba0802f7390264dd61fa3a65cd662603944c9617a04dfd51135be8ca9fac40d866a479ac3edce656ed57278142e0b6d8a8540a5427896c7a2dedb8d50c15c4c74e924907bd7737e5059e991f945e5985aaf8837e4ad0352d0dddb6d06f0c0dffea036f287e09bf032eca0bb8a4856699a2b763ba02ff10c66830768f1cec4096e86bd2b1c1da1808f7d4cad6f7e36c1ee3075ee336144ef172e887f2fe4ab7607f135c451fd0b0c044c0e0c252f4f5ba55bd2bae5a1c0eb78e789dca4bd412ee9025cbf028d7fb5f0822f8ae45f5f99f13c932c5964981330fd509ce2291ace82c69288153105526eb0ad2cb789a937af3bafe187c0d1af64ca7775492a7af2e1f673666fe388fe4e741502f45b80b57bdde44726181388d84a35703e2379687ac2edd3d1b3e21ef694ba8180e9850cb5b849e55afee34a394f021e278e2a2a1d0ab55398b7cb31b0ded97f7199e1fe8a95dd6bcb8673fdcd106d3d6a330aa716abb09ef750948186784525ca0ee0bfcd7f4c570108d7c017b130df01aa6c8049a686a5fc079088e88f4bd44ae8be9448b4c28ceeb35ad60d791ff4d1cb0c4c282bf991f53e5ce29423344b9af8fba2d6e791d3de6667b21cf6870dbbc8fb9c08914bcb0c54b4f82c6177213d8196ab874ec099e26e32c702a78badecc4582fad38cb5b0e9c8728d9f2b68267cd0195da530db2b5da0f8e7457e0f5e52ce4a7a437ea214cb25d9e7b8175447c61f373ab5c295effd2b33439d1db521cdff337560e49c80425647f13774d48596f02050e7e46be51054290c1cdd5c71ea65871cbc6b8c04e84b03f0a3eced084a684c37419999e012b10e9fe1cb1aa14da7147e7ea8621cce7238608835c2f72a90643bbf64a27be421ae33d2ae0e92acd17bd17ff6e827157e51e17574d7673b0ba86da616168611505f6f0310e62f1cf3d404fcdc283874dfc93343bbb012b1eb913e6427af9fefaa2221bc8f0b7d9149adf484f58d265f2d2b46cebc860c5ba10173666c10febfcedb026e2e4fd7685f49d1d9dd78e8f7bee7d456b49e3ee5af8d86239d8ce06507bc9c2df8b983f4e9c91ec359131384324fb0bd849b0bea38cd6f9a9e3b2d47412ee9bc896120f62c7e8f26aec84295f59c23262d1892a2e09ad9e5631a9a76b089b30c283911022574a5b264f150aade1436cdfdb85ea1ab53d76bed24f6900bad5d2a8d9a60695215fcc08a03f0e93e9162c094a0e0b33b8b8bb9b5eb4728c67a90186128ae4c8c84dd5cd24b87ff6182e9b36ab6a3dd128bbd427167607c2b89ad754eebfcd3a181c695f55afbc260d89972114303f83db8e516230c54b858e522ba45a3bd8ef98549196124f20acd81f499a7f591f7148c2581ad3e0daf0a16d09e132c8002bba3c88a91384567deb09990ec29679d7d6bc8972eaed8287a3604962fc5509b61a3a99115d6b9ebba0ca996ed88d3326bca73b6283ab26ffd3e0043dd787160a53ff9ed637abaf0b04206bd31635e7ee9417c91f5a77b9ac398ce3710e8165a5515d56c8f92f283d94249fa3009d0179c14791edc082c0cf3c16e54fcb17b301682664eac931f3cd4390f5ba435d24a8d50090c3f494eaee5b2bdaf25daae62d2233bbd7c12502389f5f1ee5bf6e7c3faa46d9ee87ad691806baa61be53e62d61e2e687738873ed4fe4e3edd3334f6cd12fe0b255d08e2894efb371923e734cc75a5648ee57bbefd2833662915874dfaf71f5f5e565f8f47b4934403d588a955fd5ff04b2e39f250818ddf817df113ed858852a38c0516d2026e0ca4fc0d669e5df1665c8b9c4ad641fc1be054591866afa9b9e80a866d342a64f9a549e54fbb2f6d04d78ab5345561b9b3b423ed75e4fea832a480f71817c4fbaba53498abff5b8e7ad223e9672eb7b0649cc43c2decd607316fd2c57273ef4781ca931bac1d3e61e11c45cb71572e518c5fa500ca85b71d67f04c815adea5069f5cb383e93745f7390a0172901468fd9d308ff63b6101308723b924e8229ab18f7bee4c8a1b11a6105f38e353f81acd4a90cba0822e722c797e8fba8dfdbc4f65b299dac425aa797e1f87b238cdbf684c19f05028960db5361c8b7eff3da25585d94a83798dc3ced3a9587812b59145e5dc1d2b4bcaddc25455ea725ebc62aef37184480aa7128af9bd625345889214cded4beeae942dcb89860174b543bf431f0a65558a12a2d4e4513b168db6a8e2684138a92024bbab907cdb329549567bc5023489b217f044198d3ab7c08b10d37b7206ebda00781e67dc0bfc8569eba57ca188a8a377bc56f333cf5fbd3527cc95814061258fa9f5dd1ca43f018a676bcd069f98767a6fe7fc0f03badffb4e4a969a0e800c9bcddde3d41aa1589177d5c33e30e97b831401dd621c4603c521d605a5dac2c476db1cbf99ad6d27453af14acf80a8dbc5c3bdf0e5acf680ce772d88dc15a6863f34c3b69cea5a41a7386531d914023404e8be8c811db025b36692e12faf91018c05d743b782b25c6cde988518c5abb379858f54711dbb5ebd255494505701efa59c0db1b5dba6c9c50695e0fbbeb8e50f4294814bfa56aafe416b74a16b10164676f8439e244b2ace9bbb8aabd7f544e191a5b3b7547197e97c3c6198879416d017323ce371d9dcbc78c41445c7d11a507c3a5d9c26627967cfa748272ce22daa4ceb47f1b9b8ae53f76fdaa23e1caaa57eb5e450b696f4ba3a059922409aff8dc2c8969eab804ce460d61c7a0170d6e77e1d0eac4ac52b2f3392dc2b5e89fb4ef1979cdfadac9ce25b4e75d5c2c1bf5a99cd6ff1994b2e4873dba9db59e905ebee67048bf14fb0289665b9c3341cfb07f08438285124a5fa5c3fde218b7b20603b3cf29536b1e0718e554af396bc46a614d371b82aa496dbd6a1c29e9b89bcdb8b963d788ab248d34d543dc484ec01001743a02c5b12b7e25734d8b41c6614b690249d74c9608e89dfe289c252395bdc66c4978142f6c72760fb63bc6367017b7bd89c6e23925b4cd7b380278a456053af908ddf3fd1f31212fce9da79d430fa93227bd9d946d1a267f3923a67af2cf34a1b8d6c3163dabff9ea45f9a24a6a75ad023cc761c49002b60275241c1ba726a27a49837876af585c5ed2d0dcf3151befe8532b61da61e114a2d5c36e59ea72256659b16e20079047cef6bcebaf9e94cabde746bfd3b84370ee8c924f9390f63f6f2c72040926b878dce2c5a3a54491b84407f38bb4c7bd8ee1a8b2258aa365933065d196868ab87c8067de5a908b27709cbcdb8a061861f0c2e4571ec08a9150bf3613150706e60dd61acdb11865d1008e5af85414aeaeca77ccbb9dc27fbdb0e2d2d95ad636162ae3b6a6d1a87d6a2f644cd88c6e1e7f301ae72f174aeba2b0d742e98d38827c3f058eda11fc6b53ec639158644221d17decb4d8e8afe7197365ef1ee82bba706fcf84d0d25e656fb08102f037a6b1e9161c8150e6fd2734df1e7e4db04ce8eb246e41b402315388647d176fcae238aa238991ea310f6de24309ee83f8fb4553d56dff60fe3e9c11dada015e351cb7a0985a1adf80fe9abcb86d222146db4f09379d6e5403c5db5a979362794ada753b6c24e68a380b2984d38f8120b00cf78d62ab5c65519a9d98860f69e44a5f01ff37b7efaa825d9400f7b1a52276b9b1b274cf4e54e86cc2bace65e54f0d629556f67ee4e37017dfc0dfda3e91e7b0bf52606cd8500782993ee5eb176a78a5986442d61e2c816343b2a367c7076181510e1130a7b066f018737257b4f9117c95a3b45c1c8f7df202bb6ec80b866a3e7ee0f9f57c836999ef7f41529ece8445eb67649415dfca434b2c77bfb963306d210c384be7ba52480b076c0f926b14383526643e89fde9c50e25f809e1156405b5ca2829eb3234e74c9b3c8f47ba46a1a569ec1a8bee422c43eca7bdef7d7e87eaeb4206a41f104c375f3c63c2d91efbeed9e25895ae9d6b687210ec5206049145ec3fcf19fc860737fd80c87d3a413448a3b7f8894ae04a620a848e1120db98dcde7c6d115a3139c123b289035797b52c1473bc3012450634b22f7fafb092e03391bed9793eefe9d3436e7022dcc8fe14a8fc69317a76d56932f941f6929d35fd4215f6e4d85206088ff5bcbf18d6de7cd2b7d8ce23b6094f4c2c4b58646b598e264b9e82bc22e81328547fb39bfde2920292cf1f5f9b2cd3599adf843e5652e6d660cb2bec4665cd1b06e688a8571f9889118a3eaef6cf67ad21018792a95525eeeecb2acdea39426fcb4291d5a37bacf73084b17193af58217cd671aa68953d2224d7a8de9893ae7095660d423a6533d0c617fd76eb8397368c437c58c7fdf7712ff5899c38090e3483067e8257a72aa5bb8a30f8eb4592246e47f98cacb44e148bee23cb4965897e0a9d00d52aa0ffd66ed93f365c0f035b2cd409e13f8e04cb6bccdbdaff65f03a085aef9093d217bdbe83ecca0b934e22c8102ce380283db6886a891e868d6b1a7c2f6aa656e40f79bafa1ae8248e9c112179f3d2595ca95421700fa5934824069e8c711854c95ea210ad784dd00b23b11fab4b37987048b9e62f24241d191d4cfd96b62012d8cfd333715bb878fb2ee9f1f654d5f4cb92ab1b90c4fec6bbbce7bd726e195a23f730de1d6422c25556ff7b70dc85e92c35099c96f47c9e30561b908020cc85046414203716b7eced0054b0b44bde48a98d9da66feba58d258be837317cd5538a124960ac6bf0117b09b77ce7d8b02ee024168987f9a04b1e215695678022f4f3714ea8e3002ab3c277499811b9681d68479f92a3876d6a3969f595702d325e9fa4c76b607de852b0e8045b82554eb9ba4364b4cc305894816791ec184affac845c49e08a6090d4e0c7f2db44e08b23a6ddbe3b0ac22f7e8fa32c9771dd16ed8d266229dc0345c572e89663ccae312519d8dcf8e1765f117bc3951eb3b0484841eb3b710d555d2a097971132a3e03edcde28d400a12738689a32e8eb95dc6dfa4f6c10dc4842165408869d53bc91402edcc0052f97f3b8cfd8e1af93f7aa51d353403ba6aa09355f6fb222ac4a011f0346ae35928f67dd96ec567d825ddcfc8f529f62429a007440ec96ebfafd4592b7667f6c3cf116d7332e5498d17bd0903b7012b576c7c46819a7c8e669e80612df9e730412606387f239bee72b2be0d102abdcb774ef67bc10f4dabcef924e5cb64b69b223ed6fde5eac6220725d67980d441222f7960ad5cd88e21d75692e80bf37d4f9a94239f432b7fbd5907570331bcf8cd4cf308a0635bc9f9442d0d14c776a86a4084b667a1acd8d92fb05b86a4d4c06e83ad8b7a9fe97fecb6a39e380026603c0976e1d2ea0b3731b35e993f0b084e0e46ca44320f5bcd5eeeec0011f8c72063aef5add32636745efb98a9ecb05db72b42cacd307fd146589382500bac9bc73a1e841fbed7f7bfac9190af167fc7e7349df8614d0feff8d64444c446f99d232c0c83547581c76f65effa3c814174dc3aeae9905aef5fa865c17f599ce72d0ec418bcf88797bccf8577da832284cf03eb396402e533b5e549a8658ac24a844835e429a78f0e67a0bdd009cdfb1466e735f26efeee8bc5c5e8c1ba7499a6dfc3d67658756e6a08cc2e9b457849cdca218bb3536224317dcb709c9cf4194d1ce7f3d4ebd33a180410444a3d62a4ba5cbdba7865363d56414526b77910b172433a16b11fc7a39eece1737f7f409921a2d60468acde7a06e329c2121a48ed485fe60e36f8beddaccd245e30070b73c5f826f70827ea269846d0633aea8781eabb0e4499413ca77c1748bcc6d2db70c4258260e313a7557ae3434370041d1c212b8fb4728677d7bcf3f411434bc12be7a2656b8282e26e4e24377920156215055f7a83f0b51f281c60a443bdded9d4cc36e4b9265c5b4c92f291332345a5eb5485b0a75d52389a2d951edb2fcd39cf304e7f18aaf43e61feea5f4087fe22348ea17276cb0247c85a4754bcb84dbc9a5415e17758c75e45459faebbd01bc1d42200121e065ba2a27ff96270d719155ea842b3b81b0749c17e747a4a22f85727583e3a12bbe1165616ceccea88801936ad87072edf386096b2a73595dfdc31322906b5d9b8769ff1fb62c582613c0fe4560ea8590895d08f95c104c8d80e0af7085588ed8dbf9b51dab04c8200e86153489326f05db4b7c46260f8dfca6ab64329c1679e10d49c906ec8fe455ccf1dd52a2e05fef60ed4fbce0696a5e659ffd8e13df00524cd7afe765ba45b16339a87bd2e7296c05d2c4d843740dce5eb34e2eb8491cd4189b418839be2e51346077cdb6680d3d8cfa5fb5cd8b9fa7627d79e17bf4f2c99679caaee2eb1991bb46527e72ffd265934a6e57c06bb3c5c44be040e8cb04945bccdda8ded81d1650137216ad9cbd2366658077ea26bf053d814331dbb2c6c3fb22c2557b9f58d4807c93f09f25a50f232692247629f28ddbe3741ddf5d97362f25a84b03fc2593c3ba89f2158a46f86e30a5bd0f87163b080fb030d6fcfc5f862f8a37728d428f1ca5ad8c8d5eb348c0212e314726a0688997c57b24f34d35ef87e6091611f27141f58dad19812b02f4cc46767a7acc4688d9bd5f8466b87d1585a9fe99bfc88f50947ec465d7fc36f11ecf1ebb827c48eed4789ea090b65040fa370cb72c32c25d2c1f44ce5ff9d827a03f13f4b200405a6668183caf159e1fd4b55c95628635f93ba083e74182b0408fd61f281a200b12db9beedc928aff1ffed78f54d3de7fd0a6539a48a1d6636f3db51e5bf165bad0561665b1917d12c0d3e4f2317a19dff4dbc22b61f04c8bd905f36407478dba8a7275ccc69702ae6e303c4a8ca99017704f7e464729bd076cce80c84ea9ec5b0a97cc836936475e2a4203e2cd1a8e1428416690e0feb0420d41d894c82c80c2be966703dd607ce58a34052761738a2346f0874ac9352cdc51f1993d760310b55179e91f87c462a83db7c143fd51c4dffb1be65516ef65acc25b2d4f605f2bb2196efc7bb39bf8b5187e002ce26de3034b3edbbed6d06fe90d70b2795854197dd3a330ea3f5afb7f509253c41d99fb9106c50dc44ecd169d1f99ab16c7ffe67a20caea05b7e5cc0322a144175ce3449c9b6f455b9d3128d4355fb63e4e7ecebe5fa3e92fe7897905f6697347fc62e5971fca5fb182d5f368a1a2e88fe7d46a984b69e413c2f76d644765136848d74b5e34bdf72624ed2c92365818c725aee6d0eb8c642419182b37005d441e49eb7b71dd11d75526671488b54048abc2c7649914ca6fb133941ccda6f9fc3a0dda33e2888c1c2b8bd08384d0cba1c5b6379568944a8f7b706b89b40d18155d9aac187cd7ee0d797bb540cb6f5f12f8ac7a16cbafdd4b193ac14df36d6245a09ae5af77039a7dfcc963322ca67fbc87efd5479a3d8aa82f54fd7930d116300e0992f7e8abe34e166123a3f43ec54d913ea9ffc957b171507ce741d0bf31ef8be23896a7b78d99d35d4e6b8c5bc9f73b71fe3e48013e295965778d0047d9865fd6c1b8b361aa405195e5ffebec207abcc095c617ebc03d86df92f298d376d2609f205454be95cfb800a8df584b910da72ea8e7aecaea95e5bd3b1eaae85393418897c6a94000dbca63d9a081a9ca7116fce2495c153049780ddc0b37950f6a3d96f8c28063945ec4c5688569ad05f11685a2ecc73eee50dd2ff41f83dad74bdca8c4dcc5d37a1b954d252f4f75905f0f6f050c50a919cc26a5d8eaea25a50f0a79713f72e69044e2db1a4684394c15dd212158c3af769cfba88efd05e6df31fb2e8b1a95f0a2f13a0534fb44a4b324ddb9a4187911877507db2f4c797ea8c407e6bde2f6f8fb559400285c0cbaf4df0579221372c9d9cd9a55ed41f552c8cc53c566a743d8d1220afe68bdbb6b5db894162533f902378ac15e85c60e7f2a9a5fc3826d01c46f271df877bcf66ca8eee5cc793409737903b61d1dc377d5eaa1c026ea3687aceb0fd633c48feaffc749782a91b8fd18d2e1c4708f993fb4349f5f072fc0c532edfa3ad3cee5af0a3f05f1be373e3542b8d504bab7cfaa90f2b032c7d2b1d2163d10a16e7efcd2ae5b23c7102702bdfc7b5327f19e435faed58cf0781905a9fdde82902fa9ade67d7725e34a07e2de0a5ff3b354787d15ca586c3eefdd9e8ea19fda7b3bab89f876788e559f5cb1aa3679b9a7be886e81f0888da8a68654dccc78d389a3bc01a55db706e025e435db9f96f0d75bcddf21f178f9c910dfbe01b4c7145dc6921a83e18fc05b4be6b1b7d8879c3d262deff88dbf0acdad6765f7c061bb5ccfe47f80a9f2680c94c60cdc4fc52e15c1cf73f20e18201f6672d36f3f45a2f8904baa777a573b8146d9afa9c0d8954ef27995f6296221aec86e2a6dc255e89c88e9867bf331798023dcbc5ab10a65455fb2aa4da1489924873873e3aeeb09519fd347904f40e4de5e60d04377aa1d95a877f2ce00906804a754c8cdfea8628b9a53db0ecdcefd98fa19b2f7f93dcfe1299ee7ec7aa5929e66595caaabadfdafced3f6578d3cb8b1f24f26ed6ab8fdf1ebe30c039538d531de97fe2cecaf82b01283e6183b12356e70275c46bdbd0b13fbf3b98f2a1a99cb2c8a4e1808e6cc763ecd2c08d3b6434b988dbef60d4b326c9077eb959893694d426c16a015625a5ea83e37a957761e5a73d34ee28d1a5d4188ad60f2d59cc0a59cf1739912850b53c9d5162d8aa49fed42cedf33ca94408d99848dc17628d1c9be6176739753c084e1ccd97ecb72415cd8747507d244df71b1e005987876a0fd398a264339f2fad40560c352418f8de8ca176d5cb52740ba348242d7b854e9898c8000839bbb42238cbe5a23b02923e9227b90f11b663c4e186ff863815830f95f1bd0aefb352c91b9768d8cfc7433acef899201ae87a2256ded09e4107df6836848e6bb639097370acd38856bf9c12950217146158e15cacb35f267240d6348d4304511410cb033d33ce34f1372ccc88ee60c3526c18cddc435cc1267711d42a0629e91acfb839121488de0ae5274a28b9f7abba10e5d9aefcfc65cb922719edd4c7a811301b490087a383fd1e9e535c7201be7b19cddd159cbfc7c4bc1979941cca22a2d610c78a3714248633a79ff70205615569b44997679461c77a17493f5cd08f9ee1577ce95b5c9a39ba016db96a93e1c9182048e38dff09984d3fa1f7487410b383e436ab853282c341ee4ea329e15deb2f855611791f0fd8e5fdd5709b3c37242bcdde2e3e9f076998fa869cdd293a7fcbedd9bf176264c237d9ed51c03ec77b1a4882ad560dcf36dcffdbeca3737ffb98948984428c1c0cff5ea282893c3bbd55f01038b80f73eaaaef6335c0e1fbdf3dfd5fa5dec95f07997c4aeb035132405d28baa6a632e3bfcd314dee7f35e2e0f4baf8656fdee2845f59309370b5c8351655c356f75d3527c56b08ce18735481f330c06da2fb5acd34f1d67f0ae892e46d9e076c42253f35ce461b58a96eeed133b63b0876f239dce251c2bd9013a61f13296955c4a7585532c701e2c59abfb335a4802e7f8c2b4119002ec0a3b89cf0a082e6ec523dff50c4c888c3a7b8f5f0121b53ff95259fcfd880b0e04b0ad7377aa6cc3e4ba6eef6822d87962bf547366713a577edbade7e988f6b6849c15cf4614a2dd940068ab654d652148dfef2e4338f686e5acb947228499417f9844708d5a7578274a0344f6573db0fc4e1cbdc20d1c127724ee07317cbe004fcf76236bcf08990a702f2c7566a683a66b2efb00fa7a7b67a3f1ffa80e3896090ff19df14951364517bd6e5187534fd3b2bb348a96696b9f51188ae6b8539d3f561b2a47b3c3c5329280e1a91aa84883d11c72c723e2ae0b679445c9c6d3ca4c1c419746ed81bbf0b0a988bf0418d32bf48a1be80ae55a265f2c476ed8907044d2e3a03a0ed551beb48eac440041341abd28d1077080d4cb4862f7ec0a8c2315b1a6d3d58ab8e35f6f15598313fb698811b7e74a2bcae816aefe3859f8b25ee504ccf2f39cacfd426962c2ed2423acbd0317d22a1c1b25332fb920ea9ddca7690e79a78dec85abb8475cdeb253e8512a059645a7f9ec5dc39da2b3df6670502eb19525e46a537671b4e6584b2f84b44ee8e43b302191f85e2e0a31782cd4c0cbb45cfb9213165d2ee1a0d3db579cee62666ffb31d8a7cb4b4fc5e0e40cb87f99c14a1282e5540323115588702e265329b03c769c24a4a85de2274a054e87a86d845aa18ca62aa15b619d3d3691e93ca1955ad781df6ea895f9a8cc70b98abcad25c034295f457719877efe08d04d487249d9ce0bb8f8273fe2be3cd3e24b172e0667842e1bdc2b4213ca82c6d730d3c73ad5ad86070cf112999d3a6ad3f3d0ec8d6edce38dcb48f01744e1451a51ca8692f4cc9113e3d9714c7e077c065bc67d9c8473e14b402bfc1009684268992a9e892d94d23eed5587d7a94a29b1e35a73ebec7d8267294ef60b6ffcf9bcfc9f4e178965acbd4b140c048396f0815277bec6b14f88fb9e74f25d847bf8dcf064b86d9faed349b6942442984015e9de3397d2e1d11cc1de53de1551c70fe1d0fc9538c860d2e755a56f9b9fe976990646795ac593c69192b24d4586c9e0d4c193083c6d9edddd6025bf3622a2072b07c2a75bac160fac21b33685d5a4be7772e60cd974082d98d91bec85cfd4a10fe1f3cc359e23965ac9ae966dd10be8ac092dd8451399b4804a02d2b0f66eca14d3de8a7517891613d47e1c26936630467b502801a53ef7b286936b533069721beec21382fc48b46f39c769251c6f44de94ff47b66756aae1c56997ce77ee8b04340f0e66e08d6f301add79ca7193d57553f98d43e3a5f3a41bb89803cddd7da1d2c217f16b4d1c9e2f25b6159083af9be06ea91a61c3102ee6fe77b498fcd883bd77ce68ced3aa2d17b9bb2be05e300797201e4f1222681e92c22926ab737e801ce45289cb96ab4a5496d1f9e4ba0553234be89d40658b5dbf8aaae81819ee023fc1309636a090813fc8c71e2bd1977a5b0cacc6cef41567533b414d215181134f2d92de353ff028557fd0edfda8a72eb3cb6b2de64887b4bc1ef97c9382d677eb90a2a03aa84154792cf02938aff7b8dabe4ded58aed403e8a585d067d5fb9c37b9321d099e711fe1c0e6252074ced3adf1ca6f4d6ace6cc894dd2add99a8aad6667febf7dc53bc38a04295f3514cc5e087d92e932bc49ad9ce981999fff1b51afdf5192cc87c9e20315f318b08a0e3a977781b751e23827250df65e52a922731b48c2aefa325deb259325b782bba643850e27641fb732b726f22698f27e3
  
    
      
      
        您好, 这里需要密码.
      
    
  

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>题解P7361拜神</title>
    <url>/posts/48ad214/</url>
    <content><![CDATA[可能更洛谷的阅读体验
题目很好，考察了 SA 中的并查集思想以及启发式合并，而且实现也不难，值得一做。
形式化题面如下：

给定一个长为 nnn 的字符串，询问次数为 qqq，多次询问区间 [l,r][l,r][l,r] 内最长重复子串的长度。
1≤n≤5×104,1≤q≤1051\le n \le 5\times 10^4,1\le q \le 10^51≤n≤5×104,1≤q≤105。

没有形式化题面感觉都想不出来怎么做 www。
肯定没有那么菜啦，首先考虑二分长度，问题转化为区间内是否存在一个长为 midmidmid 的最长重复子串。
接下来我们考虑这个最长重复子串怎么求，一个比较明显的想法就是后缀数组的 LCP 功能，原命题询问的实质就是是否存在 i,j∈[l,r−mid+1],LCP⁡(i,j)≥midi,j \in [l,r-mid+1],\operatorname{LCP}(i,j)\ge midi,j∈[l,r−mid+1],LCP(i,j)≥mid。看到后面这个式子，回忆起品酒大会的思路：从大到小将 Height 数组插入，若仅考虑 ≥L\ge L≥L 的 Height，将 sai−1,saisa_{i-1},sa_{i}sai−1​,sai​ 之间连边，那么若 p,qp,qp,q 在同一联通块里，表明 LCP⁡(p,q)≥L\operatorname{LCP}(p,q)\ge LLCP(p,q)≥L。我们通过并查集和启发式合并就可以做到 O(log⁡n)O(\log n)O(logn) 的优秀复杂度啦。
但是有点问题啊，如果我们直接这么做我们并没有考虑区间位置，也就是说在两个联通块启发式合并的时候我们必须要记录区间的位置。我们不妨考虑对于联通块内每一个位置，我们维护它在当前联通块内上一个元素的位置，记作 preipre_{i}prei​，那么区间限制转化为 max⁡i∈set(L),i∈[l,r−L+1]prei≥l\max\limits_{i\in set(L),i\in [l,r-L+1]} pre_{i}\ge li∈set(L),i∈[l,r−L+1]max​prei​≥l。我们可以通过对每一个联通块开主席树来辅助查询，这样就能够做到优秀的 O(qlog⁡2nO(q \log^2 nO(qlog2n) 的查询啦，其中两个 log⁡\loglog 由二分和主席树查询贡献。
问题转化为如何维护 preprepre 的合并。首先，唯一确定一个联通块的信息就是所对应的 LCP 长度 LLL（具体见上面品酒大会思路），根据品酒大会启发式合并的思路，一次启发式 preprepre 的变化最多只有 O(log⁡n)O(\log n)O(logn) 个，考虑用 set 把联通块内的元素存下来，启发式合并的时候暴力单点修改 preprepre，这样处理的复杂度是 O(nlog⁡2n)O(n \log^2 n)O(nlog2n) 的，可以过。故总时间复杂度为 O(qlog⁡2n+nlog⁡2n)O(q\log^2 n + n \log^2 n)O(qlog2n+nlog2n)。
请注意二分的实现：
#include&lt;bits/stdc++.h&gt;#define pir pair&lt;int,int&gt;using namespace std;constexpr int MN=5e4+15;int n,q,pre[MN];vector&lt;int&gt; vht[MN];set&lt;int&gt; st[MN];string s;struct Segment&#123;#define ls t[p].lson#define rs t[p].rson    struct Node&#123;        int lson,rson,val;    &#125;t[MN&lt;&lt;9];    int tot,rt[MN];        void pushup(int p)&#123;        t[p].val=max(t[ls].val,t[rs].val);    &#125;    void modfiy(int &amp;p,int lst,int l,int r,int pos,int v)&#123;        p=++tot;        t[p]=t[lst];        if(l==r)&#123;            t[p].val=max(t[p].val,v);            return;        &#125;        int mid=(l+r)&gt;&gt;1;        if(mid&gt;=pos) modfiy(ls,t[lst].lson,l,mid,pos,v);        else modfiy(rs,t[lst].rson,mid+1,r,pos,v);        pushup(p);    &#125;    int query(int p,int l,int r,int fl,int fr)&#123;        if(l&gt;=fl&amp;&amp;r&lt;=fr)&#123;            return t[p].val;        &#125;        int mid=(l+r)&gt;&gt;1,ret=0;        if(mid&gt;=fl) ret=max(ret,query(ls,l,mid,fl,fr));        if(mid&lt;fr) ret=max(ret,query(rs,mid+1,r,fl,fr));        return ret;    &#125;#undef ls#undef rs&#125;sg;namespace SA&#123;    int len,sa[MN],x[MN],y[MN],rk[MN],c[MN],ht[MN],ST[30][MN];    // 接受 string 和 vector_int 输入，其他输入不保证正确性    // ST表需要手动初始化调用initst函数    template&lt;typename vct&gt;    void getsa(vct &amp;s)&#123;        int m=400000;        len=s.size();        s.insert(s.begin(),&#x27; &#x27;);        for(int i=1;i&lt;=len;i++)&#123;            x[i]=s[i];            ++c[x[i]];        &#125;        for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=len;i&gt;=1;i--) sa[c[x[i]]--]=i;        for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123;            int num=0;            for(int i=len-k+1;i&lt;=len;i++) y[++num]=i;            for(int i=1;i&lt;=len;i++)&#123;                if(sa[i]&gt;k) y[++num]=sa[i]-k;            &#125;            for(int i=1;i&lt;=m;i++) c[i]=0;            for(int i=1;i&lt;=len;i++) c[x[i]]++;            for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];            for(int i=len;i&gt;=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;            swap(x,y);            num=1,x[sa[1]]=1;            for(int i=2;i&lt;=len;i++)&#123;                if(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;                else x[sa[i]]=++num;            &#125;            if(num==len) break;            m=num;        &#125;        for(int i=1;i&lt;=len;i++) rk[sa[i]]=i;        for(int i=1,k=0;i&lt;=len;i++)&#123;            if(rk[i]==1) continue;            if(k) k--;            int j=sa[rk[i]-1];            while(i+k&lt;=len&amp;&amp;j+k&lt;=len&amp;&amp;s[i+k]==s[j+k]) k++;            ht[rk[i]]=ST[0][rk[i]]=k;        &#125;    &#125;&#125;using namespace SA;int root(int x)&#123;    if(pre[x]==x) return pre[x];    else return pre[x]=root(pre[x]);&#125;void merge(int x,int y,int L)&#123;    int rx=root(x),ry=root(y);    if(rx==ry) return;    if(st[rx].size()&lt;st[ry].size()) swap(rx,ry);    pre[ry]=rx;    for(auto p:st[ry])&#123;        auto it=st[rx].lower_bound(p);        if(it!=st[rx].end())&#123;            sg.modfiy(sg.rt[L],sg.rt[L],1,n,*it,p);        &#125;        if(it!=st[rx].begin())&#123;            it--;            sg.modfiy(sg.rt[L],sg.rt[L],1,n,p,*it);        &#125;    &#125;    for(auto p:st[ry]) st[rx].insert(p);&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;    getsa(s);    for(int i=2;i&lt;=n;i++)&#123;        vht[ht[i]].push_back(i);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        pre[i]=i;        st[i].insert(i);    &#125;    for(int i=n;i&gt;=1;i--)&#123;        sg.rt[i]=sg.rt[i+1];        for(auto p:vht[i])&#123;            merge(sa[p],sa[p-1],i);        &#125;    &#125;    while(q--)&#123;        int L,R;        cin&gt;&gt;L&gt;&gt;R;        int l=0,r=R-L+1;        while(l+1&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(sg.query(sg.rt[mid],1,n,L,R-mid+1)&gt;=L)&#123;                l=mid;            &#125;else r=mid;        &#125;        cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
